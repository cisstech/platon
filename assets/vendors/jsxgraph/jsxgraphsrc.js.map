{"version":3,"file":"jsxgraphsrc.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qFAAmB,CAAC,qDAAG;;AAEvB,yDAAe,SAAS,EAAC;;;;;;;;;;;;;ACvPzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACO;AACU;AACT;AACF;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mEAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAW;;AAE/B;AACA,QAAQ,+EAAqB;AAC7B;AACA;AACA;;AAEA,mEAAU;AACV,IAAI,uFAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mEAAO;AACrD;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,YAAY;AAC/B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yFAAoB;AACnD;AACA;AACA;;AAEA,0BAA0B,mEAAO,GAAG,mEAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B;AACA,mBAAmB,SAAS;AAC5B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yFAAoB;AACnD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA,8CAA8C,mEAAO;AACrD;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,mEAAU,EAAC;;;;;;;;;;;;;;;;ACtR1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;AACM;AACS;AACA;AACI;AACd;AACE;AACC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,IAAI,2BAA2B;AAC/B;AACA,iFAAiB;AACjB;;AAEA,SAAS,0EAAW;AACpB;AACA;;AAEA,gBAAgB,wBAAwB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAM,CAAC,yFAAoB;AACjD,6BAA6B,wDAAM,CAAC,yFAAoB;;AAExD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA;;AAEA;AACA,UAAU,sCAAsC;AAChD,qBAAqB,wBAAwB;AAC7C,QAAQ,+CAA+C;AACvD,mCAAmC;AACnC;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,8EAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,QAAQ,0EAAW;AACnB;AACA;AACA;AACA;;AAEA,mEAAU;AACV,IAAI,qGAA2B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA,iBAAiB,8EAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iGAAwB;AACtD;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,mGAAyB;AAChE,oBAAoB,8EAAa;AACjC;AACA;AACA,4BAA4B,yGAA6B;AACzD;AACA,oBAAoB,uEAAY;AAChC;AACA;AACA;AACA;AACA,cAAc,gCAAgC,+FAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,mEAAO;AAC7C;AACA;AACA;;AAEA,yBAAyB,qGAA2B;AACpD;AACA;;AAEA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,yFAAoB;;AAErD;AACA,wBAAwB,mEAAO;AAC/B;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gCAAgC,qGAA2B;AAC3D;AACA;;AAEA;AACA,2CAA2C,mEAAO;AAClD;AACA;;AAEA,0CAA0C,mEAAO;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,4BAA4B,mEAAO;AACzD;AACA;;AAEA,0CAA0C,mEAAO;AACjD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA,0CAA0C,mEAAO;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,8EAAa;AACrC;AACA,oBAAoB,8EAAa;AACjC,yDAAyD,mEAAO;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,8EAAa;AAClC,iDAAiD,mEAAO;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,8EAAa;AAClC,iDAAiD,mEAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB,iGAAwB;AAC9D;AACA;AACA,sBAAsB,yGAA6B;AACnD;AACA,iCAAiC;AACjC,cAAc,gCAAgC,iGAAwB;AACtE;AACA,mCAAmC,2FAAqB;AACxD,mCAAmC,iGAAwB;AAC3D;AACA,gCAAgC,yGAA6B;;AAE7D,4BAA4B,uEAAY;AACxC;AACA,2BAA2B,uEAAY;AACvC;;AAEA,4BAA4B,8EAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,mEAAO;AACjD;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0EAAW;AACpD;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA,yCAAyC,2EAAW;AACpD,qCAAqC,iFAAc;AACnD;AACA,qCAAqC,wDAAM,CAAC,yFAAoB;AAChE,gCAAgC,yGAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE,qCAAqC,iFAAc;AACnD;AACA,uCAAuC,wDAAM,CAAC,yFAAoB;AAClE,0BAA0B;AAC1B;AACA,qCAAqC,2EAAW;AAChD,iCAAiC,iFAAc;AAC/C,qCAAqC,wDAAM,CAAC,yFAAoB;AAChE,gCAAgC,yGAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,8BAA8B,uGAA4B;AAC1D;AACA,yCAAyC;AACzC;AACA;AACA,cAAc,SAAS,4EAAY;AACnC;AACA,4BAA4B,uGAA4B;AACxD,wCAAwC;AACxC;;AAEA,uCAAuC,yFAAoB;AAC3D;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,mGAAyB;AAChE;AACA,oBAAoB,8EAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gCAAgC,+FAAuB;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B,mEAAO;AACrD,iEAAiE,mEAAO;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B,mEAAO;AACrD,mDAAmD,mEAAO;AAC1D,8CAA8C,mEAAO;;AAErD;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB,iGAAwB;AAC9D,2CAA2C,yFAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yGAA6B;AACjD,cAAc,gCAAgC,iGAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAW;AAC5C;AACA;AACA;AACA;AACA,+CAA+C,yFAAoB;AACnE;AACA;AACA;AACA;AACA,kBAAkB;AAClB,+CAA+C,yFAAoB;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,2FAAqB;AACxD,mCAAmC,iGAAwB;AAC3D;AACA,gCAAgC,uEAAY;AAC5C;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,uEAAY;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8EAAa;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,mEAAO;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,4BAA4B,uGAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D,oCAAoC,wDAAM;AAC1C,gCAAgC,yFAAoB;AACpD,gCAAgC,iFAAc;AAC9C;AACA;AACA;AACA,sBAAsB;AACtB,4BAA4B,uGAA4B;AACxD;AACA;AACA,cAAc,SAAS,4EAAY;AACnC,oBAAoB,uGAA4B;AAChD;;AAEA,uCAAuC,yFAAoB;AAC3D,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mEAAO;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,eAAe,sCAAsC;AACrD;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,YAAY,sCAAsC;AAClD;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,4CAA4C,yFAAoB;AAChE;AACA;AACA,SAAS;;AAET;AACA,sBAAsB;AACtB,mBAAmB,SAAS;AAC5B,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA;AACA,mBAAmB,SAAS;AAC5B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAa;AACvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAgB,8EAAa;AAC7B,wBAAwB,8EAAa;AACrC,wBAAwB,8EAAa;;AAErC,4BAA4B,SAAS;AACrC;;AAEA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,4EAAY;AACpC,kCAAkC,uGAA4B;AAC9D;AACA,iDAAiD,6FAAsB;AACvE,0BAA0B;AAC1B,iDAAiD,yFAAoB;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,yFAAoB;AACnE;AACA;;AAEA;AACA,SAAS;;AAET;AACA,sBAAsB,2CAA2C;AACjE;AACA,mBAAmB,SAAS;AAC5B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8EAAa;AACrC,wBAAwB,8EAAa;AACrC,wBAAwB,8EAAa;AACrC,uBAAuB,8EAAa;AACpC;;AAEA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;;AAEA,oBAAoB,0EAAW;AAC/B,wBAAwB,4EAAY;AACpC,qCAAqC,uGAA4B;AACjE,sBAAsB,6BAA6B,+FAAuB;AAC1E,qCAAqC,6GAA+B;AACpE;AACA;AACA;AACA;AACA,6BAA6B,8EAAa;AAC1C;AACA,0BAA0B;AAC1B,6BAA6B,8EAAa;AAC1C;AACA;AACA;AACA,0BAA0B;AAC1B,6CAA6C,wDAAM;AACnD,gCAAgC,yFAAoB;AACpD;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B,mGAAyB;AAC5E,qCAAqC,yGAA6B;AAClE,sBAAsB,6BAA6B,iGAAwB;AAC3E,qCAAqC,uGAA4B;AACjE,sBAAsB,qBAAqB,iGAAwB;AACnE,qCAAqC,yGAA6B;AAClE,sBAAsB,qBAAqB,mGAAyB;AACpE,yCAAyC,wDAAM;AAC/C,4BAA4B,yFAAoB;AAChD,4BAA4B,6GAA+B;AAC3D;AACA;AACA;;AAEA;AACA,gDAAgD,6FAAsB;AACtE,sBAAsB;AACtB,gDAAgD,yFAAoB;AACpE;;AAEA;AACA;AACA;AACA,8CAA8C,iGAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,gCAAgC,0BAA0B,KAAK,2BAA2B;AAC1F,mBAAmB,OAAO;AAC1B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,wDAAM;AAC9B,oBAAoB,8EAAa;AACjC,yBAAyB,mFAAmB;AAC5C;AACA;AACA,kBAAkB;AAClB,yBAAyB,mFAAmB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,QAAQ;AAC9D,+BAA+B,6FAAsB;AACrD,oCAAoC,wDAAM;AAC1C,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yFAAoB;AACxC,oBAAoB,iFAAc,CAAC,2EAAW;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D,iGAAwB;AACtF;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,gCAAgC,0BAA0B,KAAK,2BAA2B;AAC1F,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;;AAEA,qBAAqB,wDAAM;AAC3B;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,gCAAgC,0BAA0B,KAAK,2BAA2B;AAC1F,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,4BAA4B;AAC/C,mBAAmB,QAAQ;AAC3B,qBAAqB,WAAW;AAChC;AACA;AACA,8BAA8B,iGAAwB;AACtD;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,mGAAyB;AAC3D;AACA;AACA,4BAA4B,6BAA6B;AACzD,2BAA2B,6GAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,0EAAW;AAC5B;AACA,cAAc,2BAA2B,+FAAuB;AAChE;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,iGAAwB;AAChD;AACA,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,+FAAuB;AAC7D;AACA,sBAAsB,+BAA+B,+FAAuB;AAC5E;AACA,sBAAsB,uBAAuB,+FAAuB;AACpE;AACA,sBAAsB,uBAAuB,+GAA+B;AAC5E;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,iGAAwB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,iGAAwB;AACtE,oCAAoC,+FAAuB;AAC3D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,sCAAsC,iGAAwB;AAC9D,4BAA4B,+FAAuB;AACnD;AACA,cAAc,+BAA+B,+FAAuB;AACpE;AACA;AACA,cAAc,+BAA+B,iGAAwB;AACrE;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,iGAAwB;AAC9D,4BAA4B,2FAAqB;AACjD;;AAEA;;AAEA,wBAAwB,kBAAkB;AAC1C;;AAEA,oBAAoB,8EAAa;AACjC;AACA;AACA,sEAAsE;AACtE;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,SAAS,kFAAe;AAC1C;AACA,kBAAkB,SAAS,8EAAa;AACxC;AACA,kBAAkB,SAAS,8EAAa,OAAO,kFAAe;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,4EAAY;AACpC,mDAAmD,yFAAoB;AACvE;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA,+CAA+C,yFAAoB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA,+CAA+C,yFAAoB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA,0CAA0C,wDAAM;AAChD,oBAAoB,6FAAsB;AAC1C;AACA;AACA;AACA,cAAc;AACd,0CAA0C,wDAAM,CAAC,yFAAoB;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,8EAAa;AACjC,2BAA2B,8EAAa;AACxC;AACA;AACA,iCAAiC,wDAAM;AACvC,wBAAwB,6FAAsB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,8EAAa;AACjC,2BAA2B,8EAAa;AACxC;AACA;AACA,iCAAiC,wDAAM;AACvC,wBAAwB,6FAAsB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,0FAAmB;;AAE5C;AACA,2CAA2C,yFAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,qBAAqB,mBAAmB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,iCAAiC;AACzD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,0BAA0B,sBAAsB;AACnE,2BAA2B,yBAAyB;AACpD,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA,uBAAuB,4EAAY;AACnC;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA,uEAAuE,SAAS;AAChF;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B,iGAAwB,KAAK,0EAAW;AACtE;AACA;AACA,iBAAiB;;AAEjB,qBAAqB,0EAAW;AAChC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA,gBAAgB,0EAAW;AAC3B;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,UAAU;AAC7B,mBAAmB,SAAS;AAC5B;AACA,kBAAkB,gCAAgC;AAClD,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,4EAAY;AAC5B;AACA,4BAA4B,SAAS;AACrC,wBAAwB,4EAAY;AACpC;AACA,sBAAsB;AACtB;AACA,0CAA0C,iGAAwB;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,yFAAoB;AACzD;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,0EAAW;AAChC,8BAA8B,+EAAgB;AAC9C,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,gCAAgC,WAAW;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS,kFAAe;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAM,CAAC,yFAAoB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,0EAAW;AAC5B;AACA,0EAA0E,mEAAO;AACjF;AACA,iCAAiC,yFAAoB;AACrD;AACA;;AAEA;AACA;AACA,iBAAiB,0EAAW;AAC5B,+BAA+B,mEAAO;AACtC,+BAA+B,mEAAO;AACtC;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAM,CAAC,yFAAoB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,8EAAa;AAC7B,4BAA4B;AAC5B,cAAc;AACd;AACA,qBAAqB,0EAAW;AAChC;AACA;AACA;;AAEA;;AAEA,wBAAwB,oBAAoB;AAC5C,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD,+FAAuB;AACzE;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,2CAA2C,6FAAsB;AACjE;AACA;AACA;AACA,cAAc,2CAA2C,iGAAwB;AACjF;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,2CAA2C,6FAAsB;AACjE,sBAAsB,uGAA4B;AAClD;AACA;AACA,cAAc,2CAA2C,mGAAyB;AAClF;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,2CAA2C,yFAAoB;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,iGAAwB;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,OAAO;AACjB;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB;AACA,UAAU,OAAO;AACjB;AACA,YAAY,QAAQ;AACpB;AACA,+FAAwB;AACxB;AACA;AACA;;AAEA,gBAAgB,mBAAmB;AACnC,YAAY,kFAAe,eAAe,8EAAa;AACvD;AACA;AACA;;AAEA;AACA,YAAY,8EAAa,eAAe,8EAAa;AACrD;;AAEA,gBAAgB,0EAAW;AAC3B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU,SAAS,8EAAa,eAAe,4GAA4B;AAC3E;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAe,iFAAiB,EAAC;;;;;;;;;;;;;;;;;ACziEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACO;AACF;AACC;AACa;AACX;AACS;AACP;AACF;;AAEjC;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,qFAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,0CAA0C;AAC1C,kBAAkB;AAClB;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS,MAAM,SAAS;AACrC;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,+EAAqB;;AAEzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iGAAwB;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,0EAAW;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA;AACA;;AAEA;;AAEA;AACA,QAAQ,4FAAoB;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAU;AACV,IAAI,yGAA6B;AACjC;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,aAAa;AACjC;AACA,uGAAuG,cAAc;AACrH;AACA;AACA,4FAA4F,qFAAqF;AACjL,oDAAoD,SAAS;AAC7D,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG,aAAa;AACnC;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,4EAAY;AAC5B;AACA,cAAc;AACd;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC,qBAAqB,0EAAW;AAChC;AACA;AACA,oBAAoB,sEAAS;AAC7B;AACA,kBAAkB,SAAS,0EAAW;AACtC;AACA;AACA;AACA,2BAA2B,oFAAgB;AAC3C,SAAS;;AAET;AACA;AACA,gDAAgD,qCAAqC;AACrF,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,0BAA0B,sBAAsB;AACnE,2BAA2B,yBAAyB;AACpD,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,+CAA+C;AAC3D;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB,8EAAa;AAC9B;AACA,8BAA8B,iGAAwB;AACtD;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,gCAAgC,0BAA0B,KAAK,2BAA2B;AAC1F,mBAAmB,OAAO;AAC1B,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA,oBAAoB,4EAAY;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD,mBAAmB;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,wCAAwC,iGAAwB;AAChE;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,gCAAgC,0BAA0B,KAAK,2BAA2B;AAC1F,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB,qBAAqB;AAC1C;AACA;AACA,wBAAwB,wDAAM;AAC9B,2BAA2B,wDAAM;AACjC,qBAAqB,mFAAmB;;AAExC,6BAA6B,yFAAoB;;AAEjD;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAa;AACxC,2BAA2B,6EAAa;;AAExC;AACA;AACA;AACA;;AAEA,gCAAgC,WAAW;AAC3C,sEAAsE,6EAAa;AACnF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4EAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,gBAAgB,8EAAa;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,SAAS;AAC7B,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA,oBAAoB,4EAAY;AAChC;AACA,gCAAgC,WAAW;AAC3C;AACA,4BAA4B,0EAAW;AACvC,4BAA4B,0EAAW;AACvC,4BAA4B,8EAAa;AACzC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,wBAAwB,0EAAW;AACnC,wBAAwB,0EAAW;AACnC,wBAAwB,8EAAa;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,0EAAW,gBAAgB,0EAAW;AACvE,oBAAoB,8EAAa;AACjC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,4CAA4C,eAAe,EAAE;AAC7D,oBAAoB,qBAAqB;AACzC;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA,SAAS;;AAET;AACA;AACA,sBAAsB;AACtB,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,4CAA4C,cAAc,EAAE;AAC5D,oBAAoB,qBAAqB;AACzC;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA,SAAS;;AAET;AACA;AACA,sBAAsB;AACtB,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,gBAAgB,yCAAyC;AACzD;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA,oBAAoB,SAAS;AAC7B,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,0BAA0B,8EAAa;;AAEvC;AACA,wBAAwB,0EAAW;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA,wBAAwB,4EAAY;AACpC;AACA,oCAAoC,WAAW;AAC/C;AACA,gCAAgC,0EAAW;AAC3C,gCAAgC,8EAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,4BAA4B,0EAAW;AACvC,4BAA4B,8EAAa;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0EAAW;AAC/B,oBAAoB,0EAAW;AAC/B,oBAAoB,8EAAa;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAa;AAC7B;AACA;AACA;AACA,wBAAwB,iFAAe;AACvC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,8EAAa;AACjC,qBAAqB,0EAAW;AAChC,qBAAqB,0EAAW;AAChC;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,6EAAiB;AACzC,oBAAoB,2GAAgC;AACpD,wBAAwB,0EAAW;AACnC,oCAAoC,IAAI,6EAAiB,cAAc;AACvE,iCAAiC,0EAAW,YAAY,6EAAiB;AACzE,2CAA2C,6EAAiB;AAC5D;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD,4BAA4B,8EAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,gBAAgB,0EAAW;AAC3B,6CAA6C,sBAAsB;AACnE;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C,SAAS;;AAET;AACA,iCAAiC,uCAAuC;AACxE,4BAA4B,uCAAuC;AACnE;AACA;AACA,YAAY,2EAAc;AAC1B;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA,yDAAyD;AACzD,kDAAkD,eAAe;AACjE;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA,oBAAoB,8EAAa;AACjC;AACA;AACA,+BAA+B,sEAAS,aAAa,sEAAS;AAC9D,kBAAkB,UAAU,4EAAY;AACxC,gEAAgE;AAChE,oBAAoB,mEAAU;AAC9B,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,+DAA+D,eAAe;AAC9E,wBAAwB,8EAAa,WAAW,0EAAW;AAC3D,4CAA4C,wEAAU;;AAEtD;AACA,+CAA+C,QAAQ,qCAAqC;AAC5F,0CAA0C,+FAAuB,IAAI,0EAAW;AAChF;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA,0BAA0B,SAAS,0EAAW;AAC9C,gCAAgC,4EAAY;AAC5C,4CAA4C,sBAAsB;AAClE;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iFAAe;AACnD;AACA;AACA;AACA,oCAAoC,0EAAW;AAC/C;AACA;AACA;AACA,gCAAgC,0EAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+FAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8EAAa;AAC7C;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA;;AAEA,oDAAoD,8EAAa;AACjE;AACA,gCAAgC,8EAAa;AAC7C,gCAAgC,0EAAW;AAC3C;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,4EAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iFAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8EAAa;AAC9C;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,0DAA0D,oBAAoB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+FAAuB;AACrE,8CAA8C,iGAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+FAAuB;AAC9E,oCAAoC,8EAAa;AACjD,8CAA8C,+FAAuB;AACrE;AACA;AACA;AACA;AACA;AACA,8CAA8C,+FAAuB,IAAI,8EAAa;AACtF;AACA;AACA;AACA;AACA;AACA,8CAA8C,+FAAuB;AACrE,gCAAgC,kFAAe;AAC/C;AACA;AACA;AACA;AACA;AACA,8CAA8C,iGAAwB;AACtE;AACA;AACA;AACA;AACA;AACA,gCAAgC,0EAAW;AAC3C;AACA;AACA;AACA;AACA;AACA,gCAAgC,0EAAW;AAC3C;AACA;AACA;AACA;AACA;AACA,gCAAgC,0EAAW;AAC3C;AACA;AACA;AACA;AACA,+DAA+D,8EAAa;AAC5E;AACA;AACA;AACA,gCAAgC,0EAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0EAAW;AAC3C,kCAAkC,yEAAa;AAC/C,qCAAqC,yEAAa,SAAS,yEAAa;AACxE,qCAAqC,yEAAa;AAClD,wCAAwC,kFAAe;AACvD,wCAAwC,yEAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,8EAAa;AAC9B;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA,iCAAiC,uCAAuC;AACxE,4BAA4B,uCAAuC;AACnE;AACA;AACA,YAAY,2EAAc;AAC1B;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,iDAAiD;AACjD;AACA,2BAA2B,wCAAwC;AACnE;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,0EAA0E,6BAA6B;AACvG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,uBAAuB,wDAAM,CAAC,yFAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,uBAAuB,wDAAM,CAAC,yFAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B,iGAAwB;AACpD;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAa;AACpC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iFAAiB;AACjC,uBAAuB,8EAAa;AACpC;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,iFAAiB;AAClD;AACA;AACA;AACA;AACA;AACA,oCAAoC,kFAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,gBAAgB,iEAAS;AACzB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,SAAS;AAC5B,qBAAqB;AACrB;AACA;AACA,oBAAoB,oEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,8EAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,OAAO;AAC5B,qCAAqC,+BAA+B;AACpE;AACA,qBAAqB,OAAO,YAAY,+BAA+B;AACvE;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,2BAA2B,+EAAa;AACxC;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA,wBAAwB,0EAAW;AACnC;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D,wBAAwB;;AAExB;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,+FAAuB;AAC/D,oBAAoB,8EAAa;AACjC,kCAAkC,+FAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,8EAAa;AACjD;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,8BAA8B;AAC9D;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,qBAAqB;AACrD;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,oBAAoB;AACpD;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,mBAAmB;AACnD;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,4BAA4B;AAC5D;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,oBAAoB;AACpD;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,SAAS;AACzC;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,YAAY;AAC5C;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,4BAA4B;AAC5B;AACA;AACA,YAAY,2EAAc;AAC1B,gCAAgC,WAAW;AAC3C;AACA,SAAS;;AAET;AACA,+CAA+C,uBAAuB;AACtE,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA,oEAAoE,uBAAuB;AAC3F,qBAAqB;AACrB;AACA;AACA,mBAAmB,4EAAY;AAC/B,SAAS;;AAET;AACA;AACA,2CAA2C,2BAA2B,KAAK,0BAA0B;AACrG,oEAAoE,4BAA4B;AAChG,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,2CAA2C,mCAAmC,KAAK,8BAA8B;AACjH;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA,6BAA6B,8EAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,QAAQ;AAC7B;AACA;AACA,oCAAoC,0EAAW;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAW;AAC3B,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA,gBAAgB,0EAAW;AAC3B;AACA;;AAEA,gBAAgB,0EAAW;AAC3B,gDAAgD,QAAQ;AACxD;AACA;;AAEA;AACA,wCAAwC,gCAAgC;AACxE,oCAAoC,0EAAW;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA,iBAAiB,8EAAa;AAC9B,iBAAiB,8EAAa;;AAE9B;AACA;AACA,yCAAyC,8EAAa;AACtD;;AAEA;AACA;AACA,yCAAyC,8EAAa;AACtD;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8EAAa;AAC7C,wBAAwB,8EAAa;AACrC,wBAAwB,8EAAa;;AAErC,iBAAiB,0EAAW,iBAAiB,8EAAa;AAC1D;AACA;;AAEA;AACA,gBAAgB,8EAAa;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,mEAAU,CAAC,yFAAoB;AACjE;AACA;AACA;AACA,iDAAiD,6FAAsB,GAAG,yFAAoB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,mDAAmD,yFAAoB;AACvE;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,mGAAyB;AACvD;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B,mGAAyB;AACtE;AACA;AACA;AACA,cAAc,+BAA+B,iGAAwB;AACrE;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAY,CAAC,yGAA6B;;AAE5D;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAY,CAAC,yGAA6B;;AAE/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,qFAAmB,EAAC;;;;;;;;;;;;;;;;ACj4EnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACO;AACQ;AACM;AACf;AACE;AACF;AACa;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA,wFAAwF,wBAAwB;AAChH,SAAS,YAAY;AACrB;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B;AACA;AACA,+DAAQ;AACR,wCAAwC,6FAAsB,EAAE,+FAAuB;;AAEvF;AACA,mCAAmC,8EAAa;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,8EAAa;AACrB;AACA;AACA;;AAEA,qBAAqB,8EAAa;AAClC;AACA;AACA;AACA,KAAK;AACL;;AAEA,mFAAkB,OAAO,yDAAe;AACxC,sGAAyB,CAAC,+DAAQ,EAAE,+DAAa;;AAEjD,mEAAU;AACV,IAAI,mFAAkB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,8EAAa,CAAC,8EAAa;AAC3C;AACA,oBAAoB,8EAAa;AACjC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iFAAc;AACpC,oBAAoB,2EAAW;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;;AAEA,gBAAgB,8EAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,yBAAyB,KAAK,gBAAgB;AAClE,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAa;AACpC,wBAAwB,8EAAa;AACrC,wBAAwB,8EAAa;AACrC;;AAEA;;AAEA,gBAAgB,kFAAe;AAC/B;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd,oBAAoB,8EAAa;AACjC,mCAAmC,4EAAY,OAAO,8EAAa;AACnE,kBAAkB,SAAS,8EAAa;AACxC,wBAAwB,8EAAa;AACrC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,4EAA4E;AAC5E,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,iDAAiD,kCAAkC,KAAK,uBAAuB;AAC/G;AACA,mBAAmB,wBAAwB;AAC3C,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,iDAAiD,SAAS;AAC1D,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA,gBAAgB,kFAAe;AAC/B;AACA,2BAA2B,sFAAiB;AAC5C;AACA,cAAc;AACd,oBAAoB,8EAAa;AACjC;AACA,kBAAkB;AAClB,wBAAwB,sFAAiB;AACzC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,iBAAiB;AACpC,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAa;;AAEpC,iBAAiB,+EAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,0EAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,yBAAyB;AACzB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mCAAmC,8EAAa;AAChD;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA,4CAA4C;AAC5C;AACA,aAAa;AACb,SAAS;;AAET;AACA,uBAAuB,OAAO;AAC9B,mBAAmB,QAAQ,wBAAwB;AACnD,qBAAqB,QAAQ,sBAAsB,gBAAgB,OAAO;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA,gCAAgC,KAAK;AACrC;;AAEA;AACA,gEAAgE;AAChE,2CAA2C;AAC3C;AACA,mEAAmE;AACnE;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,uBAAuB,OAAO;AAC9B,mBAAmB,QAAQ,wBAAwB;AACnD,qBAAqB,QAAQ,sBAAsB,gBAAgB,OAAO;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA,gCAAgC,KAAK;AACrC;;AAEA;AACA,iEAAiE;AACjE,2CAA2C;AAC3C;AACA,mEAAmE;AACnE;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,gBAAgB,4EAAY;AAC5B;AACA;AACA;;AAEA,gBAAgB,8EAAa,0BAA0B,0EAAW;AAClE;AACA;AACA;;AAEA,mDAAmD,6FAAsB;AACzE,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,yFAAoB;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,8EAAa;AAC7B,oBAAoB,8EAAa;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAa;AAC7B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B,kBAAkB,SAAS;AAC3B,kBAAkB,SAAS;AAC3B;AACA,kBAAkB,SAAS;AAC3B;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD,IAAI,UAAU;AAChE,iEAAiE;AACjE,iDAAiD,YAAY,UAAU;AACvE,iDAAiD,aAAa,YAAY;;AAE1E,iDAAiD,SAAS;AAC1D,iDAAiD,WAAW;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8BAA8B,sFAAwB;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,8EAAa;AACzC,gCAAgC,sEAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8EAAa;AAC7C;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,IAAI;AACjD,gDAAgD;AAChD;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,SAAS;AAC1D,iDAAiD,WAAW;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8EAAa;AACzC,gCAAgC,sEAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8EAAa;AACjD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD,SAAS;;AAET;AACA;AACA,+CAA+C;AAC/C,8BAA8B,aAAa,UAAU;AACrD,kDAAkD;AAClD,8BAA8B,cAAc,YAAY;;AAExD;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAa;AAC7B;AACA,4BAA4B,gBAAgB;AAC5C,0DAA0D;AAC1D;AACA,sCAAsC,kBAAkB;AACxD;AACA,4BAA4B,aAAa;AACzC,0DAA0D;AAC1D;AACA,sCAAsC,eAAe;AACrD;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAa;AAC7B;AACA,4BAA4B,mBAAmB;AAC/C,gEAAgE,gBAAgB;AAChF;AACA,sCAAsC,qBAAqB;AAC3D;AACA,4BAA4B,0BAA0B;AACtD,gEAAgE,gBAAgB;AAChF;AACA,sCAAsC,4BAA4B;AAClE;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,SAAS;AACpD,2CAA2C,WAAW;;AAEtD;AACA;AACA;;AAEA;AACA,oBAAoB,kGAA8B;AAClD;AACA;AACA;AACA,cAAc;;AAEd;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,gBAAgB,8EAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,oBAAoB,8EAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,oBAAoB,8EAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,8EAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,8EAAa;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iEAAiE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,uFAAuF,qFAAqF;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D,sCAAsC;AACtC;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,uFAAuF,qFAAqF;AAC5K;AACA,mDAAmD,kBAAkB,gBAAgB,uDAAuD;AAC5I;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,2DAA2D,UAAU;AACrE;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,2EAAc;AACd;AACA,eAAe,0FAAmB;AAClC;AACA;;AAEA;AACA;AACA,QAAQ,6EAAoB,CAAC,+DAAQ;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qFAAmB,SAAS,2EAAc;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uFAAoB;AACpB;AACA;AACA,eAAe,0FAAmB;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,2EAAc;AACtB,aAAa,0GAA2B;;AAExC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ,iEAAS;AACjB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,6EAAe;AACvB;AACA;AACA;AACA;AACA,QAAQ,6EAAY;AACpB,MAAM;AACN;AACA;AACA;AACA,QAAQ,6EAAY;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qFAAmB,eAAe,uFAAoB;;AAEtD,yDAAe;AACf,UAAU,+DAAQ;AAClB,gBAAgB,2EAAc;AAC9B,sBAAsB,uFAAoB;AAC1C,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;;;;AC3yCF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACC;;AAE1B;AACA;AACA;AACA;AACA,0BAAO;AACP;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA,eAAe,uCAAW;AAC1B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAe,0BAAO,EAAC;;;;;;;;;AC/FvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEyB;AACQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;;AAEA,YAAY,uCAAW;AACvB;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;;AAEA,YAAY,uCAAW;AACvB;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,8CAAe,uCAAa,EAAC;;;;;AC3mB7B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,2CAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ,2EAA2E;AAClG;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,4CAA4C;AAC5C,cAAc;AACd,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,2BAA2B,OAAO;AAClC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAe,2CAAe,EAAC;;;AChb/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACQ;;AAEjC;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,qCAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAW;AACX,IAAI,yDAAsB;AAC1B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,YAAY;AAC/B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,qCAAY;AAC7C,iCAAiC,qCAAY;AAC7C,iCAAiC,qCAAY;AAC7C,iCAAiC,qCAAY;;AAE7C,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC,mBAAmB,QAAQ;AAC3B,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAe,qCAAY,EAAC;;;;;ACvO5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAY;AACZ;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,UAAU;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA,sBAAsB;AACtB;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA,UAAU;;AAEV;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,uBAAuB;;AAEvB,sBAAsB,YAAY;AAClC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA,cAAc;AACd;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAe,oCAAY,EAAC;;;;;;;;;ACl3C5B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACa;AACF;AACX;AACe;AACN;AACI;AACJ;AACI;AACL;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA,iEAAiE,2BAAO;AACxE;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,+EAA+E,gCAAgC;AAC/G,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,SAAS,gCAAgC,4BAA4B;AACtF;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,+EAA+E,gCAAgC;AAC/G,yEAAyE,mCAAmC;AAC5G;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,2BAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,wCAAc;;AAEtB;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,UAAU;AACV;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,sDAAoB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,sDAAoB;AAChC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,gCAAgC,0BAAM,CAAC,0DAAsB;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sDAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,0BAAM,CAAC,0DAAsB;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,sBAAsB,0BAAM,CAAC,sDAAoB;AACjD;AACA;;AAEA,iBAAiB,2BAAO;AACxB,2BAA2B,sDAAoB;AAC/C;AACA;AACA;AACA,qBAAqB,2BAAO;AAC5B;AACA,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,0BAAM,CAAC,sDAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,oBAAoB,sDAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,0BAAM,CAAC,sDAAoB;AACnD;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAAM,CAAC,sDAAoB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,sDAAoB;AAC/C;;AAEA;AACA;AACA;;AAEA,2CAA2C;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB,0BAAM,CAAC,0DAAsB;AACjD;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,+EAA+E,6BAA6B;AAC5G;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA,qCAAqC;AACrC;AACA;AACA,UAAU;AACV,oBAAoB,2CAAa;AACjC;AACA;AACA,qCAAqC,aAAa;AAClD,0CAA0C;AAC1C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY,sDAAoB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,sDAAoB;AAChC;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,0DAAsB;AAChD;AACA;AACA,0BAA0B,0DAAsB;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,0BAAM,CAAC,sDAAoB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2BAAO;AAC7D,yDAAyD,2BAAO;AAChE;AACA,qBAAqB,0BAAM,CAAC,0DAAsB;AAClD;AACA;AACA;;AAEA,iBAAiB,0BAAM,CAAC,sDAAoB;AAC5C;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,uCAAW;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,0BAAM,CAAC,0DAAsB;AAC7C;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;;AAEA,eAAe,yCAAiB;AAChC,eAAe,yCAAiB;AAChC,eAAe,yCAAiB;AAChC,eAAe,yCAAiB;;AAEhC;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAAM,CAAC,sDAAoB;;AAE7C,oBAAoB,QAAQ;AAC5B;AACA;AACA,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,WAAW;AAC3B,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,QAAQ,gCAAgC;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAuD;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAAM,CAAC,sDAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU,gDAAgD,2BAAO;AACjE;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,qCAAe;AAC9B,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,oBAAoB,2BAAO,GAAG,2BAAO;AACrC;AACA;AACA;AACA;;AAEA,eAAe,qCAAe;AAC9B,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;;AAEA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;;AAEA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;;AAEA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,+EAA+E,6BAA6B;AAC5G;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC,UAAU;AACV,oBAAoB,2CAAa;AACjC;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY,sDAAoB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,sDAAoB;AAChC;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,0DAAsB;AAChD;AACA;AACA,0BAA0B,0DAAsB;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,kDAAkD;;AAElD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iCAAc;AAChC,cAAc,uCAAiB;;AAE/B;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,YAAY;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,0BAAM,CAAC,sDAAoB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,QAAQ,iCAA0B;;AAElC,gBAAgB,mCAA2B;AAC3C,8BAA8B,iBAAkB;AAChD,iCAAiC,iBAAkB;AACnD;AACA;AACA;AACA,iCAAiC,4BAAQ;;AAEzC;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,2CAAa;AACzB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAa;AACzC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,iCAAiC,qCAAe;AAChD,iCAAiC,qCAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8FAA8F,6BAA6B;AAC3H,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,iEAAiE,yCAAyC;AAC1G;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAe,6BAAQ,EAAC;;;AC7iFxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEiC;AACR;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,QAAQ;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,oBAAoB;AACpB;AACA;;AAEA,2CAA2C,2CAAa;;AAExD;AACA;AACA;AACA,sBAAsB,2CAAa;AACnC,oBAAoB,yCAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2CAAa;AACnC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAAe,qCAAY,EAAC;;;AC7qB5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAAQ,GAAG,4BAAQ;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,8BAAS;AAC7B;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,kDAAkD;;AAElD;AACA;AACA,sCAAsC;AACtC,sDAAsD;AACtD,0BAA0B;AAC1B;AACA,qCAAqC;AACrC;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;;AAEA;;AAEA,4BAA4B,cAAc;AAC1C;AACA;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,SAAS;AACrC;AACA;;AAEA;;AAEA,uCAAuC,eAAe;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI,gFAAkC;AACtC;;AAEA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,IAAI,wEAA8B;AAClC;AACA;AACA;AACA;;AAEA,wCAAe,4BAAQ,EAAC;;;AC90BxB;AACA;;AAEyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAAQ,GAAG,4BAAQ;;AAEnB;AACA;AACA;AACA;AACA,sCAAa;AACb;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAe,sCAAa,EAAC;;;AC7O7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACS;;AAElC;AACA;;AAEA;AACA,4BAAQ,GAAG,4BAAQ;;AAEnB;AACA;AACA;AACA;AACA,0CAAe;AACf;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAe;AAClC;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS,qCAAqC,4BAA4B;AACzF;AACA,gBAAgB,OAAO;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,qBAAe;AACpC;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA,2CAAe,0CAAe,EAAC;;;ACnO/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;AACM;AACM;AACJ;;AAEjC;AACA;AACA;AACA;AACA,gCAAU;AACV;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,QAAQ,8BAAS;AACjB,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,uCAAW;;AAEjC;AACA;AACA;AACA,UAAU,OAAO,uCAAW;;AAE5B;AACA,kCAAkC;AAClC,YAAY,uCAAW;AACvB;AACA;;AAEA,kBAAkB,wCAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;;AAEhC;AACA;AACA;;AAEA,sBAAsB,SAAS,CAAC,oBAAoB;AACpD,gBAAgB,yCAAY;AAC5B;AACA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,yBAAyB;AACrD;AACA;;AAEA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,8GAA8G;AAC9G,2BAA2B;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,4BAAQ;;AAE1B;AACA;AACA;AACA,+CAA+C;AAC/C,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC,YAAY,8BAAS;AACrB;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,sDAAqB;AACpC;AACA,YAAY,4DAAwB;AACpC,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;;AAEA,0CAAe,GAAG,sDAAqB;;AAEvC,2CAAe,gCAAU,EAAC;;;ACtR1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEsC;AACF;AACX;AACS;AACI;AACL;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAY;AACZ;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,qBAAqB;AACpC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,YAAY;AAClD,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,yCAAY;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,yCAAY;AACxB;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B,oBAAoB,yCAAY;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,qBAAqB;AACpC,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,yCAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,uBAAuB,0BAAM,CAAC,oDAAmB;AACjD,uBAAuB,0BAAM;AAC7B,gBAAgB,oDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,sBAAsB;AAClC,YAAY,iBAAiB;AAC7B;;AAEA,YAAY,sBAAsB;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAc;AAC9B;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAc;AAClC;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA,sBAAsB,+BAAY;AAClC;AACA;;AAEA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,2BAAO;AACpE;;AAEA,gCAAgC,mCAAmC;AACnE;AACA;AACA;;AAEA,gCAAgC,8BAA8B;AAC9D;AACA,kEAAkE,gEAAyB;AAC3F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,mCAAmC;AAC3D;;AAEA,mCAAmC,2BAAO;AAC1C;AACA;;AAEA,oDAAoD,2BAAO;AAC3D;AACA;;AAEA;;AAEA,mCAAmC,2BAAO;AAC1C;AACA;;AAEA,oDAAoD,2BAAO;AAC3D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mCAAS;;AAE3B,QAAQ,gCAAgC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAAe,qCAAY,EAAC;;;AC/Z5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;AACa;AACF;AACX;AACS;AACD;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,6BAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,QAAQ;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAwB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,kBAAkB,2BAAO,GAAG,2BAAO;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAwB;AAClD,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,UAAU;AAC9B;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,kBAAkB,2BAAO,GAAG,2BAAO;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,4BAA4B,2BAAO;AACnC;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,WAAW;AAC3B;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA,oBAAoB,UAAU;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,6DAA2B;;AAEjD,qBAAqB,yCAAiB;AACtC,qBAAqB,yCAAiB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,6BAAQ;AAC3E;AACA,+BAA+B,0BAAM,CAAC,sDAAoB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAAM,CAAC,sDAAoB;AAClE,0BAA0B;AAC1B,uCAAuC,0BAAM,CAAC,sDAAoB;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,wBAAwB,6BAAQ;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAAM,CAAC,sDAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAiB;AAC7C;AACA,uCAAuC,0BAAM,CAAC,sDAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,iBAAiB,mCAAc;AAC/B,iBAAiB,mCAAc;AAC/B,iBAAiB,mCAAc;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc,mCAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAiB,8BAA8B,2BAAO;AAC1E;AACA;AACA,oBAAoB,yCAAiB,8BAA8B,2BAAO;AAC1E;AACA;;AAEA;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C,oBAAoB,yCAAiB,8BAA8B,2BAAO;AAC1E;AACA;AACA,oBAAoB,yCAAiB,8BAA8B,2BAAO;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE,2BAAO;AACxE,iEAAiE,2BAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAoB;AAC5C;AACA;AACA,kBAAkB;AAClB,wBAAwB,+CAAoB;AAC5C;AACA;AACA,kBAAkB;AAClB,wBAAwB,+CAAoB;AAC5C;AACA;AACA,kBAAkB;AAClB,wBAAwB,+CAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,uCAAW;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,gCAAgC,mCAAc;AAC9C;AACA;AACA;AACA;AACA,gCAAgC,2BAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAAM,CAAC,sDAAoB;AAC9D;AACA;AACA;AACA;AACA,0CAA0C,8DAAwB;AAClE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAsB;AAClC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,kCAAkC;AAClC,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,uCAAW;AAC/B;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,sBAAsB;AACrC,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,mDAAsB;AAClC;AACA;AACA,gBAAgB,mDAAsB;AACtC;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,wBAAwB,mDAAsB,MAAM,mDAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,WAAW;AAC3B;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,8DAAwB;AACzD,0BAA0B,wDAAqB,iBAAiB,8DAAwB;AACxF;AACA,oBAAoB,+BAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,8DAAwB;AACrD;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,wBAAwB,0BAAM;AAC9B,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAwB;AACrD;AACA;AACA,UAAU,8BAA8B,8DAAwB,IAAI,uCAAW;AAC/E;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,sBAAsB,gEAAyB;AACzD,wBAAwB,yBAAyB;AACjD;AACA;AACA,UAAU,8BAA8B,gEAAyB;AACjE;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,wBAAwB,0BAAM;AAC9B,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS,yCAAY;AAC/B;AACA,wBAAwB,SAAS;AACjC,oBAAoB,uCAAW;AAC/B;AACA;AACA,kBAAkB,SAAS,yCAAY;AACvC;AACA,2CAA2C,0BAAM,CAAC,sDAAoB;AACtE,kBAAkB,SAAS,uCAAW;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,WAAW;AAC3B;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA,4DAA4D,sDAAsD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,gEAAgE,sDAAsD;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA,4DAA4D,sDAAsD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA;AACA;AACA,oBAAoB,0DAA0D;AAC9E;AACA;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA,gEAAgE,sDAAsD;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA;AACA,oBAAoB;AACpB,4BAA4B,uBAAuB,WAAW,SAAS;AACvE;AACA,4DAA4D,sDAAsD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA;AACA;AACA,oBAAoB,0DAA0D;AAC9E;AACA;AACA,wBAAwB;AACxB,gCAAgC,uBAAuB,WAAW,SAAS;AAC3E;AACA;AACA,gEAAgE,sDAAsD;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,wDAAwD,sDAAsD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG,4DAA4D,sDAAsD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAiB,0DAA0D,2BAAO;AAC9F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAiB;AAC7B,gBAAgB,2BAAO,GAAG,2BAAO;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,gBAAgB,kCAAkC;AAClD,gBAAgB,WAAW;AAC3B;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA,4DAA4D,sDAAsD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA,gEAAgE,sDAAsD;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,gBAAgB,kCAAkC;AAClD,gBAAgB,WAAW;AAC3B;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA,yDAAyD,6BAA6B;AACtF;AACA;AACA,8BAA8B,sDAAsD;AACpF;AACA,wDAAwD,sDAAsD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA,6DAA6D,6BAA6B;AAC1F;AACA;AACA,kCAAkC,sDAAsD;AACxF;AACA;AACA,4DAA4D,sDAAsD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,gBAAgB,kCAAkC;AAClD,gBAAgB,WAAW;AAC3B;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA,4DAA4D,sDAAsD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAA0D;AAC9E;AACA;AACA,gEAAgE,sDAAsD;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,gCAAU,CAAC,6BAAQ,gCAAgC;;AAEnD,yCAAe,6BAAQ,EAAC;;;AClsExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;AACA;AACQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAAQ;;AAER;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,uCAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,2DAAuB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA,+CAAiB;AACjB;;AAEA,SAAS,uCAAW;AACpB;AACA;;AAEA,SAAS,yCAAY;AACrB;AACA;;AAEA;;AAEA,+BAA+B,sBAAsB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAa;AAClC;;AAEA,gCAAU;AACV,IAAI,mEAA2B;AAC/B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,uBAAuB,+CAAiB;AACxC,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;;AAE7B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2BAA2B;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,QAAQ;AACnB;AACA,mDAAmB;AACnB,8BAA8B;AAC9B;;AAEA,SAAS,uCAAW;AACpB;AACA;AACA;AACA;;AAEA,QAAQ,uCAAW,SAAS,2CAAa;AACzC;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,uEAA6B;AACjC;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2BAA2B;AACnD,oBAAoB,6CAAc;AAClC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,iDAAiD;AACpE;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B,oBAAoB,yCAAY;AAChC;AACA;AACA,kBAAkB;AAClB;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,iDAAiD;AACpE;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B,oBAAoB,yCAAY;AAChC;AACA;AACA,kBAAkB;AAClB;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,oBAAoB,mDAAmB;;AAEvC,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2BAA2B;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAe,6BAAQ,EAAC;;;ACzTxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACQ;;AAEjC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,kCAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,sDAAqB;AACzB;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,oBAAoB;AACvC,qBAAqB,aAAa;AAClC;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,oBAAoB;AACvC,qBAAqB,aAAa;AAClC;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,sBAAK;;AAEL;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,aAAa,aAAa;AAC1B;AACA,8BAAS;AACT,gBAAgB,kCAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,aAAa,aAAa;AAC1B;AACA,8BAAS;AACT,gBAAgB,kCAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,aAAa,aAAa;AAC1B;AACA,gCAAU;AACV,gBAAgB,kCAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,aAAa,aAAa;AAC1B;AACA,8BAAS;AACT,gBAAgB,kCAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,aAAa,aAAa;AAC1B;AACA,gCAAU;AACV,gBAAgB,kCAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B,aAAa,QAAQ;AACrB;AACA,8BAAS;AACT,gBAAgB,kCAAW;;AAE3B;AACA;;AAEA;AACA;;AAEA,sCAAa,GAAG,sBAAK;;AAErB,4CAAe,kCAAW,EAAC;;;;;ACjT3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;AACQ;AACG;AACE;AACP;AACS;AACP;AACF;;AAE/B;AACA;AACA,yDAAyD,sBAAsB,GAAG,sBAAsB;AACxG,QAAQ,0BAA0B;AAClC;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB,GAAG,eAAe;AAC3G,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,eAAe;AACvE;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,YAAY,iBAAiB,YAAY;AACzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,mCAAmC;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,wEAA8B;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,8CAA8C;AAChG,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ,OAAO,uDAAuD,uBAAuB;AAChH;AACA,mBAAmB,SAAS,2BAA2B,8CAA8C;AACrG;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,2CAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uCAAW,eAAe,uCAAW;AACtD;AACA;AACA;AACA;;AAEA,4BAA4B,uCAAW;AACvC;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,iCAAiC,gBAAgB;AACjD,mBAAmB,WAAW,mBAAmB,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAA0B,CAAC,2CAAa;;AAE/D;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;;AAEA;AACA,qCAAqC,0BAA0B;;AAE/D;AACA;AACA;AACA,SAAS;;AAET;AACA,oFAAoF,gBAAgB;AACpG,mBAAmB,WAAW,mBAAmB,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;AACpC;AACA;AACA,uBAAuB,4DAA0B,CAAC,2CAAa;AAC/D,uBAAuB,2CAAa;AACpC,uBAAuB,2CAAa;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA,SAAS;;AAET;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA,mBAAmB,WAAW,mBAAmB,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,uCAAW;AAC3B;AACA;;AAEA;AACA;AACA,YAAY,yDAAoB;;AAEhC;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,gCAAgC,gBAAgB;AAChD,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA,oFAAoF,eAAe;AACnG,mBAAmB,UAAU,qBAAqB,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB,QAAQ,gBAAgB;AAC7D,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA,oFAAoF,gBAAgB;AACpG,mBAAmB,WAAW,mBAAmB,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC;AACA,cAAc;AACd,oBAAoB,2CAAa;AACjC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,4DAAuB;AAC3D;AACA,cAAc,6BAA6B,8DAAwB;AACnE;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,yBAAyB,2BAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B,gCAAgC,2CAAa;AAC7C,kBAAkB;AAClB,4CAA4C,4DAAuB;AACnE;AACA,sBAAsB;AACtB;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B,+BAA+B,2CAAa;AAC5C,kBAAkB;AAClB,4CAA4C,4DAAuB;AACnE;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,uCAAW;AACnC,+BAA+B,2CAAa;AAC5C;AACA,qCAAqC,uCAAW;AAChD,+BAA+B,2CAAa;AAC5C;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,uCAAW;AACnC,+BAA+B,2CAAa;AAC5C;AACA,qCAAqC,uCAAW;AAChD,+BAA+B,2CAAa;AAC5C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD,qBAAqB,2CAAa;AAClC,YAAY,iDAAqB;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B,oBAAoB,YAAY,kDAAkD,qCAAqC;AACvH,oBAAoB,YAAY,mDAAmD,qCAAqC;AACxH,oBAAoB,SAAS;AAC7B,oBAAoB,QAAQ;AAC5B,4BAA4B,0CAA0C;AACtE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAsB;;AAEtD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,oBAAoB,0DAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAsB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,YAAY;AAC/B,mBAAmB,YAAY;AAC/B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC;AACA,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;;AAEjC;AACA,iCAAiC,2CAAa;AAC9C,oCAAoC,0DAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAa;AAC7C,oCAAoC,0DAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAsB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA,SAAS;;AAET;AACA,mBAAmB,aAAa,MAAM,eAAe;AACrD;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,mBAAmB,YAAY,mBAAmB,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA,iDAAiD,kBAAkB,QAAQ,gBAAgB;AAC3F,mBAAmB,YAAY,mBAAmB,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0DAA0D,2BAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB,QAAQ,gBAAgB;AAC/D,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA,oCAAoC,kBAAkB;AACtD,mBAAmB,aAAa,mBAAmB,mBAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B;AAC/D;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA,mBAAmB,UAAU,wBAAwB,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6DAA6D,gBAAgB;AAC7E,mBAAmB,UAAU,yBAAyB,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,uBAAuB,gBAAgB,QAAQ,iBAAiB;AAChE,mBAAmB,UAAU,oBAAoB,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B,gBAAgB,sCAAa;AAC7B;AACA;AACA;AACA,8GAA8G;AAC9G;AACA,iCAAiC,2CAAa;;AAE9C,wBAAwB,2CAAa;AACrC,qBAAqB,uCAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,uCAAW;AACjD,6BAA6B,2CAAa;AAC1C;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA,6DAA6D,gBAAgB;AAC7E,mBAAmB,UAAU,oBAAoB,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,+DAAuB;AACnE;AACA,8BAA8B;AAC9B,4CAA4C,mEAAyB;AACrE,4CAA4C,6DAAsB;AAClE;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,2CAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,gCAAgC,8BAAS;AACzC;AACA,0BAA0B,SAAS,2CAAa;AAChD;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8BAA8B;AAC9B,gCAAgC,8BAAS;AACzC;AACA,0BAA0B,SAAS,2CAAa;AAChD;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,gCAAgC,8BAAS;AACzC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa,gBAAgB,GAAG,4BAA4B;AAC5D;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAS,sBAAsB,gBAAgB;;AAEtE;AACA,wBAAwB,SAAS;AACjC,oBAAoB,mCAAS;AAC7B;AACA,0BAA0B,mCAAS;AACnC;AACA;AACA,yBAAyB;AACzB;AACA,0BAA0B,mCAAS;AACnC,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA,SAAS;;AAET;AACA,0FAA0F,gBAAgB;AAC1G;AACA,mBAAmB,UAAU,qBAAqB,gBAAgB;AAClE,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAa;AACvC;AACA;AACA,2BAA2B,2CAAa;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA,gCAAgC,2CAAa;AAC7C;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD,gCAAgC,uCAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2CAAa;AAClC;AACA;AACA;AACA,uCAAuC,aAAa;AACpD,gCAAgC,uCAAW;AAC3C;AACA;AACA;AACA,sBAAsB;AACtB;AACA,uCAAuC,aAAa;AACpD,gCAAgC,uCAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB,YAAY;AAClD;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,yCAAyC,iBAAiB;AAC1D,mBAAmB,WAAW,oBAAoB,iBAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,0BAA0B;AAC/D,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,oBAAoB,yCAAc;AAClC;AACA;AACA;AACA;AACA,gBAAgB,yCAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,oBAAoB,WAAW,iBAAiB,IAAI,gBAAgB;AACvF,mBAAmB,OAAO,6BAA6B,0BAA0B;AACjF;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU,qBAAqB,iBAAiB;AACnE,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;AACjD;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,YAAY,6BAA6B;AACzC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,MAAM;AACzB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,aAAa,oCAAoC;AACpE;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,uDAAuD,uCAAW;AAClE,sBAAsB,2CAAa;AACnC,oDAAoD,2CAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,oDAAoD;AACpD,mBAAmB,qBAAqB;AACxC,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,iDAAiD;AACjD;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,2CAA2C;AAC3C;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,4FAA4F;AAC5F;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,cAAc,6EAA6E;AAC3F;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,iBAAiB,2CAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,gEAAyB;AACrD;AACA,cAAc;AACd,wCAAwC,8DAAwB;AAChE;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,4BAA4B,gEAAyB;AACrD;AACA,cAAc;AACd,gCAAgC,8DAAwB;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB,0BAA0B,2BAA2B;AAC7F;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,gEAAyB;AACzD;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,4CAA4C,4DAAuB;AACnE;AACA,sBAAsB,qBAAqB,4DAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA,4CAA4C,4DAAuB;AACnE,4CAA4C,8DAAwB;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,sEAAsE,qCAAqC;AAC3G,mBAAmB,qBAAqB;AACxC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,2CAAa;AAC9B,gCAAgC,gEAAyB;AACzD;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,4CAA4C,4DAAuB;AACnE;AACA,sBAAsB,qBAAqB,4DAAuB;AAClE;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA,qBAAqB,2CAAa;AAClC;AACA;AACA,wCAAwC,4DAAuB;AAC/D,wCAAwC,8DAAwB;AAChE;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mFAAmF,SAAS;AAC5F;AACA,6EAA6E,SAAS;AACtF;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;;AAExB,oBAAoB,oCAAY;AAChC;AACA;AACA;AACA,4BAA4B,mCAAS;AACrC;AACA,yBAAyB;AACzB;AACA;AACA;AACA,oBAAoB,oCAAY;AAChC,oBAAoB,oCAAY;AAChC,oBAAoB,oCAAY;AAChC,oBAAoB,oCAAY;AAChC;;AAEA,gBAAgB,sCAAa;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,uCAAuC,kEAAkE;AACzG;AACA,mBAAmB,SAAS;AAC5B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,0CAA0C;;AAE1C;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,uCAAuC;;AAEvC;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,uCAAuC;;AAEvC;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA,sDAAe,oDAAoB,EAAC;;;ACnzEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACM;AACE;AACQ;AACJ;;AAErC;AACA;AACA;AACA,wCAAc;AACd;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD;AACtD,cAAc;AACd,oDAAoD;AACpD;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,YAAY,8BAAS;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA,4BAA4B,8BAAwB;AACpD;AACA;AACA,+BAA+B,aAAa;AAC5C,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mCAAS;AAC3B;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,MAAM;AACrB,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,aAAa,uCAAW;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mCAAS;;AAE3B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA,oEAAoE;AACpE,eAAe,QAAQ;AACvB,eAAe,oBAAoB;AACnC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,UAAU;AACzB;AACA;AACA,YAAY,2CAAa;AACzB;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;;AAEA;AACA,iBAAiB,kCAAW;;AAE5B,YAAY,uCAAW;AACvB;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;;AAEA,YAAY,+CAAe;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK,wCAAc;AACnB,IAAI,sCAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAe,wCAAc,EAAC;;;;;;;;;AC/R9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACQ;;AAEjC;AACA,kEAAkE,0BAA0B;AAC5F,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,0CAAe;AACf;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,uCAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2BAA2B;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,8DAAyB;AAC7B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,iBAAiB,uCAAW,gBAAgB,uCAAW;AACvD,oBAAoB,uCAAW;AAC/B;AACA,kBAAkB;AAClB;AACA;;AAEA,oBAAoB,uCAAW;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,gBAAgB,uCAAW,CAAC,8BAAS;AACrC,uBAAuB,0EAA+B;AACtD;;AAEA,uBAAuB,0CAAe;AACtC,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAe,0CAAe,EAAC;;;ACrR/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEyB;AACO;AACF;AACG;AACO;AACT;AACS;AACF;AACM;AACE;AACX;AACF;AACS;AACX;AACS;;AAExC;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA,WAAW,QAAQ;AACnB,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ,2CAA2C;AAC9D;AACA;AACA;AACA;AACA;AACA,8BAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uCAAW;AACvB;AACA,UAAU,SAAS,sCAAa;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,sCAAa;;AAE1C,YAAY,sCAAa;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa,CAAC,sBAAO;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,yBAAU;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,uCAAW,qBAAqB,sCAAa,KAAK,uCAAW;AACzE;AACA,UAAU;AACV;AACA;;AAEA,QAAQ,4CAAqB;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0EAA0E,mCAAmC;AAC7G,eAAe,sBAAsB,QAAQ,iCAAiC;AAC9E,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,gDAAiB;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC,0BAA0B,4BAAQ,EAAE;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,kDAAmB;AACvB;AACA;AACA;AACA,wBAAwB,gBAAgB,iDAAiD;AACzF,sEAAsE,kBAAkB;AACxF,4EAA4E,kBAAkB;AAC9F;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,4DAAuB;AACvD;AACA;;AAEA,gBAAgB,yCAAY,YAAY,6CAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB,4DAAuB;AAC9D;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B,4BAA4B;AAC5B,4BAA4B;AAC5B,8BAA8B;AAC9B,2BAA2B;AAC3B,0BAA0B;AAC1B,4BAA4B;AAC5B,2BAA2B;AAC3B,4BAA4B;AAC5B,6BAA6B;AAC7B,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,8BAA8B;AAC9B,yBAAyB;AACzB,0BAA0B;AAC1B,4BAA4B;AAC5B,0BAA0B;AAC1B,8BAA8B;AAC9B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,4BAA4B;AAC5B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,yCAAY;AAC7B,wCAAwC,4DAAuB;AAC/D,gCAAgC,4DAAuB;AACvD;AACA,oCAAoC,gEAAyB;AAC7D,8BAA8B;AAC9B,kBAAkB,iCAAiC,gEAAyB;AAC5E,8BAA8B;AAC9B,kBAAkB,iCAAiC,4DAAuB;AAC1E,8BAA8B;AAC9B,kBAAkB;AAClB,8BAA8B;AAC9B;AACA,yBAAyB;AACzB;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA,qCAAqC,mCAAmC;AACxE;;AAEA,4CAA4C,OAAO;AACnD;AACA;;AAEA,yBAAyB,uCAAW;AACpC;AACA;AACA;AACA;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA,mBAAmB,uCAAW,CAAC,gCAAU;AACzC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,0CAA0C;AAC1C;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,uCAAW;AAC3C;AACA,uBAAuB,uCAAW;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,iBAAiB,2CAAa;AAC9B,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAW;AACvC;AACA,wBAAwB,uCAAW;AACnC,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,kCAAW;AACtC,2BAA2B,kCAAW;;AAEtC;AACA;AACA;AACA,+BAA+B,kCAAW;AAC1C,+BAA+B,kCAAW;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sCAAa;AAChC;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA,2BAA2B,kCAAW;AACtC,2BAA2B,kCAAW;;AAEtC,2BAA2B,kCAAW;AACtC,2BAA2B,kCAAW;;AAEtC,2BAA2B,kCAAW;AACtC,2BAA2B,kCAAW;AACtC;;AAEA;AACA,2BAA2B,kCAAW;AACtC,2BAA2B,kCAAW;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,kCAAW;AAClC,uBAAuB,kCAAW;;AAElC;AACA;AACA;AACA,2BAA2B,kCAAW;AACtC,2BAA2B,kCAAW;AACtC;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA,qBAAqB,OAAO,iEAAiE;AAC7F;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,0CAAe;;AAEpC;AACA;AACA;AACA,iBAAiB,uCAAW;AAC5B;AACA;AACA;AACA;AACA,gBAAgB,yCAAc;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;;AAEtC;AACA,yBAAyB,UAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAY,8BAA8B,4DAAuB;AAC1F;AACA,qBAAqB,2CAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uCAAW;AACxC;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,uCAAW;AAC3C;AACA,oCAAoC,2CAAmB;AACvD;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B,gBAAgB,2CAAa;AAC7B;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ,qCAAqC,iBAAiB,IAAI,kBAAkB;AACvG,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA,6BAA6B,0BAAM;AACnC,oBAAoB,0DAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,iCAAc;AAC/C;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B,yCAAyC,0DAAsB;AAC/D,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,0DAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ,qCAAqC,kBAAkB;AAClF,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA,gBAAgB,uCAAW,OAAO,uCAAW;AAC7C;AACA,cAAc;AACd;AACA;;AAEA;AACA,sCAAsC,4DAAuB;AAC7D,8BAA8B,gEAAyB;AACvD;AACA;AACA,cAAc,+BAA+B,gEAAyB;AACtE;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO,2CAA2C,0BAA0B;AAC/F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,uCAAW;AAC3B,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,0BAA0B,0BAAM,CAAC,0DAAsB;AACvD;AACA;AACA,yBAAyB,0BAAM,CAAC,0DAAsB;AACtD;AACA;AACA,yBAAyB,0BAAM,CAAC,0DAAsB;;AAEtD;AACA,qBAAqB,6CAAgB;AACrC,qBAAqB,6CAAgB;;AAErC;AACA,oBAAoB,6CAAgB;;AAEpC;AACA,qCAAqC,2BAAO;AAC5C;AACA;;AAEA,oBAAoB,2CAAa;AACjC,4BAA4B,+BAAY;AACxC;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA,oBAAoB,2CAAa;AACjC;AACA,wBAAwB,yCAAiB,YAAY,yCAAiB;;AAEtE;AACA;AACA,qBAAqB;AACrB,4DAA4D,eAAe;AAC3E;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA,0CAA0C,4DAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,gEAAyB;AAClE;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO,2CAA2C,0BAA0B;AAC/F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,uCAAW;AAC3B,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,0BAA0B,0BAAM,CAAC,0DAAsB;AACvD;AACA;AACA,yBAAyB,0BAAM,CAAC,0DAAsB;AACtD;AACA;AACA,yBAAyB,0BAAM,CAAC,0DAAsB;;AAEtD,wBAAwB,+BAAY;;AAEpC;AACA;AACA;AACA,iBAAiB;AACjB,yDAAyD,gBAAgB;AACzE;AACA,oBAAoB,2CAAa;AACjC,wBAAwB,yCAAiB,YAAY,yCAAiB;AACtE,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,wBAAwB,2CAAa;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,uCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,4DAAuB;AACpD;AACA,cAAc,8BAA8B,4DAAuB;AACnE;AACA;AACA,cAAc,8BAA8B,gEAAyB;AACrE;AACA;AACA;AACA;AACA,cAAc,sBAAsB,gEAAyB;AAC7D;AACA,4BAA4B,SAAS;AACrC;AACA;AACA,cAAc,sBAAsB,8DAAwB;AAC5D;AACA;AACA;AACA,cAAc,SAAS,yCAAY,sBAAsB,8DAAwB;AACjF;AACA,cAAc,8BAA8B,8DAAwB;AACpE;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB,oBAAoB,8BAAS;AAC7B;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,WAAW;AAC/B;AACA;AACA,8BAA8B,8CAAiB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,8DAAyB;AACzC;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,4EAA4E,oBAAoB,cAAc;AAC9G;AACA;AACA;AACA;AACA,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,sCAAa;AAC7B;AACA;AACA;AACA,kBAAkB;AAClB;AACA,oBAAoB,oCAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAY;AAC5B;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,sCAAa;AAC7B,oBAAoB,uCAAW;AAC/B;AACA,kBAAkB;AAClB,oBAAoB,0CAAe;AACnC;AACA;AACA,gBAAgB,0CAAe;AAC/B;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,4CAA4C,sCAAa;AACzD;;AAEA;AACA;AACA,oBAAoB,oCAAY;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,oCAAY;AAChC,kBAAkB;AAClB,oBAAoB,oCAAY;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,oCAAY;AAChC;AACA,gBAAgB,oCAAY;AAC5B,gBAAgB,oCAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,0CAA0C,sCAAa;AACvD;;AAEA,gBAAgB,oCAAY;AAC5B,gBAAgB,oCAAY;;AAE5B,gBAAgB,oCAAY;AAC5B,gBAAgB,oCAAY;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,0CAA0C,sCAAa;AACvD;;AAEA,gBAAgB,oCAAY;AAC5B,gBAAgB,oCAAY;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,sCAAa;AAChE,4BAA4B,QAAQ;AACpC,oBAAoB,oCAAY;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA,2EAA2E,sCAAa;AACxF,gBAAgB,oCAAY;AAC5B,gBAAgB,oCAAY;AAC5B,gBAAgB,oCAAY;AAC5B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,4CAA4C,sCAAa;AACzD,gBAAgB,0CAAe;AAC/B,gBAAgB,0CAAe;AAC/B,gBAAgB,0CAAe;AAC/B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,sCAAa;AAC/D,4BAA4B,QAAQ;AACpC,oBAAoB,0CAAe;AACnC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,2CAA2C,sCAAa;AACxD;;AAEA;AACA;AACA,oBAAoB,0CAAe;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAAe;AACnC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,0CAAe;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAAe;AACnC;;AAEA,gBAAgB,0CAAe;AAC/B,gBAAgB,0CAAe;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,0CAAe;AACvC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,wBAAwB,0CAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,yCAAyC,sCAAa;AACtD;;AAEA,gBAAgB,0CAAe;AAC/B,gBAAgB,0CAAe;;AAE/B;AACA,oBAAoB,0CAAe;AACnC;AACA;;AAEA,gBAAgB,0CAAe;AAC/B,gBAAgB,0CAAe;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,yCAAyC,sCAAa;AACtD;;AAEA,gBAAgB,0CAAe;AAC/B,gBAAgB,0CAAe;;AAE/B;AACA,oBAAoB,0CAAe;AACnC;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,yCAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,+BAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,0BAAM,CAAC,0DAAsB;;AAEjD;AACA;;AAEA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,yCAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,oBAAoB,SAAS;AAC7B;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,+BAA+B;AAC3F;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,0DAA0D,+BAA+B;AACzF;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,SAAS;;AAET;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,+CAA+C,+BAA+B;AAC9E;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,gBAAgB,sCAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,oCAAY;AAChC,kBAAkB;AAClB;AACA,oBAAoB,oCAAY;AAChC,oBAAoB,oCAAY;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,+CAAe;AAC1D;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,sCAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA,gBAAgB,2CAAa;AAC7B,kBAAkB,2CAAa,4BAA4B,2CAAa;AACxE;AACA,qCAAqC;AACrC;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,yBAAyB;AACrD;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,sDAAsD,QAAQ;AAC9D;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uCAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,0CAAe;AACnC,kBAAkB;AAClB,oBAAoB,0CAAe;AACnC,oBAAoB,0CAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAiB;AAClD;AACA;;AAEA;AACA,gBAAgB,oCAAY;AAC5B;AACA;;AAEA;AACA,2CAA2C;;AAE3C;AACA,2CAA2C,+CAAe;AAC1D;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA,wBAAwB,yBAAyB;AACjD;AACA,4BAA4B,yBAAyB;AACrD;AACA;;AAEA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,wBAAwB,8BAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAAS;AACjC,+DAA+D,4DAA0B;AACzF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,yCAAY;AACxC,iDAAiD,4DAAuB;AACxE,yCAAyC,4DAAuB;AAChE,yCAAyC,4DAAuB;AAChE;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD,4BAA4B;AAC5E;AACA,0BAA0B;AAC1B,iDAAiD,4DAAuB;AACxE,iDAAiD,gEAAyB;AAC1E,iDAAiD,8DAAwB;AACzE,yCAAyC,gEAAyB;AAClE;AACA;;AAEA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAiB;;AAElD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8CAAiB;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,4BAA4B,yBAAyB;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;;AAEA,gCAAgC,yBAAyB;AACzD;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,yCAAY;AACpC;AACA,sBAAsB,4CAA4C,4DAAuB;AACzF;AACA;AACA;AACA,sBAAsB,4CAA4C,gEAAyB;AAC3F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,0CAAe;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA;AACA,2CAA2C,+CAAe;AAC1D;AACA,cAAc;AACd;AACA;;AAEA;AACA,gBAAgB,oCAAY;AAC5B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,uCAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,4BAA4B,6BAA6B;AACzD;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,0CAAe;AAC/B;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,0BAAM,CAAC,0DAAsB;;AAEvD;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAa;AAClC,qBAAqB,2CAAa;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;;AAEA;AACA,iBAAiB,2CAAa;AAC9B,iBAAiB,2CAAa;AAC9B;AACA;;AAEA,oBAAoB,2CAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,uCAAW;AAC/B;AACA,wBAAwB,uCAAW;AACnC;AACA,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,wBAAwB,uCAAW;AACnC;AACA,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;AACrC;AACA;AACA,mCAAmC,2CAAa;AAChD;;AAEA,4BAA4B,2CAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,yCAAY;AACzC,gDAAgD,4DAAuB;AACvE;AACA,yBAAyB,2CAAa;AACtC;;AAEA;AACA,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA;AACA;AACA,mCAAmC,gDAAkB;AACrD,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sCAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sCAAa;AAC9B;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sCAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sCAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA,uBAAuB,uDAAmB,GAAG;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;;AAEtD;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC,kBAAkB,2CAAa;AAC/B;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;;AAEA,kCAAkC,2CAAa;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,+CAAe;AAC3C,4BAA4B,+CAAe;AAC3C,sBAAsB,SAAS,2CAAa;AAC5C,4BAA4B,yCAAY;AACxC,4BAA4B,yCAAY;AACxC,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,qBAAqB;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,qBAAqB;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,iEAAiE,wBAAwB;AACzF;AACA,+DAA+D,wBAAwB;AACvF,oBAAoB;AACpB;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA;AACA,qEAAqE,wBAAwB;AAC7F;AACA,mEAAmE,wBAAwB;AAC3F,wBAAwB;AACxB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAe;AACxC;AACA;AACA,gCAAgC,0BAAM,CAAC,0DAAsB;;AAE7D;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,yBAAyB,0CAAe;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;;AAEA,oBAAoB,uCAAW;AAC/B,wBAAwB,2CAAa;AACrC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,gBAAgB,uCAAW,OAAO,uCAAW;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,0BAAM,CAAC,0DAAsB;AACtD,yBAAyB,0BAAM;AAC/B,oBAAoB,0DAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD,sDAAoB;AACtE,0BAA0B;AAC1B,kDAAkD,sDAAoB;AACtE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,YAAY;AACrD;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,gCAAgC,8CAAe;AAC/C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,uCAAuC;AACvC,yCAAyC,uBAAuB;AAChE,yCAAyC,mDAAiB;;AAE1D;AACA;AACA;AACA,oCAAoC;AACpC,wBAAwB,uDAAmB;;AAE3C;AACA,qBAAqB,uCAAW;AAChC,oBAAoB,8BAAS;AAC7B,kBAAkB;AAClB,0EAA0E;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,sBAAsB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA,yBAAyB,0BAAM,CAAC,sDAAoB;AACpD,yBAAyB,0BAAM;AAC/B,oBAAoB,sDAAoB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2CAAa,OAAO,2CAAa;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;;AAExE;AACA;AACA;;AAEA,gBAAgB,2CAAa,OAAO,2CAAa;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;;AAEA,oBAAoB,yCAAY;AAChC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,yCAAY;AAC7B;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;;AAEA;AACA,oBAAoB,yCAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B,4BAA4B,mBAAmB;AAC/C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,uCAAW,YAAY,2CAAa;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAW;AAC3C,gCAAgC,uCAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,uCAAW;AACtC;AACA;AACA;AACA;AACA,gCAAgC,uCAAW;AAC3C,gCAAgC,uCAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA,kBAAkB,yBAAyB,8DAAwB;AACnE,oBAAoB,8BAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,2CAAa;AACnD;AACA;;AAEA;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA,cAAc;AACd,gBAAgB,8BAAS;AACzB;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;;AAET;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;;AAEA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD;AACjD,iDAAiD;;AAEjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA,uCAAuC,+CAAe;AACtD;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6BAA6B,8BAA8B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,8BAA8B;AACvD;AACA,iEAAiE,4DAAuB;AACxF;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,uCAAW;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,cAAc;AACd,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,6BAA6B,WAAW;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,uBAAuB,oBAAoB;AAC3C,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,YAAY,wCAAc;AAC1B,gBAAgB,iCAAQ;;AAExB,sBAAsB,iCAAQ;;AAE9B;AACA;;AAEA;AACA,SAAS;;AAET;AACA,qBAAqB,mBAAmB;AACxC;AACA,kBAAkB,oCAAY,CAAC,kDAAmB;;AAElD;AACA,uBAAuB,qBAAqB;AAC5C,mBAAmB,iBAAiB;AACpC,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,YAAY,wCAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,qBAAqB,oBAAoB;AACzC;AACA,qBAAqB,oCAAY,CAAC,kDAAmB;;AAErD;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA,YAAY,wCAAc;;AAE1B,qBAAqB,iCAAQ;AAC7B;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA;AACA,gBAAgB,uCAAW,WAAW,uCAAW;AACjD;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,+CAAe,CAAC,oCAAY;AAC5C,qBAAqB,oCAAY;AACjC,cAAc;AACd;AACA;;AAEA,iBAAiB,uCAAW;AAC5B,gBAAgB,8BAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,YAAY,wCAAc;AAC1B;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA,yBAAyB,8BAA8B;AACvD;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B;AACA,mBAAmB,QAAQ;AAC3B,iBAAiB,uBAAuB,KAAK,uBAAuB;AACpE;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAiB;;AAEvC,iBAAiB,yCAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD,wDAAwD;AACxD;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,wDAAwD,6BAAQ;AAChE;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA,wDAAwD,6BAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd,6BAA6B,uCAAW;AACxC,6BAA6B,uCAAW;AACxC;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA,yBAAyB,0BAAM,CAAC,0DAAsB;AACtD,yBAAyB,0BAAM;AAC/B,oBAAoB,0DAAsB;AAC1C;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;;AAEA;AACA,4BAA4B,+CAAe;AAC3C;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA,6BAA6B,uCAAW;AACxC,8BAA8B,yCAAY;AAC1C;AACA;AACA,0BAA0B;AAC1B,kDAAkD,sDAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,uCAAW;AAChD;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,uCAAW,sBAAsB,uCAAW;AACrE;AACA;;AAEA,4BAA4B,uCAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,SAAS;AAC5B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wCAAY;AACrD,gCAAgC,2CAAa;AAC7C;AACA;AACA,uCAAuC,wCAAY;AACnD,gCAAgC,2CAAa;AAC7C;AACA;AACA,kDAAkD,wCAAY;AAC9D,gCAAgC,2CAAa;AAC7C;AACA;AACA,gDAAgD,wCAAY;AAC5D,gCAAgC,2CAAa;AAC7C;AACA;AACA,yBAAyB;AACzB,sBAAsB,SAAS,uCAAW;AAC1C,wBAAwB,gCAAU;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA,mBAAmB,SAAS;AAC5B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB,eAAe;AAC3C;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA,kBAAkB,SAAS,uCAAW;AACtC;AACA;AACA,kBAAkB,SAAS,uCAAW;AACtC;AACA;;AAEA;AACA,cAAc;AACd;AACA,iBAAiB,+CAAe,QAAQ,2CAAa,QAAQ,+CAAe;AAC5E;AACA,wBAAwB,uDAAmB;;AAE3C;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,wBAAwB,WAAW;;AAEnC;AACA,cAAc;AACd,gBAAgB,2CAAa;AAC7B,gBAAgB,uCAAW;AAC3B,iBAAiB,uCAAW;AAC5B;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,mBAAmB,sBAAsB,kBAAkB;AAC9E,mBAAmB,QAAQ,6DAA6D,kBAAkB;AAC1G,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW,OAAO,yCAAY;AAC9C;AACA;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,8DAAyB;;AAExD;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,uCAAuC,yCAAc,CAAC,8DAAyB;AAC/E;AACA;AACA,mCAAmC,mCAAW;AAC9C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAc,CAAC,8DAAyB;;AAE/E;AACA;AACA,2CAA2C,yCAAc,CAAC,8DAAyB;AACnF;AACA;AACA;AACA;AACA,mCAAmC,mCAAW;AAC9C;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAA+C,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,mBAAmB;AACnB;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE,oDAAoB;AACtF;AACA;AACA;AACA,kEAAkE,oDAAoB;AACtF;AACA;AACA;AACA,kEAAkE,oDAAoB;AACtF;AACA;AACA;AACA,kEAAkE,oDAAoB;AACtF;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,+CAA+C,oCAAoC;AACnF,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,qBAAqB,uCAAW;AAChC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA,iBAAiB,uCAAW;AAC5B,gCAAgC,uDAAmB,OAAO,sBAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,qBAAqB;AACxC;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA,6BAA6B;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,eAAe,mDAAmD,aAAa,KAAK,IAAI;AACxF,eAAe,yCAAyC,cAAc;AACtE;AACA,eAAe;AACf,yDAAyD,mCAAmC;AAC5F;AACA,eAAe;AACf;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA;AACA,wBAAwB,iFAAiF;AACzG;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,wCAAwC,eAAe;AACtE,eAAe,iDAAiD,yBAAyB,IAAI;AAC7F,eAAe;AACf,eAAe,gDAAgD,cAAc;AAC7E;AACA,eAAe;AACf;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA,YAAY;AACZ,oDAAoD;AACpD,eAAe;AACf;AACA,qEAAqE,eAAe;AACpF,8FAA8F,qBAAqB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAsD,wBAAwB;AACtG,oEAAoE;AACpE,wDAAwD;AACxD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,oBAAoB,uCAAW;AAC/B;AACA,kBAAkB,SAAS,uCAAW;AACtC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,oDAAoB,sCAAsC,2CAAa;;AAEvF;AACA;AACA;AACA,cAAc,SAAS,uCAAW;AAClC;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU,gBAAgB,UAAU,IAAI,cAAc;AAChH;AACA,6CAA6C,SAAS;AACtD;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,sBAAsB;AACtB,kCAAkC;AAClC;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB,mCAAmC;AACzD;AACA;AACA,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA,uGAAuG,cAAc;AACrH;AACA,wFAAwF,oFAAoF;AAC5K;AACA,0DAA0D,UAAU,gBAAgB,UAAU,IAAI,cAAc;AAChH;AACA,6CAA6C,SAAS;AACtD;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,sBAAsB;AACtB,kCAAkC;AAClC;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB,mCAAmC;AACzD;AACA;AACA,qDAAqD,mCAAmC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iCAAa;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,uCAAuC,2BAAU;AACjD,uCAAuC,2BAAU;AACjD,uCAAuC,2BAAU;AACjD,uCAAuC,2BAAU;AACjD,wCAAwC,2BAAU;AAClD,wCAAwC,2BAAU;AAClD;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iCAAiC,iCAAa;;AAE9C;AACA,gCAAgC,OAAO;;AAEvC;AACA,gCAAgC,OAAO;;AAEvC,iCAAiC,OAAO,CAAC,2BAAU,gBAAgB,2BAAU;AAC7E,iCAAiC,OAAO,CAAC,2BAAU,gBAAgB,2BAAU;;AAE7E;AACA,4BAA4B,aAAa;;AAEzC;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAAe,8BAAS,EAAC;;;ACl4NzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACQ;AACS;AACJ;AACL;AACE;AACE;AACG;;AAExC;AACA,2DAA2D,2BAA2B;AACtF;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,0CAAe;AACf;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yEAAyE,sBAAsB;;AAE/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,cAAc;AACjC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yCAAY;AAC/C;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA,oBAAoB,IAAI,sDAAuB,EAAE;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAAyB,OAAO,iBAAgB;;AAEhD,gCAAU;AACV,IAAI,8DAAyB;AAC7B;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;;AAEA,iDAAiD,2CAAa;AAC9D;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA,+CAA+C,2CAAa;AAC5D,uDAAuD,2CAAa;AACpE,2DAA2D;AAC3D;;AAEA;AACA,sEAAsE;;AAEtE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sBAAsB;AACtB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,2CAAa;AAClC;AACA;AACA,4BAA4B,oBAAoB;AAChD,wBAAwB,2CAAa;AACrC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA,2CAA2C,2CAAa;AACxD;AACA;;AAEA,gDAAgD,2CAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA,sDAAsD,2CAAa;AACnE;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,yBAAyB,eAAe,YAAY;AACpD;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,+EAA+E;AAC/E;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,2CAAa;;AAEpD;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,2CAAa;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,qGAAqG;AACrG,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,2CAAa;AACpD;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,sBAAsB,2CAAa;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,sBAAsB,2CAAa;AACnC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uCAAW;AAC5B;AACA;AACA,cAAc,kBAAkB,sDAAuB;AACvD,wBAAwB,sDAAuB;AAC/C;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,gBAAgB,uCAAW,WAAW,uCAAW;AACjD;AACA;AACA,SAAS;;AAET;AACA;AACA,iBAAiB,uCAAW;AAC5B;AACA,cAAc,kBAAkB,sDAAuB;AACvD,wBAAwB,sDAAuB;AAC/C;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,uCAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,qBAAqB,uCAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC,2BAA2B,2CAAa;;AAExC;AACA;AACA;;AAEA;AACA,4BAA4B,+DAA4B;AACxD;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,SAAS;AACrC;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE;AACtE,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,wCAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,wCAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,4BAA4B,2CAAa;AACzC;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC,iBAAiB,uCAAW,YAAY,uCAAW;AACnD;AACA;;AAEA,iBAAiB,2CAAa;AAC9B;AACA,kBAAkB,2CAAa;;AAE/B,wEAAwE;AACxE;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC,sBAAsB;AACtB,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA,sDAAsD,2CAAa;AACnE,cAAc;AACd;AACA;AACA,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,2CAAa;AACxC;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,4DAAuB;AAC3D,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,uBAAuB,2CAAa;AACpC,oBAAoB,2CAAa;AACjC,uBAAuB,2CAAa;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,2BAA2B,8CAAe;AAC1C;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA,gCAAgC,sDAAqB;AACrD;AACA;AACA,qBAAqB;AACrB,mDAAmD;AACnD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,uBAAuB,2CAAa;AACpC;AACA,oBAAoB,2CAAa;AACjC;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,2BAA2B,8CAAe;AAC1C;AACA;AACA;;AAEA;;AAEA,wCAAwC,4DAAuB;AAC/D,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA,yBAAyB;AACzB,sBAAsB;AACtB;AACA;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB;AAClB;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA,wCAAwC,8DAAwB;AAChE,wCAAwC,4DAAuB;AAC/D;AACA,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,2CAAa;;AAEjC;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,uCAAW;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,2BAA2B,2CAAa;;AAExC;AACA;AACA;AACA;AACA,iBAAiB,uCAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,uBAAuB,2CAAa;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,oBAAoB,2CAAa;AACjC;AACA;AACA,wBAAwB,sCAAa,CAAC,2CAAa;AACnD,wBAAwB,2CAAa;AACrC,yBAAyB,2CAAa;AACtC,wBAAwB,2CAAa;AACrC,yBAAyB,2CAAa;AACtC,kBAAkB;AAClB;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD,oDAAoD;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oCAAoC;AACpC;AACA,mBAAmB,SAAS;AAC5B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uCAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gEAAgE;AAChE;AACA,qCAAqC;;AAErC;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA,oEAAoE,sBAAsB;AAC1F;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,uCAAW;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAe,0CAAe,EAAC;;;ACvrE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACiB;AACJ;AACL;AACE;AACJ;AACS;;AAExC;AACA,2DAA2D,2BAA2B;AACtF;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA,0CAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA,+FAA+F;AAC/F,SAAS,uCAAW,CAAC,8CAAiB;AACtC;AACA,QAAQ,8CAAiB;AACzB,QAAQ,8DAAyB;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAAyB,OAAO,iBAAgB;;AAEhD,gCAAU;AACV,IAAI,8DAAyB;AAC7B;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd,gBAAgB,8BAAS;AACzB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA,oBAAoB,2CAAa,UAAU,2CAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA,qDAAqD,2CAAa;AAClE;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;;AAElB;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,2CAAa;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,sBAAsB,2CAAa;;AAEnC;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAAa;AACxC,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA,4BAA4B,+DAA4B;AACxD;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,aAAa;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,wCAAc;;AAE1B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,wCAAc;;AAE1B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA,iDAAiD,2CAAa;AAC9D,cAAc;AACd;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA,uBAAuB,2CAAa;AACpC;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,2BAA2B,8CAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA,gCAAgC,4DAAuB;AACvD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,uBAAuB,2CAAa;AACpC;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,uCAAW,oBAAoB,4DAAuB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,2CAAa;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA,+BAA+B,uCAAW;AAC1C;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAe,0CAAe,EAAC;;;;;ACpxC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACiB;AACJ;AACP;AACE;AACA;AACE;AACC;AACL;AACS;AACA;AACxC;;AAEA;AACA,mEAAmE,2BAA2B;AAC9F;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,gDAAkB;AAClB;;AAEA;AACA;AACA,oBAAoB,mCAAY;;AAEhC;;AAEA,QAAQ,sCAAa;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,gCAAU;AACzB;AACA;AACA;AACA;AACA,4BAA4B,KAA0B,GAAG,mBAAc,CAAC,GAAQ,IAAI,CAAgB;AACpG;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oEAA4B,OAAO,iBAAgB;;AAEnD,gCAAU;AACV,IAAI,oEAA4B;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA,kBAAkB;AAClB,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD,qBAAqB,0BAAM,CAAC,sDAAoB;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;AACpC;;AAEA,iBAAiB,2CAAa;AAC9B;AACA,kBAAkB,2CAAa;;AAE/B;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA,cAAc;AACd;AACA;AACA,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC;AACA;AACA,kCAAkC,2CAAa;AAC/C;AACA,gBAAgB,2CAAa;AAC7B,gBAAgB,2CAAa;AAC7B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,2CAAa;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2CAAa;AAChC;AACA,oBAAoB,2CAAa;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,2BAA2B,8CAAe;AAC1C;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA,4BAA4B,2CAAa;AACzC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,0BAA0B,2CAAa;;AAEvC;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,2CAAa;AACjC,uBAAuB,2CAAa;AACpC;AACA;AACA;AACA,sCAAsC,2CAAa;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B,wCAAwC,4DAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2CAAa;;AAElC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,yBAAyB,0BAAM,CAAC,sDAAoB;AACpD,yBAAyB,0BAAM,CAAC,sDAAoB;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B;;AAEA;AACA;AACA;AACA,YAAY,iDAAqB;AACjC;;AAEA,yBAAyB,0BAAM,CAAC,sDAAoB;AACpD,yBAAyB,0BAAM,CAAC,sDAAoB;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,wBAAwB,2CAAa;AACrC,2BAA2B,2CAAa;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,uBAAuB,2CAAa;AACpC;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,2BAA2B,8CAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,wCAAwC,4DAAuB;AAC/D,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC,2BAA2B,mCAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,+BAAY,QAAQ,2BAAO;AACxD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,kBAAkB,2CAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uCAAW,WAAW,uCAAW;AACjD;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,SAAS;AACrC;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC,2BAA2B,2CAAa;AACxC;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,+DAA4B;AACxD;;AAEA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,SAAS;AACrC;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,wCAAc;;AAE1B,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,wCAAc;;AAE1B,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,iBAAiB,2CAAa;AAC9B;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qCAAqC,4DAAuB;AAC5D,gBAAgB,2CAAa;AAC7B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qCAAqC,4DAAuB;AAC5D,gBAAgB,2CAAa;AAC7B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,0CAAe;AACrD;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,2CAAe,gDAAkB,EAAC;;;ACzoDlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;AACiB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAc;AACd;AACA;AACA;AACA,QAAQ,mCAAmC;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,4DAAwB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,gBAAgB;AACjD,mBAAmB,WAAW,wBAAwB,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA,oFAAoF,gBAAgB;AACpG,mBAAmB,WAAW,wBAAwB,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA,mBAAmB,WAAW,wBAAwB,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;;AAEA;AACA,gCAAgC,gBAAgB;AAChD,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA,oFAAoF,eAAe;AACnG,mBAAmB,UAAU,0BAA0B,gBAAgB;AACvE;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA,mBAAmB,aAAa,MAAM,eAAe;AACrD;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB,QAAQ,gBAAgB;AAC7D,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA,oFAAoF,gBAAgB;AACpG,mBAAmB,WAAW,wBAAwB,iBAAiB;AACvE;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,mBAAmB,YAAY,wBAAwB,kBAAkB;AACzE;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA,iDAAiD,kBAAkB,QAAQ,gBAAgB;AAC3F,mBAAmB,YAAY,wBAAwB,kBAAkB;AACzE;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB,QAAQ,gBAAgB;AAC/D,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA,oCAAoC,kBAAkB;AACtD,mBAAmB,aAAa,wBAAwB,mBAAmB;AAC3E;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA,mBAAmB,UAAU,wBAAwB,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6DAA6D,gBAAgB;AAC7E,mBAAmB,UAAU,yBAAyB,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,uBAAuB,gBAAgB,QAAQ,iBAAiB;AAChE,mBAAmB,UAAU,yBAAyB,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA,6DAA6D,gBAAgB;AAC7E,mBAAmB,UAAU,yBAAyB,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA,8CAA8C,gBAAgB;AAC9D,mBAAmB,UAAU,0BAA0B,gBAAgB;AACvE,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB,YAAY;AAClD,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,yCAAyC,iBAAiB;AAC1D,mBAAmB,WAAW,yBAAyB,iBAAiB;AACxE;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA,mBAAmB,oBAAoB,WAAW,iBAAiB,IAAI,gBAAgB;AACvF,mBAAmB,OAAO,6BAA6B,0BAA0B;AACjF;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,YAAY,6BAA6B;AACzC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,aAAa,oCAAoC;AACpE;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA,oDAAoD;AACpD,mBAAmB,qBAAqB;AACxC,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,iDAAiD;AACjD;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,2CAA2C;AAC3C;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,kGAAkG;AAClG;AACA,mBAAmB,MAAM;AACzB,mBAAmB,QAAQ;AAC3B,cAAc,6EAA6E;AAC3F;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA,uCAAuC;;AAEvC;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB,0BAA0B,2BAA2B;AAC7F,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB,sBAAsB;AAC3C;AACA,wCAAwC;;AAExC;AACA,sEAAsE,qCAAqC;AAC3G,mBAAmB,qBAAqB;AACxC,qBAAqB,sBAAsB;AAC3C;AACA,0CAA0C;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA,wCAAwC;;AAExC;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4DAAwB,OAAO,iBAAgB;;AAE/C,uCAAe,wCAAc,EAAC;;;ACztB9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEwB;AACM;AACE;AACC;AACM;AACP;AACS;AACA;AACM;AACR;;AAEvC;AACA;AACA;AACA;AACA;AACA,oCAAY;AACZ;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAsB;;AAE9B,YAAY,0CAAe;AAC3B,YAAY,oDAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY,gDAAkB;AAC9B,YAAY,oDAAsB;AAClC;;AAEA,YAAY,0CAAe;AAC3B,YAAY,oDAAsB;AAClC;;AAEA;AACA,YAAY,gCAAU,MAAM,gDAAkB;AAC9C,YAAY,oDAAsB;AAClC;;AAEA,YAAY,gCAAU,MAAM,wCAAgB;AAC5C,YAAY,gDAAoB;AAChC,YAAY,sDAAuB;AACnC;;AAEA,eAAe,oDAAsB;AACrC,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uCAAW;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAW;AACtC,UAAU;AACV,2BAA2B,GAAW;AACtC,UAAU;AACV,2BAA2B,MAAc;AACzC,UAAU;AACV,2BAA2B,EAAU;AACrC;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAmB,aAAa,sBAAO;;AAE1D;AACA,oBAAoB,uDAAmB,OAAO,sBAAO;AACrD,mBAAmB,uDAAmB,OAAO,sBAAO;AACpD,oBAAoB,uDAAmB,OAAO,sBAAO;AACrD,wBAAwB,uDAAmB,OAAO,sBAAO;AACzD,yBAAyB,uDAAmB,OAAO,sBAAO;AAC1D,sBAAsB,uDAAmB,cAAc,sBAAO;AAC9D,0BAA0B,uDAAmB,OAAO,sBAAO;AAC3D,sBAAsB,uDAAmB,OAAO,sBAAO;AACvD,0BAA0B,uDAAmB,OAAO,sBAAO;AAC3D,uBAAuB,uDAAmB,OAAO,sBAAO;;AAExD;AACA;AACA;AACA,8DAA8D,wDAAwB;;AAEtF;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gCAAU;AAClB,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,sCAAa;AAClC;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B,eAAe,SAAS;AACxB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,8CAAiB;;AAEtC;AACA,sBAAsB,iCAAQ;AAC9B,sBAAsB,iCAAQ;AAC9B,oBAAoB,iCAAQ;AAC5B,oBAAoB,iCAAQ;AAC5B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,UAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,2CAAa,CAAC,8DAA2B;AAChE,uBAAuB,2CAAa,CAAC,8DAA2B;AAChE;AACA;AACA,2BAA2B,2CAAa;AACxC;AACA;AACA,2BAA2B,2CAAa;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,UAAU;AACzB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,+BAA+B;AAC/B;AACA;AACA;AACA,aAAa,uBAAuB;AACpC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,8CAAiB;AACtC;AACA;;AAEA;AACA,oBAAoB,UAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4BAA2B;;AAEnC;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,UAAU;AACzB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,8CAAiB;AAC1C;AACA;;AAEA;AACA,oBAAoB,UAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uBAAsB;;AAE9B;AACA,KAAK;;AAEL;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAU;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,gCAAU;AACzB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAc;AACtB,QAAQ,kDAAmB;AAC3B;AACA;;AAEA;AACA;AACA,IAAI,sCAAa;AACjB,IAAI,oCAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,0BAA0B;AAC1B,4BAA4B,8BAAS;AACrC;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,wBAAwB,wDAAsB;AAC9C;AACA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA,2BAA2B,2CAAa;AACxC,2BAA2B,2CAAa;;AAExC,yBAAyB,uCAAW;AACpC;AACA;AACA;;AAEA,kEAAkE;AAClE,sEAAsE;AACtE,6EAA6E;AAC7E,sFAAsF;;AAEtF;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;;AAEA,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,wBAAwB,8BAAS;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,6CAAe,oCAAY,EAAC;;;;;;;ACvwB5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACQ;AACF;AACS;AACR;AACQ;AACP;AACW;;AAE5C;AACA;AACA;AACA;AACA,0FAA0F,wBAAwB;AAClH,SAAS,YAAY,GAAG,aAAa,MAAM,oBAAoB;AAC/D;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,QAAQ,2DAA2D,yBAAyB;AACvG,IAAI,2BAA2B;AAC/B;AACA;AACA,8BAAS;AACT,wCAAwC,4DAAuB,EAAE,8DAAwB;AACzF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA,kDAAmB,OAAO,2BAAe;AACzC,mEAAyB,CAAC,8BAAS,EAAE,4BAAa;;AAElD,gCAAU;AACV,IAAI,kDAAmB;AACvB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC,gBAAgB,2CAAa,CAAC,2CAAa;AAC3C;AACA,uBAAuB,2CAAa;AACpC,cAAc;AACd;AACA;AACA;AACA,2BAA2B,2CAAa;AACxC;AACA;AACA;;AAEA,4BAA4B,2CAAa;AACzC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;;AAEA;AACA,SAAS;;AAET;AACA,0DAA0D,4BAA4B;AACtF;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,sDAAoB;AAC/D,cAAc;AACd;AACA;AACA,uCAAuC,sDAAoB;;AAE3D,wBAAwB,iCAAiC;AACzD;AACA,oBAAoB,sDAAoB;AACxC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,iEAA6B;AAChD;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,0EAA8B;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,YAAY,wCAAc;AAC1B,mBAAmB,4DAA0B;AAC7C,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ,sDAAsD,gCAAgC;AACjH;AACA;AACA;AACA;AACA,YAAY,wCAAc;AAC1B,gCAAgC,SAAS;AACzC,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,YAAY,wCAAc;AAC1B,gCAAgC,SAAS;AACzC,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE,kEAAkE,oBAAoB;AACtF,qEAAqE,oBAAoB;AACzF;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA,wDAAwD,cAAc;AACtE,sEAAsE,oBAAoB;AAC1F,yEAAyE,oBAAoB;AAC7F;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,2BAAO;;AAEhC,gBAAgB,yCAAY;AAC5B;AACA,cAAc,6BAA6B,4DAAuB;AAClE,gDAAgD,2CAAa;AAC7D,0BAA0B,4FAAwC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mDAAsB;AAC9C;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB,2BAA2B,mDAAsB;AACjD;AACA,cAAc,6BAA6B,gEAAyB;AACpE,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA,cAAc,6BAA6B,8DAAwB;AACnE,uBAAuB,+DAA4B;AACnD,uBAAuB,yCAAiB;AACxC,cAAc,qBAAqB,gEAAyB;AAC5D,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA,4BAA4B,gDAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAA+B;AACrD,uBAAuB,yCAAiB;AACxC,cAAc,qBAAqB,8DAAwB;AAC3D,uBAAuB,iEAA6B;AACpD,uBAAuB,yCAAiB;AACxC;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,2CAAa;AACxC;AACA,gCAAgC,8DAAwB;AACxD;AACA,YAAY,yDAAoB;;AAEhC;AACA,yBAAyB,2CAAa;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,sEAAsE;AACjF;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,8FAA8F,wBAAwB;AACtH;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA,oEAAoE,sBAAsB;AAC1F;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA;AACA,0CAAe;AACf;;AAEA,WAAW,uDAAmB;AAC9B,SAAS,0CAAoB,CAAC,8BAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,0CAA0C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uBAAuB;AACnG,2EAA2E,mBAAmB;AAC9F,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,uFAAuF;AACjL;AACA;AACA;AACA,sEAAsE,6BAA6B;AACnG,qEAAqE,yBAAyB;AAC9F;AACA;AACA,4CAAgB;AAChB;AACA;AACA,eAAe,uDAAmB;;AAElC;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,gDAAgD;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAmB;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,WAAW,iEAA6B;AACxC;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,0EAA8B;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,mDAAmD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA,gFAAgF,SAAS;AACzF,2FAA2F,SAAS;AACpG;AACA;AACA,4EAAgC;AAChC;;AAEA;AACA;AACA,SAAS,yCAAY;AACrB,qCAAqC,4DAAuB;AAC5D,wCAAwC,gEAAyB;AACjE,qCAAqC,4DAAuB;AAC5D,wCAAwC,gEAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,iCAAa;;AAErC;AACA,2DAA2D,2BAAO;AAClE,2DAA2D,2BAAO;AAClE,2DAA2D,2BAAO;AAClE;AACA;AACA;;AAEA,uBAAuB,iCAAa;AACpC;AACA;AACA;AACA;;AAEA,cAAc,0EAA8B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAmD;AAC3D;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,gCAAgC;AAC3C,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,aAAa;AAC1H;AACA,wFAAwF,qFAAqF;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,aAAa;AAC1H;AACA,wFAAwF,qFAAqF;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,4DAAuB;AACvD,wCAAwC,gEAAyB;AACjE;AACA,gCAAgC,4DAAuB;AACvD,wCAAwC,gEAAyB;;AAEjE,wDAAwD,4DAAuB;AAC/E,yDAAyD,4DAAuB;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sDAAqB;AACzC,oBAAoB,sDAAqB;AACzC,oBAAoB,sDAAqB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kDAAmB,UAAU,0CAAe;AAC5C,kDAAmB,WAAW,4CAAgB;AAC9C,kDAAmB,iBAAiB,kEAA2B;AAC/D,kDAAmB,sBAAsB,4EAAgC;AACzE,kDAAmB,cAAc,kDAAmB;;AAEpD,0CAAe;AACf,WAAW,8BAAS;AACpB,iBAAiB,0CAAe;AAChC,kBAAkB,4CAAgB;AAClC,wBAAwB,kEAA2B;AACnD,6BAA6B,4EAAgC;AAC7D,qBAAqB,kDAAmB;AACxC,CAAC,EAAC;;;ACh8BF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACM;AACS;AACA;AACI;AACZ;AACF;AACU;AACP;AACL;;AAE5B;AACA;AACA;AACA;AACA,QAAQ,wBAAwB;AAChC,SAAS,WAAW,GAAG,YAAY,MAAM,YAAY;AACrD;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,4BAAQ;AACR,wCAAwC,0DAAsB,EAAE,4DAAuB;;AAEvF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;;AAEA;AACA;AACA,QAAQ,yBAAyB,KAAK,4BAA4B;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,oCAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,gDAAkB,OAAO,2BAAe;;AAExC,gCAAU;AACV,IAAI,gDAAkB;AACtB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAa;;AAElC,gBAAgB,2CAAa,CAAC,2CAAa;AAC3C;AACA,uBAAuB,2CAAa;AACpC,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mDAAsB;AACtC;AACA;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B,gBAAgB,2CAAa;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,6CAAgB;AACnC;AACA,mBAAmB,6CAAgB;;AAEnC;AACA;AACA;AACA;;AAEA,uBAAuB,0BAAM,CAAC,0DAAsB;AACpD,6BAA6B,sDAAoB;AACjD;AACA;;AAEA;AACA,oBAAoB,2BAAO;AAC3B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,2BAAO;;AAEnC;AACA,2CAA2C,2BAAO;AAClD,6BAA6B,yCAAiB;AAC9C;AACA;AACA,sBAAsB;AACtB,6BAA6B,yCAAiB;AAC9C;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,2BAAO;AACzC;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,2CAAa;AAC9B;AACA;;AAEA,sBAAsB,2CAAa;AACnC,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,+CAAe;AACnC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,wBAAwB,+CAAe;AACvC;AACA,4BAA4B,yCAAY;AACxC;AACA,0BAA0B;AAC1B,4DAA4D,sDAAoB;AAChF;AACA;;AAEA,wBAAwB,+CAAe;AACvC;AACA,4BAA4B,yCAAY;AACxC;AACA,0BAA0B;AAC1B,4DAA4D,sDAAoB;AAChF;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA,gBAAgB,sDAAoB;AACpC;AACA;;AAEA;AACA,qBAAqB,2BAAO,SAAS,2BAAO;AAC5C;AACA;AACA,yCAAyC,8DAAwB;AACjE,qBAAqB,2CAAa;AAClC;AACA;AACA,yCAAyC,8DAAwB;AACjE,qBAAqB,2CAAa;;AAElC;AACA;AACA;AACA;AACA,wBAAwB,2BAAO;AAC/B;AACA,wDAAwD,sDAAoB;AAC5E;AACA;AACA;AACA;AACA,sBAAsB;AACtB,wDAAwD,sDAAoB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,wDAAwD,sDAAoB;AAC5E;AACA;AACA;AACA;AACA,sBAAsB;AACtB,wDAAwD,sDAAoB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAoB;AACxC;AACA;AACA;AACA,oBAAoB,sDAAoB;AACxC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAgB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6CAAgB,mCAAmC,2BAAO,GAAG,2BAAO;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,uBAAuB,KAAK,sBAAsB;AAC9D;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,6CAA6C,2BAAO;AACpD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,6CAA6C,2BAAO;AACpD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA,wDAAwD,uBAAuB;AAC/E,YAAY,uBAAuB;AACnC,mBAAmB,SAAS;AAC5B,YAAY,sBAAsB;AAClC,mBAAmB,SAAS;AAC5B,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,uBAAuB,0BAAM;AAC7B,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B,gDAAgD,0BAAM;AACtD,oBAAoB,0DAAsB;AAC1C;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAAM,CAAC,sDAAoB;AACpD,yBAAyB,0BAAM,CAAC,sDAAoB;AACpD,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;;AAErC;AACA,gBAAgB,iDAAqB;AACrC;;AAEA;AACA;;AAEA,iBAAiB,uCAAW;AAC5B,2BAA2B,0BAAM,CAAC,0DAAsB;AACxD;;AAEA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,uCAAW;AAC/B;AACA,yBAAyB,2CAAa;AACtC;;AAEA,kCAAkC,2BAAO;AACzC;AACA,kBAAkB;AAClB,6CAA6C,2BAAO;AACpD,sDAAsD,2BAAO;AAC7D;AACA;AACA;;AAEA,oBAAoB,2BAAO,kBAAkB,2BAAO;AACpD;AACA,kBAAkB;AAClB,8CAA8C,2BAAO;AACrD,uDAAuD,2BAAO;AAC9D;AACA;AACA;AACA;;AAEA,uBAAuB,0BAAM,CAAC,0DAAsB;AACpD,SAAS;;AAET;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA,gCAAgC,4DAAuB;AACvD;AACA;AACA;;AAEA;;AAEA;;AAEA,2BAA2B,2CAAa;AACxC;AACA,YAAY,yDAAoB;AAChC;AACA,yBAAyB,2CAAa;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,0BAA0B,sBAAsB,0BAA0B;AAC7F,YAAY,yBAAyB;AACrC,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA,uBAAuB,yCAAY;AACnC;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA,kBAAkB,SAAS,uCAAW;AACtC;AACA,yBAAyB,2CAAa;AACtC,yBAAyB,2CAAa;;AAEtC,6BAA6B,0BAAM,CAAC,0DAAsB;;AAE1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2CAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2CAAa;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAA2B,GAAG,YAAY;;AAEvE,6BAA6B,2CAAmB;AAChD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,0BAA0B,2CAAa;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA,4DAA4D,2BAAO;AACnE;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,gBAAgB,kBAAkB;AAClC,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA,4DAA4D,2BAAO;AACnE;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,4DAA4D,2BAAO;AACnE;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,YAAY,uEAAqC;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,mDAAmD,kEAAkE,iBAAiB;AACjJ;AACA;AACA,WAAW,iDAAiD;AAC5D;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA,mDAAmD,uBAAuB;AAC1E,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA,kGAAkG,cAAc;AAChH;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,uDAAuD,uBAAuB;AAC9E,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA,4FAA4F,cAAc;AAC1G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,oDAAoD,cAAc;AAClE;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wCAAwC;AACnF,4FAA4F,cAAc;AAC1G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,gEAAgE,wCAAwC;AACxG,QAAQ;AACR;AACA;AACA;AACA,wCAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAY;AACxB,mBAAmB,uDAAmB;AACtC;AACA,UAAU,SAAS,2CAAa,gBAAgB,yCAAY;AAC5D;AACA,UAAU,SAAS,+CAAe,gBAAgB,yCAAY;AAC9D;AACA;AACA,UAAU;AACV,YAAY,+CAAe;AAC3B;AACA;AACA;AACA,mBAAmB,uDAAmB;AACtC,iBAAiB,iBAAiB;AAClC;AACA,UAAU,SAAS,2CAAa,gBAAgB,yEAA4B;AAC5E;AACA,mBAAmB,uDAAmB;AACtC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uDAAmB;AACtC;AACA,UAAU,SAAS,yCAAY;AAC/B,mBAAmB,uDAAmB;AACtC;AACA,UAAU,SAAS,2CAAa,gBAAgB,yCAAY;AAC5D;AACA,UAAU,SAAS,+CAAe,gBAAgB,yCAAY;AAC9D;AACA;AACA,UAAU;AACV,YAAY,+CAAe;AAC3B;AACA;AACA;AACA,mBAAmB,uDAAmB;AACtC,iBAAiB,iBAAiB;AAClC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,uDAAmB;;AAElC,iBAAiB,4BAAQ;;AAEzB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB,OAAO;AAC3B,gBAAgB,2CAAa;AAC7B;AACA;AACA,uBAAuB,uDAAmB;AAC1C,cAAc,SAAS,+CAAe;AACtC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,uDAAmB;AAClC,iBAAiB,4BAAQ;AACzB;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA,QAAQ,+CAAe;AACvB;AACA,QAAQ,yCAAY;AACpB,QAAQ,yCAAY;AACpB;AACA;AACA,eAAe,uDAAmB;AAClC,iBAAiB,4BAAQ;AACzB;AACA;AACA;AACA,MAAM;AACN;AACA,QAAQ,+CAAe;AACvB;AACA,QAAQ,2CAAa;AACrB,QAAQ,2CAAa;AACrB,QAAQ,2CAAa;AACrB;AACA;;AAEA,eAAe,uDAAmB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,uDAAmB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,uDAAmB;AAClC,iBAAiB,4BAAQ;;AAEzB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,SAAS,wCAAc;;AAE1C;AACA;AACA,oDAAoD,YAAY,MAAM;AACtE,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,iCAAiC,kEAAkE;AAC9G;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,qBAAqB;AACxG;AACA;AACA;AACA,8CAAiB;AACjB;;AAEA;AACA;AACA,WAAW,uDAAmB;;AAE9B;;AAEA;AACA;;AAEA,YAAY,2CAAa;AACzB;AACA;AACA;AACA,UAAU,SAAS,+CAAe;AAClC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,0BAAM;AAC/C,YAAY,sDAAoB;AAChC;AACA;AACA;AACA,yCAAyC,0BAAM;AAC/C,YAAY,sDAAoB;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kDAAmB,YAAY,8CAAiB;;AAEhD;AACA;AACA,IAAI,YAAY,MAAM;AACtB,QAAQ,yBAAyB,6BAA6B,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,iCAAiC,kEAAkE,iBAAiB;AAC/H;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA,0CAAe;AACf;;AAEA;AACA;AACA,WAAW,uDAAmB;AAC9B;AACA;AACA,cAAc,8DAAwB;AACtC;;AAEA;AACA;;AAEA,kDAAmB,UAAU,0CAAe;;AAE5C;AACA,sHAAsH,YAAY,MAAM;AACxI,QAAQ,yBAAyB,sCAAsC,sBAAsB,4BAA4B,aAAa;AACtI;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,iCAAiC,kEAAkE,iBAAiB;AAC/H;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA,wCAAc;AACd;;AAEA;AACA;AACA,SAAS,yCAAY,gBAAgB,yCAAY;AACjD,SAAS,yCAAY,gBAAgB,yCAAY;AACjD;AACA;AACA,eAAe,uDAAmB;AAClC;AACA,kBAAkB,0DAAsB;AACxC;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,oEAA2B;AACpE;AACA;;AAEA;AACA,qBAAqB,uDAAmB;AACxC,YAAY,uCAAW;AACvB;AACA,UAAU,SAAS,yCAAY;AAC/B;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,SAAS,wCAAc;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,QAAQ;AACnB;AACA;AACA,iDAAiD,SAAS,aAAa,cAAc;AACrF;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K,6DAA6D,SAAS,aAAa,cAAc;AACjG;AACA;AACA;AACA;AACA,8CAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,YAAY,yCAAY;AACxB;AACA;AACA,UAAU,SAAS,yCAAY;AAC/B;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,4DAAuB;AAClD;AACA;AACA,MAAM;AACN,2BAA2B,8DAAwB;AACnD,mBAAmB,4DAAuB;AAC1C;AACA,YAAY,2CAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAAU;AAC/C,oCAAoC,2BAAU;AAC9C;AACA,qBAAqB;AACrB;AACA,+BAA+B,2BAAU;AACzC,qBAAqB;AACrB;AACA,gCAAgC,2BAAU;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,oBAAoB,8DAAwB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;;AAEA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;;AAEA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;AACA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,2BAA2B,gEAAyB;AACpD,mBAAmB,4DAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAc;AACzC,iBAAiB;AACjB;AACA,2BAA2B,yCAAc;AACzC,iBAAiB;AACjB;AACA,2BAA2B,yCAAc;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,uCAAW;AACpB;AACA;;AAEA;AACA,mBAAmB,gEAAyB;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;AACA,iFAAiF,qFAAqF;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,aAAa;AAC1H;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqB;AACrB;;AAEA;AACA;AACA,oCAAoC,gEAAyB;AAC7D,oCAAoC,gEAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,yCAAc,CAAC,uCAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAmD;AAC3D;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,gCAAgC;AAC3C,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,aAAa;AAC1H;AACA,wFAAwF,qFAAqF;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,aAAa;AAC1H;AACA,wFAAwF,qFAAqF;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,4DAAuB;AACvD,wCAAwC,gEAAyB;AACjE;AACA,gCAAgC,4DAAuB;AACvD,wCAAwC,gEAAyB;;AAEjE,6BAA6B,yCAAY;AACzC,8BAA8B,yCAAY;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAmB,YAAY,8CAAiB;AAChD,kDAAmB,UAAU,8CAAiB;AAC9C,kDAAmB,gBAAgB,sDAAqB;AACxD,kDAAmB,cAAc,kDAAmB;;AAEpD,yCAAe;AACf,UAAU,4BAAQ;AAClB,gBAAgB,wCAAc;AAC9B,mBAAmB,8CAAiB;AACpC,iBAAiB,8CAAiB;AAClC,mBAAmB,8CAAiB;AACpC,gBAAgB,wCAAc;AAC9B,iBAAiB,0CAAe;AAChC,uBAAuB,sDAAqB;AAC5C,qBAAqB,kDAAmB;AACxC,CAAC,EAAC;;;AC1pEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;AACO;AACD;AACS;AACP;;AAEjC;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,8BAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,uCAAW;AACjC;AACA,MAAM;AACN;AACA;AACA;;AAEA,gBAAgB,4DAAuB;AACvC,wBAAwB,8DAAwB;;AAEhD,wBAAwB,uCAAW;AACnC;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAQ,yCAAY;AACpB;AACA,MAAM;AACN;AACA;;AAEA,gBAAgB,qBAAqB;AACrC;;AAEA,aAAa,2CAAa,uBAAuB,uCAAW;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,kDAAmB;AACvB;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yCAAY;AACpC,4BAA4B,yCAAY;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,eAAe,yBAAyB;AACxC,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA,cAAc;AACd;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC,oBAAoB,mCAAS;AAC7B;AACA,kBAAkB,SAAS,uCAAW;AACtC;AACA;AACA;;AAEA,2BAA2B,iDAAgB;AAC3C,SAAS;;AAET;AACA;AACA,eAAe;AACf,gDAAgD,uBAAuB;AACvE,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,oEAAoE,uBAAuB;AAC3F,qBAAqB;AACrB;AACA;AACA,mBAAmB,yCAAY;AAC/B,SAAS;;AAET;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,6BAA6B,uCAAW;AACxC;AACA,wCAAwC;AACxC;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,oBAAoB,yCAAY;AAChC;AACA,kBAAkB;AAClB;AACA,kBAAkB,SAAS,yCAAY;AACvC;AACA,kBAAkB,SAAS,+CAAe;AAC1C;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,4BAA4B,+BAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,gCAAgC;AAChC,kBAAkB;AAClB,wBAAwB,yCAAiB;AACzC,sCAAsC,2BAAO;AAC7C;AACA;AACA,wBAAwB,yCAAiB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,gCAAgC;AAChC,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,sDAAoB,qBAAqB,2BAAO;AAC5F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,6CAAc;AAClC,oBAAoB,uCAAW;AAC/B;AACA;AACA,kBAAkB;AAClB,oBAAoB,6CAAc;AAClC,oBAAoB,uCAAW;AAC/B;AACA;AACA,kBAAkB,SAAS,6CAAc;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,uCAAW;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAAc;AACnD,8DAA8D,sDAAoB;AAClF;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,oCAAoC,sDAAoB;AACxD,oCAAoC,yCAAc;AAClD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA;AACA,wCAAwC;AACxC;AACA,wCAAwC;AACxC;;AAEA;AACA,4BAA4B,iDAAgB;;AAE5C;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,6CAA6C,iCAAiC;AAC9E,mBAAmB,iBAAiB,kBAAkB,iBAAiB,wBAAwB,iBAAiB;AAChH,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,6CAA6C,iCAAiC;AAC9E,mBAAmB,WAAW,OAAO,iBAAiB;AACtD,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW,OAAO,iBAAiB;AACtD,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,iBAAiB,kBAAkB,iBAAiB,wBAAwB,iBAAiB;AAChH;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,WAAW,OAAO,iBAAiB;AACtD,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW,OAAO,iBAAiB;AACtD,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,iBAAiB,kBAAkB,iBAAiB,wBAAwB,iBAAiB;AAChH,mBAAmB,QAAQ;AAC3B;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,gBAAgB,yCAAY;AAC5B;AACA,cAAc;AACd;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW,OAAO,iBAAiB;AACtD,mBAAmB,QAAQ;AAC3B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW,OAAO,iBAAiB;AACtD,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,SAAS;;AAET;AACA,+BAA+B,sCAAsC,KAAK;AAC1E;AACA;AACA;AACA;AACA,gBAAgB,yCAAY;AAC5B;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA,+BAA+B,qCAAqC,KAAK;AACzE;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,+BAA+B,wCAAwC,KAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAc;AAC1B;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,wCAAwC;AACnF,0CAA0C,wCAAwC;AAClF,0CAA0C,wCAAwC;AAClF;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,+EAA+E,+EAA+E;AAC9J;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,wCAAwC;AACnF,0CAA0C,wCAAwC;AAClF,0CAA0C,wCAAwC;AAClF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,wCAAwC;AACnF,0CAA0C,wCAAwC;AAClF,0CAA0C,wCAAwC;AAClF;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,+EAA+E,+EAA+E;AAC9J;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,wCAAwC;AACnF,0CAA0C,wCAAwC;AAClF,0CAA0C,wCAAwC;AAClF,sCAAsC,qBAAqB;AAC3D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,4CAA4C;AACvF,0CAA0C,4CAA4C;AACtF,0CAA0C,wCAAwC;AAClF;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,+EAA+E,+EAA+E;AAC9J;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,4CAA4C;AACvF,0CAA0C,4CAA4C;AACtF,0CAA0C,wCAAwC;AAClF,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,4CAA4C;AACvF,0CAA0C,4CAA4C;AACtF,0CAA0C,wCAAwC;AAClF;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,+EAA+E,+EAA+E;AAC9J;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,4CAA4C;AACvF,0CAA0C,4CAA4C;AACtF,0CAA0C,wCAAwC;AAClF,sCAAsC,qBAAqB;AAC3D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,kDAAkD;AAC7F,0CAA0C,4CAA4C;AACtF,0CAA0C,wCAAwC;AAClF;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,+EAA+E,+EAA+E;AAC9J;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,kDAAkD;AAC7F,0CAA0C,4CAA4C;AACtF,0CAA0C,wCAAwC;AAClF,sCAAsC,qBAAqB;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,kDAAkD;AAC7F,0CAA0C,4CAA4C;AACtF,0CAA0C,wCAAwC;AAClF,sCAAsC,wCAAwC;AAC9E;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,+EAA+E,+EAA+E;AAC9J;AACA;AACA,4CAA4C,wCAAwC;AACpF,2CAA2C,kDAAkD;AAC7F,0CAA0C,4CAA4C;AACtF,0CAA0C,wCAAwC;AAClF,sCAAsC,wCAAwC;AAC9E;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0CAAe;AACf,eAAe,uDAAmB;AAClC,gBAAgB,8BAAS;;AAEzB;AACA;;AAEA;AACA;;AAEA,kDAAmB,UAAU,0CAAe;;AAE5C,0CAAe;AACf,WAAW,8BAAS;AACpB,iBAAiB,0CAAe;AAChC,CAAC,EAAC;;;ACr9BF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACa;AACF;AACL;AACS;AACA;AACP;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,iDAAiD,2EAA2E,iBAAiB;AACxJ;AACA,WAAW,iDAAiD,yEAAyE,iBAAiB;AACtJ;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ,0DAA0D;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,0FAA0F,2FAA2F;AACrL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,IAAI;AACJ;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,8CAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAmB;AACvC,sBAAsB,uDAAmB;AACzC,qBAAqB,uDAAmB;;AAExC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,UAAU,SAAS,yCAAY;AAC/B;AACA;AACA,UAAU,SAAS,+CAAe,gBAAgB,yCAAY;AAC9D;AACA;AACA,UAAU,SAAS,2CAAa;AAChC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,2CAAa;AACrB,oBAAoB,uDAAmB;AACvC,MAAM,SAAS,+CAAe,gBAAgB,2CAAa;AAC3D;AACA,MAAM;AACN;AACA,YAAY,yCAAY;AACxB;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,SAAS,+CAAe,gBAAgB,yCAAY;AAC9D;AACA;AACA,UAAU,SAAS,2CAAa;AAChC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,uCAAW;AACpB;AACA;;AAEA;AACA,SAAS,uCAAW;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,4DAAuB;AACxC;AACA;AACA;AACA;AACA,QAAQ,yCAAY;AACpB;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA,YAAY,2CAAa;AACzB;AACA;AACA;AACA,oBAAoB,0BAAM,CAAC,0DAAsB;AACjD,8BAA8B,sDAAoB,mBAAmB,sDAAoB;;AAEzF;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,OAAO;AACvB,YAAY,yCAAY;AACxB;AACA;AACA;AACA,QAAQ,yCAAY;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,iDAAiD,2EAA2E,iBAAiB;AACxJ;AACA,WAAW,iDAAiD,yEAAyE,iBAAiB;AACtJ;AACA,WAAW,QAAQ,6DAA6D;AAChF,WAAW,QAAQ,yDAAyD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,0FAA0F,2FAA2F;AACrL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,kDAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAmB;AACvC,sBAAsB,uDAAmB;AACzC,qBAAqB,uDAAmB;;AAExC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,UAAU,SAAS,yCAAY;AAC/B;AACA;AACA,UAAU,SAAS,+CAAe,gBAAgB,yCAAY;AAC9D;AACA;AACA,UAAU,SAAS,2CAAa;AAChC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,2CAAa;AACrB,oBAAoB,uDAAmB;AACvC,MAAM,SAAS,+CAAe,gBAAgB,2CAAa;AAC3D;AACA,MAAM;AACN;AACA,YAAY,yCAAY;AACxB;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,SAAS,+CAAe,gBAAgB,yCAAY;AAC9D;AACA;AACA,UAAU,SAAS,2CAAa;AAChC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,uCAAW;AACpB;AACA;;AAEA;AACA,SAAS,uCAAW;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,yCAAY;AACpB;AACA;AACA,iBAAiB,4DAAuB;;AAExC;AACA,gBAAgB,OAAO;AACvB,YAAY,yCAAY;AACxB;AACA;AACA;AACA,QAAQ,yCAAY;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,0FAA0F,2FAA2F;AACrL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,gDAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAmB;AACvC,sBAAsB,uDAAmB;AACzC,qBAAqB,uDAAmB;AACxC;;AAEA;AACA;AACA;AACA;AACA,MAAM,SAAS,yCAAY;AAC3B;AACA;AACA,MAAM,SAAS,+CAAe,gBAAgB,yCAAY;AAC1D;AACA;AACA,MAAM,SAAS,2CAAa;AAC5B;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,yCAAY;AACpB,oBAAoB,uDAAmB;AACvC;AACA;;AAEA;AACA,SAAS,uCAAW;AACpB;AACA;;AAEA;AACA,SAAS,uCAAW;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAA2B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAsB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAsB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,4DAAuB;AACxC;;AAEA,QAAQ,yCAAY;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,iFAAiF;AAC5F,WAAW,2CAA2C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,0FAA0F,2FAA2F;AACrL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,0CAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAmB;AACxC,sBAAsB,uDAAmB;AACzC,qBAAqB,uDAAmB;;AAExC;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,cAAc,SAAS,yCAAY;AACnC;AACA;AACA,cAAc,SAAS,+CAAe,gBAAgB,yCAAY;AAClE;AACA;AACA,cAAc,SAAS,2CAAa;AACpC;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,yCAAc;AAC3B,cAAc,6CAAgB;AAC9B,aAAa,yCAAc;AAC3B,cAAc,6CAAgB;;AAE9B,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;;AAEA;AACA,8BAA8B,6CAAgB,cAAc,6CAAgB;AAC5E,8BAA8B,6CAAgB,cAAc,6CAAgB;AAC5E;AACA,cAAc;AACd,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,qCAAe;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,yCAAc;AAC9B,UAAU;AACV,gBAAgB,yCAAc;AAC9B,UAAU;AACV,gBAAgB,yCAAc;AAC9B;;AAEA,YAAY,uCAAW;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,4DAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B,gBAAgB,yCAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,YAAY,8CAAiB;AAChD,kDAAmB,cAAc,kDAAmB;AACpD,kDAAmB,aAAa,gDAAkB;AAClD,kDAAmB,UAAU,0CAAe;;AAE5C,0CAAe;AACf,mBAAmB,8CAAiB;AACpC,qBAAqB,kDAAmB;AACxC,oBAAoB,gDAAkB;AACtC,iBAAiB,0CAAe;AAChC,CAAC,EAAC;;;AC/nCF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACe;AACV;AACE;AACK;AACS;AACb;;AAEjC;AACA;AACA;AACA;AACA,4FAA4F,wBAAwB;AACpH,SAAS,cAAc;AACvB;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,gCAAU;AACV;AACA,wCAAwC,8DAAwB,EAAE,gEAAyB;;AAE3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,4BAA4B,uDAAmB;AAC/C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,YAAY,sDAAoB;AAChC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN,YAAY,uCAAW;AACvB;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,qBAAqB,2CAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,oDAAoB,OAAO,2BAAe;;AAE1C,gCAAU;AACV,IAAI,oDAAoB;AACxB;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAAM,CAAC,0DAAsB;AACrD;AACA;AACA;AACA;;AAEA,gBAAgB,2CAAa,CAAC,2CAAa;AAC3C;AACA,uBAAuB,2CAAa;AACpC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,oBAAoB,2CAAa;AACjC;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2CAAa;AACjC;AACA;;AAEA;AACA;AACA,wBAAwB,sDAAoB;AAC5C;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD,yCAAyC,0BAAM;AAC/C,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,kCAAkC,+BAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uCAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B,gBAAgB,wDAA8B;AAC9C;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C,qBAAqB,YAAY;AACjC;AACA;AACA,gCAAgC,uDAAmB;AACnD;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C,qBAAqB,QAAQ;AAC7B;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,6CAAc;AAClC,oBAAoB,6CAAc;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA,YAAY,wCAAc;AAC1B;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAAM,CAAC,sDAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAyB;AAC3D;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,6BAA6B,2CAAa;AAC1C;;AAEA;;AAEA;AACA,YAAY,yDAAoB;AAChC;AACA,yBAAyB,2CAAa;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,0BAA0B,sBAAsB,0BAA0B,gBAAgB,yBAAyB;AACtI,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,uBAAuB,yCAAY;AACnC;;AAEA,wBAAwB,SAAS;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,0BAA0B,2CAAa;;AAEvC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,0BAA0B,2CAAa;;AAEvC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,gDAAgD,6CAA6C,gBAAgB,OAAO,wBAAwB;AACvJ,0EAA0E,gBAAgB,KAAK,gBAAgB;AAC/G,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,yFAAyF,qFAAqF;AAC9K;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B,eAAe,qBAAqB;AAClH,+FAA+F,cAAc;AAC7G;AACA;AACA,kFAAkF,qFAAqF;AACvK;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B,eAAe,qBAAqB;AAClH,IAAI;AACJ;AACA;AACA,2CAA2C,uBAAuB;AAClE,kDAAkD,gBAAgB;AAClE;AACA,yDAAyD,SAAS,cAAc;AAChF;AACA,sGAAsG,cAAc;AACpH;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,uDAAuD,uBAAuB;AAC9E,8DAA8D,gBAAgB;AAC9E;AACA,qEAAqE,SAAS,cAAc;AAC5F;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,4DAA4D,+BAA+B,cAAc;AACzG,6CAA6C,qBAAqB;AAClE;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,oDAAoD,cAAc;AAClE,gEAAgE,+BAA+B,cAAc;AAC7G,iDAAiD,qBAAqB;AACtE;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,2CAAa;AACrB,6BAA6B,gEAAyB;AACtD,QAAQ,yEAA4B;AACpC;AACA,eAAe,uDAAmB;AAClC;AACA;AACA,sEAAsE,sBAAsB;AAC5F,aAAa;AACb;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,YAAY,iDAAgB;AAC5B;AACA,gBAAgB,qDAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,WAAW,uDAAmB;;AAE9B,0BAA0B,yCAAY,UAAU,yCAAY;AAC5D;AACA,iBAAiB,gCAAU;AAC3B,MAAM;AACN,SAAS,2CAAa,UAAU,+CAAe,UAAU,2CAAa;AACtE,QAAQ,yCAAY;AACpB;AACA;AACA,iBAAiB,gCAAU;AAC3B,MAAM;AACN,SAAS,2CAAa,UAAU,+CAAe,UAAU,2CAAa;AACtE,QAAQ,yCAAY;AACpB;AACA;AACA,iBAAiB,gCAAU;AAC3B,MAAM,+BAA+B,gEAAyB,IAAI,yCAAY;AAC9E;AACA,iBAAiB,gCAAU;AAC3B,MAAM,+BAA+B,gEAAyB,IAAI,yCAAY;AAC9E;AACA,iBAAiB,gCAAU;AAC3B,MAAM,+BAA+B,4DAAuB,IAAI,yCAAY;AAC5E;AACA,iBAAiB,gCAAU;AAC3B,MAAM,+BAA+B,4DAAuB,IAAI,yCAAY;AAC5E;AACA,iBAAiB,gCAAU;AAC3B,MAAM;AACN;AACA,QAAQ,yCAAY;AACpB,QAAQ,yCAAY;AACpB,QAAQ,yCAAY;AACpB;AACA;AACA;AACA,YAAY,8DAAyB;AACrC,iBAAiB,8DAAyB;AAC1C,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,YAAY,yCAAY;AACxB;AACA;AACA;AACA;AACA;;AAEA,kDAAmB,WAAW,4CAAgB;;AAE9C,2CAAe;AACf,YAAY,gCAAU;AACtB,kBAAkB,4CAAgB;AAClC,CAAC,EAAC;;;ACv/BF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACO;AACF;AACc;AACJ;AACP;AACO;;AAExC;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ,4DAA4D;AAC/E,QAAQ,0BAA0B;AAClC;AACA;AACA;;AAEA,kCAAW;AACX,wCAAwC,gEAAyB,EAAE,4DAAuB;;AAE1F;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAmB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAY;AAC7B;AACA;AACA,gCAAgC,uCAAW;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA,YAAY,uCAAW;AACvB;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,oCAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,sDAAqB,OAAO,2BAAe;;AAE3C,gCAAU;AACV,IAAI,sDAAqB;AACzB;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,qCAAe;AAClC,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,0BAAM,CAAC,sDAAoB;AACtD;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAAM,CAAC,sDAAoB;AAClD,SAAS;;AAET,wBAAwB,oCAAY,CAAC,sDAAqB;;AAE1D;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,2BAA2B,2CAAa;AACxC;AACA;AACA,YAAY,yDAAoB;;AAEhC;AACA,yBAAyB,2CAAa;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA,YAAY,wCAAc;;AAE1B;AACA;;AAEA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;;AAEA,iCAAiC,uCAAW;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA,YAAY,wCAAc;;AAE1B;AACA;;AAEA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,4BAA4B,mDAAsB;AAClD,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE,4DAA4D,yBAAyB;AACrF,uGAAuG,cAAc;AACrH;AACA;AACA,4FAA4F,sFAAsF;AAClL;AACA,mDAAmD,qBAAqB;AACxE,8DAA8D,yBAAyB;AACvF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,iDAAiD,6BAA6B;AAC9E;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,yBAAyB;AACjD;AACA;;AAEA,YAAY,uEAAqC;AACjD,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW,mCAAmC;AACjE,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA,iBAAiB,yCAAY;AAC7B;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,aAAa;AAClC;AACA,2DAA2D,UAAU;AACrE,qEAAqE,qBAAqB;AAC1F;AACA;AACA;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G,+DAA+D,UAAU;AACzE,yEAAyE,qBAAqB;AAC9F;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,aAAa;AAClC;AACA;AACA,2DAA2D,UAAU;AACrE,qEAAqE,qBAAqB;AAC1F;AACA;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G,+DAA+D,UAAU;AACzE,yEAAyE,qBAAqB;AAC9F;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,YAAY;AACpC,oBAAoB,qDAAkB,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW,mCAAmC,iBAAiB;AAClF,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA,oBAAoB,yCAAY;AAChC;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA,oBAAoB,yCAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,sBAAsB;AAC9C,oBAAoB,yCAAY;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,sBAAsB;AAClD,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,uBAAuB,qFAA4C;AACnE;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA,cAAc;AACd;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ,+DAA+D,0BAA0B,KAAK,2BAA2B;AACpJ,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAAM;AAC9B,2BAA2B,0BAAM;;AAEjC;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;;AAEA,iBAAiB,2CAAmB;AACpC,8DAA8D,mBAAmB;AACjF;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAA8B;AACrD,0BAA0B,wEAA8B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;AACA;;AAEA,wBAAwB,aAAa;AACrC;AACA;AACA;;AAEA;;AAEA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA,oCAAoC,oFAAoC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,gCAAgC,oFAAoC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,wDAAwD,oCAAoC;AAC5F;AACA,sDAAsD,oBAAoB;AAC1E;AACA;AACA,mBAAmB,aAAa;AAChC;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,sEAAsE,kBAAkB;AACxF,uGAAuG,cAAc;AACrH;AACA;AACA,gGAAgG,oFAAoF;AACpL;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2EAA2E,kBAAkB;AAC7F,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,wDAAwD,oCAAoC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA,gGAAgG,oFAAoF;AACpL;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,0DAA0D,oCAAoC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,sFAAsF;AAC1K;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,sFAAsF;AAC1K;AACA,2CAA2C,qBAAqB;AAChE,KAAK;AACL;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C,2BAA2B,oBAAoB;AAC/C,2BAA2B,oBAAoB;AAC/C,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,sFAAsF;AAC1K,2BAA2B,oBAAoB;AAC/C,2BAA2B,oBAAoB;AAC/C,2BAA2B,oBAAoB;AAC/C,2BAA2B,oBAAoB;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,2CAA2C,UAAU;AACrD,2CAA2C,UAAU;AACrD,6CAA6C,UAAU;AACvD,gDAAgD,WAAW,kBAAkB;AAC7E,kDAAkD,WAAW,iBAAiB;AAC9E;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,oDAAoD,cAAc;AAClE,+CAA+C,UAAU;AACzD,+CAA+C,UAAU;AACzD,iDAAiD,UAAU;AAC3D,oDAAoD,WAAW,kBAAkB;AACjF,sDAAsD,WAAW,iBAAiB;AAClF;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,8CAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2CAAa;AACrB,qBAAqB,gEAAyB;AAC9C,QAAQ,yEAA4B;AACpC;AACA;AACA;AACA,sBAAsB,uDAAmB;AACzC,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,iBAAiB,qDAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,aAAa,kCAAW;AACxB;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,4BAA4B;AACvC;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,sFAAsF;AAC1K;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,sFAAsF;AAC1K;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,mDAAmD,uBAAuB;AAC1E,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,uDAAuD,uBAAuB;AAC9E,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4DAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ,2CAAa;AACrB;AACA;AACA;AACA;;AAEA,QAAQ,2CAAa;AACrB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,QAAQ,qDAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,gBAAgB,OAAO;AACvB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV,gBAAgB,yCAAY;AAC5B;AACA;AACA;AACA,wBAAwB,wDAAqB;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU,gBAAgB;AAC7E;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU,gBAAgB;AACpF;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4DAAwB;AACxB;;AAEA,WAAW,uDAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,YAAY,8CAAiB;AAChD,kDAAmB,mBAAmB,4DAAwB;AAC9D,kDAAmB,mBAAmB,4DAAwB;;AAE9D,4CAAe;AACf,aAAa,kCAAW;AACxB,mBAAmB,8CAAiB;AACpC,0BAA0B,4DAAwB;AAClD,CAAC,EAAC;;;ACv9CF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACO;AACF;AACU;AACT;AACS;AACR;AACQ;AACM;AACb;AACH;;AAE9B;AACA;AACA,0FAA0F,wBAAwB;AAClH,SAAS,YAAY,MAAM,qBAAqB;AAChD;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,8BAAS;AACT,wCAAwC,4DAAuB,EAAE,8DAAwB;;AAEzF;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA,wBAAwB,2CAAa;;AAErC;;AAEA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;;AAEA;AACA;AACA,QAAQ,0BAA0B,KAAK,6BAA6B;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,QAAQ,2CAAa;AACrB;AACA;AACA,QAAQ,2CAAa;AACrB;AACA;;AAEA,qBAAqB,2CAAa;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,kDAAmB,OAAO,2BAAe;;AAEzC,gCAAU;AACV,IAAI,kDAAmB;AACvB;AACA;AACA;AACA,kCAAkC,6BAA6B;AAC/D,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;;AAEA,6BAA6B,0BAAM;AACnC,gBAAgB,0DAAsB;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,kCAAkC,6BAA6B;AAC/D,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;AACA,8BAA8B,0BAAM;AACpC,gBAAgB,0DAAsB;AACtC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ,oBAAoB,sBAAsB,KAAK,qBAAqB;AAC/F,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ,oBAAoB,sBAAsB,KAAK,qBAAqB;AAC/F,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ,oBAAoB,sBAAsB,KAAK,qBAAqB;AAC/F,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2CAAa,CAAC,2CAAa;AAC3C;AACA,uBAAuB,2CAAa;AACpC,cAAc;AACd;AACA;AACA;;AAEA;AACA,6BAA6B,0BAAM,CAAC,0DAAsB;AAC1D;AACA;;AAEA;AACA,2CAA2C,2CAAa;AACxD,uBAAuB,mDAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,2CAAa;AACjC,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;;AAEA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAW;AACxC,wBAAwB,yCAAc;AACtC;AACA;AACA;;AAEA;AACA,oCAAoC,WAAW;AAC/C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA,qBAAqB,uCAAW;AAChC;AACA;;AAEA;AACA,oBAAoB,uCAAW;AAC/B,oBAAoB,2CAAa;AACjC;AACA;AACA,6CAA6C,0BAAM,CAAC,sDAAoB;AACxE;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA,iCAAiC,iFAAqC;AACtE,sBAAsB;AACtB;AACA;AACA,sCAAsC,qEAA+B;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,qEAA+B;AACrE;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,kCAAkC,qEAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6CAA6C,SAAS;AACtD,yCAAyC,0BAAM;AAC/C,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,cAAc;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,2BAA2B,uBAAuB,KAAK,sBAAsB;AAC7E,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,qBAAqB;AAC5F,0DAA0D;AAC1D,mCAAmC;AACnC;AACA,oDAAoD,iCAAiC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iCAAiC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,2GAA2G;AACnI,mFAAmF,qBAAqB;AACxG,sEAAsE;AACtE,4DAA4D;AAC5D;AACA,gEAAgE,iCAAiC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iCAAiC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,uDAAuD,mCAAmC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,4CAA4C;AAC5C;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,wGAAwG,cAAc;AACtH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,2DAA2D,mCAAmC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,gDAAgD;AAChD;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;;AAEA;AACA;;AAEA,4BAA4B,SAAS;AACrC;;AAEA;AACA,wBAAwB,uCAAW;AACnC;AACA;AACA;AACA,4BAA4B,sDAAoB;AAChD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,4BAA4B,sDAAoB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,oBAAoB,2CAAa;AACjC;;AAEA,yCAAyC,2CAAa;AACtD,wBAAwB,6BAA6B;AACrD,sBAAsB;AACtB,wBAAwB,6BAA6B;AACrD,sBAAsB;AACtB,wBAAwB,6BAA6B;AACrD,sBAAsB;AACtB,wBAAwB,6BAA6B;AACrD,sBAAsB;AACtB,wBAAwB,6BAA6B;AACrD;AACA;AACA,kBAAkB;AAClB;AACA,4CAA4C,2CAAa;AACzD,sBAAsB;AACtB,4CAA4C,2CAAa;AACzD;;AAEA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;;AAEA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA,mCAAmC,GAAG;AACtC,gCAAgC,wBAAwB;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,SAAS;AACxC;AACA;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B,gBAAgB,2CAAa;AAC7B;AACA;AACA,8BAA8B,+DAA4B;AAC1D;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,oCAAoC,yCAAc;AAClD;;AAEA;AACA,SAAS;;AAET;AACA;AACA,6BAA6B,uCAAuC;AACpE,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,yCAAc;AAClC,iCAAiC,sDAAoB;AACrD;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,0BAA0B,sBAAsB,0BAA0B,gBAAgB,yBAAyB;AACtI,qBAAqB,WAAW;AAChC;AACA;AACA;AACA,uBAAuB,yCAAY;AACnC;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,+CAAe;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,+CAAe;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC,4BAA4B,+CAAe;AAC3C;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,wBAAwB,+CAAe;AACvC;AACA;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC,wBAAwB,+CAAe;AACvC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,yCAAY;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,yBAAyB,uDAAmB;AAC5C,oBAAoB,2CAAa;AACjC;AACA,kBAAkB,SAAS,+CAAe,WAAW,2CAAa;AAClE;AACA;;AAEA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;AACA,cAAc;AACd,yBAAyB,uDAAmB;AAC5C;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,+CAAe,WAAW,yCAAY;AACtD;AACA,qBAAqB,uDAAmB;AACxC,qBAAqB,uDAAmB;;AAExC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,uCAAW;AAC3B,4BAA4B,uDAAmB;AAC/C;AACA,gBAAgB,uCAAW;AAC3B,4BAA4B,uDAAmB;AAC/C;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,wDAA8B;AAC9C;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,0BAAM,CAAC,0DAAsB;AACjD,mBAAmB,iEAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAwB;;AAE1D;AACA;AACA;AACA;AACA,6BAA6B,2CAAa;AAC1C;;AAEA;AACA;AACA;;AAEA,YAAY,yDAAoB;AAChC;AACA,yBAAyB,2CAAa;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,OAAO;AACnC,uCAAuC,mCAAS;AAChD;AACA,qBAAqB;AACrB,uCAAuC,mCAAS;AAChD;AACA,qBAAqB;AACrB;AACA,yBAAyB,qCAAe;AACxC;AACA,uBAAuB,qCAAe;AACtC;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uBAAuB,qCAAe;AACtC;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uBAAuB,qCAAe;AACtC;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uBAAuB,qCAAe;AACtC;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA,2CAA2C,2CAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,iCAAiC,sDAAoB;AACrD;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,+CAA+C,8DAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,sDAAoB;AACnD,2BAA2B,0BAAM,CAAC,sDAAoB;AACtD;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wGAAwG,YAAY;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iEAAiE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAgE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D,wCAAwC,sBAAsB;AAC9D;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,uFAAuF,qFAAqF;AAC5K,yDAAyD,sBAAsB,cAAc,sBAAsB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD,+FAA+F,cAAc;AAC7G;AACA,uFAAuF,oFAAoF;AAC3K;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oCAAoC;AAC9E;AACA;AACA,4BAA4B;AAC5B;AACA,+FAA+F,cAAc;AAC7G;AACA,uFAAuF,kFAAkF;AACzK;AACA,2DAA2D,oCAAoC,yBAAyB,mBAAmB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wCAAwC;AACpF,4CAA4C,wCAAwC;AACpF,8CAA8C,wCAAwC;AACtF,0CAA0C,wCAAwC;AAClF;AACA;AACA,iBAAiB,6DAA6D,GAAG;AACjF;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,+EAA+E,kFAAkF;AACjK;AACA;AACA,4CAA4C,wCAAwC;AACpF,4CAA4C,wCAAwC;AACpF,8CAA8C,wCAAwC;AACtF,0CAA0C,wCAAwC;AAClF;AACA;AACA,iBAAiB,6DAA6D,GAAG;AACjF;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,mDAAmD,uBAAuB;AAC1E,0DAA0D,gBAAgB;AAC1E;AACA,4DAA4D,mBAAmB;AAC/E;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,uDAAuD,uBAAuB;AAC9E,8DAA8D,gBAAgB;AAC9E;AACA,gEAAgE,mBAAmB;AACnF;AACA,QAAQ;AACR;AACA;AACA;AACA,0CAAe;AACf;AACA;AACA,eAAe,uDAAmB;;AAElC;AACA;AACA,QAAQ,yEAA4B;AACpC,QAAQ,2CAAa;AACrB,sBAAsB,4DAAuB;AAC7C,yBAAyB,4DAAuB;AAChD,yBAAyB,wDAAqB;AAC9C,yBAAyB,4DAAuB;AAChD,yBAAyB,8DAAwB;AACjD;AACA,yBAAyB,8DAAwB;AACjD,mBAAmB,uDAAmB;AACtC,UAAU,sBAAsB,wDAAqB;AACrD,mBAAmB,uDAAmB;AACtC,UAAU,sBAAsB,4DAAuB;AACvD,iBAAiB,uCAAW;AAC5B;AACA;AACA,mBAAmB,uDAAmB;AACtC,UAAU;AACV,mBAAmB,uDAAmB;AACtC;AACA,eAAe,uDAAmB;;AAElC,iBAAiB,8BAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uDAAmB;AAC9B,eAAe,8BAAS;AACxB;;AAEA,kDAAmB,UAAU,0CAAe;;AAE5C;AACA;AACA,wCAAwC,aAAa,MAAM,kBAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K,mEAAmE,oBAAoB;AACvF;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA,sCAAsC,kBAAkB;AACxD;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA,mEAAmE,oBAAoB,iBAAiB,kBAAkB;AAC1H;AACA;AACA,0DAAuB;AACvB;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA,eAAe,8BAAS;AACxB;;AAEA,kDAAmB,kBAAkB,0DAAuB;AAC5D,kDAAmB,SAAS,0DAAuB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D,yCAAyC,mBAAmB;AAC5D,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;AAC3D;AACA,sCAAsC,cAAc;AACpD,gFAAgF,cAAc;AAC9F;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,6CAA6C,mBAAmB;AAChE,6CAA6C,mBAAmB;AAChE,4CAA4C,mBAAmB;AAC/D,4CAA4C,mBAAmB;AAC/D;AACA,0CAA0C,cAAc;AACxD,QAAQ;AACR;AACA;AACA;AACA;AACA,4CAAgB;AAChB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,yCAAY;AACpC,wBAAwB,yCAAY;AACpC;AACA;AACA,oCAAoC,uBAAuB;AAC3D,gCAAgC,+CAAe;AAC/C;AACA,8BAA8B;AAC9B;AACA;;AAEA,gCAAgC,+CAAe;AAC/C;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,sBAAsB;AACtB,oCAAoC,oBAAoB;AACxD,gCAAgC,yCAAY;AAC5C;AACA;AACA;AACA,8BAA8B,SAAS,yCAAY;AACnD,4CAA4C,oBAAoB;AAChE,wCAAwC,+CAAe;AACvD;AACA,sCAAsC;AACtC;AACA;;AAEA,wCAAwC,+CAAe;AACvD;AACA,sCAAsC;AACtC;AACA;AACA;AACA,8BAA8B;AAC9B,gCAAgC,+CAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,2CAAkB;AAC1C;;AAEA,uBAAuB,6CAAmB;AAC1C,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uDAAmB;AACpC;AACA;AACA,aAAa,8BAAS;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAmB,WAAW,4CAAgB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,WAAW;AACzE,6EAA6E,oBAAoB,IAAI,cAAc;AACnH,gFAAgF,cAAc;AAC9F;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,6CAA6C,mBAAmB;AAChE,6CAA6C,mBAAmB;AAChE,4CAA4C,mBAAmB;AAC/D,4CAA4C,mBAAmB;AAC/D;AACA,0CAA0C,cAAc;AACxD,QAAQ;AACR;AACA;AACA;AACA,4DAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,uCAAW,iBAAiB,yCAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uCAAW;AACpB,UAAU,2CAAa,iBAAiB,+CAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uCAAW,iBAAiB,2CAAa;AAClD;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uDAAmB;AACpC,iBAAiB,uDAAmB;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,yCAAY;AACpB,QAAQ,yCAAY;AACpB;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,gBAAgB,+CAAe;AAC/B;AACA,cAAc;AACd;AACA;;AAEA,gBAAgB,+CAAe;AAC/B;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN;AACA,oBAAoB,cAAc;AAClC,gBAAgB,2CAAa;AAC7B;AACA,cAAc,SAAS,yCAAY;AACnC;AACA;AACA,cAAc,SAAS,yCAAY;AACnC;AACA,oBAAoB,+CAAe;AACnC;AACA,kBAAkB;AAClB;AACA;;AAEA,oBAAoB,+CAAe;AACnC;AACA,kBAAkB;AAClB;AACA;AACA,cAAc,SAAS,+CAAe;AACtC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,qDAAkB;AACnC,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC,gBAAgB,yCAAY;AAC5B;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,qDAAuB;;AAEpD,aAAa,8BAAS;AACtB;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA,YAAY,yCAAY;AACxB,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAmB,mBAAmB,4DAAwB;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,4EAA4E,gBAAgB;AAC5F,yEAAyE,kBAAkB;AAC3F,4EAA4E,oBAAoB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD,wBAAwB,eAAe,uBAAuB;AAC9D,mBAAmB,eAAe,sBAAsB;AACxD,kCAAkC;AAClC,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gEAAgE,oCAAoC;AACpG;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gFAAgF,gBAAgB;AAChG,6EAA6E,kBAAkB;AAC/F,gFAAgF,oBAAoB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D,4BAA4B,eAAe,uBAAuB;AAClE,uBAAuB,eAAe,sBAAsB;AAC5D,sCAAsC;AACtC,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oEAAoE,oCAAoC;AACxG;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4DAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,uCAAW,iBAAiB,yCAAY;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS,uCAAW,iBAAiB,2CAAa;AAClD;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uDAAmB;AACpC,iBAAiB,uDAAmB;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,yCAAY;AACpB,QAAQ,yCAAY;AACpB;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,gBAAgB,+CAAe;AAC/B;AACA,cAAc;AACd;AACA;;AAEA,gBAAgB,+CAAe;AAC/B;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN;AACA,oBAAoB,cAAc;AAClC,gBAAgB,2CAAa;AAC7B;AACA,cAAc,SAAS,yCAAY;AACnC;AACA;AACA,cAAc,SAAS,yCAAY;AACnC;AACA,oBAAoB,+CAAe;AACnC;AACA,kBAAkB;AAClB;AACA;;AAEA,oBAAoB,+CAAe;AACnC;AACA,kBAAkB;AAClB;AACA;AACA,cAAc,SAAS,+CAAe;AACtC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,qDAAkB;AACnC,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC,gBAAgB,yCAAY;AAC5B;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,8BAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;;AAEA,cAAc,0DAAuB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,YAAY,yCAAY;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,mBAAmB,4DAAwB;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gFAAgF;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE,2BAA2B;AAC3B;AACA,gCAAgC,kBAAkB;AAClD,kBAAkB;AAClB;AACA;AACA,qDAAqD,4CAA4C;AACjG,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK,2BAA2B;AAC3B,2DAA2D,YAAY;AACvE,uDAAuD,kBAAkB,oBAAoB,gBAAgB;AAC7G;AACA,qDAAqD,4CAA4C;AACjG,IAAI;AACJ;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,oCAAoC,kBAAkB;AACtD,kBAAkB;AAClB;AACA;AACA;AACA,qDAAqD,4CAA4C;AACjG,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK,2DAA2D,YAAY;AACvE,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,oCAAoC,kBAAkB;AACtD,kBAAkB;AAClB;AACA;AACA;AACA,qDAAqD,4CAA4C;AACjG,IAAI;AACJ;AACA;AACA,oDAAoB;AACpB;;AAEA,WAAW,uDAAmB;AAC9B;;AAEA;AACA,QAAQ,uDAAmB;;AAE3B,SAAS,uCAAW;AACpB;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,SAAS,uCAAW;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,uCAAgB;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,eAAe,oDAAoB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,wFAAwF,sFAAsF;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,8DAAwB,KAAK,yCAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,8DAAwB;AAC9D;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA,uCAAuC,sDAAoB;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,eAAe,oDAAoB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;;AAEA,mGAAmG,cAAc;AACjH;AACA,4FAA4F,qFAAqF;AACjL;AACA;AACA;AACA,wDAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,iBAAiB,wDAAsB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA,yGAAyG,oBAAoB;AAC7H,6CAA6C,QAAQ;AACrD;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,6GAA6G,oBAAoB;AACjI,iDAAiD,QAAQ;AACzD;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,oDAAoB;AACpB;;AAEA,qDAAqD,8DAAwB;AAC7E;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;;AAE9B;AACA,SAAS,2BAAU;AACnB,SAAS,2BAAU;;AAEnB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kDAAmB,eAAe,oDAAoB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA,+DAA+D,sCAAsC;AACrG;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,mDAAmD,gCAAgC;AACnF;AACA,mEAAmE,sCAAsC;AACzG;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,kEAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAA0B;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA,wDAAwD,sCAAsC;AAC9F;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,mDAAmD,gCAAgC;AACnF;AACA,4DAA4D,sCAAsC;AAClG;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,oDAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAmB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C,WAAW,kCAAkC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E;AACA,6DAA6D,sCAAsC;AACnG;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,mDAAmD,gCAAgC;AACnF;AACA,iEAAiE,sCAAsC;AACvG;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,8DAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAwB;AACxC;AACA;AACA;AACA;AACA;;AAEA,kDAAmB,oBAAoB,8DAAyB;AAChE,kDAAmB,sBAAsB,kEAA2B;AACpE,kDAAmB,eAAe,oDAAoB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,mDAAmD,eAAe;AAClE;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,+CAA+C,iDAAiD;AAChG;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,mDAAmD,iDAAiD;AACpG;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,mFAAmF;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB,0BAA0B,gBAAgB;AACnF;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,6BAA6B,gBAAgB,0BAA0B,gBAAgB;AACvF;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,8CAAiB;AACjB;AACA;AACA;AACA;AACA,eAAe,uDAAmB;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA,gBAAgB,SAAS;AACzB,mBAAmB,uDAAmB;AACtC;AACA,YAAY,uDAAmB;AAC/B,YAAY,uDAAmB;;AAE/B;AACA;;AAEA,aAAa,2CAAa;AAC1B,cAAc,2CAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAmB,YAAY,8CAAiB;;AAEhD,0CAAe;AACf,WAAW,8BAAS;AACpB,0BAA0B,4DAAwB;AAClD,iBAAiB,0CAAe;AAChC,2BAA2B,8DAAyB;AACpD,6BAA6B,kEAA2B;AACxD,sBAAsB,oDAAoB;AAC1C,sBAAsB,oDAAoB;AAC1C,yBAAyB,0DAAuB;AAChD,0BAA0B,4DAAwB;AAClD,gBAAgB,0DAAuB;AACvC,kBAAkB,4CAAgB;AAClC,sBAAsB,oDAAoB;AAC1C,wBAAwB,wDAAsB;AAC9C,sBAAsB,oDAAoB;AAC1C,CAAC,EAAC;;;ACn8FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;AACe;AACT;AACK;AACA;AACH;AACK;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAmD;AAC1F,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAmD;AAChG,IAAI;AACJ;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,2DAA2D,mBAAmB;AAC9E,4CAA4C,mBAAmB;AAC/D;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,oDAAoD,cAAc;AAClE,+DAA+D,mBAAmB;AAClF,gDAAgD,mBAAmB;AACnE;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sCAAa;AACb;;AAEA,aAAa,qDAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,wDAAqB;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAa;;AAEhC,cAAc,+BAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,2CAAkB;;AAE/B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uEAAuE,kBAAkB,KAAK,sBAAsB;AACpH;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAc;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,+BAA+B,+BAAY;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,2CAAa;AACzB;AACA;;AAEA,YAAY,2CAAa,CAAC,2CAAa;AACvC;AACA,mBAAmB,2CAAa;AAChC,UAAU;AACV;AACA;AACA;AACA;AACA,yBAAyB,0BAAM,CAAC,0DAAsB;;AAEtD;AACA;AACA;AACA;AACA,qBAAqB,mCAAW;AAChC,gBAAgB,yCAAc;AAC9B,6BAA6B,0BAAM,CAAC,sDAAoB;AACxD;;AAEA,2CAA2C,sDAAoB;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAoB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA,6BAA6B,0BAAM,CAAC,0DAAsB;AAC1D;AACA,+CAA+C,sDAAoB;AACnE;;AAEA;AACA,kBAAkB,+CAAoB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAa;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,0BAAM;AAC3B,YAAY,sDAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,2DAA0B,CAAC,+BAAY;;AAE/D,mBAAmB,0BAAM,CAAC,sDAAoB;AAC9C;;AAEA;AACA,6BAA6B,2CAA2C;;AAExE;AACA,uBAAuB,qCAAqC;;AAE5D,mBAAmB,oCAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,kDAAmB,QAAQ,sCAAa;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oDAAoB;AACpB;;AAEA;AACA,aAAa,qDAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,eAAe,oDAAoB;;AAEtD;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,8DAAyB;AACzB;;AAEA;AACA,aAAa,qDAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,oBAAoB,8DAAyB;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,gDAAkB;AAClB;AACA,WAAW,sCAAa;AACxB;;AAEA,kDAAmB,aAAa,gDAAkB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gDAAkB;AAClB;AACA,WAAW,sCAAa;AACxB;;AAEA,kDAAmB,aAAa,gDAAkB;;AAElD,wCAAe;AACf,eAAe,sCAAa;AAC5B,sBAAsB,oDAAoB;AAC1C,2BAA2B,8DAAyB;AACpD,oBAAoB,gDAAkB;AACtC,oBAAoB,gDAAkB;AACtC,CAAC,EAAC;;;AC7nBF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACe;AACT;AACa;AACR;AACE;AACL;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA,WAAW,6DAA6D;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oCAAoC;AAC7E,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,4CAA4C,oCAAoC;AAChF,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA,gCAAgC,aAAa,WAAW,cAAc,gBAAgB,cAAc;AACpG,6DAA6D;AAC7D,4CAA4C,0CAA0C;AACtF;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,oDAAoD,cAAc;AAClE;AACA,oCAAoC,aAAa,WAAW,cAAc,gBAAgB,cAAc;AACxG,iEAAiE;AACjE,gDAAgD,0CAA0C;AAC1F;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC,0BAA0B;AAC1B;AACA,UAAU;AACV,6BAA6B,kBAAkB;AAC/C,2BAA2B,iBAAiB;AAC5C;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,8BAA8B;AAC9B;AACA,cAAc;AACd,iCAAiC,kBAAkB;AACnD,+BAA+B,iBAAiB;AAChD;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,4CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,4DAAuB;AAC3D,oCAAoC,4DAAuB;AAC3D,SAAS,yCAAY,gBAAgB,2CAAa;AAClD,SAAS,yCAAY,gBAAgB,2CAAa;AAClD,SAAS,2CAAa,gBAAgB,+CAAe,gBAAgB,2CAAa;AAClF;AACA;AACA,MAAM;AACN,iBAAiB,qDAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA,cAAc,8DAAwB;AACtC;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC,YAAY,yCAAY;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA,YAAY,iDAAqB;;AAEjC,YAAY,yCAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAA2B;AAC3C,kBAAkB,UAAU,yBAAyB;AACrD;AACA;AACA;AACA,gBAAgB,2CAAmB;AACnC;AACA,gBAAgB,6CAAgB;AAChC;AACA;AACA,UAAU;AACV;AACA;;AAEA,YAAY,yCAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAA2B;AAC3C,kBAAkB,UAAU,yBAAyB;AACrD;AACA;AACA;AACA,gBAAgB,2CAAmB;AACnC;AACA,gBAAgB,6CAAgB;AAChC;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,6CAAgB;;AAEhC,iCAAiC,2BAAO,GAAG,2BAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iCAAc;;AAE9B;AACA;AACA,gBAAgB,iCAAc;;AAE9B,qCAAqC,0BAAM,CAAC,sDAAoB;AAChE,qCAAqC,0BAAM,CAAC,sDAAoB;AAChE,qCAAqC,0BAAM,CAAC,sDAAoB;;AAEhE;AACA,iCAAiC,2BAAO;AACxC,iCAAiC,2BAAO;AACxC,iCAAiC,2BAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,2CAAkB;;AAEnC;AACA;;AAEA;AACA;;AAEA,uBAAuB,oCAAY;AACnC;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uCAAW;AACvB;AACA;AACA;;AAEA,uBAAuB,oCAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,+BAAY;AAC9B;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,uCAAW;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,2CAAkB;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ,sBAAsB,qBAAqB,KAAK,oBAAoB;AACjG;AACA;AACA;AACA;;AAEA,eAAe,uDAAmB;AAClC;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0BAAM,CAAC,0DAAsB;AAC1D;AACA,+CAA+C,sDAAoB;AACnE;AACA,mBAAmB,2CAAa;;AAEhC,YAAY,2CAAa,CAAC,2CAAa;AACvC;AACA,mBAAmB,2CAAa;AAChC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAAY;AAChC;AACA,mBAAmB,+BAAY;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,6BAA6B,0BAAM,CAAC,0DAAsB;AAC1D;AACA,+CAA+C,sDAAoB;AACnE;AACA;AACA;AACA,mBAAmB,2CAAa;;AAEhC;AACA,oBAAoB,+BAAY;AAChC;AACA,mBAAmB,+BAAY;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,2CAAa;AACzB,YAAY,2CAAa;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAa;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,0BAAM;AAC3B,YAAY,sDAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,2DAA0B,CAAC,+BAAY;;AAE/D,mBAAmB,0BAAM,CAAC,sDAAoB;AAC9C;;AAEA;AACA;AACA,gBAAgB,mCAAmC;AACnD,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAc;AACtB;AACA;;AAEA;AACA;AACA,eAAe,QAAQ,+DAA+D,0BAA0B,KAAK,2BAA2B;AAChJ,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAAM;AAC9B,2BAA2B,0BAAM;;AAEjC;AACA;AACA;;AAEA,iBAAiB,2CAAmB;AACpC,8DAA8D,mBAAmB;AACjF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kDAAmB,WAAW,4CAAgB;;AAE9C;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oEAA4B;AAC5B;;AAEA,aAAa,qDAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,uBAAuB,oEAA4B;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC,0BAA0B;AAC1B;AACA,UAAU;AACV,6BAA6B,kBAAkB;AAC/C,2BAA2B,iBAAiB;AAC5C;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,8BAA8B;AAC9B;AACA,cAAc;AACd,iCAAiC,kBAAkB;AACnD,+BAA+B,iBAAiB;AAChD;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sDAAqB;AACrB;AACA,WAAW,4CAAgB;AAC3B;;AAEA,kDAAmB,gBAAgB,sDAAqB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,sDAAqB;AACrB;AACA,WAAW,4CAAgB;AAC3B;;AAEA,kDAAmB,gBAAgB,sDAAqB;;AAExD;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA,WAAW,6CAA6C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mCAAmC;AACvF,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,oDAAoD,mCAAmC;AACvF,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oCAAoC;AAC7E,yCAAyC,eAAe;AACxD;AACA,+DAA+D,UAAU;AACzE,oDAAoD,UAAU;AAC9D;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,4CAA4C,oCAAoC;AAChF,4CAA4C,eAAe;AAC3D;AACA,kEAAkE,UAAU;AAC5E,uDAAuD,UAAU;AACjE,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,oDAAoD,cAAc;AAClE;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,0CAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,4DAAuB;AAC3D,oCAAoC,4DAAuB;AAC3D,SAAS,yCAAY,gBAAgB,2CAAa;AAClD,SAAS,yCAAY,gBAAgB,2CAAa;AAClD;AACA;AACA,MAAM;AACN,iBAAiB,qDAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;;AAE9B;AACA,SAAS,uCAAW;AACpB,yCAAyC,MAAM,4DAAuB,EAAE;AACxE;;AAEA,QAAQ,uCAAW;AACnB;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC,kBAAkB,+BAAY;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,2CAAkB;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB,yCAAc;;AAEvC,oBAAoB,+CAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B,yCAAc;AAC3C,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B;AAC/B,MAAM;;AAEN;AACA,QAAQ,uCAAW;AACnB,yBAAyB,2CAAa;AACtC;;AAEA;AACA,cAAc,4DAAuB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,yCAAiB;AAC9B,aAAa,yCAAiB;;AAE9B;AACA;AACA;;AAEA,YAAY,6CAAgB;AAC5B;AACA,YAAY,6CAAgB;AAC5B;;AAEA,YAAY,6CAAgB;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2CAAa;AAChC,kBAAkB,2CAAkB;AACpC,mBAAmB,2CAAa;;AAEhC;AACA;AACA;;AAEA,mCAAmC,2CAAa,kCAAkC,2BAAO;AACzF,mBAAmB,2CAAa;AAChC;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;;AAEA;AACA,oCAAoC,gBAAgB;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAmB;AACjC;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,uCAAW;AAC/B;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,yCAAiB;AACrC,qBAAqB,+BAAY;;AAEjC,uBAAuB,2CAAa;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAc;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,MAAM;AACN,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAa;AAChC;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,uCAAW;AACvB,iBAAiB,2CAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA,YAAY,yCAAiB;AAC7B,aAAa,+BAAY;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAc;AAC5B;AACA;AACA;;AAEA,YAAY,yCAAiB;AAC7B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2DAA0B,CAAC,+BAAY;;AAE/D,mBAAmB,0BAAM,CAAC,sDAAoB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,eAAe,+BAAY;AAC3B;;AAEA,mBAAmB,2CAAa;AAChC;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,kDAAmB,UAAU,0CAAe;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE,oDAAoD,mCAAmC;AACvF,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE,oDAAoD,mCAAmC;AACvF,IAAI;AACJ;AACA;AACA,4DAAwB;AACxB;;AAEA;AACA,SAAS,0CAAe;;AAExB;AACA;AACA,gBAAgB,+BAAY;AAC5B;AACA;AACA;AACA;;AAEA,kDAAmB,mBAAmB,4DAAwB;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE,oDAAoD,mCAAmC;AACvF,+FAA+F,cAAc;AAC7G;AACA;AACA,kFAAkF,qFAAqF;AACvK;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE,oDAAoD,mCAAmC;AACvF,IAAI;AACJ;AACA;AACA,sDAAqB;AACrB;;AAEA;AACA,SAAS,0CAAe;;AAExB;AACA;AACA,gBAAgB,+BAAY;AAC5B;AACA;AACA;AACA;;AAEA,kDAAmB,gBAAgB,sDAAqB;;AAExD,2CAAe;AACf,kBAAkB,4CAAgB;AAClC,8BAA8B,oEAA4B;AAC1D,uBAAuB,sDAAqB;AAC5C,uBAAuB,sDAAqB;AAC5C,iBAAiB,0CAAe;AAChC,uBAAuB,sDAAqB;AAC5C,0BAA0B,4DAAwB;AAClD,CAAC,EAAC;;;ACroDF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACO;AACD;AACE;;AAEjC;AACA;AACA;AACA,QAAQ,wBAAwB;AAChC,SAAS,sBAAsB;AAC/B;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAkB;AAClB,wBAAwB,8DAAwB;AAChD,gBAAgB,8EAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oEAA4B;;AAE5B,gCAAU;AACV,IAAI,oEAA4B;AAChC;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,+DAAuB;AACxD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iCAAiC,+DAAuB;AACxD;AACA,2DAA2D;AAC3D,2DAA2D;AAC3D;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,+DAAuB;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,4BAA4B,6CAAgB;AAC5C;AACA;AACA;AACA;AACA,sBAAsB;AACtB,4BAA4B,6CAAgB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,qCAAqC,+DAAuB;AAC5D;AACA,kBAAkB;AAClB,qCAAqC,+DAAuB;;AAE5D,gDAAgD,yCAAY;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,gCAAgC,yCAAY;AAC5C;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,iCAAiC,+DAAuB;AACxD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,iCAAiC,+DAAuB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B,uBAAuB,yCAAc;AACrC;AACA,mBAAmB,yCAAc;AACjC,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA,iBAAiB,yCAAY;AAC7B;AACA;;AAEA;;AAEA,wBAAwB,SAAS;AACjC;AACA,oBAAoB,yCAAc;AAClC,2CAA2C,sDAAoB;AAC/D;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,gBAAgB,yCAAY;AAC5B;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAc;AAC1B,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;;AAEA,wBAAwB,SAAS;AACjC,4BAA4B,UAAU;AACtC;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,SAAS;AACrC,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD,kDAAkD,gBAAgB,YAAY,kBAAkB;AAChG,4CAA4C,cAAc;AAC1D;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,+CAA+C,UAAU;AACzD,sDAAsD,gBAAgB,YAAY,iBAAiB;AACnG,gDAAgD,cAAc;AAC9D;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,4CAA4C,cAAc;AAC1D;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,oDAAoD,cAAc;AAClE,gDAAgD,cAAc;AAC9D;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA,oDAAoD,eAAe;AACnE,4CAA4C,cAAc;AAC1D;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,+CAA+C,UAAU;AACzD;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA,wDAAwD,eAAe;AACvE,gDAAgD,cAAc;AAC9D;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB;AACnE,oDAAoD,eAAe;AACnE,+CAA+C,kBAAkB;AACjE,uDAAuD,cAAc;AACrE;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,qDAAqD,iBAAiB;AACtE,wDAAwD,cAAc;AACtE,mDAAmD,iBAAiB;AACpE,2DAA2D,cAAc;AACzE;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D,4CAA4C,cAAc;AAC1D;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D,gDAAgD,cAAc;AAC9D;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,kDAAkD,cAAc;AAChE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,kBAAkB;AACxE,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,2CAA2C,cAAc;AACzD;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA,sDAAsD,kBAAkB;AACxE,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,2CAA2C,cAAc;AACzD;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,kDAAmB;AACnB,eAAe,gDAAkB;AACjC;;AAEA,kDAAmB,cAAc,kDAAmB;;AAEpD,mDAAe;AACf,oBAAoB,gDAAkB;AACtC,qBAAqB,kDAAmB;AACxC,CAAC,EAAC;;;AC3uBF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,2BAA2B;AAChD,uBAAuB,iBAAiB;AACxC;AACA,UAAU,qBAAqB;AAC/B,UAAU,eAAe;AACzB,UAAU,cAAc;AACxB,UAAU,mBAAmB;AAC7B,UAAU,2BAA2B;AACrC,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB,UAAU,kBAAkB;AAC5B,UAAU,aAAa;AACvB,UAAU,2BAA2B;AACrC,UAAU,eAAe;AACzB,UAAU,oBAAoB;AAC9B,UAAU,yBAAyB;AACnC,UAAU,2BAA2B;AACrC,UAAU,iBAAiB;AAC3B;;AAEyB;AACM;AACS;AACA;AACJ;AACH;AACK;AACJ;AACF;AACI;AACW;AACD;AACZ;AACI;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAA8B;AAC9B;;AAEA;AACA;;AAEA;AACA,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA,YAAY,qDAAkB;AAC9B;AACA,MAAM;AACN,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA,YAAY,qDAAkB;AAC9B;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;;AAE9B;AACA;AACA;AACA;AACA,uBAAuB,6DAA2B;AAClD;AACA;AACA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,gBAAgB,OAAO;AACvB,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA,6FAA6F,qFAAqF;AAClL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAuB;AACvB;;AAEA;AACA;;AAEA;AACA,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA;AACA,YAAY,qDAAkB;AAC9B,MAAM;AACN,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA;AACA,YAAY,qDAAkB;AAC9B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,SAAS,eAAe;AACxB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAA4B;AAC5B;;AAEA;AACA;AACA;AACA,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA,YAAY,qDAAkB;AAC9B;AACA,MAAM;AACN,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA,YAAY,qDAAkB;AAC9B;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,mDAAsB;AAC7C;AACA;AACA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE,IAAI,iBAAiB;AACrB;AACA,YAAY,OAAO;AACnB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,yFAAyF,qFAAqF;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAA8B;AAC9B;;AAEA;AACA;AACA;AACA,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA;AACA,YAAY,qDAAkB;AAC9B,MAAM;AACN,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA;AACA,YAAY,qDAAkB;AAC9B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uDAAmB;AAC9B,QAAQ,oEAA4B;AACpC;;AAEA,SAAS,uCAAW;AACpB;AACA;;AAEA,WAAW,uDAAmB;AAC9B,SAAS,eAAe;AACxB;AACA;AACA;AACA,uBAAuB,mDAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,qBAAqB;AAChC,WAAW,UAAU,yCAAyC,uBAAuB,KAAK,uBAAuB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAkB;AAClB;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,QAAQ,iDAAgB;AACxB,QAAQ,iDAAgB;AACxB;AACA,kBAAkB,qDAAkB;AACpC;AACA;AACA,MAAM,6DAA6D,4DAAuB;AAC1F;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2BAAO;AAC7D,sDAAsD,2BAAO;AAC7D;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sDAAsD,2BAAO;AAC7D,sDAAsD,2BAAO;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA,0DAAuB;AACvB;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,QAAQ,iDAAgB;AACxB,QAAQ,iDAAgB;AACxB,QAAQ,iDAAgB;AACxB;AACA,kBAAkB,qDAAkB;AACpC;AACA;AACA;AACA,MAAM;AACN,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA,YAAY,qDAAkB;AAC9B;AACA;AACA,MAAM;AACN,QAAQ,iDAAgB;AACxB,oCAAoC,4DAAuB;AAC3D;AACA,YAAY,qDAAkB;AAC9B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,0CAA0C;AAC3F;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0CAA0C;AAC/F;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,gDAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA,kBAAkB,qDAAkB;AACpC;AACA;AACA,MAAM,SAAS,iDAAgB;AAC/B;AACA,YAAY,qDAAkB;AAC9B;AACA;AACA;AACA;AACA,MAAM,SAAS,iDAAgB;AAC/B;AACA,YAAY,qDAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA,SAAS,uCAAW;AACpB;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAgB;AAC3C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0DAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA,YAAY,gDAAkB;AAC9B;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,oDAAoD;AAC/D;AACA,WAAW,QAAQ,oDAAoD,oCAAoC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAAgB;AAChB;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,YAAY,iDAAgB;AAC5B,gBAAgB,qDAAkB;AAClC;AACA,UAAU,SAAS,iDAAgB;AACnC;AACA,gBAAgB,qDAAkB;AAClC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,2BAA2B,4DAAuB;AAClD;AACA,gBAAgB,uDAAmB;AACnC;AACA;AACA;AACA;AACA,4BAA4B,6CAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4BAA4B,gEAAyB;AAC3D;AACA,MAAM,4BAA4B,8DAAwB;AAC1D,YAAY,2CAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAAU;AAC/C,oCAAoC,2BAAU;AAC9C;AACA,qBAAqB;AACrB;AACA,+BAA+B,2BAAU;AACzC,qBAAqB;AACrB;AACA,+BAA+B,2BAAU;AACzC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,oBAAoB,8DAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;;AAEA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;AACA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;AACA,wCAAwC,4DAAuB;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gDAAkB;AAClB;;AAEA,cAAc,qDAAkB;AAChC,QAAQ,yCAAY,gBAAgB,yCAAY,gBAAgB,yCAAY;AAC5E;AACA,eAAe,uDAAmB;AAClC;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mDAAsB;AACjD;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,aAAa,uCAAW;AACxB;AACA;;AAEA,eAAe,uDAAmB;AAClC,YAAY,eAAe;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oFAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,4DAAuB;AACnD,4BAA4B,4DAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,uCAAW;AACpB;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS,uCAAW;AACpB;AACA;AACA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,WAAW,GAAG,sBAAsB;;AAElD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,cAAc;AACjG;AACA;AACA,uFAAuF,qFAAqF;AAC5K;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,2FAA2F,qFAAqF;AAChL;AACA;AACA;AACA;AACA;AACA;AACA,wDAAsB;AACtB;;AAEA,cAAc,qDAAkB;AAChC,QAAQ,yCAAY,gBAAgB,yCAAY,gBAAgB,yCAAY;AAC5E;AACA;AACA;;AAEA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA,2BAA2B,iDAAqB;AAChD;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,2FAA2F,qFAAqF;AAChL;AACA;AACA;AACA;AACA;AACA;AACA,gDAAkB;AAClB;;AAEA,cAAc,qDAAkB;AAChC;AACA;AACA,QAAQ,yCAAY;AACpB,QAAQ,yCAAY;AACpB,QAAQ,yCAAY;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,0BAAM;AACrC,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA,wDAAsB;AACtB;;AAEA,cAAc,qDAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAmB;AAClC,YAAY,wDAAsB;;AAElC;;AAEA,aAAa,uCAAW;AACxB;AACA;AACA,eAAe,uDAAmB;AAClC,YAAY,mBAAmB;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA,gDAAkB;AAClB;;AAEA,cAAc,qDAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAmB;AAClC,YAAY,gDAAkB;;AAE9B;;AAEA,aAAa,uCAAW;AACxB;AACA;AACA,eAAe,uDAAmB;AAClC,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B,gBAAgB,uCAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,mDAAmD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uBAAuB;AAC1E;AACA,oDAAoD,UAAU;AAC9D,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA,0GAA0G,cAAc;AACxH,4DAA4D,kCAAkC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mBAAmB;AACtF,0DAA0D,mBAAmB;AAC7E;AACA;AACA,0CAA0C,aAAa,WAAW,cAAc,gBAAgB,cAAc;AAC9G,uEAAuE;AACvE,0DAA0D,4DAA4D;AACtH;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,uDAAuD,uBAAuB;AAC9E;AACA,wDAAwD,UAAU;AAClE,8DAA8D,WAAW;AACzE;AACA;AACA;AACA;AACA,8GAA8G,cAAc;AAC5H,gEAAgE,kCAAkC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mBAAmB;AACtF,0DAA0D,mBAAmB;AAC7E;AACA;AACA,0CAA0C,aAAa,WAAW,cAAc,gBAAgB,cAAc;AAC9G,uEAAuE;AACvE,0DAA0D,4DAA4D;AACtH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,oDAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;;AAEA,WAAW,uDAAmB;;AAE9B,QAAQ,yCAAY;AACpB,cAAc,qDAAkB;AAChC,MAAM;AACN,oCAAoC,8DAAwB;AAC5D,oCAAoC,4DAAuB;AAC3D,4BAA4B,gEAAyB;AACrD,oCAAoC,gEAAyB;AAC7D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,4DAAuB;AAC3D;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8BAAyB,eAAe,iBAAiB;;AAEjE,QAAQ,yCAAY;AACpB,YAAY,iBAAiB;;AAE7B;AACA,MAAM,8BAA8B,8DAAwB;AAC5D,YAAY,iBAAiB;AAC7B,MAAM,8BAA8B,4DAAuB;AAC3D,YAAY,eAAe;AAC3B,MAAM,sBAAsB,gEAAyB;AACrD,YAAY,qBAAqB;AACjC,MAAM,8BAA8B,gEAAyB;AAC7D;AACA;AACA,oBAAoB,uDAAmB;AACvC,kBAAkB,iBAAiB;AACnC;AACA;AACA,kCAAkC,2CAAa;AAC/C;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gBAAgB,mBAAmB;AACnC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC,QAAQ,yCAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,qDAAqD;AAChE;AACA;AACA,sDAAsD,iBAAiB;AACvE;AACA,oDAAoD,UAAU;AAC9D,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA,0GAA0G,cAAc;AACxH,iEAAiE,kCAAkC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mBAAmB;AACtF,+DAA+D,mBAAmB;AAClF;AACA;AACA,0CAA0C,aAAa,WAAW,cAAc,gBAAgB,cAAc;AAC9G,uEAAuE;AACvE,+DAA+D,4DAA4D;AAC3H;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA,0DAA0D,iBAAiB;AAC3E;AACA,wDAAwD,UAAU;AAClE,mEAAmE,WAAW;AAC9E;AACA;AACA;AACA;AACA,8GAA8G,cAAc;AAC5H,qEAAqE,kCAAkC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mBAAmB;AACtF,+DAA+D,mBAAmB;AAClF;AACA;AACA,0CAA0C,aAAa,WAAW,cAAc,gBAAgB,cAAc;AAC9G,uEAAuE;AACvE,+DAA+D,4DAA4D;AAC3H;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,0DAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;;AAEA,WAAW,uDAAmB;AAC9B,QAAQ,yCAAY;AACpB;AACA,cAAc,qDAAkB;AAChC,MAAM;AACN,oCAAoC,8DAAwB;AAC5D,oCAAoC,4DAAuB;AAC3D,4BAA4B,gEAAyB;AACrD,oCAAoC,gEAAyB;AAC7D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,yCAAY;AACpB,gBAAgB,uDAAmB;AACnC;AACA,YAAY,qDAAkB;AAC9B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,8BAAyB,wBAAwB,gBAAgB;AACzE,QAAQ,yCAAY;AACpB,YAAY,iBAAiB;;AAE7B;AACA,MAAM,8BAA8B,8DAAwB;AAC5D,YAAY,iBAAiB;AAC7B,MAAM,8BAA8B,4DAAuB;AAC3D,YAAY,eAAe;AAC3B,MAAM,sBAAsB,gEAAyB;AACrD,YAAY,qBAAqB;AACjC,MAAM,8BAA8B,gEAAyB;AAC7D;AACA;AACA,oBAAoB,uDAAmB;AACvC,kBAAkB,iBAAiB;AACnC;AACA;AACA,kCAAkC,2CAAa;AAC/C;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gBAAgB,mBAAmB;AACnC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,qBAAqB;AAChC;AACA,mDAAmD,8BAA8B;AACjF;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA;AACA;AACA,sDAAqB;AACrB,aAAa,0DAAuB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,iBAAiB;AAC5B;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA,+FAA+F,cAAc;AAC7G;AACA,2FAA2F,qFAAqF;AAChL,0EAA0E,uBAAuB;AACjG;AACA;AACA;AACA,gDAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,yCAAY,4CAA4C,8DAAwB;AACxF;AACA;AACA,MAAM;AACN,QAAQ,yCAAY;AACpB,oCAAoC,8DAAwB;AAC5D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA,QAAQ,+CAAe;AACvB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,QAAQ,+CAAe;AACvB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA,QAAQ,+CAAe;AACvB;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;;AAEA;AACA,aAAa;AACb;AACA,oBAAoB,2CAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA,QAAQ,+CAAe;AACvB;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB,2CAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA,eAAe,uDAAmB;AAClC,eAAe,uDAAmB;;AAElC;AACA;AACA;AACA;AACA,kCAAkC,0BAAM;AACxC,4BAA4B,0DAAsB;AAClD;AACA,gCAAgC,2CAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,kCAAkC,0BAAM;AACxC,4BAA4B,0DAAsB;AAClD;AACA;AACA,gCAAgC,2CAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,8BAA8B,+CAAoB;AAClD,kCAAkC,MAAM,yCAAY;AACpD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,2BAAU;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,2CAAa;AACzB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oCAAY;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,+EAA+E,6EAA6E;AAC5J;AACA,IAAI;AACJ;AACA;AACA,wCAAc;AACd;;AAEA,WAAW,uDAAmB;AAC9B;;AAEA;AACA,aAAa,0DAAsB;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;;AAEjC,YAAY,yCAAY;AACxB,0BAA0B,0BAAM;AAChC,gBAAgB,2CAAa,yBAAyB,sDAAoB;AAC1E;AACA;AACA;AACA,UAAU;AACV,0BAA0B,0BAAM,CAAC,0DAAsB;AACvD;;AAEA,YAAY,yCAAY;AACxB,8BAA8B,0BAAM;AACpC,gBAAgB,2CAAa,yBAAyB,sDAAoB;AAC1E;AACA;AACA;AACA,UAAU;AACV,8BAA8B,0BAAM;AACpC,gBAAgB,0DAAsB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yEAAyE;AACzE;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,mFAAmF,6EAA6E;AAChK;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D,+FAA+F,cAAc;AAC7G;AACA;AACA,mFAAmF,6EAA6E;AAChK;AACA,gDAAgD,aAAa;AAC7D,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mCAAmC;AAC1F;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA,2DAA2D,mCAAmC;AAC9F;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,oDAAoB;AACpB;;AAEA,WAAW,uDAAmB;AAC9B,oCAAoC,4DAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAsB;AAC1C,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,6CAAgB;AACzC,gBAAgB,2BAAO;AACvB;AACA,qBAAqB,mDAAsB;AAC3C,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oCAAoC,8DAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAAa;;AAEvC;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,YAAY,uDAAmB;AAC/B,aAAa,uCAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAmB,kBAAkB,0DAAuB;AAC5D,kDAAmB,aAAa,gDAAkB;AAClD,kDAAmB,kBAAkB,oFAAoC;AACzE,kDAAmB,YAAY,8CAAiB;AAChD,kDAAmB,iBAAiB,wDAAsB;AAC1D,kDAAmB,yBAAyB,wDAAsB;AAClE,kDAAmB,iBAAiB,wDAAsB;AAC1D,kDAAmB,aAAa,gDAAkB;AAClD,kDAAmB,aAAa,gDAAkB;AAClD,kDAAmB,aAAa,gDAAkB;AAClD,kDAAmB,aAAa,gDAAkB;AAClD,kDAAmB,kBAAkB,0DAAuB;AAC5D,kDAAmB,gBAAgB,sDAAqB;AACxD,kDAAmB,WAAW,4CAAgB;AAC9C,kDAAmB,yBAAyB,wEAA8B;AAC1E,kDAAmB,aAAa,gDAAkB;AAClD,kDAAmB,kBAAkB,0DAAuB;AAC5D,kDAAmB,kBAAkB,0DAAuB;AAC5D,kDAAmB,uBAAuB,oEAA4B;AACtE,kDAAmB,yBAAyB,wEAA8B;AAC1E,kDAAmB,eAAe,oDAAoB;AACtD,kDAAmB,SAAS,wCAAc;AAC1C,kDAAmB,eAAe,oDAAoB;;AAEtD,wDAAe;AACf,yBAAyB,0DAAuB;AAChD,oBAAoB,gDAAkB;AACtC,qCAAqC,oFAAoC;AACzE,wBAAwB,wDAAsB;AAC9C,wBAAwB,wDAAsB;AAC9C,oBAAoB,gDAAkB;AACtC,oBAAoB,gDAAkB;AACtC,oBAAoB,gDAAkB;AACtC,oBAAoB,gDAAkB;AACtC,yBAAyB,0DAAuB;AAChD,uBAAuB,sDAAqB;AAC5C,kBAAkB,4CAAgB;AAClC,gCAAgC,wEAA8B;AAC9D,oBAAoB,gDAAkB;AACtC,yBAAyB,0DAAuB;AAChD,yBAAyB,0DAAuB;AAChD,8BAA8B,oEAA4B;AAC1D,+BAA+B,wEAA8B;AAC7D,sBAAsB,oDAAoB;AAC1C,gBAAgB,wCAAc;AAC9B,sBAAsB,oDAAoB;AAC1C,CAAC,EAAC;;;AC5xHF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACe;AACP;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D,+FAA+F,cAAc;AAC7G;AACA,oFAAoF,4EAA4E;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA,0CAAe;AACf;;AAEA,QAAQ,yCAAY,qCAAqC,yCAAY;AACrE;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,4BAA4B;AAC1C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,eAAe,qCAAqC;;AAEpD;AACA;AACA;AACA;;AAEA,kDAAmB,UAAU,0CAAe;;AAE5C,0CAAe;AACf,iBAAiB,0CAAe;AAChC,CAAC,EAAC;;;;;AC/JF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACO;AACF;AACU;AACT;AACE;AACW;;AAE5C;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uBAAuB,kBAAkB;AACzC;AACA,0FAA0F,wBAAwB;AAClH,SAAS,aAAa;AACtB;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B,YAAY,OAAO;AACnB;AACA;AACA,8BAAS;AACT,wCAAwC,4DAAuB,EAAE,8DAAwB;AACzF;AACA;;AAEA,aAAa,uDAAmB;AAChC,aAAa,uDAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,oCAAY;AACjC;AACA;AACA,KAAK;AACL;;AAEA,kDAAmB,OAAO,2BAAe;AACzC,mEAAyB,CAAC,8BAAS,EAAE,4BAAa;;AAElD,gCAAU;AACV,IAAI,kDAAmB;AACvB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2CAAa,CAAC,2CAAa;AAC3C;AACA,uBAAuB,2CAAa;AACpC,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,0BAAM,CAAC,0DAAsB;AACjD;AACA;AACA;AACA,kBAAkB,6CAAgB,EAAE;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,SAAS;AACrC,gCAAgC,OAAO;AACvC,+BAA+B,yCAAc;AAC7C;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA,gBAAgB,yCAAY;AAC5B,4BAA4B,sBAAsB;AAClD;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA,oBAAoB,0BAA0B;AAC9C;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB,cAAc,gBAAgB;AAC1F;AACA;AACA;AACA,kCAAkC,yBAAyB,cAAc,yBAAyB;AAClG;AACA;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA,gDAAgD,gBAAgB,cAAc,gBAAgB;AAC9F;AACA;AACA;AACA,sCAAsC,yBAAyB,cAAc,yBAAyB;AACtG;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAmB;AACxC,qBAAqB,uDAAmB;;AAExC;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA,yBAAyB;;AAEzB;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,0FAA0F,qFAAqF;AAC/K;AACA;AACA;AACA,0CAAe;AACf;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,SAAS,0CAAoB,CAAC,8BAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,UAAU,0CAAe;;AAE5C,+CAAe;AACf,WAAW,8BAAS;AACpB,iBAAiB,0CAAe;AAChC,CAAC,EAAC;;;AC9aF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACM;AACO;AACF;AACH;AACC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,sFAAsF,qFAAqF;AAC3K;AACA,MAAM;AACN;AACA;AACA;AACA,kEAAkE,uBAAuB,mBAAmB;AAC5G,+FAA+F,cAAc;AAC7G;AACA;AACA,sFAAsF,qFAAqF;AAC3K,sEAAsE,uBAAuB,mBAAmB;AAChH,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,oBAAoB,aAAa;AACjC,sBAAsB;AACtB,QAAQ;AACR;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA,wBAAwB,aAAa;AACrC,wBAAwB,aAAa;AACrC,0BAA0B;AAC1B,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC,iBAAiB,mBAAmB;AACpC;AACA,aAAa,oCAAoC;AACjD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,qBAAqB,oBAAoB;AACzC,qBAAqB,mBAAmB;AACxC;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;;AAEA;AACA,WAAW,uDAAmB;AAC9B;;AAEA;AACA,WAAW,uDAAmB;AAC9B;AACA;;AAEA;AACA,WAAW,uDAAmB;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,2CAAa;AACtB;AACA;AACA;;AAEA;AACA,WAAW,uDAAmB;AAC9B,mCAAmC;AACnC;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;;AAE5C;AACA,WAAW,uDAAmB;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,2CAAa;;AAEjC;AACA;AACA;AACA;;AAEA,mBAAmB,2CAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA,8BAA8B,2BAAO;AACrC;AACA,UAAU;AACV,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,4BAA4B,2CAAa;AACzC,6BAA6B,2CAAa;AAC1C,6BAA6B,2CAAa;AAC1C,6BAA6B,2CAAa;;AAE1C,mCAAmC,2CAAa;AAChD;AACA,4BAA4B,2CAAa;AACzC;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;;AAEA,yBAAyB,yCAAY;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,uDAAmB;AAClC,aAAa,uCAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,2BAAO,oBAAoB,2BAAO;AAC9D;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,sDAAoB;;AAE1E,gCAAgC,2BAAO;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,iCAAiC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY,2CAAa,0BAA0B,2CAAa;AAChE;AACA,oBAAoB,0BAAM,CAAC,0DAAsB;AACjD;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,WAAW,4CAAgB;;AAE9C,2CAAe;AACf,kBAAkB,4CAAgB;AAClC,CAAC,EAAC;;;ACtjBF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACQ;AACa;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,YAAY;AACzE,+FAA+F,cAAc;AAC7G;AACA;AACA,sFAAsF,qFAAqF;AAC3K;AACA;AACA;AACA,iEAAiE,aAAa;AAC9E,MAAM;AACN;AACA;AACA,sDAAqB;AACrB;;AAEA;AACA;;AAEA;AACA,WAAW,uDAAmB;AAC9B;;AAEA;AACA,WAAW,uDAAmB;AAC9B;;AAEA,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;;AAEjD;AACA,WAAW,uDAAmB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,uBAAuB,yCAAY;AACnC,SAAS;AACT;;AAEA;AACA,eAAe,uDAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ,uEAAqC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,oCAAY;AAC/B;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,gBAAgB,sDAAqB;;AAExD,4CAAe;AACf,uBAAuB,sDAAqB;AAC5C,CAAC,EAAC;;;AC5LF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;AACQ;;AAEjC,wCAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA,gCAAU;AACV,IAAI,4DAAwB;AAC5B;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;;AAEA,4BAA4B,kBAAkB;AAC9C;;AAEA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B;AACA;AACA;;AAEA,4BAA4B,gBAAgB;AAC5C;AACA;;AAEA,gCAAgC,gBAAgB;AAChD;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+CAAe,wCAAc,EAAC;;;AC5O9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACe;AACI;AACZ;AACF;AACU;AACM;AACX;AACF;AACF;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,wBAAwB,WAAW,aAAa;AACxD;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,8BAAS;AACT;;AAEA;;AAEA,SAAS,yCAAY;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,2CAAa;AACrB;AACA;;AAEA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA,MAAM,iCAAiC,yCAAY;AACnD;AACA;;AAEA;AACA;;AAEA,cAAc,2CAAa;AAC3B,oBAAoB,SAAS;AAC7B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA,QAAQ,yCAAY;AACpB;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,OAAO,2BAAe;;AAEzC,gCAAU;AACV,IAAI,kDAAmB;AACvB;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B,qBAAqB,cAAc;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iEAA6B;AAC9C;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uDAAmB;;AAEtC;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,uDAAmB;;AAEzC,wBAAwB,cAAc;AACtC,oBAAoB,+CAAe;AACnC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,oBAAoB,+CAAe;AACnC;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,uCAAW,iBAAiB,uCAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,uCAAW,iBAAiB,uCAAW;AAC/D;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA,oBAAoB,yCAAY;AAChC;AACA;AACA;;AAEA;AACA,oBAAoB,uCAAW,iBAAiB,uCAAW;AAC3D;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B,qBAAqB,SAAS,aAAa,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C,4CAA4C,2CAAa;AACzD;;AAEA;AACA,wCAAwC,cAAc;AACtD,4CAA4C,2CAAa;AACzD;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,wBAAwB,uCAAW;AACnC;AACA,gCAAgC,2CAAa;AAC7C;AACA;;AAEA,6CAA6C,0BAAM;AACnD,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,yCAAY;AAC7B;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;;AAEA,iBAAiB,+CAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B,qBAAqB,QAAQ,YAAY,2CAA2C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,+BAA+B,0BAAM;AACrC,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,gEAAgE,gBAAgB;AAChF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uCAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC,4BAA4B,iBAAiB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,uCAAW;AAC3B,4BAA4B,iBAAiB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,uCAAW;AAC3B,4BAA4B,iBAAiB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAAS;AAC7B;;AAEA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,gBAAgB;AAChB;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,gCAAgC;AAChC,oBAAoB;AACpB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,+CAA+C,wCAAwC;AACvF;AACA,8DAA8D,iDAAiD;AAC/G,yBAAyB,mCAAmC;AAC5D,mCAAmC,oCAAoC;AACvE,mCAAmC,iCAAiC;AACpE,mCAAmC,iCAAiC;AACpE,mCAAmC,sCAAsC;AACzE,mCAAmC,mCAAmC;AACtE,mCAAmC,mCAAmC;AACtE,mCAAmC,uCAAuC;AAC1E,mCAAmC,mCAAmC;AACtE,mCAAmC,iCAAiC;AACpE,mCAAmC;AACnC;AACA;AACA,gDAAgD;AAChD;AACA,2FAA2F;AAC3F;AACA;AACA,kDAAkD,wBAAwB;AAC1E;AACA,kBAAkB,KAAK;AACvB,yCAAyC,2EAA2E;AACpH;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,sFAAsF;AACtG,4EAA4E,iDAAiD;AAC7H,uCAAuC,mCAAmC;AAC1E,uCAAuC,oCAAoC;AAC3E,uCAAuC,iCAAiC;AACxE,uCAAuC,iCAAiC;AACxE,uCAAuC,sCAAsC;AAC7E,uCAAuC,mCAAmC;AAC1E,uCAAuC,mCAAmC;AAC1E,uCAAuC,uCAAuC;AAC9E,uCAAuC,mCAAmC;AAC1E,uCAAuC,iCAAiC;AACxE,uCAAuC;AACvC;AACA;AACA,oDAAoD;AACpD;AACA,+FAA+F;AAC/F;AACA;AACA,gEAAgE,wBAAwB;AACxF;AACA,gCAAgC,KAAK;AACrC,kDAAkD,2EAA2E;AAC7H;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,qFAAqF;AACrG,sEAAsE,WAAW;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,yDAAyD,6CAA6C;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,0FAA0F;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAa;;AAE7B,gCAAgC,2CAAa;AAC7C,YAAY,uCAAW;AACvB;AACA,mBAAmB,uDAAmB;;AAEtC,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6BAA6B,yCAAY;AACzC,4BAA4B,SAAS;AACrC,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;;AAEA,gCAAgC,wBAAwB;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,uCAAuC,0CAAa;AACpD;;AAEA;AACA;AACA,kBAAkB;AAClB,qCAAqC,0CAAa;AAClD;;AAEA;AACA;AACA,kBAAkB;AAClB,gDAAgD,0CAAa;AAC7D;;AAEA;AACA;AACA,kBAAkB;AAClB,8CAA8C,0CAAa;AAC3D;;AAEA;AACA,oCAAoC,8BAAS;AAC7C,kBAAkB;AAClB,oCAAoC,8BAAS;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,eAAe,8BAAS;AACxB;;AAEA,kDAAmB,UAAU,0CAAe;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wBAAwB,WAAW,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA,gCAAU;AACV;;AAEA;AACA;;AAEA,WAAW,uDAAmB;;AAE9B;AACA,sBAAsB,0BAAM,CAAC,sDAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,oDAAoB,OAAO,2BAAe;;AAE1C;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,QAAQ;AACpB;AACA,0FAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAAM;AAC7B,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA;;AAEA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,2CAAa;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,iDAAiD,0CAA0C;AAC3F;AACA;AACA;AACA;AACA,uCAAuC,6DAA6D;AACpG,oCAAoC,+CAA+C;AACnF;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,0FAA0F;AAC1G;AACA;AACA;AACA;AACA,2CAA2C,6DAA6D;AACxG,wCAAwC,+CAA+C;AACvF;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,4CAAgB;AAChB;AACA;;AAEA,QAAQ,uCAAW;AACnB;AACA,MAAM;AACN;AACA;;AAEA,eAAe,gCAAU;AACzB;;AAEA,kDAAmB,WAAW,4CAAgB;;AAE9C,0CAAe;AACf,WAAW,8BAAS;AACpB,YAAY,gCAAU;AACtB,iBAAiB,0CAAe;AAChC,kBAAkB,4CAAgB;AAClC,CAAC,EAAC;;;AC59CF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACO;AACQ;AACP;;AAEjC;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,gDAAgD,oCAAoC;AACpF,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,MAAM;AACN,uBAAuB;AACvB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,6FAA6F;AAC7G,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,kBAAkB;AAClB,uCAAuC;AACvC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,gCAAU;AACV;;AAEA,wCAAwC,8DAAwB,EAAE,8DAAwB;;AAE1F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAmB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gBAAgB,yCAAY;AAC5B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,2CAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA,oDAAoB,OAAO,2BAAe;;AAE1C,gCAAU;AACV,IAAI,oDAAoB;AACxB;AACA;AACA,mEAAmE,6BAA6B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+DAA+D,mBAAmB;;AAElF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA,wBAAwB,yBAAyB;AACjD;AACA,gCAAgC,4DAAuB;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA,cAAc;AACd;AACA;;AAEA;AACA,gDAAgD,sDAAoB;AACpE,iDAAiD,sDAAoB;AACrE;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,2DAA2D,iBAAiB;AAC5E;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,4DAA4D,kBAAkB;AAC9E;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,mBAAmB,2CAAa;AAChC,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,sEAAsE,2BAA2B;AACjG;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,oDAAoD,uCAAuC;AAC3F;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA,gCAAgC,4DAAuB;AACvD;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,2CAAa;AACxC;AACA,+BAA+B,2CAAa;AAC5C;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,cAAc,gFAAgF;AACjH;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS,2CAAa;AACpC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA;;AAEA;AACA,mEAAmE,mBAAmB;AACtF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB;AACtB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,SAAS;AACxC;;AAEA,wCAAwC,8DAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA,iBAAiB,uCAAW;AAC5B;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA,iBAAiB,uCAAW;AAC5B;AACA;AACA;AACA,SAAS;;AAET;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA,wCAAwC,8DAAwB;AAChE;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA;AACA,wBAAwB,yBAAyB;AACjD;;AAEA,gCAAgC,4DAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,QAAQ,kGAAkG;AACrH,aAAa,YAAY;AACzB;AACA,4CAAgB;AAChB;AACA;;AAEA,WAAW,uDAAmB;AAC9B,eAAe,gCAAU;AACzB;;AAEA,kDAAmB,WAAW,4CAAgB;;AAE9C,2CAAe;AACf,YAAY,gCAAU;AACtB,kBAAkB,4CAAgB;AAClC,CAAC,EAAC;;;ACv6BF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEyB;AACM;AACS;AACA;AACR;AACQ;AACV;AACG;AACP;;AAE1B;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,8BAAS;AACT,6CAA6C,4DAAuB,EAAE,8DAAwB;;AAE9F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAQ,+CAAe;AACvB;AACA;AACA;;AAEA,QAAQ,yCAAY;AACpB;AACA,MAAM;AACN,8BAA8B,2BAAO;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kDAAmB,OAAO,2BAAe;;AAEzC,gCAAU;AACV,IAAI,kDAAmB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA,oBAAoB,2CAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2CAAa,CAAC,2CAAa;AAC3C;AACA,oBAAoB,2CAAa;AACjC,cAAc;AACd;AACA;AACA;AACA,iBAAiB,2CAAa;AAC9B;AACA,iBAAiB,2CAAa;AAC9B,2CAA2C,8DAAwB;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,0DAAsB;AACzD;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAAO;AAC3C;AACA;AACA,oCAAoC,2BAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ,+DAA+D,0BAA0B,KAAK,2BAA2B;AACpJ,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA,wBAAwB,0BAAM;AAC9B,2BAA2B,0BAAM;AACjC;;AAEA;AACA,mCAAmC,0DAAsB;AACzD,iBAAiB,2CAAa;AAC9B;AACA;AACA;;AAEA;AACA,iDAAiD,2BAAO;AACxD,+DAA+D,2BAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,iDAAiD,2BAAO;AACxD,+DAA+D,2BAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,4DAAuB;AAClE;AACA;;AAEA;AACA,wCAAwC,2BAAO,wBAAwB,2BAAO;AAC9E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,4DAAuB;AAClE;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAAa;AACvC,0BAA0B,2CAAa;;AAEvC;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,iCAAU,YAAY,2BAAO;AACxD;AACA;AACA;AACA;AACA,kBAAkB,SAAS,iCAAU,YAAY,2BAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kCAAkC,2BAAU;AAC5C,iCAAiC,2BAAU;AAC3C;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,2CAAa;AACzC,4BAA4B,2CAAa;AACzC,SAAS;;AAET;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA,kDAAkD;AAClD;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC,2CAA2C,4DAAuB;AAClE,uCAAuC,0DAAsB;AAC7D,2BAA2B,6DAA2B;AACtD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,0BAAM;AACrC,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC,+BAA+B,0BAAM;AACrC,wBAAwB,sDAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc,SAAS,2CAAa;AACpC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,eAAe,mCAAmC;AAClD;AACA,oBAAoB,YAAY;AAChC,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;AACrC,uBAAuB,2CAAa;;AAEpC;AACA,2CAA2C,8DAAwB;AACnE;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,0BAAM;AAC/B,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA,yBAAyB,0BAAM;AAC/B,gBAAgB,sDAAoB;AACpC;AACA;AACA;AACA;AACA;AACA,iDAAiD,2BAAO;AACxD;AACA;AACA;AACA;AACA;AACA,iDAAiD,2BAAO;AACxD;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,gBAAgB,iDAAqB;AACrC;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;AACA,cAAc;AACd;AACA;AACA,gBAAgB,yEAAiC;AACjD;;AAEA;AACA,iBAAiB,2CAAa;AAC9B,iBAAiB,2CAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAAa;AACjC;;AAEA;AACA,0CAA0C,0DAAsB;AAChE;AACA;AACA;AACA;AACA;AACA,0CAA0C,0DAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAAO;AACzC;AACA;AACA;AACA,kCAAkC,2BAAO;AACzC;AACA,cAAc;AACd;AACA;AACA;AACA,kCAAkC,2BAAO;AACzC;AACA;AACA;AACA,kCAAkC,2BAAO;AACzC;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,sDAAoB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAgB;AAChC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,gEAAgE,6BAA6B,KAAK;AAClG;AACA,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,uBAAuB,2BAAO;AAC9B;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;;AAErC,2CAA2C,4DAAuB;AAClE;AACA;AACA;;AAEA;AACA,0BAA0B,2CAAa;AACvC,iDAAiD,2BAAO;AACxD;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA,6BAA6B,2BAAO;AACpC;AACA;;AAEA;AACA;AACA,iBAAiB,2CAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,qCAAqC,0CAA0C;AAC/E,oDAAoD,kCAAkC;AACtF;AACA,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAAa;;AAExC,2CAA2C,8DAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAsB;AACtC,oBAAoB,0BAAM,CAAC,sDAAoB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,0DAAsB;AAC1C,wBAAwB,0BAAM,CAAC,sDAAoB;AACnD;AACA;AACA;AACA,SAAS;;AAET;AACA,qCAAqC,0CAA0C;AAC/E;AACA;AACA,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAa;AAC7C;;AAEA;AACA,2CAA2C,4DAAuB;AAClE;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,6BAA6B,0BAAM,CAAC,sDAAoB;AACxD,2CAA2C,8DAAwB;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAa;AAClC;;AAEA;AACA;AACA,gCAAgC,2CAAa;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2CAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,0DAA0D,4BAA4B,KAAK,uBAAuB;AAClH;AACA,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAAO;AAC9B;AACA,oCAAoC,yCAAY;AAChD;AACA,wBAAwB,2CAAa;;AAErC;AACA,2CAA2C,4DAAuB;AAClE;AACA;AACA,wBAAwB,4BAA4B;AACpD,+CAA+C,4DAAuB;AACtE;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,iCAAiC,0BAAM,CAAC,sDAAoB;;AAE5D,+CAA+C,8DAAwB;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,uCAAW;AAClE;AACA,8BAA8B,2CAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,0DAAsB;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yEAAyE,2BAAO;AAChF;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,SAAS;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA,sBAAsB,2CAAa;AACnC,sBAAsB,2CAAa;AACnC,cAAc;AACd;AACA;AACA;AACA,sBAAsB,2CAAa;AACnC,sBAAsB,2CAAa;AACnC;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,2CAAa;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC;AACA;AACA,mCAAmC,mDAAsB;;AAEzD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAgB;AAC5C;AACA;AACA;AACA,4BAA4B,6CAAgB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC,gDAAgD;AAChD;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C,gDAAgD;AAChD;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,wBAAwB,2CAAa;AACrC;AACA,sBAAsB,SAAS,2CAAa;AAC5C;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C;AAC7C,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAa;;AAEpC;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA,uCAAuC,2CAAa;AACpD;AACA;AACA,6BAA6B,2CAAa;AAC1C,wBAAwB,2CAAa;AACrC;AACA,iCAAiC,2CAAa;AAC9C;;AAEA;AACA;AACA;;AAEA,oBAAoB,2CAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,oBAAoB,eAAe;AACnC,oBAAoB,eAAe;AACnC,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,uCAAW;AAC5B;AACA;AACA,yCAAyC,2BAAO;AAChD;AACA;AACA;AACA,mCAAmC,2CAAa;AAChD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC,oBAAoB,YAAY;AAChC,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,2CAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,2CAAa;AAC9B,iBAAiB,2CAAa;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAAa;AACxC;;AAEA,4BAA4B,8CAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,2CAAa;AACvC;AACA;AACA;;AAEA;;AAEA,kCAAkC,2CAAa;AAC/C,kCAAkC,2CAAa;AAC/C;;AAEA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA,YAAY,wCAAc;;AAE1B;AACA;AACA,wBAAwB,wBAAwB;AAChD,oBAAoB,uCAAW;AAC/B;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA,YAAY,wCAAc;;AAE1B;AACA;;AAEA,wBAAwB,wBAAwB;AAChD,oBAAoB,uCAAW;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB,KAAK,wBAAwB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,oBAAoB;AAC/B,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,yEAAyE;AAC7J;AACA;AACA;AACA,6CAA6C,iBAAiB;AAC9D,IAAI;AACJ;AACA;AACA,0CAAe;AACf;AACA;AACA,eAAe,uDAAmB;;AAElC;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,oCAAoC,4DAAuB;AAC3D,oCAAoC,8DAAwB;AAC5D;AACA,iBAAiB,8BAAS;AAC1B,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,QAAQ,+CAAe;AACvB;AACA;AACA,QAAQ,+CAAe;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B,eAAe,oBAAoB;AACnC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA,wFAAwF,yEAAyE;AACjK;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA;AACA;AACA,mDAAmD,+BAA+B;AAClF;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6BAA6B;AAC7E,gDAAgD,0CAA0C;AAC1F,gDAAgD,0CAA0C;AAC1F;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA;AACA,oDAAoD,6BAA6B;AACjF,oDAAoD,0CAA0C;AAC9F,oDAAoD,0CAA0C;AAC9F;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,IAAI,kDAAmB;AACvB;AACA;AACA,mBAAmB,uDAAmB;;AAEtC;AACA,qCAAqC,4DAAuB;AAC5D,wCAAwC,8DAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,UAAU,0CAAe;AAC5C,kDAAmB,SAAS,kDAAmB;AAC/C,kDAAmB,UAAU,kDAAmB;;AAEhD,0CAAe;AACf,WAAW,8BAAS;AACpB,iBAAiB,0CAAe;AAChC,oBAAoB,kDAAmB;AACvC,qBAAqB,kDAAmB;AACxC,CAAC,EAAC;;;ACjsDF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEyB;AACQ;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,2BAA2B,iDAAiD,6BAA6B;AACxH;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA,wBAAM;AACN;AACA;AACA;AACA;;AAEA,gCAAU;AACV,IAAI,4CAAgB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;AACjD,oCAAoC,2CAAa;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAa;AAC7C,gCAAgC,2CAAa;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAa;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAa;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC,wBAAwB,2CAAa;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAa;AACzC,4BAA4B,2CAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;AACjD,oCAAoC,2CAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2CAAa;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAa;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAa;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2CAAa;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAAa;AACrD,wCAAwC,2CAAa;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAAa;AACzD,4CAA4C,2CAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAa;AAC7C,gCAAgC,2CAAa;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;AACjD,oCAAoC,2CAAa;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2CAAa;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2CAAa;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2CAAa;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAAa;AACrD,wCAAwC,2CAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAAa;AACrD,wCAAwC,2CAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAa;AAC7C,gCAAgC,2CAAa;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAAa;AACrD;AACA;AACA;AACA;AACA,wCAAwC,2CAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;AACjD,oCAAoC,2CAAa;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAa;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAAa;AACzD,4CAA4C,2CAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2CAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,kBAAkB,SAAS,yCAAY;AACvC,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC,0EAA0E;AAC1E;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,gBAAgB,yCAAY;AAC5B;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAe,wBAAM,EAAC;;;AC1mDtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACC;;AAE1B;AACA;AACA;AACA;AACA,4BAAQ;AACR;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;;AAEA,aAAa,yCAAY;AACzB;AACA;;AAEA,aAAa,yCAAY;AACzB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA,aAAa,yCAAY;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,0CAA0C,mBAAmB;AAC7D,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,2BAA2B,yBAAyB;AACpD,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB,2CAAa;AAChC;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;;AAEA,cAAc,2CAAa,MAAM,oDAAoB;AACrD,kCAAkC,OAAO;AACzC,kBAAkB,2CAAa;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,qBAAqB;AACpC,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA,qDAAqD,kCAAW;;AAEhE;AACA;AACA;AACA;AACA,oBAAoB,kCAAW;AAC/B,oBAAoB,kCAAW;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;AACA,0EAA0E,yBAAyB;AACnG,QAAQ,6BAA6B;AACrC,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,4BAA4B;AACxD;AACA,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA;AACA,sBAAsB,SAAS,yCAAY;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,QAAQ,kBAAkB,IAAI,uBAAuB;AACrD,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,yCAAY;AACpC,oCAAoC,gBAAgB;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;;AAEA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;;AAEA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA,iEAAiE,uCAAW;AAC5E,uBAAuB;AACvB;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,oBAAoB,uCAAW;AAC/B,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAe,4BAAQ,EAAC;;;ACtcxB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACQ;AACC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,WAAW,mDAAmD;AAC9D,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAA+C;AAC3F;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA,gDAAgD,+CAA+C;AAC/F;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,4BAA4B,wCAAwC;AACpE,8BAA8B,mBAAmB;AACjD,0BAA0B,iCAAiC;AAC3D;AACA;AACA;AACA,IAAI;AACJ;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD,gCAAgC,wCAAwC;AACxE,kCAAkC,mBAAmB;AACrD,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,wCAAc;AACd;AACA;;AAEA;AACA;AACA,YAAY,yCAAY;AACxB,mBAAmB,uDAAmB;AACtC;AACA,UAAU,SAAS,2CAAa,gBAAgB,yCAAY;AAC5D;AACA,UAAU,SAAS,+CAAe,gBAAgB,yCAAY;AAC9D;AACA,UAAU;AACV,YAAY,+CAAe;AAC3B;AACA;AACA;AACA,mBAAmB,uDAAmB;AACtC,iBAAiB,iBAAiB;AAClC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,yCAAY;AACxB,mBAAmB,uDAAmB;AACtC;AACA,UAAU,SAAS,2CAAa,gBAAgB,yCAAY;AAC5D;AACA,UAAU,SAAS,+CAAe,gBAAgB,yCAAY;AAC9D;AACA,UAAU;AACV,YAAY,+CAAe;AAC3B;AACA;AACA;AACA,mBAAmB,uDAAmB;AACtC,iBAAiB,iBAAiB;AAClC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,uDAAmB;AAC9B,IAAI,qCAAU,OAAO,uDAAmB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,2CAAa;AAC1B,iBAAiB,2CAAa;AAC9B,gBAAgB,2CAAa;AAC7B,YAAY,2CAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,SAAS,wCAAc;;AAE1C,yCAAe;AACf,gBAAgB,wCAAc;AAC9B,CAAC,EAAC;;;ACrQF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACQ;AACK;AACA;;AAEtC;AACA;AACA,QAAQ,qCAAqC;;AAE7C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,WAAW,UAAU;AACrB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA,oFAAoF,qFAAqF;AACzK;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0DAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,gEAAyB;AAC7E;AACA;AACA,MAAM,qDAAqD,8DAAwB;AACnF;AACA,eAAe,uDAAmB;AAClC;AACA;AACA,MAAM;AACN;AACA,oCAAoC,4DAAuB;AAC3D,QAAQ,yCAAY;AACpB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;;AAEA,WAAW,uDAAmB;AAC9B;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,mBAAmB,uDAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA,qCAAqC,kBAAkB;AACvD,qCAAqC,kBAAkB;AACvD;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,yCAAY,aAAa,2CAAa;AACrD,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,oCAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA,kDAAmB,kBAAkB,0DAAuB;;AAE5D,kDAAe;AACf,yBAAyB,0DAAuB;AAChD,CAAC,EAAC;;;ACpQF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACM;AACE;;AAEjC,IAAI,aAAI;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,+FAA+F,cAAc;AAC7G;AACA;AACA,uFAAuF,qFAAqF;AAC5K,sEAAsE;AACtE;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI;AACJ,+FAA+F,cAAc;AAC7G;AACA;AACA,kFAAkF,qFAAqF;AACvK;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,uEAAuE,oCAAoC;AAC3G,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB,wBAAwB;AACxC;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,2EAA2E,oCAAoC;AAC/G,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB,wBAAwB;AAC5C;AACA,QAAQ;AACR;AACA;AACA;AACA,gDAAkB;AAClB;AACA;AACA,eAAe,uDAAmB;;AAElC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mEAAyB;;AAEtC;AACA;;AAEA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,wEAA8B;AAC1C;AACA;AACA;AACA;;AAEA,IAAI,oCAAY,+BAA+B,aAAI;;AAEnD;AACA;;AAEA,kDAAmB,aAAa,gDAAkB;;AAElD,qDAAe;AACf,oBAAoB,gDAAkB;AACtC,CAAC,EAAC;;;AC9OF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACM;AACE;;AAEjC,IAAI,UAAI;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wDAAwD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,yBAAyB;AAC7F;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kCAAkC,gBAAgB,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA,uFAAuF,qFAAqF;AAC5K,wEAAwE,yBAAyB;AACjG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,qFAAqF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,0CAAe;AACf;AACA;AACA,eAAe,uDAAmB;;AAElC;AACA;AACA;AACA,sCAAsC,oBAAoB,YAAY;AACtE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,6DAAsB;;AAEnC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,wEAA8B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,qBAAqB;AACtC;AACA;AACA,2EAA2E,oCAAoC;AAC/G,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB,wBAAwB;AAC5C;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG,+EAA+E,oCAAoC;AACnH,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB,wBAAwB;AAChD;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,oCAAY,2BAA2B,UAAI;AAC/C,IAAI,oCAAY;AAChB;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI,oCAAY;AAChB;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI,oCAAY;AAChB;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,UAAU,0CAAe;;AAE5C,0CAAe;AACf,iBAAiB,0CAAe;AAChC,CAAC,EAAC;;;ACpUF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACM;AACE;;AAEjC,IAAI,WAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAA0D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA,KAAK,KAAK;AACV;AACA;AACA;AACA,uCAAuC;AACvC,SAAS;AACT;AACA,+FAA+F,cAAc;AAC7G;AACA,sFAAsF,qFAAqF;AAC3K,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA,KAAK,KAAK;AACV;AACA;AACA;AACA,uCAAuC;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,uEAAuE,oCAAoC;AAC3G,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB,wBAAwB;AACxC;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,2EAA2E,oCAAoC;AAC/G,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB,wBAAwB;AAC5C;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4CAAgB;AAChB;AACA;AACA,eAAe,uDAAmB;;AAElC;AACA;AACA;AACA;AACA;;AAEA;AACA,4EAA4E;AAC5E;AACA,aAAa,+DAAuB;;AAEpC;AACA;AACA;;AAEA,sCAAsC;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,2CAAa;AACzB,wBAAwB,wCAAc;AACtC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,IAAI,oCAAY,4BAA4B,WAAI;AAChD,IAAI,oCAAY;AAChB;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI,oCAAY;AAChB;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI,oCAAY;AAChB;AACA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA,kDAAmB,WAAW,4CAAgB;;AAE9C,mDAAe;AACf,kBAAkB,4CAAgB;AAClC,CAAC,EAAC;;;ACjRF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACO;AACF;AACU;AACT;AACE;AACW;;AAE5C;AACA;AACA;AACA,0GAA0G,wBAAwB;AAClI,SAAS,qBAAqB;AAC9B;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B,YAAY,OAAO;AACnB;AACA;AACA,8CAAiB;AACjB;AACA;AACA;AACA,QAAQ,4EAA+B;AACvC,QAAQ,8DAAwB;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAW;AACnB;;AAEA,iBAAiB,uDAAmB;AACpC,iBAAiB,uDAAmB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qBAAqB,oCAAY;AACjC;AACA;AACA,KAAK;AACL;;AAEA,kEAA2B,OAAO,2BAAe;AACjD,mEAAyB,CAAC,8CAAiB,EAAE,4BAAa;;AAE1D,gCAAU;AACV,IAAI,kEAA2B;AAC/B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2CAAa,CAAC,2CAAa;AAC3C;AACA,uBAAuB,2CAAa;AACpC,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,0BAAM,CAAC,0DAAsB;AACjD;AACA;AACA;AACA,kBAAkB,6CAAgB,EAAE;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,SAAS;AACrC,gCAAgC,OAAO;AACvC,+BAA+B,yCAAc;AAC7C;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA,gBAAgB,yCAAY;AAC5B,4BAA4B,sBAAsB;AAClD;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA,oBAAoB,0BAA0B;AAC9C;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA,qBAAqB,uDAAmB;AACxC,qBAAqB,uDAAmB;AACxC;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA,yBAAyB;;AAEzB;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,sBAAsB,UAAU,OAAO,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ,2DAA2D,UAAU,OAAO;AAC/F,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA,YAAY,6HAA6H;AACzI;AACA,QAAQ;AACR;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,8CAA8C,SAAS;AACvD;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA,YAAY,kCAAkC,eAAe,cAAc,aAAa,aAAa,KAAK,SAAS,QAAQ;AAC3H;AACA,QAAQ;AACR;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG,8CAA8C,SAAS;AACvD;AACA,+CAA+C,eAAe,cAAc,aAAa,aAAa;AACtG;AACA,YAAY;AACZ;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iDAAiD;AACnG,kDAAkD,kDAAkD;AACpG,kDAAkD,iDAAiD;AACnG;AACA;AACA,YAAY,8HAA8H;AAC1I;AACA,QAAQ;AACR;AACA;AACA;AACA,4DAA4D,mCAAmC;AAC/F;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,kFAAkF;AAClG;AACA;AACA,sDAAsD,iDAAiD;AACvG,sDAAsD,kDAAkD;AACxG,sDAAsD,iDAAiD;AACvG;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gEAAgE,mCAAmC;AACnG;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,SAAS,0CAAoB,CAAC,8CAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAmB,kBAAkB,0DAAuB;AAC5D,kDAAmB,OAAO,0DAAuB;;AAEjD,kDAAe;AACf,mBAAmB,8CAAiB;AACpC,yBAAyB,0DAAuB;AAChD,CAAC,EAAC;;;ACneF;;AAEwB;AACQ;;AAEhC,gCAAU,CAAC,sBAAO;AAClB;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB,aAAa;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB,aAAa;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB,aAAa;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mCAAmC,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA,sBAAsB,mCAAmC,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA,sBAAsB,mCAAmC,YAAY;;AAErE;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA,uBAAuB,oCAAoC,YAAY;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C,kBAAkB,mCAAmC;AACrD,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C,kBAAkB,0BAA0B;AAC5C,kBAAkB;AAClB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;AAED,8CAAe,kCAAW,EAAC;;;AClU3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACa;AACL;AACF;AACe;AACA;;AAE9C;AACA;AACA;AACA,uFAAuF,wBAAwB;AAC/G,SAAS,cAAc;AACvB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,gCAAU;AACV,wCAAwC,8DAAwB,EAAE,wDAAqB;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAqB,2CAAa;AAClC;AACA,KAAK;AACL;AACA,oDAAoB,OAAO,2BAAe;;AAE1C,gCAAU;AACV,IAAI,oDAAoB;AACxB;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA,mBAAmB,SAAS;AAC5B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB,eAAe;AAC3C;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,2CAAa;AAC7B;AACA,oBAAoB,uCAAW;AAC/B;AACA;AACA,kBAAkB,SAAS,uCAAW;AACtC;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,cAAc;AACd;AACA,iBAAiB,+CAAe,QAAQ,2CAAa,QAAQ,+CAAe;AAC5E;AACA,wBAAwB,uDAAmB;;AAE3C;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,wBAAwB,WAAW;;AAEnC;AACA,cAAc;AACd,gBAAgB,2CAAa;AAC7B,gBAAgB,uCAAW;AAC3B,iBAAiB,uCAAW;AAC5B;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,uCAAW;AAC5B,iBAAiB,uCAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gFAAgF;AAChF,gFAAgF;AAChF,4EAA4E;AAC5E,4EAA4E;AAC5E,4BAA4B,yCAAc;;AAE1C;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,oBAAoB,UAAU;AAC9B,oBAAoB,UAAU;AAC9B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,mBAAmB,yCAAc;AACjC,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,6BAAQ;AACzB,gBAAgB,6CAAgB;;AAEhC,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2BAAO;AACnD;AACA,sBAAsB,iDAAkB;AACxC,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,2CAA2C,2BAAO;AAClD,2CAA2C,2BAAO;AAClD,2CAA2C,2BAAO;AAClD,2CAA2C,2BAAO;AAClD,2CAA2C,2BAAO;AAClD,2CAA2C,2BAAO;AAClD;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,aAAa;AAChC,mBAAmB,aAAa;AAChC,mBAAmB,aAAa;AAChC,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,6DAAwB;AACxC;AACA;AACA;AACA;AACA,gBAAgB,6CAAgB;AAChC;AACA;AACA,kBAAkB,mEAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAAQ;AACxB;AACA;AACA;AACA;AACA,gBAAgB,6BAAQ;AACxB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2CAAa,kBAAkB,2CAAa;AACnE,uBAAuB,2CAAa,kBAAkB,2CAAa;;AAEnE,0BAA0B,gBAAgB;AAC1C;AACA,8BAA8B,gBAAgB;AAC9C;AACA,wBAAwB,+CAAe;AACvC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,gBAAgB;AAC1C;AACA,8BAA8B,gBAAgB;AAC9C;AACA,wBAAwB,+CAAe;AACvC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oCAAoC;AACzD;AACA;AACA,0BAA0B,+BAA+B,gBAAgB;AACzE,2BAA2B,iCAAiC;AAC5D;AACA;AACA,8BAA8B,mBAAmB;AACjD,8BAA8B,mBAAmB;AACjD;AACA,+BAA+B,oBAAoB;AACnD,+BAA+B,oBAAoB;AACnD;AACA,+BAA+B,eAAe;AAC9C,+BAA+B;AAC/B,SAAS;AACT;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,qFAAqF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA,iCAAiC,+BAA+B,gBAAgB;AAChF,kCAAkC,iCAAiC;AACnE;AACA,qCAAqC,mBAAmB;AACxD,qCAAqC,mBAAmB;AACxD,sCAAsC,oBAAoB;AAC1D,sCAAsC,oBAAoB;AAC1D,sCAAsC,eAAe;AACrD,sCAAsC;AACtC,gBAAgB;AAChB,QAAQ;AACR;AACA;AACA;AACA;AACA,4CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B,WAAW,uDAAmB;AAC9B,eAAe,gCAAU;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA,wBAAwB,+CAAe;AACvC;AACA,wBAAwB,+CAAe;AACvC;AACA,wBAAwB,+CAAe;AACvC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,wBAAwB,yCAAY;AACpC;AACA,wBAAwB,yCAAY;AACpC;AACA,wBAAwB,yCAAY;AACpC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kDAAmB,WAAW,4CAAgB;;AAE9C,2CAAe,gCAAU,EAAC;;;ACzwB1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;;AAEzB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,sDAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAAe,sDAAqB,EAAC;;;AChFrC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACyB;AACQ;AACjC;AACA;;AAEA,4CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,uCAAW;AACnB,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,MAAM;AACN,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,WAAW,uDAAmB;AAC9B;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uDAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA,oBAAoB,kBAAkB;AACtC,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,uDAAmB;AAC1C;AACA;AACA,mEAAmE;AACnE;AACA;AACA;;AAEA;AACA;AACA,kDAAmB,WAAW,4CAAgB;;AAE9C,4CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;;AAEA;AACA;AACA,kDAAmB,WAAW,4CAAgB;;AAE9C,4CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY,+CAAe;AAC3B;AACA,UAAU;AACV,wBAAwB,OAAO;AAC/B,uBAAuB,2CAAa;AACpC;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC;AACA,aAAa,sCAAa;AAC1B,aAAa,sCAAa;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAmB,WAAW,4CAAgB;;;AC/S9C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACa;AACP;AACS;AACP;AACjC;;AAEA;AACA;AACA,gGAAgG,yBAAyB;AACzH,SAAS,eAAe;AACxB;AACA;AACA,WAAW,YAAY;AACvB,WAAW,gBAAgB;AAC3B,YAAY,uBAAuB;AACnC,WAAW,QAAQ,2DAA2D,2BAA2B;AACzG,IAAI,2BAA2B;AAC/B;AACA;AACA,kCAAW;AACX,6CAA6C,gEAAyB,EAAE,wDAAqB;AAC7F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0GAA0G,mBAAmB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,2CAAa;AAClC;AACA,KAAK;AACL;AACA,sDAAqB,OAAO,kDAAmB;AAC/C,mEAAyB,CAAC,kCAAW,EAAE,sDAAqB;;AAE5D,gCAAU;AACV,IAAI,sDAAqB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,+CAAe;AAC/B,yCAAyC,2CAAa;AACtD,cAAc;AACd;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,wBAAwB,+CAAe;AACvC,6CAA6C,2CAAa;AAC1D;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA,gBAAgB,+CAAe;AAC/B,yCAAyC,2CAAa;AACtD,cAAc;AACd;AACA,4BAA4B,OAAO;AACnC,yCAAyC,2CAAa;AACtD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,2CAA2C,2BAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAiB;AACjC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,oBAAoB,sDAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,uCAAW;AAC3B;AACA;AACA,gBAAgB,mDAAmB;;AAEnC;AACA;AACA;AACA;AACA,iDAAiD,sDAAoB;AACrE;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA,WAAW,iDAAiD;AAC5D,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,kDAAkD,mBAAmB;AACrE,kDAAkD,mCAAmC,IAAI,gCAAgC;AACzH;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,qFAAqF;AACrG;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uDAAuD,mBAAmB;AAC1E,uDAAuD,mCAAmC,IAAI,mBAAmB;AACjH,QAAQ;AACR;AACA;AACA;AACA;AACA,8CAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,uCAAW;AACzC;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;;AAEA,WAAW,uDAAmB;AAC9B,aAAa,kCAAW;AACxB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD;;AAErD;AACA;;AAEA,kDAAmB,YAAY,8CAAiB;;;AChdhD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACa;AACL;;AAEjC;AACA;AACA,gGAAgG,yBAAyB,WAAW,eAAe;AACnJ;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,kCAAW;AACX,6CAA6C,gEAAyB,EAAE,wDAAqB;AAC7F;;AAEA;AACA;;AAEA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,2CAAa;AAClC;AACA,KAAK;AACL;AACA,sDAAqB,OAAO,kDAAmB;AAC/C,mEAAyB,CAAC,kCAAW,EAAE,sDAAqB;;AAE5D,gCAAU;AACV,IAAI,sDAAqB;AACzB;AACA;AACA,wBAAwB,2CAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,yCAAY;AAC5B;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC,oBAAoB,2CAAa;AACjC;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,2CAA2C;AACtD;AACA;AACA,WAAW,yBAAyB;AACpC;AACA,WAAW,mBAAmB;AAC9B;AACA,8CAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,aAAa,kCAAW;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAmB,YAAY,8CAAiB;;;AC3NhD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACyB;AACa;AACL;AACF;AACS;;AAExC;AACA;AACA;;AAEA;AACA;AACA,8FAA8F,yBAAyB,WAAW,cAAc;AAChJ;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,gCAAU;AACV,6CAA6C,8DAAwB,EAAE,wDAAqB;AAC5F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2CAAa;AAClC;AACA,KAAK;AACL;AACA,oDAAoB,OAAO,kDAAmB;AAC9C,mEAAyB,CAAC,gCAAU,EAAE,sDAAqB;;AAE3D,gCAAU;AACV,IAAI,oDAAoB;AACxB;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,+CAAe;AAC/B;AACA,cAAc;AACd,4BAA4B,OAAO;AACnC,2BAA2B,2CAAa;AACxC;AACA;;AAEA,iBAAiB,2CAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA,WAAW,uDAAuD;AAClE,WAAW,0DAA0D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mDAAmD,mBAAmB;AACtE;AACA,kEAAkE,SAAS,cAAc,WAAW,gBAAgB;AACpH;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,qFAAqF;AACrG;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uDAAuD,mBAAmB;AAC1E;AACA,sEAAsE,sBAAsB,cAAc,WAAW,gBAAgB;AACrI;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4CAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;;AAE9B;AACA,YAAY,yDAAoB;;AAEhC;AACA,QAAQ,6CAAc;AACtB,kCAAkC,yCAAY,gBAAgB,+CAAe;AAC7E;AACA,uCAAuC;;AAEvC;AACA,iBAAiB,yDAAoB;AACrC;AACA;AACA;AACA;AACA,iBAAiB,gCAAU;AAC3B,MAAM;AACN;;AAEA;AACA;AACA,YAAY,+CAAe;AAC3B;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA,iBAAiB,yDAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gCAAU;;AAE3B;AACA;AACA;AACA,qCAAqC,2CAAa;AAClD;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,2CAAa;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAmB,WAAW,4CAAgB;;AAE9C;AACA;AACA;;AAEA;AACA;AACA,gGAAgG,wBAAwB,WAAW,eAAe;AAClJ;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,kCAAW;AACX,6CAA6C,gEAAyB,EAAE,wDAAqB;AAC7F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,iBAAiB;AAC3C,cAAc;AACd;AACA;;AAEA;AACA,0BAA0B,iBAAiB;AAC3C,cAAc;AACd;AACA;;AAEA;AACA,oFAAoF,kBAAkB,KAAK,aAAa;AACxH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oFAAoF,kBAAkB,KAAK,aAAa;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,2CAAa;AAClC;AACA,KAAK;AACL;AACA,sDAAqB,OAAO,kDAAmB;AAC/C,mEAAyB,CAAC,kCAAW,EAAE,sDAAqB;;AAE5D,gCAAU;AACV,IAAI,sDAAqB;AACzB;AACA;AACA;AACA,yBAAyB,YAAY,KAAK,WAAW;AACrD;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,+BAA+B,2CAAa;AAC5C,+BAA+B,2CAAa;AAC5C;;AAEA,0BAA0B,6CAAgB;;AAE1C,kBAAkB,6BAAQ;AAC1B,gCAAgC,2BAAO;AACvC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,qBAAqB,6CAAgB;;AAErC;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,2CAAa;AAC7B,gBAAgB,2CAAa;AAC7B,gBAAgB,2CAAa;AAC7B,gBAAgB,2CAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;;AAEA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA,iCAAiC,yCAAiB,0BAA0B,2BAAO;AACnF,oCAAoC,yCAAiB,0BAA0B,2BAAO;AACtF,iCAAiC,yCAAiB,0BAA0B,2BAAO;AACnF,oCAAoC,yCAAiB,0BAA0B,2BAAO;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,6CAAgB;AACxC;;AAEA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA,iCAAiC,yCAAiB,0BAA0B,2BAAO;AACnF,oCAAoC,yCAAiB,0BAA0B,2BAAO;AACtF,iCAAiC,yCAAiB,0BAA0B,2BAAO;AACnF,oCAAoC,yCAAiB,0BAA0B,2BAAO;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,mBAAmB;AACnD,yCAAyC,yCAAiB,oBAAoB,2BAAO;AACrF;AACA;AACA;AACA;AACA,yCAAyC,yCAAiB,oBAAoB,2BAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,cAAc;AACd;AACA,qBAAqB,2CAAa;AAClC,qBAAqB,2CAAa;AAClC,qBAAqB,2CAAa;AAClC,qBAAqB,2CAAa;;AAElC;;AAEA;AACA;AACA,qBAAqB,6BAAQ;AAC7B,qBAAqB,6BAAQ;AAC7B,4BAA4B,OAAO;AACnC;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,yDAAoB;AAChC;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,aAAa,kCAAW;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAmB,YAAY,8CAAiB;;;AC/sBhD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACa;AACL;;AAEjC;AACA;AACA,oGAAoG,yBAAyB,WAAW,iBAAiB;AACzJ;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,sCAAa;AACb;AACA;AACA;AACA,QAAQ,oEAA2B;AACnC,QAAQ,wDAAqB;AAC7B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,2CAAa;AAClC;AACA,KAAK;AACL;AACA,0DAAuB,OAAO,kDAAmB;AACjD,mEAAyB,CAAC,sCAAa,EAAE,sDAAqB;;AAE9D,gCAAU;AACV,IAAI,0DAAuB;AAC3B;AACA;AACA,0BAA0B,2CAAa;AACvC,0BAA0B,2CAAa;AACvC,sBAAsB,2CAAa;AACnC,sBAAsB,2CAAa;AACnC;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,qBAAqB;AACrB,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA,WAAW,0DAA0D;AACrE;AACA;AACA,WAAW,wCAAwC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,qFAAqF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA;AACA;AACA;AACA,sEAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAmB;AAC9B,aAAa,sCAAa;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAmB,wBAAwB,sEAA6B;;AAExE;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,wBAAwB,eAAe;AACvC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,+FAA+F,cAAc;AAC7G;AACA;AACA;AACA,gBAAgB,qFAAqF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C,4BAA4B,eAAe;AAC3C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ;AACR;AACA;AACA;AACA;AACA,8DAAyB;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,kDAAmB,oBAAoB,8DAAyB;;;AClVxC;AACM,CAAC;AACL;AACJ;AACD;AACE;AACC;AACH;AACK;AACP;AACS;AACR;AACK;AACL;AACC;AACI;AACE;AACF;AACA;AACJ;AACA;AACG;AACK;AACN;AACG;AACJ;AACH;AACC;AACI;AACD;AACO;AACR;AACD;AACC;AACC;AACE;AACD;AACF;AACC;AACG;AACE;AACG;AACN;AACJ;AACC;AACI;AACC;AACL;AACS;AACR;AACA;AACD;AACD;AACG;AACF;AACI;AACD;AACI;AACA;AACR;AACC;AACE;AACA;AACG;AACJ;AACC;AACS;AACL;AACH;AACC;AACI;AACT;AACA;AACG;AACJ;AACE;AACA;AACG;AACD;;;AAGxB;AACA,IAAI,sCAAa;AACjB,iBAAiB,kBAAG;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,EAAE,SAAS,0CAAe;AAC1B,eAAe,kBAAG;AAClB;;AAEA,wCAAe,kBAAG,EAAC;;;;;;;;;;AClGnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,uBAAuB;AAClC,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA,oBAAoB;;AAEpB;AACA,+FAA+F;AAC/F;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,UAAU;AAC7B,oFAAoF,uBAAuB;AAC3G;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,iDAAiD,+BAA+B,kBAAkB,uBAAuB;AACzH;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,uCAAuC,iBAAiB;AACxD,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,GAAG,EAAC;;;;;;;;;;;;;;;AC1VnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;AACa;AACF;AACX;AACS;AACD;AACI;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAY;;AAEZ;;AAEA,mEAAU;AACV,IAAI,wEAAY;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC,mBAAmB,iBAAiB;AACpC,mBAAmB,iBAAiB;AACpC,4BAA4B,6BAA6B;AACzD;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,2EAAc;AAC1B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,iBAAiB;AACpC,mBAAmB,iBAAiB;AACpC,mBAAmB,iBAAiB;AACpC;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,2DAA2D;AAC3D,SAAS;;AAET;AACA;AACA,mBAAmB,iBAAiB;AACpC,mBAAmB,iBAAiB;AACpC,mBAAmB,iBAAiB;AACpC;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA;AACA,2BAA2B,6DAAM;AACjC,oBAAoB,8FAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC,sBAAsB,WAAW;AACjC,sBAAsB,WAAW;AACjC,sBAAsB,QAAQ;AAC9B;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;;AAEZ;AACA;AACA,mBAAmB,UAAU;AAC7B,mBAAmB,WAAW;AAC9B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,8DAAO;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA,kCAAkC,8DAAO;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,kBAAkB,gFAAgB,wBAAwB,8DAAO;AAC/E;AACA;AACA;;AAEA,kCAAkC,8DAAO;AACzC;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,8DAAO;AACzC,yCAAyC,8DAAO;AAChD,yCAAyC,8DAAO;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,oBAAoB,gFAAgB,QAAQ;AAC5C,oBAAoB,gFAAgB,mBAAmB;AACvD;AACA;;AAEA,wBAAwB,6DAAM,CAAC,8FAAoB;AACnD,SAAS;;AAET;AACA,mCAAmC,sCAAsC;AACzE;AACA;AACA,YAAY,2EAAc;AAC1B;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA;AACA,iBAAiB,gFAAgB;;AAEjC;AACA;AACA,iBAAiB,gFAAgB;;AAEjC,uBAAuB,6DAAM,CAAC,8FAAoB,EAAE,gFAAgB;AACpE,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,8DAAO;AAC3B,uCAAuC,8DAAO,0BAA0B,8DAAO;AAC/E;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,mBAAmB,kBAAkB;AACrC,mBAAmB,kBAAkB;AACrC,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA,gBAAgB,0EAAW;AAC3B;AACA;AACA,gBAAgB,0EAAW;AAC3B;AACA;AACA,gBAAgB,0EAAW;AAC3B;AACA;;AAEA;;AAEA,+BAA+B,8DAAO;AACtC;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO,uBAAuB,gBAAgB,GAAG,iBAAiB;AACrF;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB,wEAAW,IAAI,sFAAkB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,mBAAmB,4BAA4B;AAC/C,mBAAmB,4BAA4B;AAC/C;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB,sFAAkB;AACtC,oBAAoB,sFAAkB;AACtC,oBAAoB,sFAAkB;;AAEtC;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO,uBAAuB,gBAAgB,GAAG,iBAAiB;AACrF,mBAAmB,SAAS;AAC5B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAW,IAAI,sFAAkB;;AAEtD;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO,4BAA4B,gBAAgB,GAAG,iBAAiB;AAC1F;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB,wEAAW,SAAS,sFAAkB;AAC3D;;AAEA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,sEAAS;AAC9B;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,mBAAmB,YAAY;AAC/B;AACA,mBAAmB,YAAY;AAC/B;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;AACA;AACA;;AAEA,4BAA4B,8EAAa;AACzC,2BAA2B,8EAAa;;AAExC;AACA;AACA,gDAAgD,8DAAO;AACvD;AACA;AACA,gDAAgD,8DAAO;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,8DAAO;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,8DAAO;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,8FAAoB;AAC1D;;AAEA;AACA;AACA,sCAAsC,8FAAoB;AAC1D;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,mBAAmB,YAAY;AAC/B;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,8EAAa;AACzC,2BAA2B,8EAAa;;AAExC;AACA;AACA,gDAAgD,8DAAO;AACvD;AACA;AACA,gDAAgD,8DAAO;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU,kDAAkD;AAClF;AACA;AACA;AACA;AACA,sBAAsB,UAAU,kDAAkD;AAClF;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,sBAAsB,UAAU,kDAAkD;AAClF;AACA;AACA;AACA;AACA,sBAAsB,UAAU,kDAAkD;AAClF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8FAAoB;AACnE;AACA;AACA;AACA,4CAA4C,8FAAoB;AAChE,oDAAoD,8FAAoB;AACxE;AACA,4BAA4B,8DAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8FAAoB;AAChE,oDAAoD,8FAAoB;AACxE;AACA,4BAA4B,8DAAO;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,8FAAoB;AAC1D;;AAEA;AACA;AACA,sCAAsC,8FAAoB;AAC1D;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,YAAY;AAC/B,mBAAmB,YAAY;AAC/B,mBAAmB,YAAY;AAC/B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,8DAAO;AACnD;AACA;AACA;;AAEA,4CAA4C,8DAAO;AACnD;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,YAAY;AAC/B,mBAAmB,YAAY;AAC/B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B,8DAAO;AACtC;AACA;;AAEA,+BAA+B,8DAAO;AACtC;AACA;;AAEA,+BAA+B,8DAAO;AACtC;AACA;;AAEA,+BAA+B,8DAAO;AACtC;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,0EAAW;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA,oBAAoB,0EAAW;AAC/B;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAO;AAC/C;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,wCAAwC,8DAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,oBAAoB,OAAO;AAC3B;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,8FAAoB;AACnD,2BAA2B,6DAAM,CAAC,8FAAoB;AACtD;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,qCAAqC,aAAa;AAClD,qBAAqB,0EAAW;AAChC,qBAAqB,0EAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,wCAAwC;AACtE,mBAAmB,WAAW;AAC9B,mBAAmB,gDAAgD;AACnE;AACA;AACA;AACA,wBAAwB,wCAAwC;AAChE,mBAAmB,SAAS;AAC5B;AACA,qBAAqB,UAAU,sBAAsB,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,sGAAwB;AAC7D,8BAA8B,gGAAqB,iBAAiB,sGAAwB;AAC5F;AACA;AACA;AACA,qCAAqC,sGAAwB;AAC7D,8BAA8B,gGAAqB,iBAAiB,sGAAwB;AAC5F;AACA;;AAEA;AACA,sCAAsC,sGAAwB;AAC9D,yCAAyC,sGAAwB;AACjE,sCAAsC,sGAAwB;AAC9D,yCAAyC,wGAAyB;AAClE,sCAAsC,sGAAwB;AAC9D,yCAAyC,wGAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,sCAAsC,sGAAwB;AAC9D;AACA,yCAAyC,oGAAuB;AAChE,sCAAsC,sGAAwB;AAC9D;AACA,yCAAyC,oGAAuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,6BAA6B,wGAAyB;AACtD,6BAA6B,wGAAyB;AACtD;AACA;AACA;AACA;;AAEA,yCAAyC,oGAAuB;AAChE;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B,oGAAuB;AACvE;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,qCAAqC,oGAAuB;AAC5D,qCAAqC,oGAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8EAAa;AAC9C,gCAAgC,8EAAa;AAC7C,iCAAiC,8EAAa;AAC9C,gCAAgC,8EAAa;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8EAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA,mCAAmC,6DAAM,CAAC,8FAAoB;AAC9D;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,oGAAuB;AACpE,gCAAgC,8EAAa;AAC7C,+BAA+B,8EAAa;AAC5C;AACA;AACA,kDAAkD,8DAAO,wBAAwB,8DAAO;AACxF,2CAA2C,6DAAM,CAAC,mFAAkB;AACpE;AACA;AACA;AACA,6CAA6C,oGAAuB;AACpE,gCAAgC,8EAAa;AAC7C,+BAA+B,8EAAa;AAC5C;AACA;AACA,kDAAkD,8DAAO,wBAAwB,8DAAO;AACxF,2CAA2C,6DAAM,CAAC,mFAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAM,CAAC,mFAAkB;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB,oBAAoB,YAAY;AAChC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA,sBAAsB,8DAAO;;AAE7B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,oBAAoB,WAAW;AAC/B,oBAAoB,WAAW;AAC/B,oBAAoB,WAAW;AAC/B,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA,mBAAmB,gFAAgB;AACnC;AACA,mBAAmB,gFAAgB;AACnC;AACA,mBAAmB,gFAAgB;AACnC;AACA,mBAAmB,gFAAgB;;AAEnC;AACA,wBAAwB,OAAO;AAC/B,wCAAwC,8DAAO;AAC/C,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,8DAAO;AAC3C,mCAAmC;AACnC,mCAAmC;AACnC;AACA,cAAc,6BAA6B,8DAAO;AAClD,mCAAmC;AACnC,mCAAmC;AACnC;AACA,cAAc;AACd,mCAAmC;;AAEnC;AACA;AACA,uCAAuC;AACvC,kBAAkB;AAClB,uCAAuC;AACvC;AACA;AACA,cAAc;AACd,mCAAmC;;AAEnC;AACA;AACA,uCAAuC;AACvC,kBAAkB;AAClB,uCAAuC;AACvC;AACA,cAAc;AACd,mCAAmC;;AAEnC;AACA;AACA,uCAAuC;AACvC;AACA,kBAAkB;AAClB,uCAAuC;AACvC,kBAAkB;AAClB,uCAAuC;AACvC;AACA;;AAEA,6BAA6B,6DAAM,CAAC,kGAAsB;AAC1D,6BAA6B,6DAAM,CAAC,kGAAsB;AAC1D;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gFAAgB;AACvE,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA;AACA,0BAA0B,8DAAO;AACjC,6BAA6B,gFAAgB,mCAAmC,8DAAO;AACvF,+BAA+B,6DAAM,CAAC,8FAAoB;AAC1D;;AAEA,2BAA2B,6DAAM,CAAC,8FAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,8DAAO,GAAG,8DAAO;AACtC;AACA;;AAEA;AACA,0BAA0B,6DAAM;AAChC,0BAA0B,8FAAoB;AAC9C;AACA;AACA;AACA,0BAA0B,6DAAM;AAChC,0BAA0B,8FAAoB;AAC9C;AACA;AACA;AACA;;AAEA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA;AACA,2BAA2B,8DAAO;AAClC;AACA;AACA,oBAAoB,8DAAO;AAC3B;AACA,+BAA+B,6DAAM,CAAC,8FAAoB;AAC1D;;AAEA,2BAA2B,6DAAM,CAAC,8FAAoB;AACtD;;AAEA;AACA,2BAA2B,8DAAO;AAClC;AACA;AACA,oBAAoB,8DAAO;AAC3B;AACA,+BAA+B,6DAAM,CAAC,8FAAoB;AAC1D;;AAEA,2BAA2B,6DAAM,CAAC,8FAAoB;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0EAAa;;AAEvC;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA,gBAAgB,0EAAW;AAC3B,qBAAqB,8FAA0B;AAC/C,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA;AACA,YAAY,8CAA8C;AAC1D,2CAA2C;AAC3C;AACA;AACA,mBAAmB,oBAAoB;AACvC,mBAAmB,oBAAoB;AACvC,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,SAAS;AAC5B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA,qCAAqC,sGAAwB;AAC7D;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,iBAAiB,+CAA+C;AAChE,qDAAqD,6BAA6B;AAClF;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,SAAS;AAC5B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAO;AAC7B,yBAAyB,8DAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA,wBAAwB,WAAW;AACnC,oBAAoB,oEAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,oEAAa;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA;;AAEA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,SAAS;AAC5B;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8EAAa;AACrC,wBAAwB,8EAAa;;AAErC;AACA,oBAAoB,6DAAM,CAAC,8FAAoB;;AAE/C;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA,wBAAwB,8DAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA,wCAAwC,6DAAM,CAAC,8FAAoB;AACnE,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,aAAa;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gFAAgB;AACtC,sBAAsB,gFAAgB;AACtC,oBAAoB,gFAAgB;;AAEpC,iCAAiC,8DAAO;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,8DAAO;AACzD;AACA;;AAEA,kDAAkD,8DAAO;AACzD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD,mBAAmB,kCAAkC;AACrD,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,2FAAsB;AACtC;AACA;AACA;AACA,uFAAuF,8DAAO;AAC9F;AACA;AACA;;AAEA,gBAAgB,2FAAsB;AACtC;AACA;AACA;AACA;AACA,oBAAoB,8DAAO,GAAG,8DAAO;AACrC;AACA;AACA;;AAEA;AACA,0BAA0B,iGAAyB;AACnD,2BAA2B,6DAAM,CAAC,8FAAoB;AACtD;;AAEA,YAAY,mHAAkC;AAC9C,YAAY,mHAAkC;;AAE9C,4BAA4B,6GAA+B;AAC3D;AACA;AACA;AACA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA,mBAAmB,aAAa;AAChC,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,SAAS;AAC5B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;;AAEA;AACA;AACA,sFAAsF;AACtF,sFAAsF;AACtF,sFAAsF;AACtF,sFAAsF;AACtF,cAAc;AACd;AACA,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;AAC5D;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0EAAW;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,SAAS;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,sGAAwB;AACrD;AACA;AACA;AACA,8BAA8B,sGAAwB;AACtD;AACA;AACA;;AAEA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA,yCAAyC,8DAAO;AAChD,4CAA4C,8DAAO;AACnD,yCAAyC,8DAAO;AAChD,4CAA4C,8DAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,yBAAyB,8DAAO;AAChC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAc;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,8DAAO;AAC/C;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,YAAY;AAC/B,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA,gBAAgB,4EAAY;AAC5B,6CAA6C,8FAAoB;AACjE;AACA;AACA,cAAc;AACd,sCAAsC,8FAAoB;AAC1D;AACA;;AAEA,iCAAiC,8DAAO;AACxC,uBAAuB,8DAAO;AAC9B;;AAEA;AACA;AACA;;AAEA,uBAAuB,6DAAM,CAAC,8FAAoB;AAClD,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,UAAU;AAC7B,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B,oBAAoB,0EAAW;AAC/B;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,gBAAgB,0EAAW;AAC3B;AACA,cAAc;AACd;AACA;;AAEA,gBAAgB,gFAAgB;AAChC,uBAAuB,6DAAM,CAAC,8FAAoB,EAAE,gFAAgB;AACpE,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,8DAAO,qBAAqB,8DAAO;AACpE;AACA;;AAEA,gBAAgB,gFAAgB;AAChC,oBAAoB,gFAAgB;AACpC;;AAEA;AACA,SAAS;;AAET;AACA;AACA,YAAY,iBAAiB;AAC7B,mBAAmB,OAAO;AAC1B,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,+FAAwB;;AAEzC;AACA,SAAS;;AAET;AACA;AACA,iBAAiB,6CAA6C;AAC9D;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA,gBAAgB,8EAAa;AAC7B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA,mCAAmC,6DAAM,CAAC,8FAAoB;AAC9D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,WAAW;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,wEAAe;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA,mCAAmC,6DAAM;AACzC,oBAAoB,8FAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,aAAa;AAChC,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,aAAa;AACrC,6BAA6B,+HAAwC;AACrE;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,mGAA0B;AAClD;AACA,kBAAkB;AAClB,wBAAwB,mGAA0B;AAClD;AACA,kBAAkB;AAClB,wBAAwB,mGAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,yDAAyD,4CAA4C;AACrG,mBAAmB,WAAW;AAC9B,mBAAmB,YAAY;AAC/B,mBAAmB,WAAW;AAC9B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;;AAEA,wCAAwC,sGAAwB;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,6DAAM,CAAC,8FAAoB;AACvD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,wBAAwB,gFAAgB;AACxC;AACA;AACA;AACA;AACA,wBAAwB,0EAAa;;AAErC;AACA,uDAAuD,gBAAgB,IAAI,YAAY;AACvF;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,8DAAO;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,2DAA2D,8EAA8E;AACzI;AACA,qCAAqC,wFAAwF;AAC7H;AACA,uGAAuG,cAAc;AACrH;AACA,wFAAwF,oFAAoF;AAC5K;AACA;AACA,2DAA2D,8EAA8E;AACzI;AACA,qCAAqC,wFAAwF;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,gFAAgB;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gFAAgB;AAClC,kBAAkB,gFAAgB;AAClC,kBAAkB,gFAAgB;AAClC,oBAAoB,gFAAgB;AACpC,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B,uBAAuB,8EAAa;AACpC,uBAAuB,8EAAa;AACpC;AACA,kBAAkB,gFAAgB;;AAElC,wBAAwB,OAAO;AAC/B,uBAAuB,8EAAa;AACpC,uBAAuB,8EAAa;AACpC;AACA,kBAAkB,gFAAgB;;AAElC,mBAAmB,gFAAgB;AACnC,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,gEAAQ;AACzB,iBAAiB,gFAAgB;AACjC,iBAAiB,gFAAgB;AACjC;AACA;AACA;AACA,kBAAkB,gEAAQ;;AAE1B;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,sEAAc;AACpC;AACA;;AAEA;AACA,sBAAsB,sEAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,wEAAY,EAAC;;;;;;;;;;;ACl4G5B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACA;AACQ;;AAEjC,qFAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAU;AACV,IAAI,yGAA6B;AACjC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qFAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kHAAiC;AACjD,qBAAqB,oHAAkC;AACvD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB,kHAAiC;AACjD,qBAAqB,oHAAkC;AACvD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,wBAAwB,sGAA2B,MAAM,sGAA2B;AACpF,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,2BAA2B,sGAA2B,MAAM,sGAA2B;AACvF,KAAK;;AAEL;AACA,2BAA2B,sGAA2B;AACtD,KAAK;;AAEL;AACA,+BAA+B,sGAA2B;AAC1D,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,qGAA2B;AAC3B;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,+BAA+B,sCAAsC;AACrE,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA,YAAY,8EAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,yBAAyB,gEAAQ;AACjC,KAAK;AACL;AACA,yBAAyB,gEAAQ;AACjC,KAAK;AACL;AACA,yBAAyB,gEAAQ;AACjC,KAAK;AACL;AACA,yBAAyB,gEAAQ;AACjC,KAAK;AACL;AACA,yBAAyB,gEAAQ;AACjC,KAAK;AACL;AACA,yBAAyB,gEAAQ;AACjC,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA,2GAA8B;AAC9B,IAAI,wGAA4B;AAChC,IAAI,0GAA6B;AACjC;AACA,qHAAmC;AACnC,IAAI,gHAAgC;AACpC,IAAI,kHAAiC;AACrC;AACA,uHAAoC;AACpC,IAAI,kHAAiC;AACrC,IAAI,oHAAkC;AACtC;AACA,+GAAgC;AAChC,6GAA+B;AAC/B,iHAAiC;AACjC,iHAAiC;;AAEjC,yDAAe,qGAA2B,EAAC;;;;;;;;;;AChoD3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACyB;AACQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,+DAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;;AAEA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,UAAU;AACV,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA,4BAA4B,8EAAa;AACzC;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA,4BAA4B,8EAAa;AACzC;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA,+BAA+B,8EAAa;AAC5C;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,8EAAa,OAAO,8EAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,iBAAiB,UAAU;AAC3B;AACA;AACA;;AAEA,cAAc,8EAAa,OAAO,8EAAa;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,6BAA6B,mDAAmD;AAChF;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,2CAA2C,mEAAmE;AAC9G;AACA;AACA,mBAAmB,IAAI,EAAE,GAAG,YAAY,KAAK;AAC7C;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,+DAAQ,EAAC;;;;;;;;;;;;ACnmCxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;AACQ;AACF;AACN;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAY;AACZ;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAS;AACjC,wBAAwB,sEAAS;AACjC,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO,2FAA2F;AACjH,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAO;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;;AAEA,oBAAoB,WAAW;AAC/B;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAO,GAAG,8DAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA,0CAA0C,gDAAgD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAa;AACvC,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,yBAAyB;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,6BAA6B;AACzD;AACA;AACA;;AAEA;;AAEA,4BAA4B,yBAAyB;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,6BAA6B;AACzD;AACA;AACA;;AAEA;;AAEA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,yBAAyB;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,aAAa;AACjF;AACA;AACA;AACA,0CAA0C,gCAAgC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAa;AACvC,4BAA4B,8EAAa;;AAEzC;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;;AAEA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,aAAa;AACvF;AACA;AACA;AACA,0CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAa;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,UAAU;AACV;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,gCAAgC,sCAAsC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,gCAAgC,uCAAuC;AACvE,QAAQ,uCAAuC;AAC/C,QAAQ,uCAAuC;AAC/C;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,WAAW;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,sCAAsC,4BAA4B;AAClE,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gCAAgC,uCAAuC;AACvE,QAAQ,uCAAuC;AAC/C,QAAQ,uCAAuC;AAC/C;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA;AACA;AACA,0CAA0C,oCAAoC;AAC9E;AACA;AACA;AACA;AACA;AACA,8BAA8B,8EAAa;AAC3C,+BAA+B,8EAAa;AAC5C,+BAA+B,8EAAa;AAC5C,0BAA0B,kFAAe;AACzC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,+DAAQ;AACpB;AACA,0CAA0C,8DAAO;AACjD,YAAY,+DAAQ;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY,+DAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY,+DAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+CAA+C;AAChG,6CAA6C,mCAAmC;AAChF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAO;AACvB;AACA;;AAEA;AACA,YAAY,4EAAY;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,wBAAwB,qCAAqC;AAC7D,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,8DAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE,gDAAgD,iBAAiB;AACjE,6CAA6C,iBAAiB;AAC9D,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA,8CAA8C,iCAAiC;AAC/E;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA,kDAAkD,qBAAqB;AACvE,oDAAoD,iBAAiB;AACrE,iDAAiD,iBAAiB;AAClE,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA,kDAAkD,iCAAiC;AACnF;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAY;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA,oBAAoB,WAAW;AAC/B;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;;AAEA;AACA,wBAAwB,QAAQ;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO,8CAA8C;AACpE;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,4EAAY;AACxB;AACA;AACA,UAAU;AACV;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD,4CAA4C,OAAO;AACnD,4CAA4C,OAAO;AACnD,6CAA6C,OAAO;AACpD;AACA,+DAA+D,cAAc;AAC7E;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA,iDAAiD,OAAO;AACxD,gDAAgD,OAAO;AACvD,gDAAgD,OAAO;AACvD,iDAAiD,OAAO;AACxD;AACA,mEAAmE,cAAc;AACjF;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD,kDAAkD,OAAO;AACzD,kDAAkD,OAAO;AACzD;AACA;AACA,+DAA+D,cAAc;AAC7E,kFAAkF,aAAa;AAC/F;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA,sDAAsD,OAAO;AAC7D,sDAAsD,OAAO;AAC7D,sDAAsD,OAAO;AAC7D;AACA;AACA,mEAAmE,cAAc;AACjF,sFAAsF,aAAa;AACnG;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,SAAS;AACzC;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA,4BAA4B,SAAS;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,+CAA+C;AACjE;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D,sDAAsD,OAAO;AAC7D,sDAAsD,OAAO;AAC7D;AACA;AACA,mEAAmE,cAAc;AACjF,sFAAsF,aAAa;AACnG;AACA,uGAAuG,cAAc;AACrH;AACA;AACA;AACA,wBAAwB,oFAAoF;AAC5G;AACA,0DAA0D,OAAO;AACjE,0DAA0D,OAAO;AACjE,0DAA0D,OAAO;AACjE;AACA;AACA,uEAAuE,cAAc;AACrF,0FAA0F,aAAa;AACvG;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD,kDAAkD,OAAO;AACzD,kDAAkD,OAAO;AACzD;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA,wDAAwD,aAAa;AACrE;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA,sDAAsD,OAAO;AAC7D,sDAAsD,OAAO;AAC7D,sDAAsD,OAAO;AAC7D;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA,4DAA4D,aAAa;AACzE;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,wBAAwB,SAAS;AACjC;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAS;AAC7C,4BAA4B,mBAAmB;AAC/C;AACA;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;AACA,kCAAkC,8DAAO;AACzC;AACA;AACA,oBAAoB,mEAAU;AAC9B,wBAAwB,6EAAY;AACpC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB,gDAAgD;AACtE;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,kFAAe;AAC3B;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,8DAAO;AAC7C;AACA;AACA,sCAAsC,8DAAO;AAC7C;AACA;AACA,sCAAsC,8DAAO;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA,eAAe,OAAO;AACtB,oBAAoB,gBAAgB,MAAM,iBAAiB;AAC3D;AACA,eAAe,OAAO;AACtB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,4EAAY,YAAY,kFAAe;AACnD;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS,kFAAe;AAClC;AACA;AACA,UAAU,SAAS,8EAAa;AAChC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,4EAAY,WAAW,4EAAY;AACzE;AACA;AACA,UAAU;AACV;AACA,YAAY,4EAAY;AACxB;AACA,YAAY,4EAAY;AACxB;AACA;AACA,UAAU;AACV;AACA,YAAY,4EAAY;AACxB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC,4BAA4B,kFAAe;AAC3C;AACA,0BAA0B;AAC1B;AACA;;AAEA,4BAA4B,kFAAe;AAC3C;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,SAAS;AACrC;AACA;;AAEA,4BAA4B,QAAQ;AACpC,gCAAgC,SAAS;AACzC;AACA;AACA;;AAEA;AACA,qBAAqB,0EAAa;AAClC,oBAAoB,4EAAc;AAClC,oBAAoB,4EAAc;AAClC,yBAAyB,oFAAkB;AAC3C,uBAAuB,sHAAmC;AAC1D;;AAEA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO,kCAAkC,iBAAiB;AACzE;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,eAAe;AAC3C;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,4BAA4B,QAAQ;AACpC,wCAAwC,QAAQ;AAChD;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,YAAY;AACZ,YAAY,yBAAyB;AACrC,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,aAAa,0EAAW;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,uCAAuC,cAAc;AACrD;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ,sDAAsD,cAAc;AAC3F,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,+BAA+B;;AAE/B;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;;AAEA,kCAAkC,iBAAiB;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV,sBAAsB;AACtB;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,4EAAY;AACxB;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,QAAQ,2EAAc;AACtB;AACA,KAAK;;AAEL;AACA;AACA,YAAY,wDAAwD;AACpE,eAAe,eAAe;AAC9B;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B,kBAAkB,UAAU;AAC5B,kBAAkB,SAAS;AAC3B,kBAAkB;AAClB;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,oBAAoB,KAAK,aAAa;AACtC;AACA;AACA;AACA,sDAAsD,kBAAkB;AACxE,mGAAmG,cAAc;AACjH;AACA,sFAAsF,qFAAqF;AAC3K;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,sDAAsD,qCAAqC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,8EAAa;AACzB;AACA;AACA;;AAEA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,SAAS;AACrC;AACA;;AAEA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,SAAS;AACzC;AACA;AACA;;AAEA;AACA,4BAA4B,SAAS;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;;AAEA,wBAAwB,OAAO;AAC/B,4BAA4B,SAAS;AACrC;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,wCAAwC,+BAA+B;AACvE,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,4EAAY;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAO;AACzB;AACA;AACA;;AAEA,YAAY,4EAAY;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,4EAAY;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,KAAK;;AAEL;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,4EAAY;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,4EAAY;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAO;AACzB,sBAAsB,8DAAO;AAC7B;AACA;AACA;;AAEA,aAAa,4EAAY;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,kBAAkB;AAClB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,cAAc;AACpC,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,4CAA4C;AAC3F;AACA;AACA,uBAAuB,OAAO,cAAc;AAC5C,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,8DAAO;AACtC;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iDAAiD,4CAA4C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO,cAAc;AAC5C,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B,uBAAuB,OAAO,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,QAAQ,2EAAc;AACtB;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,cAAc;AACpC,eAAe,QAAQ;AACvB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,uDAAuD,qBAAqB;AAC5E;AACA,qDAAqD,qCAAqC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,2DAA2D,qBAAqB;AAChF;AACA,yDAAyD,qCAAqC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA,gBAAgB,yFAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,yFAAqB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yFAAqB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA,yDAAe,wEAAY,EAAC;;;;;;;;;;;ACjgI5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACA;AACQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,4EAAc;AACd;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,mGAAmG,+CAA+C;AAClJ;AACA;AACA,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,gBAAgB,4EAAY;AAC5B;AACA,cAAc;AACd;AACA;;AAEA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,gBAAgB,4EAAY;AAC5B;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qDAAqD,gCAAgC;AACrF;AACA;AACA,gBAAgB,OAAO;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,YAAY,4EAAY;AACxB;AACA;AACA,cAAc;AACd;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,kFAAe;AAC9B,eAAe,kFAAe;;AAE9B,YAAY,4EAAY,UAAU,8EAAa;AAC/C;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,8EAAa,UAAU,4EAAY;AACtD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,4EAAY,UAAU,4EAAY;AACrD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,kFAAe;AAC9B,eAAe,kFAAe;;AAE9B,YAAY,4EAAY,UAAU,8EAAa;AAC/C;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,8EAAa,UAAU,4EAAY;AACtD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,4EAAY,UAAU,4EAAY;AACrD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA,QAAQ,2EAAc;AACtB,QAAQ,gGAAwB,CAAC,4EAAc;AAC/C,KAAK;;AAEL;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,oEAAQ;;AAEvB;AACA,kBAAkB,8DAAO;AACzB;;AAEA,eAAe,kFAAe;AAC9B,eAAe,kFAAe;;AAE9B,YAAY,4EAAY,UAAU,8EAAa;AAC/C;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,8EAAa,UAAU,4EAAY;AACtD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,4EAAY,UAAU,4EAAY;AACrD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,kFAAe;AAC9B,eAAe,kFAAe;;AAE9B,YAAY,4EAAY,UAAU,8EAAa;AAC/C;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,8EAAa,UAAU,4EAAY;AACtD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,4EAAY,UAAU,4EAAY;AACrD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,kFAAe;AAC9B,eAAe,kFAAe;;AAE9B,YAAY,4EAAY,UAAU,8EAAa;AAC/C;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,8EAAa,UAAU,4EAAY;AACtD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU,SAAS,4EAAY,UAAU,4EAAY;AACrD;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,gDAAgD,6CAA6C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,iBAAiB,iBAAiB;AACxD,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,sDAAsD,uCAAuC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mCAAmC;AAC7C;AACA,mGAAmG,cAAc;AACjH;AACA;AACA;AACA,oBAAoB,kFAAkF;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA,wBAAwB,mBAAmB;AAC3C,gFAAgF,8DAAO;AACvF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,4EAAc,EAAC;;;;;;;;;;;;;ACznB9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEwB;AACa;AACP;AACI;AACF;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,qEAAW;;AAEX;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA,oBAAoB;AACpB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA,wBAAwB;AACxB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,uBAAuB,KAAK,sBAAsB;AACvG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA,yBAAyB,IAAI,SAAS,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa,wBAAwB,oBAAoB;AACzG,gDAAgD,2BAA2B,oBAAoB,oBAAoB,YAAY,UAAU,2CAA2C;AACpL,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2EAA2E,oBAAoB;AAC/F;AACA,4GAA4G,cAAc;AAC1H;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,+EAA+E,oBAAoB;AACnG,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,kCAAkC,GAAG,gCAAgC;AACrF,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,uCAAuC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,uCAAuC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,sBAAsB;AACjG,yEAAyE,sBAAsB;AAC/F;AACA;AACA;AACA,0DAA0D,uBAAuB,KAAK,sBAAsB;AAC5G,0DAA0D,uBAAuB,KAAK,sBAAsB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,oBAAoB;AACpB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,wBAAwB;AACxB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,wBAAwB;AACxB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iCAAiC;AACjC,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB,uFAAkB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB,qFAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,kGAAkG,cAAc;AAChH,wFAAwF,gBAAgB;AACxG,wFAAwF,gBAAgB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E,iEAAiE,mBAAmB;AACpF,+DAA+D,mBAAmB;AAClF;AACA,wBAAwB;AACxB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,2FAA2F;AACvH,sGAAsG,cAAc;AACpH,4FAA4F,gBAAgB;AAC5G,4FAA4F,gBAAgB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,mBAAmB;AAClF,qEAAqE,mBAAmB;AACxF,mEAAmE,mBAAmB;AACtF;AACA,4BAA4B;AAC5B;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,yFAAyF,eAAe;AACxG,yFAAyF,eAAe;AACxG,yFAAyF,gBAAgB;AACzG,uFAAuF,gBAAgB;AACvG,sFAAsF,UAAU;AAChG,yFAAyF,WAAW;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oBAAoB;AAC5E,wDAAwD,oBAAoB;AAC5E,uDAAuD,mBAAmB;AAC1E,wDAAwD,oBAAoB;AAC5E,wDAAwD,oBAAoB;AAC5E,wDAAwD,oBAAoB;AAC5E,iEAAiE,oBAAoB;AACrF,+DAA+D,oBAAoB;AACnF;AACA,oBAAoB;AACpB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,2FAA2F;AACvH,6FAA6F,eAAe;AAC5G,6FAA6F,eAAe;AAC5G,6FAA6F,gBAAgB;AAC7G,2FAA2F,gBAAgB;AAC3G,0FAA0F,UAAU;AACpG,6FAA6F,WAAW;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oBAAoB;AAChF,4DAA4D,oBAAoB;AAChF,2DAA2D,mBAAmB;AAC9E,4DAA4D,oBAAoB;AAChF,4DAA4D,oBAAoB;AAChF,4DAA4D,oBAAoB;AAChF,qEAAqE,oBAAoB;AACzF,mEAAmE,oBAAoB;AACvF;AACA,wBAAwB;AACxB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kCAAkC;AACpG;AACA;AACA,kEAAkE,iCAAiC;AACnG;AACA;AACA,kEAAkE,8BAA8B,gBAAgB;AAChH;AACA;AACA,mEAAmE;AACnE,oCAAoC;AACpC,wBAAwB;AACxB;AACA;AACA,oEAAoE;AACpE,oCAAoC;AACpC,wBAAwB;AACxB;AACA;AACA,oEAAoE;AACpE,oCAAoC;AACpC,wBAAwB;AACxB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,oFAAoF;AAChH;AACA;AACA,sEAAsE,kCAAkC;AACxG;AACA;AACA,sEAAsE,iCAAiC;AACvG;AACA;AACA,sEAAsE,8BAA8B,gBAAgB;AACpH;AACA;AACA,uEAAuE;AACvE,wCAAwC;AACxC,4BAA4B;AAC5B;AACA;AACA,wEAAwE;AACxE,wCAAwC;AACxC,4BAA4B;AAC5B;AACA;AACA,wEAAwE;AACxE,wCAAwC;AACxC,4BAA4B;AAC5B;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,uCAAuC,sCAAsC;AAC7E;AACA,oDAAoD,YAAY;AAChE;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAA0D,wCAAwC;AAClG,2DAA2D,oCAAoC;AAC/F;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,oFAAoF;AAChH,8DAA8D,wCAAwC;AACtG,+DAA+D,oCAAoC;AACnG;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,0GAA0G,cAAc;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,uBAAuB;AACvB,mBAAmB;AACnB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2EAA2E,OAAO;AAClF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,2GAA2G,cAAc;AACzH;AACA;AACA,gGAAgG,+EAA+E;AAC/K;AACA;AACA;AACA,yDAAyD,4CAA4C,gBAAgB,mBAAmB;AACxI,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4BAA4B;AAClF;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,oFAAoF;AAChH;AACA;AACA;AACA,0DAA0D,4BAA4B;AACtF;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2FAAoB;AAC3C,gCAAgC,2FAAoB;AACpD,yBAAyB,2FAAoB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,6BAA6B,uFAAkB;AAC/C,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;AAGA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,uFAAkB;AAC3C,uBAAuB,uFAAkB;AACzC;AACA;AACA,kCAAkC,uFAAkB;AACpD,gCAAgC,uFAAkB;AAClD;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,qFAAiB;AAC5C,6BAA6B,qFAAiB;AAC9C;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,2BAA2B,qFAAiB;AAC5C,6BAA6B,qFAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,2FAAoB;AAC3C,gCAAgC,2FAAoB;AACpD;AACA;AACA,yBAAyB,uFAAkB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,8BAA8B,aAAa,4BAA4B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,wCAAwC;AACpH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,2BAA2B,qFAAiB;AAC5C,6BAA6B,qFAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,uBAAuB,qFAAiB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qFAAiB;AACxC;AACA,gCAAgC,qFAAiB;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,uBAAuB,qFAAiB;AACxC;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,uBAAuB,qFAAiB;AACxC;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA,+CAA+C;AAC/C,iBAAiB;AACjB;AACA,+CAA+C;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,oFAAoF;AAChH,6DAA6D,QAAQ;AACrE,gEAAgE,2BAA2B,qCAAqC;AAChI,+DAA+D,2BAA2B,qCAAqC;AAC/H;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,gDAAgD,yCAAyC;AACzF;AACA;AACA;AACA,6DAA6D,aAAa,QAAQ,WAAW,gBAAgB;AAC7G,6DAA6D,aAAa,QAAQ,WAAW,gBAAgB;AAC7G,6DAA6D,aAAa,QAAQ,WAAW,gBAAgB;AAC7G,6DAA6D,aAAa,QAAQ,WAAW,gBAAgB;AAC7G,6DAA6D,aAAa,QAAQ,WAAW,gBAAgB;AAC7G,+DAA+D,aAAa,QAAQ,WAAW,gBAAgB;AAC/G,+DAA+D,aAAa,QAAQ,WAAW,gBAAgB;AAC/G;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,qFAAqF;AACjH;AACA,wDAAwD;AACxD,oDAAoD,yCAAyC;AAC7F;AACA;AACA;AACA,iEAAiE,aAAa,QAAQ,WAAW,gBAAgB;AACjH,iEAAiE,aAAa,QAAQ,WAAW,gBAAgB;AACjH,iEAAiE,aAAa,QAAQ,WAAW,gBAAgB;AACjH,iEAAiE,aAAa,QAAQ,WAAW,gBAAgB;AACjH,iEAAiE,aAAa,QAAQ,WAAW,gBAAgB;AACjH,mEAAmE,aAAa,QAAQ,WAAW,gBAAgB;AACnH,mEAAmE,aAAa,QAAQ,WAAW,gBAAgB;AACnH;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE,2DAA2D,QAAQ;AACnE;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oCAAoC,mCAAmC;AACvE;AACA,qCAAqC;AACrC,wBAAwB;AACxB;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,oFAAoF;AAChH,gEAAgE,OAAO;AACvE,+DAA+D,QAAQ;AACvE;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,wCAAwC,mCAAmC;AAC3E;AACA,yCAAyC;AACzC,4BAA4B;AAC5B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,gDAAgD,yCAAyC;AACzF;AACA,6DAA6D,YAAY,QAAQ,WAAW,gBAAgB;AAC5G,6DAA6D,YAAY,QAAQ,WAAW,gBAAgB;AAC5G,6DAA6D,YAAY,QAAQ,WAAW,gBAAgB;AAC5G,6DAA6D,YAAY,QAAQ,WAAW,gBAAgB;AAC5G,6DAA6D,YAAY,QAAQ,WAAW,gBAAgB;AAC5G,+DAA+D,YAAY,QAAQ,WAAW,gBAAgB;AAC9G,+DAA+D,YAAY,QAAQ,WAAW,gBAAgB;AAC9G;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,qFAAqF;AACjH;AACA;AACA;AACA,uDAAuD;AACvD,oDAAoD,yCAAyC;AAC7F;AACA,iEAAiE,YAAY,QAAQ,WAAW,gBAAgB;AAChH,iEAAiE,YAAY,QAAQ,WAAW,gBAAgB;AAChH,iEAAiE,YAAY,QAAQ,WAAW,gBAAgB;AAChH,iEAAiE,YAAY,QAAQ,WAAW,gBAAgB;AAChH,iEAAiE,YAAY,QAAQ,WAAW,gBAAgB;AAChH,mEAAmE,YAAY,QAAQ,WAAW,gBAAgB;AAClH,mEAAmE,YAAY,QAAQ,WAAW,gBAAgB;AAClH,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,uFAAkB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,gBAAgB,uBAAuB,KAAK,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;;AAGA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA,4BAA4B,kBAAkB,KAAK,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,qFAAiB;AACxC,yBAAyB,qFAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,uBAAuB,KAAK,uBAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qEAAqE;AACpH;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,oFAAoF;AAChH,mDAAmD,qEAAqE;AACxH;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2FAAoB;AAC3C,gCAAgC,2FAAoB;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qFAAiB;AAC9C,2BAA2B,qFAAiB;AAC5C;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2FAAoB;AAC3C,gCAAgC,2FAAoB;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qFAAiB;AAC9C,2BAA2B,qFAAiB;AAC5C;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,2FAAoB;;AAE3C;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2FAAoB;AAC3C,gCAAgC,2FAAoB;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qFAAiB;AAC5C,6BAA6B,qFAAiB;AAC9C;AACA,sCAAsC,qFAAiB;AACvD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,qFAAiB;AACxC;AACA,gCAAgC,qFAAiB;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,8BAA8B;AAC9F;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,oFAAoF;AAChH,oEAAoE,8BAA8B;AAClG;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,gFAAgF;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,yFAAyF;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mBAAmB,GAAG,EAAE,IAAI;AAClF,iEAAiE;AACjE;AACA;AACA,sDAAsD,oBAAoB,GAAG,EAAE,GAAG;AAClF,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS,IAAI,QAAQ,SAAS,IAAI;AAC1E,+BAA+B;AAC/B,oBAAoB;AACpB;AACA,+EAA+E,EAAE;AACjF;AACA;AACA,gBAAgB;AAChB,sEAAsE,0BAA0B,EAAE,IAAI;AACtG;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,cAAc;AACnH;AACA;AACA;AACA,4BAA4B,qFAAqF;AACjH;AACA,0DAA0D,mBAAmB,GAAG,EAAE,IAAI;AACtF,qEAAqE;AACrE;AACA;AACA,0DAA0D,oBAAoB,GAAG,EAAE,GAAG;AACtF,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS,IAAI,QAAQ,SAAS,IAAI;AAC9E,mCAAmC;AACnC,wBAAwB;AACxB;AACA,mFAAmF,EAAE;AACrF;AACA;AACA,oBAAoB;AACpB,0EAA0E,0BAA0B,EAAE,IAAI;AAC1G;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAwE,IAAI;AAClG;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,wBAAwB;AACxB;AACA,6CAA6C;AAC7C;AACA,mCAAmC;AACnC,wBAAwB;AACxB;AACA,yDAAyD,wBAAwB;AACjF;AACA,+CAA+C,qCAAqC;AACpF,+CAA+C;AAC/C,oCAAoC,cAAc,4BAA4B;AAC9E;AACA;AACA,+CAA+C,qCAAqC;AACpF,+CAA+C;AAC/C,oCAAoC,cAAc,4BAA4B;AAC9E;AACA;AACA,uBAAuB,eAAe;AACtC;AACA,uDAAuD,sDAAsD;AAC7G;AACA,gBAAgB;AAChB;AACA,wFAAwF,eAAe;AACvG,uDAAuD,sDAAsD;AAC7G;AACA,gBAAgB;AAChB;AACA;AACA;AACA,yCAAyC,WAAW,UAAU,QAAQ,oCAAoC;AAC1G,6BAA6B;AAC7B,oBAAoB,GAAG,+BAA+B;AACtD;AACA;AACA;AACA,qGAAqG,cAAc;AACnH;AACA;AACA;AACA,4BAA4B,6FAA6F;AACzH;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,4BAA4B;AAC5B;AACA,iDAAiD;AACjD;AACA,uCAAuC;AACvC,4BAA4B;AAC5B;AACA,6DAA6D,wBAAwB;AACrF;AACA,mDAAmD,qCAAqC;AACxF,mDAAmD;AACnD,wCAAwC,cAAc,4BAA4B;AAClF;AACA;AACA,mDAAmD,qCAAqC;AACxF,mDAAmD;AACnD,wCAAwC,cAAc,4BAA4B;AAClF;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA,2DAA2D,sDAAsD;AACjH;AACA,oBAAoB;AACpB;AACA,4FAA4F,eAAe;AAC3G,2DAA2D,sDAAsD;AACjH;AACA,oBAAoB;AACpB;AACA;AACA;AACA,6CAA6C,WAAW,UAAU,QAAQ,oCAAoC;AAC9G,iCAAiC;AACjC,wBAAwB,GAAG,+BAA+B;AAC1D;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,6DAA6D,0CAA0C;AACvG;AACA;AACA;AACA;AACA,2CAA2C,GAAG;AAC9C,kCAAkC;AAClC;AACA,gEAAgE,uBAAuB,IAAI,mBAAmB;AAC9G;AACA,8CAA8C,sCAAsC;AACpF,wBAAwB,IAAI,0EAA0E;AACtG;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA,4BAA4B,uFAAuF;AACnH;AACA;AACA;AACA;AACA,+CAA+C,GAAG;AAClD,sCAAsC;AACtC;AACA,oEAAoE,uBAAuB,IAAI,mBAAmB;AAClH;AACA,kDAAkD,sCAAsC;AACxF,4BAA4B,IAAI,0EAA0E;AAC1G;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,wCAAwC,GAAG;AAC3C,kCAAkC;AAClC;AACA,gEAAgE,uBAAuB,IAAI,mBAAmB;AAC9G;AACA,2CAA2C,sCAAsC;AACjF,wBAAwB,IAAI,4DAA4D;AACxF;AACA;AACA;AACA;AACA,qGAAqG,cAAc;AACnH;AACA;AACA;AACA,4BAA4B,qFAAqF;AACjH;AACA;AACA;AACA,4CAA4C,GAAG;AAC/C,sCAAsC;AACtC;AACA,oEAAoE,uBAAuB,IAAI,mBAAmB;AAClH;AACA,+CAA+C,sCAAsC;AACrF,4BAA4B,IAAI,4DAA4D;AAC5F;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,YAAY,GAAG,YAAY,IAAI,aAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qFAAiB;AAC9C;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,0BAA0B,wCAAwC;AAClE,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yEAAa;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,uBAAuB,8EAAa;AACpC,aAAa;AACb;AACA,uBAAuB,0EAAW,CAAC,2FAAsB;AACzD,aAAa;AACb;AACA,sDAAsD,mEAAO;AAC7D,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,kBAAkB;AAClB;AACA;AACA;AACA,iCAAiC,8EAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8EAAa;AACrC;AACA,6BAA6B,8EAAa;AAC1C;AACA;AACA;AACA,uBAAuB,8EAAa;AACpC,uBAAuB,8EAAa;AACpC;AACA;AACA,sCAAsC,8EAAa;AACnD;AACA,wCAAwC,8EAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8EAAa;AACtC,wBAAwB,8EAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8EAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8EAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,aAAa,IAAI;AACjD;AACA;AACA,iCAAiC,aAAa;AAC9C,kCAAkC,aAAa;AAC/C;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA,IAAI,2FAAsB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,eAAe,WAAW;AAC1B;AACA,IAAI,2FAAsB;AAC1B;AACA,gBAAgB,qEAAW;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,sGAAwB;AAC/D;AACA,kBAAkB,4BAA4B,oGAAuB;AACrE;;AAEA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B,wGAAyB;AACvE;AACA,kBAAkB,oBAAoB,oGAAuB;AAC7D;AACA,kBAAkB,oBAAoB,gGAAqB;AAC3D;AACA,kBAAkB,oBAAoB,wGAAyB;AAC/D;AACA,kBAAkB,oBAAoB,oGAAuB;AAC7D;AACA,kBAAkB,oBAAoB,oGAAuB;AAC7D;AACA,kBAAkB,oBAAoB,sGAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA,IAAI,+FAAwB;AAC5B,gBAAgB,qEAAW;AAC3B,4BAA4B,2EAAY;AACxC,qCAAqC,2EAAY;AACjD,8BAA8B,2EAAY;AAC1C,uCAAuC,2EAAY;;AAEnD,2BAA2B,2EAAY;AACvC,oCAAoC,2EAAY;AAChD,6BAA6B,2EAAY;AACzC,sCAAsC,2EAAY;;AAElD,6BAA6B,2EAAY;AACzC,sCAAsC,2EAAY;AAClD,+BAA+B,2EAAY;AAC3C,wCAAwC,2EAAY;;AAEpD,0BAA0B,2EAAY;AACtC,mCAAmC,2EAAY;AAC/C,4BAA4B,2EAAY;AACxC,qCAAqC,2EAAY;;AAEjD,8BAA8B,2EAAY;AAC1C,wCAAwC,2EAAY;;AAEpD,6BAA6B,2EAAY;AACzC,uCAAuC,2EAAY;;AAEnD,8BAA8B,2EAAY;AAC1C,2BAA2B,2EAAY;;AAEvC,QAAQ,2FAAsB;AAC9B;;AAEA;AACA,2GAA8B,GAAG,2FAAsB;;AAEvD,yDAAe,qEAAW,EAAC;;;;;;;;;;;ACp0M3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;AACa;AACL;;AAEjC;AACA;AACA;AACA;AACA,iFAAiB;AACjB;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,iCAAiC;AACjC,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B;AACA;AACA;;AAEA,aAAa,0EAAW;AACxB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sDAAsD,oGAAuB;AAC7E,6BAA6B,8EAAa;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,iCAAiC;AACjC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAe,iFAAiB,EAAC;;;;;;;;;;;;;;;;;;;AC1iBjC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;AACa;AACN;AACD;AACG;AACM;AACI;AACX;AACA;AACF;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,2DAAG;AACjB,yBAAyB,+DAAQ;AACjC,2BAA2B,iEAAU;AACrC,yBAAyB,6EAAY;AACrC;AACA;;AAEA;AACA;AACA;AACA,eAAe,2BAA2B,iDAAiD,6BAA6B;AACxH;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA,2EAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA,sDAAsD,+BAA+B;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,2DAAM;AACd,sBAAsB,2DAAM;AAC5B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mEAAU;AACV,IAAI,+FAAwB;AAC5B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;;AAEA,0CAA0C,8EAAa;AACvD;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,wBAAwB,2BAA2B;AACnD,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,gCAAgC,0EAAW;AAC3C;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA,oBAAoB,0EAAW;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA,oBAAoB,4EAAY;AAChC;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB,uEAAY;AACjC,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,oEAAQ;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,oBAAoB,0EAAW;AAC/B;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,oEAAQ;AAC5B,wBAAwB,oEAAQ;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC,gDAAgD;AAChD,uBAAuB;AACvB;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,8EAAa;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,0EAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,sEAAS;AAC7B;AACA;AACA;AACA;AACA,kBAAkB,SAAS,0EAAW;AACtC;AACA;AACA;AACA;AACA,kBAAkB,SAAS,4EAAY;AACvC;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,UAAU;AAC7B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB,6CAA6C;AAC7C;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,yCAAyC;AACzC,0BAA0B;AAC1B,kBAAkB;AAClB;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6EAA6E,EAAE;AAC/E,wDAAwD;AACxD;AACA,gCAAgC,EAAE;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,iBAAiB;AACrD;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,oBAAoB;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAA0D,8EAAa;AACvE;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C,uBAAuB,8EAAa;AACpC;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,oBAAoB;AACvC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA,mCAAmC,sGAAwB;AAC3D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,8FAAoB;AACtD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd,mCAAmC,oGAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA,8BAA8B,0FAAmB;AACjD;AACA;;AAEA;;AAEA;AACA,cAAc;AACd;AACA,oBAAoB,0EAAW;AAC/B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,2DAAI;AACpB,gCAAgC,yGAA2B;AAC3D,gBAAgB,yGAA2B,GAAG,6HAAqC;AACnF;;AAEA;AACA,qBAAqB,0EAAW;AAChC;AACA;;AAEA,4BAA4B,kBAAkB;AAC9C;AACA,mCAAmC,uGAA4B;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,oBAAoB,2DAAI;AACxB,oBAAoB,yGAA2B;AAC/C;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA,sBAAsB,oEAAQ;AAC9B,sBAAsB,oEAAQ;AAC9B,sBAAsB,oEAAQ;;AAE9B;AACA,0DAA0D;AAC1D;AACA,+BAA+B;AAC/B,kBAAkB;;AAElB;AACA,SAAS;;AAET;AACA;AACA,YAAY,mCAAmC;AAC/C,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,0EAAW;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,4EAAY;AAC5B,4BAA4B,iBAAiB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,OAAO;AACtD,wBAAwB,0EAAW;AACnC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB,qBAAqB,0EAAW;AAChC,oBAAoB,0EAAW;AAC/B;AACA;AACA;AACA;;AAEA,gBAAgB,4EAAY;AAC5B,4BAA4B,iBAAiB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,OAAO;AACtD,wBAAwB,0EAAW;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,mDAAmD;AACnD;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA,gBAAgB,4EAAY;AAC5B;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,OAAO;AACtD,wBAAwB,0EAAW;AACnC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,sBAAsB,oEAAQ;;AAE9B;AACA;AACA;AACA,oBAAoB,0EAAW,YAAY,0EAAW;AACtD;AACA;AACA,kBAAkB,SAAS,0EAAW;AACtC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,kFAAe;AAC/B;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D,6CAA6C,iBAAiB,QAAQ;AACtE;AACA;AACA;AACA,mDAAmD,cAAc;AACjE,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D,oDAAoD,UAAU;AAC9D,gDAAgD,gBAAgB,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B,gBAAgB,4EAAY;AAC5B;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,4EAAY;AAC7C;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,mEAAO;AACrE;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,0EAAW;AAC3C;AACA;AACA;;AAEA,gDAAgD,kBAAkB;AAClE,+CAA+C,8EAAa;AAC5D;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA,gDAAgD,0EAAW;AAC3D;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,iBAAiB;AACzD;AACA,oCAAoC,0EAAW;AAC/C,oCAAoC,0EAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,gBAAgB;AAChE;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,0EAAW;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mEAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0EAAW;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4EAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,8BAA8B;AAC9B;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,kCAAkC;AAClC;AACA;AACA;AACA,sCAAsC;AACtC;AACA,mCAAmC;AACnC;AACA,mCAAmC;AACnC;AACA;AACA,uFAAuF,4CAA4C,6CAA6C,+CAA+C;AAC/N;AACA;AACA,+FAA+F;AAC/F;AACA,mCAAmC,oCAAoC;AACvE,2GAA2G;AAC3G,oCAAoC;AACpC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,wCAAwC;AACxC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6BAA6B;AACzE;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,SAAS;AAC5B,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,0EAAW,SAAS,0EAAW;AAC/C;AACA,sBAAsB,0EAAW;AACjC;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,oBAAoB;AACvC,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,oBAAoB;AACvC,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,eAAe;AAClC,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,UAAU;AAC7B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C,qBAAqB;AACrB;AACA;AACA,iBAAiB,0EAAW,UAAU,0EAAW;AACjD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,qBAAqB;AACrB;AACA;AACA,iBAAiB,0EAAW,SAAS,0EAAW;AAChD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,mBAAmB;AACtC,qBAAqB;AACrB;AACA;AACA,iBAAiB,0EAAW,UAAU,0EAAW;AACjD;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C,mBAAmB,wBAAwB;AAC3C,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,kFAAe;AAC/B,gBAAgB,kFAAe;;AAE/B,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,sBAAsB,iEAAY;AAClC,cAAc,SAAS,4EAAY,OAAO,4EAAY;AACtD;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA,cAAc,SAAS,8EAAa,OAAO,8EAAa;AACxD;AACA,cAAc,SAAS,8EAAa,OAAO,8EAAa;AACxD;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C,mBAAmB,wBAAwB;AAC3C,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,kFAAe;AAC/B,gBAAgB,kFAAe;;AAE/B,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,sBAAsB,iEAAY;AAClC,cAAc,SAAS,4EAAY,OAAO,4EAAY;AACtD;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA,cAAc,SAAS,8EAAa,OAAO,8EAAa;AACxD;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,kFAAe;;AAE/B,gBAAgB,+EAAmB;AACnC,sBAAsB,2EAAiB;AACvC,cAAc,SAAS,4EAAY;AACnC;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA,cAAc,SAAS,8EAAa;AACpC;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,cAAc;AACjC,qBAAqB,cAAc;AACnC;AACA;AACA;;AAEA,gBAAgB,kFAAe;AAC/B,gBAAgB,kFAAe;;AAE/B,gBAAgB,4EAAY,OAAO,8EAAa;AAChD;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,sBAAsB,iEAAY;AAClC,cAAc,SAAS,4EAAY,OAAO,4EAAY;AACtD;AACA,sBAAsB,qFAAgB;AACtC,cAAc,SAAS,8EAAa,OAAO,4EAAY;AACvD;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA,cAAc,SAAS,8EAAa,OAAO,8EAAa;AACxD;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,kFAAe;AAC/B,gBAAgB,kFAAe;;AAE/B,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,sBAAsB,iEAAY;AAClC,cAAc,SAAS,4EAAY,OAAO,8EAAa;AACvD;AACA;;AAEA,4BAA4B,SAAS;AACrC;AACA;AACA,cAAc,SAAS,8EAAa,OAAO,8EAAa;AACxD;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,kFAAe;AAC/B,gBAAgB,kFAAe;;AAE/B,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,uBAAuB,mEAAa;AACpC,cAAc,SAAS,4EAAY,OAAO,8EAAa;AACvD;AACA;;AAEA,4BAA4B,SAAS;AACrC,6BAA6B,mEAAO;AACpC;AACA,cAAc,SAAS,8EAAa,OAAO,8EAAa;AACxD,sBAAsB,mEAAO;AAC7B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC,qBAAqB;AACrB;AACA;AACA,gBAAgB,kFAAe;AAC/B,gBAAgB,kFAAe;;AAE/B,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,uBAAuB,iEAAY;AACnC;AACA,mBAAmB,mEAAO;AAC1B,SAAS;;AAET;AACA,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,uBAAuB,+DAAW;AAClC;AACA;AACA,SAAS;AACT;AACA,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,uBAAuB,iEAAY;AACnC;AACA;AACA,SAAS;AACT;AACA,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D,uBAAuB,+DAAW;AAClC;AACA;AACA,SAAS;AACT;AACA,gBAAgB,+EAAmB,OAAO,+EAAmB;AAC7D;AACA;AACA;AACA,SAAS;;AAET;AACA,iBAAiB,0EAAW;AAC5B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,qBAAqB,GAAG;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,gBAAgB,mEAAU;AAC1B,gBAAgB,mEAAU;AAC1B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,mEAAU;AACpC,wBAAwB,iGAAyB,OAAO,mEAAU;AAClE,8BAA8B,mEAAU;AACxC;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA,oBAAoB,oEAAQ;;AAE5B;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,uEAAS;AACpC,0BAA0B,qEAAQ;AAClC,2BAA2B,uEAAS;AACpC,8BAA8B,6EAAY;AAC1C,0BAA0B,qEAAQ;AAClC,0BAA0B,qEAAQ;AAClC,yBAAyB,mEAAO;AAChC,yBAAyB,mFAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAO;AAChC,0BAA0B,qEAAQ;AAClC,0BAA0B,qEAAQ;AAClC,+BAA+B,+EAAa;AAC5C,yBAAyB,mEAAO;AAChC,wBAAwB,qEAAQ;AAChC,yBAAyB,mEAAO;AAChC,wBAAwB,qEAAQ;AAChC,wBAAwB,uEAAS;AACjC;AACA,yBAAyB,mEAAO;AAChC,2BAA2B,uEAAS;AACpC,0BAA0B,qEAAQ;AAClC,0BAA0B,qEAAQ;AAClC,2BAA2B,uEAAS;AACpC,6BAA6B,2EAAW;AACxC,yBAAyB,mEAAO;AAChC,yBAAyB,uEAAY;AACrC,4BAA4B,yEAAU;AACtC,2BAA2B,wEAAU;AACrC,0BAA0B,qEAAQ;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,+DAAQ;AACrC,6BAA6B,+DAAQ;AACrC,mCAAmC,2DAAG;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,SAAS,2EAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS,uEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,mEAAU;AAClC;AACA;AACA,kBAAkB;AAClB,qBAAqB,mEAAU;AAC/B;AACA;AACA;AACA,wBAAwB,mEAAU;AAClC;AACA,kBAAkB;AAClB;AACA,wBAAwB,mEAAU;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,+EAAa;AACpC;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,2CAA2C,iBAAiB;AAC5D,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,+EAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mCAAmC,4CAA4C;AAC/E,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oJAAoJ;AACpJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB,KAAK;AACjD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,8BAA8B,0CAA0C;AACxE,8BAA8B,0CAA0C;AACxE,8BAA8B,SAAS;AACvC;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,8BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,cAAc;AAC5B;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8BAA8B,6CAA6C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,cAAc;AAC5B,cAAc,gCAAgC;AAC9C,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,cAAc,4BAA4B;AAC1C;AACA,cAAc,cAAc;AAC5B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,aAAa;AAC3B;AACA;AACA;AACA,cAAc,cAAc;AAC5B,8BAA8B,SAAS;AACvC;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,cAAc;AAC5B;AACA,8BAA8B,2BAA2B;AACzD,8BAA8B,oCAAoC;AAClE,8BAA8B,oCAAoC;AAClE,8BAA8B,oCAAoC;AAClE;AACA,cAAc,kBAAkB;AAChC,cAAc,uBAAuB;AACrC;AACA,cAAc,cAAc;AAC5B,cAAc,uBAAuB;AACrC,8BAA8B,kBAAkB;AAChD,8BAA8B,kBAAkB;AAChD,8BAA8B,kBAAkB;AAChD,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8BAA8B,2BAA2B;AACzD,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,cAAc;AAC5B;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,cAAc,cAAc;AAC5B;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,kDAAkD;AAC5E;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,0CAA0C;AAC1C,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb,kEAAkE;AAClE;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,IAAI,UAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,QAAQ,KAA6B,IAAI,4CAAY;AACrD;AACA;AACA;AACA;AACA;;AAEA,yDAAe,2EAAc,EAAC;;;;;;;;;;;ACnrN9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEyB;AACC;AACK;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kCAAkC,IAAI,YAAY,IAAI,YAAY,IAAI,eAAe,IAAI;AACzF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iCAAiC,IAAI,YAAY,IAAI,YAAY,IAAI;AACrE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,EAAE,KAAK,EAAE,KAAK,EAAE;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,EAAE,KAAK,EAAE,KAAK,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA,yEAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,oEAAW;AACpB;AACA;;AAEA,QAAQ,oEAAW,QAAQ,oEAAW;AACtC;AACA;;AAEA;;AAEA;AACA,QAAQ,sEAAY;AACpB,oBAAoB,OAAO;AAC3B;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA,qEAAW;AACX;;AAEA,QAAQ,yEAAa;;AAErB;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA,qEAAW;AACX;;AAEA,QAAQ,yEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,oBAAoB,mBAAmB;AACvC,aAAa,QAAQ;AACrB;AACA,qEAAW;AACX,IAAI,2EAAc;AAClB,WAAW,qEAAW;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA,qEAAW;AACX;;AAEA;;AAEA;AACA,4BAA4B,mEAAO;AACnC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA,qEAAW;AACX;;AAEA,QAAQ,yEAAa;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA,qEAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,yEAAa;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA,qEAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA,yEAAa;AACb;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA,yEAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA,mEAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,yEAAa;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA,mEAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,qEAAW;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA,UAAU,qEAAW;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA,iFAAiB;AACjB,cAAc,yEAAa;AAC3B;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA,eAAe,yEAAa;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA,uEAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,yEAAa;;AAEvB;AACA,eAAe,yEAAa;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA;AACA,uFAAoB;AACpB,IAAI,+GAAgC;AACpC,IAAI,2GAA8B;AAClC,IAAI,yGAA6B;AACjC,IAAI,qGAA2B;AAC/B,IAAI,uHAAoC;AACxC,IAAI,yGAA6B;AACjC,IAAI,qHAAmC;AACvC,IAAI,qGAA2B;AAC/B,IAAI,qHAAmC;AACvC,IAAI,yHAAqC;AACzC,IAAI,uHAAoC;AACxC,IAAI,iIAAyC;AAC7C,IAAI,qIAA2C;AAC/C,IAAI,6HAAuC;AAC3C,IAAI,mIAA0C;AAC9C,IAAI,+HAAwC;AAC5C,IAAI,iJAAiD;AACrD,IAAI,yGAA6B;AACjC,IAAI,yGAA6B;AACjC,IAAI,+GAAgC;AACpC,IAAI,yHAAqC;AACzC,IAAI,6HAAuC;AAC3C,IAAI,+GAAgC;AACpC,IAAI,2GAA8B;AAClC,IAAI,uHAAoC;AACxC,IAAI,yHAAqC;AACzC,IAAI,uGAA4B;AAChC,IAAI,qGAA2B;AAC/B,IAAI,yGAA6B;AACjC,IAAI,yGAA6B;AACjC,IAAI,2HAAsC;AAC1C,IAAI,+HAAwC;AAC5C,IAAI,2HAAsC;AAC1C,IAAI,uHAAoC;AACxC,IAAI,yIAA6C;AACjD,IAAI,6IAA+C;AACnD,IAAI,yIAA6C;AACjD,IAAI,+GAAgC;AACpC,IAAI,uGAA4B;AAChC,IAAI,yHAAqC;AACzC,IAAI,6HAAuC;AAC3C,IAAI,iIAAyC;AAC7C,IAAI,qHAAmC;AACvC,IAAI,uIAA4C;AAChD,IAAI,uHAAoC;AACxC;;AAEA,mEAAU;AACV,IAAI,qDAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oCAAoC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gCAAgC;AACrF;AACA;AACA,qEAAW,GAAG,6EAAe;;AAE7B,yDAAe,qDAAG,EAAC;;;;;;;;;;ACrhCnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEyB;AACC;;AAE1B,qFAAmB;AACnB,IAAI,qDAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAU;AACV,IAAI,qDAAG;AACP;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA,mBAAmB,mEAAU,KAAK,iFAAiB;AACnD,SAAS;;AAET;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA,mBAAmB,mEAAU;AAC7B,SAAS;;AAET;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA,oBAAoB,+EAAgB,UAAU,mFAAkB;AAChE,SAAS;;AAET;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;;AAEA,gBAAgB,+EAAgB;AAChC,wBAAwB,iFAAiB;AACzC;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA,8BAA8B,mGAA0B;;AAExD,gBAAgB,mFAAkB;AAClC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,KAA0B,GAAG,mBAAc,CAAC,GAAQ,IAAI,CAAgB;AAChG;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,2EAA2E;AAC3E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gBAAgB,oEAAW;AAC3B;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gBAAgB,oEAAW;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gBAAgB,oEAAW;AAC3B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gBAAgB,oEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;;AAEd;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,oEAAW;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,oEAAW;AACxD;AACA;AACA;;AAEA;AACA,gBAAgB,oEAAW,SAAS,oEAAW;AAC/C,6CAA6C;AAC7C;AACA;;AAEA;AACA,gBAAgB,oEAAW,SAAS,oEAAW;AAC/C;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA,iBAAiB,oEAAW;AAC5B,gBAAgB,iEAAS;AACzB;AACA;;AAEA,iBAAiB,oEAAW;AAC5B,gBAAgB,iEAAS;AACzB;AACA;;AAEA,iBAAiB,sEAAY;AAC7B,gBAAgB,iEAAS;AACzB;AACA;;AAEA,gBAAgB,sEAAY;;AAE5B;AACA,gBAAgB,iEAAS;AACzB;AACA;;AAEA;AACA;AACA,oBAAoB,oEAAW,SAAS,oEAAW;AACnD;AACA;;AAEA;AACA,oBAAoB,oEAAW,SAAS,oEAAW;AACnD;AACA;AACA,cAAc;AACd,gBAAgB,iEAAS;AACzB;;AAEA;AACA,SAAS;;AAET;AACA,uEAAuE;AACvE,iBAAiB,iBAAiB;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C,oBAAoB,6EAAe;AACnC;;AAEA;AACA,oBAAoB,iEAAS;AAC7B;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,iFAAiB;;AAE5C;AACA,gBAAgB,oEAAW;AAC3B;AACA;;AAEA,gBAAgB,oEAAW,WAAW,oEAAW;AACjD;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,6BAA6B,yEAAa;AACxD;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,SAAS;AAC3C,oBAAoB,oEAAW;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAmD,UAAU;AAC7D;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,oEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,OAAO,yDAAyD,oCAAoC;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,sCAAsC,SAAS;AAC/C,wBAAwB,oEAAW;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAmD,UAAU;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,oEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA,uEAAuE,aAAa;AACpF;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,qDAAG,EAAC;;;;;;;;;;ACh+BnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACC;;AAE1B;AACA;AACA;AACA;AACA,+EAAgB;AAChB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,sEAAY;AACzB;AACA;;AAEA,kBAAkB,8DAAQ;;AAE1B;AACA;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA,uBAAuB,sEAAY;AACnC;AACA;;AAEA;AACA,gBAAgB,sEAAY;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,+EAAgB,EAAC;;;;;;;;;;;;AC/JhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEyB;AACC;AACY;AACF;;AAEpC;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,SAAS;AACxB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,YAAY,oEAAW;AACvB;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,SAAS;AACxB;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,oCAAoC,sGAAwB;AAC5D;AACA,UAAU;AACV;AACA;;AAEA;AACA,wBAAwB,6DAAM,CAAC,8FAAoB;AACnD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,eAAe,SAAS;AACxB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA,aAAa,sEAAY;AACzB;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mEAAU;;AAEV,yDAAe,MAAM,EAAC;;;;;;;;;;AC3HtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEyB;AACa;;AAEtC,mEAAU;AACV,IAAI,qDAAG;AACP;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,0CAA0C,sGAAwB;AAClE;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sHAAgC;AACtE;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA,qBAAqB;AACrB,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B,uBAAuB,mFAAkB;AACzC;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,wBAAwB;AAC3C,mBAAmB,WAAW;AAC9B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,SAAS;AAC5B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2EAA2E;;AAE3E;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,OAAO;AAC1B;AACA,sBAAsB,iBAAiB;AACvC,sBAAsB,gCAAgC,IAAI,iBAAiB;AAC3E,sBAAsB,8BAA8B,IAAI,iBAAiB;AACzE;AACA;AACA,kCAAkC,WAAW,cAAc,WAAW;AACtE,uEAAuE;AACvE;AACA;AACA,mBAAmB,QAAQ,6DAA6D;AACxF,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO,uBAAuB,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,OAAO;AAC1B;AACA,sBAAsB,mBAAmB;AACzC,sBAAsB,gCAAgC,IAAI,mBAAmB;AAC7E,sBAAsB,8BAA8B,IAAI,mBAAmB;AAC3E;AACA;AACA,kCAAkC,WAAW,cAAc,WAAW,cAAc,WAAW;AAC/F,uEAAuE;AACvE;AACA;AACA,mBAAmB,QAAQ,gEAAgE;AAC3F,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO,uBAAuB,mBAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,UAAU;AAC7B,mBAAmB,QAAQ;AAC3B,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,OAAO;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD,mCAAmC,yEAAa;AAChD;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,gBAAgB;AACxC;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,qBAAqB;AACrB;AACA;AACA,mBAAmB,qEAAW;AAC9B,SAAS;;AAET;AACA,iCAAiC,kBAAkB;AACnD,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,qBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA,gBAAgB,6DAAO;;AAEvB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC,sBAAsB,WAAW;AACjC,sBAAsB,WAAW;AACjC,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B,oBAAoB,QAAQ;AAC5B,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA,iEAAiE,cAAc;AAC/E;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,2DAA2D,oBAAoB;AAC/E;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,oBAAoB;AACxD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,2EAA2E,SAAS,kBAAkB;AACtG;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,uEAAY;AAChC,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAY;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAY;AACtC;AACA,sBAAsB,uEAAY;;AAElC;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA,sBAAsB,6DAAO;;AAE7B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,gBAAgB;AACxD,0CAA0C,mEAAU;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,mEAAU;AACpD,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA,iCAAiC,wBAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,qBAAqB;AACxC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,4CAA4C,QAAQ,IAAI,OAAO,QAAQ,GAAG,WAAW,QAAQ,GAAG;AAChG,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA,2CAA2C,sBAAsB,sBAAsB;AACvF,SAAS;;AAET;AACA,sDAAsD,SAAS;AAC/D,gBAAgB,KAAK,QAAQ,OAAO,IAAI,OAAO,WAAW,IAAI,OAAO;AACrE,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B,8BAA8B;AAC9B,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,iBAAiB;AACpC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,SAAS;AAC5B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,sBAAsB;AACnE;;AAEA;AACA,SAAS;;AAET;AACA;AACA,mBAAmB,GAAG;AACtB,qBAAqB,GAAG;AACxB;AACA;AACA,gCAAgC,sGAAwB;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yDAAe,qDAAG,EAAC;;;;;;;;;AC78CnB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEyB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+DAAQ,GAAG,+DAAQ;;AAEnB,+EAAgB;AAChB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAgB,QAAQ;AACxB;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAe,+DAAQ,EAAC;;;;;;;;AC1DxB;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WC5BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA;;;;;WCVA,8CAA8C;;;;;UEA9C;UACA;UACA;UACA","sources":["webpack://JXG/webpack/universalModuleDefinition","webpack://JXG/./src/base/constants.js","webpack://JXG/./src/base/coords.js","webpack://JXG/./src/base/coordselement.js","webpack://JXG/./src/base/element.js","webpack://JXG/./src/base/text.js","webpack://JXG/./src/utils/xml.js","webpack://JXG/./src/math/probfuncs.js","webpack://JXG/./src/math/extrapolate.js","webpack://JXG/./src/math/qdt.js","webpack://JXG/./src/math/nlp.js","webpack://JXG/./src/math/plot.js","webpack://JXG/./src/math/metapost.js","webpack://JXG/./src/utils/zip.js","webpack://JXG/./src/utils/encoding.js","webpack://JXG/./src/utils/base64.js","webpack://JXG/./src/server/server.js","webpack://JXG/./src/math/symbolic.js","webpack://JXG/./src/math/clip.js","webpack://JXG/./src/math/poly.js","webpack://JXG/./src/math/complex.js","webpack://JXG/./src/renderer/abstract.js","webpack://JXG/./src/reader/file.js","webpack://JXG/./src/base/composition.js","webpack://JXG/./src/base/board.js","webpack://JXG/./src/renderer/svg.js","webpack://JXG/./src/renderer/vml.js","webpack://JXG/./src/renderer/canvas.js","webpack://JXG/./src/renderer/no.js","webpack://JXG/./src/jsxgraph.js","webpack://JXG/./src/base/point.js","webpack://JXG/./src/base/line.js","webpack://JXG/./src/base/group.js","webpack://JXG/./src/element/conic.js","webpack://JXG/./src/base/circle.js","webpack://JXG/./src/base/polygon.js","webpack://JXG/./src/base/curve.js","webpack://JXG/./src/element/arc.js","webpack://JXG/./src/element/sector.js","webpack://JXG/./src/base/transformation.js","webpack://JXG/./src/element/composition.js","webpack://JXG/./src/element/locus.js","webpack://JXG/./src/base/image.js","webpack://JXG/./src/element/slider.js","webpack://JXG/./src/element/measure.js","webpack://JXG/./src/parser/datasource.js","webpack://JXG/./src/base/chart.js","webpack://JXG/./src/base/turtle.js","webpack://JXG/./src/base/ticks.js","webpack://JXG/./src/parser/ca.js","webpack://JXG/./src/utils/dump.js","webpack://JXG/./src/element/comb.js","webpack://JXG/./src/element/slopetriangle.js","webpack://JXG/./src/element/checkbox.js","webpack://JXG/./src/element/input.js","webpack://JXG/./src/element/button.js","webpack://JXG/./src/base/foreignobject.js","webpack://JXG/./src/options3d.js","webpack://JXG/./src/3d/view3d.js","webpack://JXG/./src/3d/element3d.js","webpack://JXG/./src/3d/box3d.js","webpack://JXG/./src/3d/point3d.js","webpack://JXG/./src/3d/curve3d.js","webpack://JXG/./src/3d/linspace3d.js","webpack://JXG/./src/3d/surface3d.js","webpack://JXG/./src/index.js","webpack://JXG/./src/jxg.js","webpack://JXG/./src/math/geometry.js","webpack://JXG/./src/math/ia.js","webpack://JXG/./src/math/math.js","webpack://JXG/./src/math/numerics.js","webpack://JXG/./src/math/statistics.js","webpack://JXG/./src/options.js","webpack://JXG/./src/parser/geonext.js","webpack://JXG/./src/parser/jessiecode.js","webpack://JXG/./src/utils/color.js","webpack://JXG/./src/utils/env.js","webpack://JXG/./src/utils/event.js","webpack://JXG/./src/utils/expect.js","webpack://JXG/./src/utils/type.js","webpack://JXG/./src/utils/uuid.js","webpack://JXG/external umd {\"commonjs\":\"canvas\",\"commonjs2\":\"canvas\",\"root\":\"canvas\"}","webpack://JXG/webpack/bootstrap","webpack://JXG/webpack/runtime/define property getters","webpack://JXG/webpack/runtime/harmony module decorator","webpack://JXG/webpack/runtime/hasOwnProperty shorthand","webpack://JXG/webpack/before-startup","webpack://JXG/webpack/startup","webpack://JXG/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\t//CommonJS2 (nodejs)\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"canvas\"));\n\t//AMD\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\t//CommonJS\n\telse if(typeof exports === 'object')\n\t\texports[\"JXG\"] = factory(require(\"canvas\"));\n\t//Root (browser)\n\telse\n\t\troot[\"JXG\"] = factory(root[\"canvas\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__841__) {\nreturn ","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Andreas Walter,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\n\nvar major = 1,\n    minor = 5,\n    patch = 0,\n    add = \"rc1\", //'dev'\n    version = major + \".\" + minor + \".\" + patch + (add ? \"-\" + add : \"\"),\n    constants;\n\nconstants = /** @lends JXG */ {\n    /**\n     * Constant: the currently used JSXGraph version.\n     *\n     * @name JXG.version\n     * @type String\n     */\n    version: version,\n\n    /**\n     * Constant: the small gray version indicator in the top left corner of every JSXGraph board (if\n     * showCopyright is not set to false on board creation).\n     *\n     * @name JXG.licenseText\n     * @type String\n     */\n    licenseText: \"JSXGraph v\" + version + \" Copyright (C) see https://jsxgraph.org\",\n\n    /**\n     *  Constant: user coordinates relative to the coordinates system defined by the bounding box.\n     *  @name JXG.COORDS_BY_USER\n     *  @type Number\n     */\n    COORDS_BY_USER: 0x0001,\n\n    /**\n     *  Constant: screen coordinates in pixel relative to the upper left corner of the div element.\n     *  @name JXG.COORDS_BY_SCREEN\n     *  @type Number\n     */\n    COORDS_BY_SCREEN: 0x0002,\n\n    // object types\n    OBJECT_TYPE_ARC: 1,\n    OBJECT_TYPE_ARROW: 2,\n    OBJECT_TYPE_AXIS: 3,\n    OBJECT_TYPE_AXISPOINT: 4,\n    OBJECT_TYPE_TICKS: 5,\n    OBJECT_TYPE_CIRCLE: 6,\n    OBJECT_TYPE_CONIC: 7,\n    OBJECT_TYPE_CURVE: 8,\n    OBJECT_TYPE_GLIDER: 9,\n    OBJECT_TYPE_IMAGE: 10,\n    OBJECT_TYPE_LINE: 11,\n    OBJECT_TYPE_POINT: 12,\n    OBJECT_TYPE_SLIDER: 13,\n    OBJECT_TYPE_CAS: 14,\n    OBJECT_TYPE_GXTCAS: 15,\n    OBJECT_TYPE_POLYGON: 16,\n    OBJECT_TYPE_SECTOR: 17,\n    OBJECT_TYPE_TEXT: 18,\n    OBJECT_TYPE_ANGLE: 19,\n    OBJECT_TYPE_INTERSECTION: 20,\n    OBJECT_TYPE_TURTLE: 21,\n    OBJECT_TYPE_VECTOR: 22,\n    OBJECT_TYPE_OPROJECT: 23,\n    OBJECT_TYPE_GRID: 24,\n    OBJECT_TYPE_TANGENT: 25,\n    OBJECT_TYPE_HTMLSLIDER: 26,\n    OBJECT_TYPE_CHECKBOX: 27,\n    OBJECT_TYPE_INPUT: 28,\n    OBJECT_TYPE_BUTTON: 29,\n    OBJECT_TYPE_TRANSFORMATION: 30,\n    OBJECT_TYPE_FOREIGNOBJECT: 31,\n\n    OBJECT_TYPE_VIEW3D: 32,\n    OBJECT_TYPE_POINT3D: 33,\n    OBJECT_TYPE_LINE3D: 34,\n    OBJECT_TYPE_PLANE3D: 35,\n    OBJECT_TYPE_CURVE3D: 36,\n    OBJECT_TYPE_SURFACE3D: 37,\n\n    // IMPORTANT:\n    // ----------\n    // For being able to differentiate between the (sketchometry specific) SPECIAL_OBJECT_TYPEs and\n    // (core specific) OBJECT_TYPEs, the non-sketchometry types MUST NOT be changed\n    // to values > 100.\n\n    // object classes\n    OBJECT_CLASS_POINT: 1,\n    OBJECT_CLASS_LINE: 2,\n    OBJECT_CLASS_CIRCLE: 3,\n    OBJECT_CLASS_CURVE: 4,\n    OBJECT_CLASS_AREA: 5,\n    OBJECT_CLASS_OTHER: 6,\n    OBJECT_CLASS_TEXT: 7,\n    OBJECT_CLASS_3D: 8,\n\n    // SketchReader constants\n    GENTYPE_ABC: 1, // unused\n    GENTYPE_AXIS: 2,\n    GENTYPE_MID: 3,\n\n    /**\n     * @ignore\n     * @deprecated, now use {@link JXG.GENTYPE_REFLECTION_ON_LINE}\n     *\n     */\n    GENTYPE_REFLECTION: 4,\n    /**\n     * @ignore\n     * @deprecated, now use {@link JXG.GENTYPE_REFLECTION_ON_POINT}\n     */\n    GENTYPE_MIRRORELEMENT: 5,\n\n    GENTYPE_REFLECTION_ON_LINE: 4,\n    GENTYPE_REFLECTION_ON_POINT: 5,\n    GENTYPE_TANGENT: 6,\n    GENTYPE_PARALLEL: 7,\n    GENTYPE_BISECTORLINES: 8,\n    GENTYPE_BOARDIMG: 9,\n    GENTYPE_BISECTOR: 10,\n    GENTYPE_NORMAL: 11,\n    GENTYPE_POINT: 12,\n    GENTYPE_GLIDER: 13,\n    GENTYPE_INTERSECTION: 14,\n    GENTYPE_CIRCLE: 15,\n    /**\n     * @ignore @deprecated NOT USED ANY MORE SINCE SKETCHOMETRY 2.0 (only for old constructions needed)\n     */\n    GENTYPE_CIRCLE2POINTS: 16,\n\n    GENTYPE_LINE: 17,\n    GENTYPE_TRIANGLE: 18,\n    GENTYPE_QUADRILATERAL: 19,\n    GENTYPE_TEXT: 20,\n    GENTYPE_POLYGON: 21,\n    GENTYPE_REGULARPOLYGON: 22,\n    GENTYPE_SECTOR: 23,\n    GENTYPE_ANGLE: 24,\n    GENTYPE_PLOT: 25,\n    GENTYPE_SLIDER: 26,\n    GENTYPE_TRUNCATE: 27,\n    GENTYPE_JCODE: 28,\n    GENTYPE_MOVEMENT: 29,\n    GENTYPE_COMBINED: 30,\n    GENTYPE_RULER: 31,\n    GENTYPE_SLOPETRIANGLE: 32,\n    GENTYPE_PERPSEGMENT: 33,\n    GENTYPE_LABELMOVEMENT: 34,\n    GENTYPE_VECTOR: 35,\n    GENTYPE_NONREFLEXANGLE: 36,\n    GENTYPE_REFLEXANGLE: 37,\n    GENTYPE_PATH: 38,\n    GENTYPE_DERIVATIVE: 39,\n    // 40 // unused ...\n    GENTYPE_DELETE: 41,\n    GENTYPE_COPY: 42,\n    GENTYPE_MIRROR: 43,\n    GENTYPE_ROTATE: 44,\n    GENTYPE_ABLATION: 45,\n    GENTYPE_MIGRATE: 46,\n    GENTYPE_VECTORCOPY: 47,\n    GENTYPE_POLYGONCOPY: 48,\n    /**\n     * Constants\n     * @name Constants\n     * @namespace\n     */ //        GENTYPE_TRANSFORM: 48, // unused\n    // 49 ... 50 // unused ...\n\n    // IMPORTANT:\n    // ----------\n    // For being able to differentiate between the (GUI-specific) CTX and\n    // (CORE-specific) non-CTX steps, the non-CTX steps MUST NOT be changed\n    // to values > 50.\n\n    GENTYPE_CTX_TYPE_G: 51,\n    GENTYPE_CTX_TYPE_P: 52,\n    GENTYPE_CTX_TRACE: 53,\n    GENTYPE_CTX_VISIBILITY: 54,\n    GENTYPE_CTX_CCVISIBILITY: 55, // unused\n    GENTYPE_CTX_MPVISIBILITY: 56,\n    GENTYPE_CTX_WITHLABEL: 57,\n    GENTYPE_CTX_LABEL: 58,\n    GENTYPE_CTX_FIXED: 59,\n    GENTYPE_CTX_STROKEWIDTH: 60,\n    GENTYPE_CTX_LABELSIZE: 61,\n    GENTYPE_CTX_SIZE: 62,\n    GENTYPE_CTX_FACE: 63,\n    GENTYPE_CTX_STRAIGHT: 64,\n    GENTYPE_CTX_ARROW: 65,\n    GENTYPE_CTX_COLOR: 66,\n    GENTYPE_CTX_RADIUS: 67,\n    GENTYPE_CTX_COORDS: 68,\n    GENTYPE_CTX_TEXT: 69,\n    GENTYPE_CTX_ANGLERADIUS: 70,\n    GENTYPE_CTX_DOTVISIBILITY: 71,\n    GENTYPE_CTX_FILLOPACITY: 72,\n    GENTYPE_CTX_PLOT: 73,\n    GENTYPE_CTX_SCALE: 74,\n    GENTYPE_CTX_INTVAL: 75,\n    GENTYPE_CTX_POINT1: 76,\n    GENTYPE_CTX_POINT2: 77,\n    GENTYPE_CTX_LABELSTICKY: 78,\n    GENTYPE_CTX_TYPE_I: 79,\n    GENTYPE_CTX_HASINNERPOINTS: 80,\n    GENTYPE_CTX_SNAPWIDTH: 81,\n    GENTYPE_CTX_SNAPTOGRID: 82\n};\n\nJXG.extendConstants(JXG, constants);\n\nexport default constants;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport EventEmitter from \"../utils/event\";\nimport Type from \"../utils/type\";\nimport Mat from \"../math/math\";\n\n/**\n * @fileoverview In this file the Coords object is defined, a class to manage all\n * properties and methods coordinates usually have.\n */\n\n/**\n * Constructs a new Coordinates object.\n * @class This is the Coordinates class.\n * All members a coordinate has to provide\n * are defined here.\n * @param {Number} method The type of coordinates given by the user. Accepted values are <b>COORDS_BY_SCREEN</b> and <b>COORDS_BY_USER</b>.\n * @param {Array} coordinates An array of affine coordinates.\n * @param {JXG.Board} board A reference to a board.\n * @oaram {Boolean} [emitter=true]\n * @borrows JXG.EventEmitter#on as this.on\n * @borrows JXG.EventEmitter#off as this.off\n * @borrows JXG.EventEmitter#triggerEventHandlers as this.triggerEventHandlers\n * @borrows JXG.EventEmitter#eventHandlers as this.eventHandlers\n * @constructor\n */\nJXG.Coords = function (method, coordinates, board, emitter) {\n    /**\n     * Stores the board the object is used on.\n     * @type JXG.Board\n     */\n    this.board = board;\n\n    /**\n     * Stores coordinates for user view as homogeneous coordinates.\n     * @type Array\n     */\n    this.usrCoords = [];\n    //this.usrCoords = new Float64Array(3);\n\n    /**\n     * Stores coordinates for screen view as homogeneous coordinates.\n     * @type Array\n     */\n    this.scrCoords = [];\n    //this.scrCoords = new Float64Array(3);\n\n    /**\n     * If true, this coordinates object will emit update events every time\n     * the coordinates are set.\n     * @type boolean\n     * @default true\n     */\n    this.emitter = !Type.exists(emitter) || emitter;\n\n    if (this.emitter) {\n        EventEmitter.eventify(this);\n    }\n    this.setCoordinates(method, coordinates, false, true);\n};\n\nJXG.extend(\n    JXG.Coords.prototype,\n    /** @lends JXG.Coords.prototype */ {\n        /**\n         * Normalize homogeneous coordinates\n         * @private\n         */\n        normalizeUsrCoords: function () {\n            if (Math.abs(this.usrCoords[0]) > Mat.eps) {\n                this.usrCoords[1] /= this.usrCoords[0];\n                this.usrCoords[2] /= this.usrCoords[0];\n                this.usrCoords[0] = 1.0;\n            }\n        },\n\n        /**\n         * Compute screen coordinates out of given user coordinates.\n         * @private\n         */\n        usr2screen: function (doRound) {\n            var mround = Math.round, // Is faster on IE, maybe slower with JIT compilers\n                b = this.board,\n                uc = this.usrCoords,\n                oc = b.origin.scrCoords;\n\n            if (doRound === true) {\n                this.scrCoords[0] = mround(uc[0]);\n                this.scrCoords[1] = mround(uc[0] * oc[1] + uc[1] * b.unitX);\n                this.scrCoords[2] = mround(uc[0] * oc[2] - uc[2] * b.unitY);\n            } else {\n                this.scrCoords[0] = uc[0];\n                this.scrCoords[1] = uc[0] * oc[1] + uc[1] * b.unitX;\n                this.scrCoords[2] = uc[0] * oc[2] - uc[2] * b.unitY;\n            }\n        },\n\n        /**\n         * Compute user coordinates out of given screen coordinates.\n         * @private\n         */\n        screen2usr: function () {\n            var o = this.board.origin.scrCoords,\n                sc = this.scrCoords,\n                b = this.board;\n\n            this.usrCoords[0] = 1.0;\n            this.usrCoords[1] = (sc[1] - o[1]) / b.unitX;\n            this.usrCoords[2] = (o[2] - sc[2]) / b.unitY;\n        },\n\n        /**\n         * Calculate distance of one point to another.\n         * @param {Number} coord_type The type of coordinates used here. Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.\n         * @param {JXG.Coords} coordinates The Coords object to which the distance is calculated.\n         * @returns {Number} The distance\n         */\n        distance: function (coord_type, coordinates) {\n            var sum = 0,\n                c,\n                ucr = this.usrCoords,\n                scr = this.scrCoords,\n                f;\n\n            if (coord_type === Const.COORDS_BY_USER) {\n                c = coordinates.usrCoords;\n                f = ucr[0] - c[0];\n                sum = f * f;\n\n                if (sum > Mat.eps * Mat.eps) {\n                    return Number.POSITIVE_INFINITY;\n                }\n                f = ucr[1] - c[1];\n                sum += f * f;\n                f = ucr[2] - c[2];\n                sum += f * f;\n            } else {\n                c = coordinates.scrCoords;\n                //f = scr[0]-c[0];\n                //sum = f*f;\n                f = scr[1] - c[1];\n                sum += f * f;\n                f = scr[2] - c[2];\n                sum += f * f;\n            }\n\n            return Math.sqrt(sum);\n        },\n\n        /**\n         * Set coordinates by either user coordinates or screen coordinates and recalculate the other one.\n         * @param {Number} coord_type The type of coordinates used here. Possible values are <b>COORDS_BY_USER</b> and <b>COORDS_BY_SCREEN</b>.\n         * @param {Array} coordinates An array of affine coordinates the Coords object is set to.\n         * @param {Boolean} [doRound=true] flag If true or null round the coordinates in usr2screen. This is used in smooth curve plotting.\n         * The IE needs rounded coordinates. Id doRound==false we have to round in updatePathString.\n         * @param {Boolean} [noevent=false]\n         * @returns {JXG.Coords} Reference to the coords object.\n         */\n        setCoordinates: function (coord_type, coordinates, doRound, noevent) {\n            var uc = this.usrCoords,\n                sc = this.scrCoords,\n                // Original values\n                ou = [uc[0], uc[1], uc[2]],\n                os = [sc[0], sc[1], sc[2]];\n\n            if (coord_type === Const.COORDS_BY_USER) {\n                if (coordinates.length === 2) {\n                    // Euclidean coordinates\n                    uc[0] = 1.0;\n                    uc[1] = coordinates[0];\n                    uc[2] = coordinates[1];\n                } else {\n                    // Homogeneous coordinates (normalized)\n                    uc[0] = coordinates[0];\n                    uc[1] = coordinates[1];\n                    uc[2] = coordinates[2];\n                    this.normalizeUsrCoords();\n                }\n                this.usr2screen(doRound);\n            } else {\n                if (coordinates.length === 2) {\n                    // Euclidean coordinates\n                    sc[1] = coordinates[0];\n                    sc[2] = coordinates[1];\n                } else {\n                    // Homogeneous coordinates (normalized)\n                    sc[1] = coordinates[1];\n                    sc[2] = coordinates[2];\n                }\n                this.screen2usr();\n            }\n\n            if (this.emitter && !noevent && (os[1] !== sc[1] || os[2] !== sc[2])) {\n                this.triggerEventHandlers([\"update\"], [ou, os]);\n            }\n\n            return this;\n        },\n\n        /**\n         * Copy array, either scrCoords or usrCoords\n         * Uses slice() in case of standard arrays and set() in case of\n         * typed arrays.\n         * @private\n         * @param {String} obj Either 'scrCoords' or 'usrCoords'\n         * @param {Number} offset Offset, defaults to 0 if not given\n         * @returns {Array} Returns copy of the coords array either as standard array or as\n         *   typed array.\n         */\n        copy: function (obj, offset) {\n            if (offset === undefined) {\n                offset = 0;\n            }\n\n            return this[obj].slice(offset);\n        },\n\n        /**\n         * Test if one of the usrCoords is NaN or the coordinates are infinite.\n         * @returns {Boolean} true if the coordinates are finite, false otherwise.\n         */\n        isReal: function () {\n            return (\n                !isNaN(this.usrCoords[1] + this.usrCoords[2]) &&\n                Math.abs(this.usrCoords[0]) > Mat.eps\n            );\n        },\n\n        /**\n         * Triggered whenever the coordinates change.\n         * @name JXG.Coords#update\n         * @param {Array} ou Old user coordinates\n         * @param {Array} os Old screen coordinates\n         * @event\n         */\n        __evt__update: function (ou, os) {},\n\n        /**\n         * @ignore\n         */\n        __evt: function () {}\n    }\n);\n\nexport default JXG.Coords;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, console: true, window: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The geometry object CoordsElement is defined in this file.\n * This object provides the coordinate handling of points, images and texts.\n */\n\nimport JXG from \"../jxg\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Numerics from \"../math/numerics\";\nimport Statistics from \"../math/statistics\";\nimport Coords from \"./coords\";\nimport Const from \"./constants\";\nimport Type from \"../utils/type\";\n\n/**\n * An element containing coords is the basic geometric element. Based on points lines and circles can be constructed which can be intersected\n * which in turn are points again which can be used to construct new lines, circles, polygons, etc. This class holds methods for\n * all kind of coordinate elements like points, texts and images.\n * @class Creates a new coords element object. Do not use this constructor to create an element.\n *\n * @private\n * @augments JXG.GeometryElement\n * @param {Array} coordinates An array with the affine user coordinates of the point.\n * {@link JXG.Options#elements}, and - optionally - a name and an id.\n */\nJXG.CoordsElement = function (coordinates, isLabel) {\n    var i;\n\n    if (!Type.exists(coordinates)) {\n        coordinates = [1, 0, 0];\n    }\n\n    for (i = 0; i < coordinates.length; ++i) {\n        coordinates[i] = parseFloat(coordinates[i]);\n    }\n\n    /**\n     * Coordinates of the element.\n     * @type JXG.Coords\n     * @private\n     */\n    this.coords = new Coords(Const.COORDS_BY_USER, coordinates, this.board);\n    this.initialCoords = new Coords(Const.COORDS_BY_USER, coordinates, this.board);\n\n    /**\n     * Relative position on a slide element (line, circle, curve) if element is a glider on this element.\n     * @type Number\n     * @private\n     */\n    this.position = null;\n\n    /**\n     * True if there the method this.updateConstraint() has been set. It is\n     * probably different from the prototype function() {return this;}.\n     * Used in updateCoords fo glider elements.\n     *\n     * @see JXG.CoordsElement#updateCoords\n     * @type Boolean\n     * @private\n     */\n    this.isConstrained = false;\n\n    /**\n     * Determines whether the element slides on a polygon if point is a glider.\n     * @type Boolean\n     * @default false\n     * @private\n     */\n    this.onPolygon = false;\n\n    /**\n     * When used as a glider this member stores the object, where to glide on.\n     * To set the object to glide on use the method\n     * {@link JXG.Point#makeGlider} and DO NOT set this property directly\n     * as it will break the dependency tree.\n     * @type JXG.GeometryElement\n     */\n    this.slideObject = null;\n\n    /**\n     * List of elements the element is bound to, i.e. the element glides on.\n     * Only the last entry is active.\n     * Use {@link JXG.Point#popSlideObject} to remove the currently active slideObject.\n     */\n    this.slideObjects = [];\n\n    /**\n     * A {@link JXG.CoordsElement#updateGlider} call is usually followed\n     * by a general {@link JXG.Board#update} which calls\n     * {@link JXG.CoordsElement#updateGliderFromParent}.\n     * To prevent double updates, {@link JXG.CoordsElement#needsUpdateFromParent}\n     * is set to false in updateGlider() and reset to true in the following call to\n     * {@link JXG.CoordsElement#updateGliderFromParent}\n     * @type Boolean\n     */\n    this.needsUpdateFromParent = true;\n\n    /**\n     * Stores the groups of this element in an array of Group.\n     * @type Array\n     * @see JXG.Group\n     * @private\n     */\n    this.groups = [];\n\n    /*\n     * Do we need this?\n     */\n    this.Xjc = null;\n    this.Yjc = null;\n\n    // documented in GeometryElement\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        move: \"moveTo\",\n        moveTo: \"moveTo\",\n        moveAlong: \"moveAlong\",\n        visit: \"visit\",\n        glide: \"makeGlider\",\n        makeGlider: \"makeGlider\",\n        intersect: \"makeIntersection\",\n        makeIntersection: \"makeIntersection\",\n        X: \"X\",\n        Y: \"Y\",\n        free: \"free\",\n        setPosition: \"setGliderPosition\",\n        setGliderPosition: \"setGliderPosition\",\n        addConstraint: \"addConstraint\",\n        dist: \"Dist\",\n        onPolygon: \"onPolygon\"\n    });\n\n    /*\n     * this.element may have been set by the object constructor.\n     */\n    if (Type.exists(this.element)) {\n        this.addAnchor(coordinates, isLabel);\n    }\n    this.isDraggable = true;\n};\n\nJXG.extend(\n    JXG.CoordsElement.prototype,\n    /** @lends JXG.CoordsElement.prototype */ {\n        /**\n         * Dummy function for unconstrained points or gliders.\n         * @private\n         */\n        updateConstraint: function () {\n            return this;\n        },\n\n        /**\n         * Updates the coordinates of the element.\n         * @private\n         */\n        updateCoords: function (fromParent) {\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            if (!Type.exists(fromParent)) {\n                fromParent = false;\n            }\n\n            if (!Type.evaluate(this.visProp.frozen)) {\n                this.updateConstraint();\n            }\n\n            /*\n             * We need to calculate the new coordinates no matter of the elements visibility because\n             * a child could be visible and depend on the coordinates of the element/point (e.g. perpendicular).\n             *\n             * Check if the element is a glider and calculate new coords in dependency of this.slideObject.\n             * This function is called with fromParent==true in case it is a glider element for example if\n             * the defining elements of the line or circle have been changed.\n             */\n            if (this.type === Const.OBJECT_TYPE_GLIDER) {\n                if (this.isConstrained) {\n                    fromParent = false;\n                }\n\n                if (fromParent) {\n                    this.updateGliderFromParent();\n                } else {\n                    this.updateGlider();\n                }\n            }\n\n            this.updateTransform(fromParent);\n\n            return this;\n        },\n\n        /**\n         * Update of glider in case of dragging the glider or setting the postion of the glider.\n         * The relative position of the glider has to be updated.\n         *\n         * In case of a glider on a line:\n         * If the second point is an ideal point, then -1 < this.position < 1,\n         * this.position==+/-1 equals point2, this.position==0 equals point1\n         *\n         * If the first point is an ideal point, then 0 < this.position < 2\n         * this.position==0  or 2 equals point1, this.position==1 equals point2\n         *\n         * @private\n         */\n        updateGlider: function () {\n            var i,\n                p1c,\n                p2c,\n                d,\n                v,\n                poly,\n                cc,\n                pos,\n                sgn,\n                alpha,\n                beta,\n                delta = 2.0 * Math.PI,\n                angle,\n                cp,\n                c,\n                invMat,\n                newCoords,\n                newPos,\n                doRound = false,\n                ev_sw,\n                slide = this.slideObject,\n                res,\n                cu,\n                slides = [],\n                isTransformed;\n\n            this.needsUpdateFromParent = false;\n            if (slide.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                if (Type.evaluate(this.visProp.isgeonext)) {\n                    delta = 1.0;\n                }\n                newCoords = Geometry.projectPointToCircle(this, slide, this.board);\n                newPos =\n                    Geometry.rad(\n                        [slide.center.X() + 1.0, slide.center.Y()],\n                        slide.center,\n                        this\n                    ) / delta;\n            } else if (slide.elementClass === Const.OBJECT_CLASS_LINE) {\n                /*\n                 * onPolygon==true: the point is a slider on a segment and this segment is one of the\n                 * \"borders\" of a polygon.\n                 * This is a GEONExT feature.\n                 */\n                if (this.onPolygon) {\n                    p1c = slide.point1.coords.usrCoords;\n                    p2c = slide.point2.coords.usrCoords;\n                    i = 1;\n                    d = p2c[i] - p1c[i];\n\n                    if (Math.abs(d) < Mat.eps) {\n                        i = 2;\n                        d = p2c[i] - p1c[i];\n                    }\n\n                    cc = Geometry.projectPointToLine(this, slide, this.board);\n                    pos = (cc.usrCoords[i] - p1c[i]) / d;\n                    poly = slide.parentPolygon;\n\n                    if (pos < 0) {\n                        for (i = 0; i < poly.borders.length; i++) {\n                            if (slide === poly.borders[i]) {\n                                slide =\n                                    poly.borders[\n                                        (i - 1 + poly.borders.length) % poly.borders.length\n                                    ];\n                                break;\n                            }\n                        }\n                    } else if (pos > 1.0) {\n                        for (i = 0; i < poly.borders.length; i++) {\n                            if (slide === poly.borders[i]) {\n                                slide =\n                                    poly.borders[\n                                        (i + 1 + poly.borders.length) % poly.borders.length\n                                    ];\n                                break;\n                            }\n                        }\n                    }\n\n                    // If the slide object has changed, save the change to the glider.\n                    if (slide.id !== this.slideObject.id) {\n                        this.slideObject = slide;\n                    }\n                }\n\n                p1c = slide.point1.coords;\n                p2c = slide.point2.coords;\n\n                // Distance between the two defining points\n                d = p1c.distance(Const.COORDS_BY_USER, p2c);\n\n                // The defining points are identical\n                if (d < Mat.eps) {\n                    //this.coords.setCoordinates(Const.COORDS_BY_USER, p1c);\n                    newCoords = p1c;\n                    doRound = true;\n                    newPos = 0.0;\n                } else {\n                    newCoords = Geometry.projectPointToLine(this, slide, this.board);\n                    p1c = p1c.usrCoords.slice(0);\n                    p2c = p2c.usrCoords.slice(0);\n\n                    // The second point is an ideal point\n                    if (Math.abs(p2c[0]) < Mat.eps) {\n                        i = 1;\n                        d = p2c[i];\n\n                        if (Math.abs(d) < Mat.eps) {\n                            i = 2;\n                            d = p2c[i];\n                        }\n\n                        d = (newCoords.usrCoords[i] - p1c[i]) / d;\n                        sgn = d >= 0 ? 1 : -1;\n                        d = Math.abs(d);\n                        newPos = (sgn * d) / (d + 1);\n\n                        // The first point is an ideal point\n                    } else if (Math.abs(p1c[0]) < Mat.eps) {\n                        i = 1;\n                        d = p1c[i];\n\n                        if (Math.abs(d) < Mat.eps) {\n                            i = 2;\n                            d = p1c[i];\n                        }\n\n                        d = (newCoords.usrCoords[i] - p2c[i]) / d;\n\n                        // 1.0 - d/(1-d);\n                        if (d < 0.0) {\n                            newPos = (1 - 2.0 * d) / (1.0 - d);\n                        } else {\n                            newPos = 1 / (d + 1);\n                        }\n                    } else {\n                        i = 1;\n                        d = p2c[i] - p1c[i];\n\n                        if (Math.abs(d) < Mat.eps) {\n                            i = 2;\n                            d = p2c[i] - p1c[i];\n                        }\n                        newPos = (newCoords.usrCoords[i] - p1c[i]) / d;\n                    }\n                }\n\n                // Snap the glider point of the slider into its appropiate position\n                // First, recalculate the new value of this.position\n                // Second, call update(fromParent==true) to make the positioning snappier.\n                ev_sw = Type.evaluate(this.visProp.snapwidth);\n                if (\n                    Type.evaluate(ev_sw) > 0.0 &&\n                    Math.abs(this._smax - this._smin) >= Mat.eps\n                ) {\n                    newPos = Math.max(Math.min(newPos, 1), 0);\n\n                    v = newPos * (this._smax - this._smin) + this._smin;\n                    v = Math.round(v / ev_sw) * ev_sw;\n                    newPos = (v - this._smin) / (this._smax - this._smin);\n                    this.update(true);\n                }\n\n                p1c = slide.point1.coords;\n                if (\n                    !Type.evaluate(slide.visProp.straightfirst) &&\n                    Math.abs(p1c.usrCoords[0]) > Mat.eps &&\n                    newPos < 0\n                ) {\n                    newCoords = p1c;\n                    doRound = true;\n                    newPos = 0;\n                }\n\n                p2c = slide.point2.coords;\n                if (\n                    !Type.evaluate(slide.visProp.straightlast) &&\n                    Math.abs(p2c.usrCoords[0]) > Mat.eps &&\n                    newPos > 1\n                ) {\n                    newCoords = p2c;\n                    doRound = true;\n                    newPos = 1;\n                }\n            } else if (slide.type === Const.OBJECT_TYPE_TURTLE) {\n                // In case, the point is a constrained glider.\n                this.updateConstraint();\n                res = Geometry.projectPointToTurtle(this, slide, this.board);\n                newCoords = res[0];\n                newPos = res[1]; // save position for the overwriting below\n            } else if (slide.elementClass === Const.OBJECT_CLASS_CURVE) {\n                if (\n                    slide.type === Const.OBJECT_TYPE_ARC ||\n                    slide.type === Const.OBJECT_TYPE_SECTOR\n                ) {\n                    newCoords = Geometry.projectPointToCircle(this, slide, this.board);\n\n                    angle = Geometry.rad(slide.radiuspoint, slide.center, this);\n                    alpha = 0.0;\n                    beta = Geometry.rad(slide.radiuspoint, slide.center, slide.anglepoint);\n                    newPos = angle;\n\n                    ev_sw = Type.evaluate(slide.visProp.selection);\n                    if (\n                        (ev_sw === \"minor\" && beta > Math.PI) ||\n                        (ev_sw === \"major\" && beta < Math.PI)\n                    ) {\n                        alpha = beta;\n                        beta = 2 * Math.PI;\n                    }\n\n                    // Correct the position if we are outside of the sector/arc\n                    if (angle < alpha || angle > beta) {\n                        newPos = beta;\n\n                        if (\n                            (angle < alpha && angle > alpha * 0.5) ||\n                            (angle > beta && angle > beta * 0.5 + Math.PI)\n                        ) {\n                            newPos = alpha;\n                        }\n\n                        this.needsUpdateFromParent = true;\n                        this.updateGliderFromParent();\n                    }\n\n                    delta = beta - alpha;\n                    if (this.visProp.isgeonext) {\n                        delta = 1.0;\n                    }\n                    if (Math.abs(delta) > Mat.eps) {\n                        newPos /= delta;\n                    }\n                } else {\n                    // In case, the point is a constrained glider.\n                    this.updateConstraint();\n\n                    // Handle the case if the curve comes from a transformation of a continous curve.\n                    if (slide.transformations.length > 0) {\n                        isTransformed = false;\n                        res = slide.getTransformationSource();\n                        if (res[0]) {\n                            isTransformed = res[0];\n                            slides.push(slide);\n                            slides.push(res[1]);\n                        }\n                        // Recurse\n                        while (res[0] && Type.exists(res[1]._transformationSource)) {\n                            res = res[1].getTransformationSource();\n                            slides.push(res[1]);\n                        }\n\n                        cu = this.coords.usrCoords;\n                        if (isTransformed) {\n                            for (i = 0; i < slides.length; i++) {\n                                slides[i].updateTransformMatrix();\n                                invMat = Mat.inverse(slides[i].transformMat);\n                                cu = Mat.matVecMult(invMat, cu);\n                            }\n                            cp = new Coords(Const.COORDS_BY_USER, cu, this.board).usrCoords;\n                            c = Geometry.projectCoordsToCurve(\n                                cp[1],\n                                cp[2],\n                                this.position || 0,\n                                slides[slides.length - 1],\n                                this.board\n                            );\n                            // projectPointCurve() already would apply the transformation.\n                            // Since we are projecting on the original curve, we have to do\n                            // the transformations \"by hand\".\n                            cu = c[0].usrCoords;\n                            for (i = slides.length - 2; i >= 0; i--) {\n                                cu = Mat.matVecMult(slides[i].transformMat, cu);\n                            }\n                            c[0] = new Coords(Const.COORDS_BY_USER, cu, this.board);\n                        } else {\n                            slide.updateTransformMatrix();\n                            invMat = Mat.inverse(slide.transformMat);\n                            cu = Mat.matVecMult(invMat, cu);\n                            cp = new Coords(Const.COORDS_BY_USER, cu, this.board).usrCoords;\n                            c = Geometry.projectCoordsToCurve(\n                                cp[1],\n                                cp[2],\n                                this.position || 0,\n                                slide,\n                                this.board\n                            );\n                        }\n\n                        newCoords = c[0];\n                        newPos = c[1];\n                    } else {\n                        res = Geometry.projectPointToCurve(this, slide, this.board);\n                        newCoords = res[0];\n                        newPos = res[1]; // save position for the overwriting below\n                    }\n                }\n            } else if (Type.isPoint(slide)) {\n                //this.coords.setCoordinates(Const.COORDS_BY_USER, Geometry.projectPointToPoint(this, slide, this.board).usrCoords, false);\n                newCoords = Geometry.projectPointToPoint(this, slide, this.board);\n                newPos = this.position; // save position for the overwriting below\n            }\n\n            this.coords.setCoordinates(Const.COORDS_BY_USER, newCoords.usrCoords, doRound);\n            this.position = newPos;\n        },\n\n        /**\n         * Update of a glider in case a parent element has been updated. That means the\n         * relative position of the glider stays the same.\n         * @private\n         */\n        updateGliderFromParent: function () {\n            var p1c,\n                p2c,\n                r,\n                lbda,\n                c,\n                slide = this.slideObject,\n                slides = [],\n                res,\n                i,\n                isTransformed,\n                baseangle,\n                alpha,\n                angle,\n                beta,\n                delta = 2.0 * Math.PI;\n\n            if (!this.needsUpdateFromParent) {\n                this.needsUpdateFromParent = true;\n                return;\n            }\n\n            if (slide.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                r = slide.Radius();\n                if (Type.evaluate(this.visProp.isgeonext)) {\n                    delta = 1.0;\n                }\n                c = [\n                    slide.center.X() + r * Math.cos(this.position * delta),\n                    slide.center.Y() + r * Math.sin(this.position * delta)\n                ];\n            } else if (slide.elementClass === Const.OBJECT_CLASS_LINE) {\n                p1c = slide.point1.coords.usrCoords;\n                p2c = slide.point2.coords.usrCoords;\n\n                // If one of the defining points of the line does not exist,\n                // the glider should disappear\n                if (\n                    (p1c[0] === 0 && p1c[1] === 0 && p1c[2] === 0) ||\n                    (p2c[0] === 0 && p2c[1] === 0 && p2c[2] === 0)\n                ) {\n                    c = [0, 0, 0];\n                    // The second point is an ideal point\n                } else if (Math.abs(p2c[0]) < Mat.eps) {\n                    lbda = Math.min(Math.abs(this.position), 1 - Mat.eps);\n                    lbda /= 1.0 - lbda;\n\n                    if (this.position < 0) {\n                        lbda = -lbda;\n                    }\n\n                    c = [\n                        p1c[0] + lbda * p2c[0],\n                        p1c[1] + lbda * p2c[1],\n                        p1c[2] + lbda * p2c[2]\n                    ];\n                    // The first point is an ideal point\n                } else if (Math.abs(p1c[0]) < Mat.eps) {\n                    lbda = Math.max(this.position, Mat.eps);\n                    lbda = Math.min(lbda, 2 - Mat.eps);\n\n                    if (lbda > 1) {\n                        lbda = (lbda - 1) / (lbda - 2);\n                    } else {\n                        lbda = (1 - lbda) / lbda;\n                    }\n\n                    c = [\n                        p2c[0] + lbda * p1c[0],\n                        p2c[1] + lbda * p1c[1],\n                        p2c[2] + lbda * p1c[2]\n                    ];\n                } else {\n                    lbda = this.position;\n                    c = [\n                        p1c[0] + lbda * (p2c[0] - p1c[0]),\n                        p1c[1] + lbda * (p2c[1] - p1c[1]),\n                        p1c[2] + lbda * (p2c[2] - p1c[2])\n                    ];\n                }\n            } else if (slide.type === Const.OBJECT_TYPE_TURTLE) {\n                this.coords.setCoordinates(Const.COORDS_BY_USER, [\n                    slide.Z(this.position),\n                    slide.X(this.position),\n                    slide.Y(this.position)\n                ]);\n                // In case, the point is a constrained glider.\n                this.updateConstraint();\n                c = Geometry.projectPointToTurtle(this, slide, this.board)[0].usrCoords;\n            } else if (slide.elementClass === Const.OBJECT_CLASS_CURVE) {\n                // Handle the case if the curve comes from a transformation of a continuous curve.\n                isTransformed = false;\n                res = slide.getTransformationSource();\n                if (res[0]) {\n                    isTransformed = res[0];\n                    slides.push(slide);\n                    slides.push(res[1]);\n                }\n                // Recurse\n                while (res[0] && Type.exists(res[1]._transformationSource)) {\n                    res = res[1].getTransformationSource();\n                    slides.push(res[1]);\n                }\n                if (isTransformed) {\n                    this.coords.setCoordinates(Const.COORDS_BY_USER, [\n                        slides[slides.length - 1].Z(this.position),\n                        slides[slides.length - 1].X(this.position),\n                        slides[slides.length - 1].Y(this.position)\n                    ]);\n                } else {\n                    this.coords.setCoordinates(Const.COORDS_BY_USER, [\n                        slide.Z(this.position),\n                        slide.X(this.position),\n                        slide.Y(this.position)\n                    ]);\n                }\n\n                if (\n                    slide.type === Const.OBJECT_TYPE_ARC ||\n                    slide.type === Const.OBJECT_TYPE_SECTOR\n                ) {\n                    baseangle = Geometry.rad(\n                        [slide.center.X() + 1, slide.center.Y()],\n                        slide.center,\n                        slide.radiuspoint\n                    );\n\n                    alpha = 0.0;\n                    beta = Geometry.rad(slide.radiuspoint, slide.center, slide.anglepoint);\n\n                    if (\n                        (slide.visProp.selection === \"minor\" && beta > Math.PI) ||\n                        (slide.visProp.selection === \"major\" && beta < Math.PI)\n                    ) {\n                        alpha = beta;\n                        beta = 2 * Math.PI;\n                    }\n\n                    delta = beta - alpha;\n                    if (Type.evaluate(this.visProp.isgeonext)) {\n                        delta = 1.0;\n                    }\n                    angle = this.position * delta;\n\n                    // Correct the position if we are outside of the sector/arc\n                    if (angle < alpha || angle > beta) {\n                        angle = beta;\n\n                        if (\n                            (angle < alpha && angle > alpha * 0.5) ||\n                            (angle > beta && angle > beta * 0.5 + Math.PI)\n                        ) {\n                            angle = alpha;\n                        }\n\n                        this.position = angle;\n                        if (Math.abs(delta) > Mat.eps) {\n                            this.position /= delta;\n                        }\n                    }\n\n                    r = slide.Radius();\n                    c = [\n                        slide.center.X() + r * Math.cos(this.position * delta + baseangle),\n                        slide.center.Y() + r * Math.sin(this.position * delta + baseangle)\n                    ];\n                } else {\n                    // In case, the point is a constrained glider.\n                    this.updateConstraint();\n\n                    if (isTransformed) {\n                        c = Geometry.projectPointToCurve(\n                            this,\n                            slides[slides.length - 1],\n                            this.board\n                        )[0].usrCoords;\n                        // projectPointCurve() already would do the transformation.\n                        // But since we are projecting on the original curve, we have to do\n                        // the transformation \"by hand\".\n                        for (i = slides.length - 2; i >= 0; i--) {\n                            c = new Coords(\n                                Const.COORDS_BY_USER,\n                                Mat.matVecMult(slides[i].transformMat, c),\n                                this.board\n                            ).usrCoords;\n                        }\n                    } else {\n                        c = Geometry.projectPointToCurve(this, slide, this.board)[0].usrCoords;\n                    }\n                }\n            } else if (Type.isPoint(slide)) {\n                c = Geometry.projectPointToPoint(this, slide, this.board).usrCoords;\n            }\n\n            this.coords.setCoordinates(Const.COORDS_BY_USER, c, false);\n        },\n\n        updateRendererGeneric: function (rendererMethod) {\n            //var wasReal;\n\n            if (!this.needsUpdate || !this.board.renderer) {\n                return this;\n            }\n\n            if (this.visPropCalc.visible) {\n                //wasReal = this.isReal;\n                this.isReal = !isNaN(this.coords.usrCoords[1] + this.coords.usrCoords[2]);\n                //Homogeneous coords: ideal point\n                this.isReal =\n                    Math.abs(this.coords.usrCoords[0]) > Mat.eps ? this.isReal : false;\n\n                if (\n                    // wasReal &&\n                    !this.isReal\n                ) {\n                    this.updateVisibility(false);\n                }\n            }\n\n            // Call the renderer only if element is visible.\n            // Update the position\n            if (this.visPropCalc.visible) {\n                this.board.renderer[rendererMethod](this);\n            }\n\n            // Update the label if visible.\n            if (\n                this.hasLabel &&\n                this.visPropCalc.visible &&\n                this.label &&\n                this.label.visPropCalc.visible &&\n                this.isReal\n            ) {\n                this.label.update();\n                this.board.renderer.updateText(this.label);\n            }\n\n            // Update rendNode display\n            this.setDisplayRendNode();\n            // if (this.visPropCalc.visible !== this.visPropOld.visible) {\n            //     this.board.renderer.display(this, this.visPropCalc.visible);\n            //     this.visPropOld.visible = this.visPropCalc.visible;\n            //\n            //     if (this.hasLabel) {\n            //         this.board.renderer.display(this.label, this.label.visPropCalc.visible);\n            //     }\n            // }\n\n            this.needsUpdate = false;\n            return this;\n        },\n\n        /**\n         * Getter method for x, this is used by for CAS-points to access point coordinates.\n         * @returns {Number} User coordinate of point in x direction.\n         */\n        X: function () {\n            return this.coords.usrCoords[1];\n        },\n\n        /**\n         * Getter method for y, this is used by CAS-points to access point coordinates.\n         * @returns {Number} User coordinate of point in y direction.\n         */\n        Y: function () {\n            return this.coords.usrCoords[2];\n        },\n\n        /**\n         * Getter method for z, this is used by CAS-points to access point coordinates.\n         * @returns {Number} User coordinate of point in z direction.\n         */\n        Z: function () {\n            return this.coords.usrCoords[0];\n        },\n\n        /**\n         * New evaluation of the function term.\n         * This is required for CAS-points: Their XTerm() method is\n         * overwritten in {@link JXG.CoordsElement#addConstraint}.\n         *\n         * @returns {Number} User coordinate of point in x direction.\n         * @private\n         */\n        XEval: function () {\n            return this.coords.usrCoords[1];\n        },\n\n        /**\n         * New evaluation of the function term.\n         * This is required for CAS-points: Their YTerm() method is overwritten\n         * in {@link JXG.CoordsElement#addConstraint}.\n         *\n         * @returns {Number} User coordinate of point in y direction.\n         * @private\n         */\n        YEval: function () {\n            return this.coords.usrCoords[2];\n        },\n\n        /**\n         * New evaluation of the function term.\n         * This is required for CAS-points: Their ZTerm() method is overwritten in\n         * {@link JXG.CoordsElement#addConstraint}.\n         *\n         * @returns {Number} User coordinate of point in z direction.\n         * @private\n         */\n        ZEval: function () {\n            return this.coords.usrCoords[0];\n        },\n\n        /**\n         * Getter method for the distance to a second point, this is required for CAS-elements.\n         * Here, function inlining seems to be worthwile  (for plotting).\n         * @param {JXG.Point} point2 The point to which the distance shall be calculated.\n         * @returns {Number} Distance in user coordinate to the given point\n         */\n        Dist: function (point2) {\n            if (this.isReal && point2.isReal) {\n                return this.coords.distance(Const.COORDS_BY_USER, point2.coords);\n            }\n            return NaN;\n        },\n\n        /**\n         * Alias for {@link JXG.Element#handleSnapToGrid}\n         * @param {Boolean} force force snapping independent from what the snaptogrid attribute says\n         * @returns {JXG.CoordsElement} Reference to this element\n         */\n        snapToGrid: function (force) {\n            return this.handleSnapToGrid(force);\n        },\n\n        /**\n         * Let a point snap to the nearest point in distance of\n         * {@link JXG.Point#attractorDistance}.\n         * The function uses the coords object of the point as\n         * its actual position.\n         * @param {Boolean} force force snapping independent from what the snaptogrid attribute says\n         * @returns {JXG.Point} Reference to this element\n         */\n        handleSnapToPoints: function (force) {\n            var i,\n                pEl,\n                pCoords,\n                d = 0,\n                len,\n                dMax = Infinity,\n                c = null,\n                ev_au,\n                ev_ad,\n                ev_is2p = Type.evaluate(this.visProp.ignoredsnaptopoints),\n                len2,\n                j,\n                ignore = false;\n\n            len = this.board.objectsList.length;\n\n            if (ev_is2p) {\n                len2 = ev_is2p.length;\n            }\n\n            if (Type.evaluate(this.visProp.snaptopoints) || force) {\n                ev_au = Type.evaluate(this.visProp.attractorunit);\n                ev_ad = Type.evaluate(this.visProp.attractordistance);\n\n                for (i = 0; i < len; i++) {\n                    pEl = this.board.objectsList[i];\n\n                    if (ev_is2p) {\n                        ignore = false;\n                        for (j = 0; j < len2; j++) {\n                            if (pEl === this.board.select(ev_is2p[j])) {\n                                ignore = true;\n                                break;\n                            }\n                        }\n                        if (ignore) {\n                            continue;\n                        }\n                    }\n\n                    if (Type.isPoint(pEl) && pEl !== this && pEl.visPropCalc.visible) {\n                        pCoords = Geometry.projectPointToPoint(this, pEl, this.board);\n                        if (ev_au === \"screen\") {\n                            d = pCoords.distance(Const.COORDS_BY_SCREEN, this.coords);\n                        } else {\n                            d = pCoords.distance(Const.COORDS_BY_USER, this.coords);\n                        }\n\n                        if (d < ev_ad && d < dMax) {\n                            dMax = d;\n                            c = pCoords;\n                        }\n                    }\n                }\n\n                if (c !== null) {\n                    this.coords.setCoordinates(Const.COORDS_BY_USER, c.usrCoords);\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Alias for {@link JXG.CoordsElement#handleSnapToPoints}.\n         *\n         * @param {Boolean} force force snapping independent from what the snaptogrid attribute says\n         * @returns {JXG.Point} Reference to this element\n         */\n        snapToPoints: function (force) {\n            return this.handleSnapToPoints(force);\n        },\n\n        /**\n         * A point can change its type from free point to glider\n         * and vice versa. If it is given an array of attractor elements\n         * (attribute attractors) and the attribute attractorDistance\n         * then the point will be made a glider if it less than attractorDistance\n         * apart from one of its attractor elements.\n         * If attractorDistance is equal to zero, the point stays in its\n         * current form.\n         * @returns {JXG.Point} Reference to this element\n         */\n        handleAttractors: function () {\n            var i,\n                el,\n                projCoords,\n                d = 0.0,\n                projection,\n                ev_au = Type.evaluate(this.visProp.attractorunit),\n                ev_ad = Type.evaluate(this.visProp.attractordistance),\n                ev_sd = Type.evaluate(this.visProp.snatchdistance),\n                ev_a = Type.evaluate(this.visProp.attractors),\n                len = ev_a.length;\n\n            if (ev_ad === 0.0) {\n                return;\n            }\n\n            for (i = 0; i < len; i++) {\n                el = this.board.select(ev_a[i]);\n\n                if (Type.exists(el) && el !== this) {\n                    if (Type.isPoint(el)) {\n                        projCoords = Geometry.projectPointToPoint(this, el, this.board);\n                    } else if (el.elementClass === Const.OBJECT_CLASS_LINE) {\n                        projection = Geometry.projectCoordsToSegment(\n                            this.coords.usrCoords,\n                            el.point1.coords.usrCoords,\n                            el.point2.coords.usrCoords\n                        );\n                        if (!Type.evaluate(el.visProp.straightfirst) && projection[1] < 0.0) {\n                            projCoords = el.point1.coords;\n                        } else if (\n                            !Type.evaluate(el.visProp.straightlast) &&\n                            projection[1] > 1.0\n                        ) {\n                            projCoords = el.point2.coords;\n                        } else {\n                            projCoords = new Coords(\n                                Const.COORDS_BY_USER,\n                                projection[0],\n                                this.board\n                            );\n                        }\n                    } else if (el.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                        projCoords = Geometry.projectPointToCircle(this, el, this.board);\n                    } else if (el.elementClass === Const.OBJECT_CLASS_CURVE) {\n                        projCoords = Geometry.projectPointToCurve(this, el, this.board)[0];\n                    } else if (el.type === Const.OBJECT_TYPE_TURTLE) {\n                        projCoords = Geometry.projectPointToTurtle(this, el, this.board)[0];\n                    } else if (el.type === Const.OBJECT_TYPE_POLYGON) {\n                        projCoords = new Coords(\n                            Const.COORDS_BY_USER,\n                            Geometry.projectCoordsToPolygon(this.coords.usrCoords, el),\n                            this.board\n                        );\n                    }\n\n                    if (ev_au === \"screen\") {\n                        d = projCoords.distance(Const.COORDS_BY_SCREEN, this.coords);\n                    } else {\n                        d = projCoords.distance(Const.COORDS_BY_USER, this.coords);\n                    }\n\n                    if (d < ev_ad) {\n                        if (\n                            !(\n                                this.type === Const.OBJECT_TYPE_GLIDER &&\n                                (el === this.slideObject ||\n                                    (this.slideObject &&\n                                        this.onPolygon &&\n                                        this.slideObject.parentPolygon === el))\n                            )\n                        ) {\n                            this.makeGlider(el);\n                        }\n                        break; // bind the point to the first attractor in its list.\n                    }\n                    if (\n                        d >= ev_sd &&\n                        (el === this.slideObject ||\n                            (this.slideObject &&\n                                this.onPolygon &&\n                                this.slideObject.parentPolygon === el))\n                    ) {\n                        this.popSlideObject();\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Sets coordinates and calls the point's update() method.\n         * @param {Number} method The type of coordinates used here.\n         * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.\n         * @param {Array} coords coordinates <tt>([z], x, y)</tt> in screen/user units\n         * @returns {JXG.Point} this element\n         */\n        setPositionDirectly: function (method, coords) {\n            var i,\n                c,\n                dc,\n                oldCoords = this.coords,\n                newCoords;\n\n            if (this.relativeCoords) {\n                c = new Coords(method, coords, this.board);\n                if (Type.evaluate(this.visProp.islabel)) {\n                    dc = Statistics.subtract(c.scrCoords, oldCoords.scrCoords);\n                    this.relativeCoords.scrCoords[1] += dc[1];\n                    this.relativeCoords.scrCoords[2] += dc[2];\n                } else {\n                    dc = Statistics.subtract(c.usrCoords, oldCoords.usrCoords);\n                    this.relativeCoords.usrCoords[1] += dc[1];\n                    this.relativeCoords.usrCoords[2] += dc[2];\n                }\n\n                return this;\n            }\n\n            this.coords.setCoordinates(method, coords);\n            this.handleSnapToGrid();\n            this.handleSnapToPoints();\n            this.handleAttractors();\n\n            // Update the initial coordinates. This is needed for free points\n            // that have a transformation bound to it.\n            for (i = this.transformations.length - 1; i >= 0; i--) {\n                if (method === Const.COORDS_BY_SCREEN) {\n                    newCoords = new Coords(method, coords, this.board).usrCoords;\n                } else {\n                    if (coords.length === 2) {\n                        coords = [1].concat(coords);\n                    }\n                    newCoords = coords;\n                }\n                this.initialCoords.setCoordinates(\n                    Const.COORDS_BY_USER,\n                    Mat.matVecMult(Mat.inverse(this.transformations[i].matrix), newCoords)\n                );\n            }\n            this.prepareUpdate().update();\n\n            // If the user suspends the board updates we need to recalculate the relative position of\n            // the point on the slide object. This is done in updateGlider() which is NOT called during the\n            // update process triggered by unsuspendUpdate.\n            if (this.board.isSuspendedUpdate && this.type === Const.OBJECT_TYPE_GLIDER) {\n                this.updateGlider();\n            }\n\n            return this;\n        },\n\n        /**\n         * Translates the point by <tt>tv = (x, y)</tt>.\n         * @param {Number} method The type of coordinates used here.\n         * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.\n         * @param {Array} tv (x, y)\n         * @returns {JXG.Point}\n         */\n        setPositionByTransform: function (method, tv) {\n            var t;\n\n            tv = new Coords(method, tv, this.board);\n            t = this.board.create(\"transform\", tv.usrCoords.slice(1), {\n                type: \"translate\"\n            });\n\n            if (\n                this.transformations.length > 0 &&\n                this.transformations[this.transformations.length - 1].isNumericMatrix\n            ) {\n                this.transformations[this.transformations.length - 1].melt(t);\n            } else {\n                this.addTransform(this, t);\n            }\n\n            this.prepareUpdate().update();\n\n            return this;\n        },\n\n        /**\n         * Sets coordinates and calls the point's update() method.\n         * @param {Number} method The type of coordinates used here.\n         * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.\n         * @param {Array} coords coordinates in screen/user units\n         * @returns {JXG.Point}\n         */\n        setPosition: function (method, coords) {\n            return this.setPositionDirectly(method, coords);\n        },\n\n        /**\n         * Sets the position of a glider relative to the defining elements\n         * of the {@link JXG.Point#slideObject}.\n         * @param {Number} x\n         * @returns {JXG.Point} Reference to the point element.\n         */\n        setGliderPosition: function (x) {\n            if (this.type === Const.OBJECT_TYPE_GLIDER) {\n                this.position = x;\n                this.board.update();\n            }\n\n            return this;\n        },\n\n        /**\n         * Convert the point to glider and update the construction.\n         * To move the point visual onto the glider, a call of board update is necessary.\n         * @param {String|Object} slide The object the point will be bound to.\n         */\n        makeGlider: function (slide) {\n            var slideobj = this.board.select(slide),\n                onPolygon = false,\n                min,\n                i,\n                dist;\n\n            if (slideobj.type === Const.OBJECT_TYPE_POLYGON) {\n                // Search for the closest edge of the polygon.\n                min = Number.MAX_VALUE;\n                for (i = 0; i < slideobj.borders.length; i++) {\n                    dist = JXG.Math.Geometry.distPointLine(\n                        this.coords.usrCoords,\n                        slideobj.borders[i].stdform\n                    );\n                    if (dist < min) {\n                        min = dist;\n                        slide = slideobj.borders[i];\n                    }\n                }\n                slideobj = this.board.select(slide);\n                onPolygon = true;\n            }\n\n            /* Gliders on Ticks are forbidden */\n            if (!Type.exists(slideobj)) {\n                throw new Error(\"JSXGraph: slide object undefined.\");\n            } else if (slideobj.type === Const.OBJECT_TYPE_TICKS) {\n                throw new Error(\"JSXGraph: gliders on ticks are not possible.\");\n            }\n\n            this.slideObject = this.board.select(slide);\n            this.slideObjects.push(this.slideObject);\n            this.addParents(slide);\n\n            this.type = Const.OBJECT_TYPE_GLIDER;\n            this.elType = \"glider\";\n            this.visProp.snapwidth = -1; // By default, deactivate snapWidth\n            this.slideObject.addChild(this);\n            this.isDraggable = true;\n            this.onPolygon = onPolygon;\n\n            this.generatePolynomial = function () {\n                return this.slideObject.generatePolynomial(this);\n            };\n\n            // Determine the initial value of this.position\n            this.updateGlider();\n            this.needsUpdateFromParent = true;\n            this.updateGliderFromParent();\n\n            return this;\n        },\n\n        /**\n         * Remove the last slideObject. If there are more than one elements the point is bound to,\n         * the second last element is the new active slideObject.\n         */\n        popSlideObject: function () {\n            if (this.slideObjects.length > 0) {\n                this.slideObjects.pop();\n\n                // It may not be sufficient to remove the point from\n                // the list of childElement. For complex dependencies\n                // one may have to go to the list of ancestor and descendants.  A.W.\n                // Yes indeed, see #51 on github bugtracker\n                //  delete this.slideObject.childElements[this.id];\n                this.slideObject.removeChild(this);\n\n                if (this.slideObjects.length === 0) {\n                    this.type = this._org_type;\n                    if (this.type === Const.OBJECT_TYPE_POINT) {\n                        this.elType = \"point\";\n                    } else if (this.elementClass === Const.OBJECT_CLASS_TEXT) {\n                        this.elType = \"text\";\n                    } else if (this.type === Const.OBJECT_TYPE_IMAGE) {\n                        this.elType = \"image\";\n                    } else if (this.type === Const.OBJECT_TYPE_FOREIGNOBJECT) {\n                        this.elType = \"foreignobject\";\n                    }\n\n                    this.slideObject = null;\n                } else {\n                    this.slideObject = this.slideObjects[this.slideObjects.length - 1];\n                }\n            }\n        },\n\n        /**\n         * Converts a calculated element into a free element,\n         * i.e. it will delete all ancestors and transformations and,\n         * if the element is currently a glider, will remove the slideObject reference.\n         */\n        free: function () {\n            var ancestorId, ancestor;\n            // child;\n\n            if (this.type !== Const.OBJECT_TYPE_GLIDER) {\n                // remove all transformations\n                this.transformations.length = 0;\n\n                delete this.updateConstraint;\n                this.isConstrained = false;\n                // this.updateConstraint = function () {\n                //     return this;\n                // };\n\n                if (!this.isDraggable) {\n                    this.isDraggable = true;\n\n                    if (this.elementClass === Const.OBJECT_CLASS_POINT) {\n                        this.type = Const.OBJECT_TYPE_POINT;\n                        this.elType = \"point\";\n                    }\n\n                    this.XEval = function () {\n                        return this.coords.usrCoords[1];\n                    };\n\n                    this.YEval = function () {\n                        return this.coords.usrCoords[2];\n                    };\n\n                    this.ZEval = function () {\n                        return this.coords.usrCoords[0];\n                    };\n\n                    this.Xjc = null;\n                    this.Yjc = null;\n                } else {\n                    return;\n                }\n            }\n\n            // a free point does not depend on anything. And instead of running through tons of descendants and ancestor\n            // structures, where we eventually are going to visit a lot of objects twice or thrice with hard to read and\n            // comprehend code, just run once through all objects and delete all references to this point and its label.\n            for (ancestorId in this.board.objects) {\n                if (this.board.objects.hasOwnProperty(ancestorId)) {\n                    ancestor = this.board.objects[ancestorId];\n\n                    if (ancestor.descendants) {\n                        delete ancestor.descendants[this.id];\n                        delete ancestor.childElements[this.id];\n\n                        if (this.hasLabel) {\n                            delete ancestor.descendants[this.label.id];\n                            delete ancestor.childElements[this.label.id];\n                        }\n                    }\n                }\n            }\n\n            // A free point does not depend on anything. Remove all ancestors.\n            this.ancestors = {}; // only remove the reference\n\n            // Completely remove all slideObjects of the element\n            this.slideObject = null;\n            this.slideObjects = [];\n            if (this.elementClass === Const.OBJECT_CLASS_POINT) {\n                this.type = Const.OBJECT_TYPE_POINT;\n                this.elType = \"point\";\n            } else if (this.elementClass === Const.OBJECT_CLASS_TEXT) {\n                this.type = this._org_type;\n                this.elType = \"text\";\n            } else if (this.elementClass === Const.OBJECT_CLASS_OTHER) {\n                this.type = this._org_type;\n                this.elType = \"image\";\n            }\n        },\n\n        /**\n         * Convert the point to CAS point and call update().\n         * @param {Array} terms [[zterm], xterm, yterm] defining terms for the z, x and y coordinate.\n         * The z-coordinate is optional and it is used for homogeneous coordinates.\n         * The coordinates may be either <ul>\n         *   <li>a JavaScript function,</li>\n         *   <li>a string containing GEONExT syntax. This string will be converted into a JavaScript\n         *     function here,</li>\n         *   <li>a Number</li>\n         *   <li>a pointer to a slider object. This will be converted into a call of the Value()-method\n         *     of this slider.</li>\n         *   </ul>\n         * @see JXG.GeonextParser#geonext2JS\n         */\n        addConstraint: function (terms) {\n            var i,\n                v,\n                newfuncs = [],\n                what = [\"X\", \"Y\"],\n                makeConstFunction = function (z) {\n                    return function () {\n                        return z;\n                    };\n                },\n                makeSliderFunction = function (a) {\n                    return function () {\n                        return a.Value();\n                    };\n                };\n\n            if (this.elementClass === Const.OBJECT_CLASS_POINT) {\n                this.type = Const.OBJECT_TYPE_CAS;\n            }\n\n            this.isDraggable = false;\n\n            for (i = 0; i < terms.length; i++) {\n                v = terms[i];\n\n                if (Type.isString(v)) {\n                    // Convert GEONExT syntax into JavaScript syntax\n                    //t  = JXG.GeonextParser.geonext2JS(v, this.board);\n                    //newfuncs[i] = new Function('','return ' + t + ';');\n                    //v = GeonextParser.replaceNameById(v, this.board);\n                    newfuncs[i] = this.board.jc.snippet(v, true, null, true);\n\n                    if (terms.length === 2) {\n                        this[what[i] + \"jc\"] = terms[i];\n                    }\n                } else if (Type.isFunction(v)) {\n                    newfuncs[i] = v;\n                } else if (Type.isNumber(v)) {\n                    newfuncs[i] = makeConstFunction(v);\n                } else if (Type.isObject(v) && Type.isFunction(v.Value)) {\n                    // Slider\n                    newfuncs[i] = makeSliderFunction(v);\n                }\n\n                newfuncs[i].origin = v;\n            }\n\n            // Intersection function\n            if (terms.length === 1) {\n                this.updateConstraint = function () {\n                    var c = newfuncs[0]();\n\n                    // Array\n                    if (Type.isArray(c)) {\n                        this.coords.setCoordinates(Const.COORDS_BY_USER, c);\n                        // Coords object\n                    } else {\n                        this.coords = c;\n                    }\n                    return this;\n                };\n                // Euclidean coordinates\n            } else if (terms.length === 2) {\n                this.XEval = newfuncs[0];\n                this.YEval = newfuncs[1];\n\n                this.setParents([newfuncs[0].origin, newfuncs[1].origin]);\n\n                this.updateConstraint = function () {\n                    this.coords.setCoordinates(Const.COORDS_BY_USER, [\n                        this.XEval(),\n                        this.YEval()\n                    ]);\n                    return this;\n                };\n                // Homogeneous coordinates\n            } else {\n                this.ZEval = newfuncs[0];\n                this.XEval = newfuncs[1];\n                this.YEval = newfuncs[2];\n\n                this.setParents([newfuncs[0].origin, newfuncs[1].origin, newfuncs[2].origin]);\n\n                this.updateConstraint = function () {\n                    this.coords.setCoordinates(Const.COORDS_BY_USER, [\n                        this.ZEval(),\n                        this.XEval(),\n                        this.YEval()\n                    ]);\n                    return this;\n                };\n            }\n            this.isConstrained = true;\n\n            /**\n             * We have to do an update. Otherwise, elements relying on this point will receive NaN.\n             */\n            this.prepareUpdate().update();\n            if (!this.board.isSuspendedUpdate) {\n                this.updateVisibility().updateRenderer();\n                if (this.hasLabel) {\n                    this.label.fullUpdate();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * In case there is an attribute \"anchor\", the element is bound to\n         * this anchor element.\n         * This is handled with this.relativeCoords. If the element is a label\n         * relativeCoords are given in scrCoords, otherwise in usrCoords.\n         * @param{Array} coordinates Offset from th anchor element. These are the values for this.relativeCoords.\n         * In case of a label, coordinates are screen coordinates. Otherwise, coordinates are user coordinates.\n         * @param{Boolean} isLabel Yes/no\n         * @private\n         */\n        addAnchor: function (coordinates, isLabel) {\n            if (isLabel) {\n                this.relativeCoords = new Coords(\n                    Const.COORDS_BY_SCREEN,\n                    coordinates.slice(0, 2),\n                    this.board\n                );\n            } else {\n                this.relativeCoords = new Coords(Const.COORDS_BY_USER, coordinates, this.board);\n            }\n            this.element.addChild(this);\n            if (isLabel) {\n                this.addParents(this.element);\n            }\n\n            this.XEval = function () {\n                var sx, coords, anchor, ev_o;\n\n                if (Type.evaluate(this.visProp.islabel)) {\n                    ev_o = Type.evaluate(this.visProp.offset);\n                    sx = parseFloat(ev_o[0]);\n                    anchor = this.element.getLabelAnchor();\n                    coords = new Coords(\n                        Const.COORDS_BY_SCREEN,\n                        [sx + this.relativeCoords.scrCoords[1] + anchor.scrCoords[1], 0],\n                        this.board\n                    );\n\n                    return coords.usrCoords[1];\n                }\n\n                anchor = this.element.getTextAnchor();\n                return this.relativeCoords.usrCoords[1] + anchor.usrCoords[1];\n            };\n\n            this.YEval = function () {\n                var sy, coords, anchor, ev_o;\n\n                if (Type.evaluate(this.visProp.islabel)) {\n                    ev_o = Type.evaluate(this.visProp.offset);\n                    sy = -parseFloat(ev_o[1]);\n                    anchor = this.element.getLabelAnchor();\n                    coords = new Coords(\n                        Const.COORDS_BY_SCREEN,\n                        [0, sy + this.relativeCoords.scrCoords[2] + anchor.scrCoords[2]],\n                        this.board\n                    );\n\n                    return coords.usrCoords[2];\n                }\n\n                anchor = this.element.getTextAnchor();\n                return this.relativeCoords.usrCoords[2] + anchor.usrCoords[2];\n            };\n\n            this.ZEval = Type.createFunction(1, this.board, \"\");\n\n            this.updateConstraint = function () {\n                this.coords.setCoordinates(Const.COORDS_BY_USER, [\n                    this.ZEval(),\n                    this.XEval(),\n                    this.YEval()\n                ]);\n            };\n            this.isConstrained = true;\n\n            this.updateConstraint();\n            //this.coords = new Coords(Const.COORDS_BY_SCREEN, [0, 0], this.board);\n        },\n\n        /**\n         * Applies the transformations of the element.\n         * This method applies to text and images. Point transformations are handled differently.\n         * @param {Boolean} fromParent True if the drag comes from a child element. Unused.\n         * @returns {JXG.CoordsElement} Reference to itself.\n         */\n        updateTransform: function (fromParent) {\n            var i;\n\n            if (this.transformations.length === 0) {\n                return this;\n            }\n\n            for (i = 0; i < this.transformations.length; i++) {\n                this.transformations[i].update();\n            }\n\n            return this;\n        },\n\n        /**\n         * Add transformations to this element.\n         * @param {JXG.GeometryElement} el\n         * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation}\n         * or an array of {@link JXG.Transformation}s.\n         * @returns {JXG.CoordsElement} Reference to itself.\n         */\n        addTransform: function (el, transform) {\n            var i,\n                list = Type.isArray(transform) ? transform : [transform],\n                len = list.length;\n\n            // There is only one baseElement possible\n            if (this.transformations.length === 0) {\n                this.baseElement = el;\n            }\n\n            for (i = 0; i < len; i++) {\n                this.transformations.push(list[i]);\n            }\n\n            return this;\n        },\n\n        /**\n         * Animate the point.\n         * @param {Number} direction The direction the glider is animated. Can be +1 or -1.\n         * @param {Number} stepCount The number of steps in which the parent element is divided.\n         * Must be at least 1.\n         * @param {Number} delay Time in msec between two animation steps. Default is 250.\n         * @returns {JXG.CoordsElement} Reference to iself.\n         *\n         * @name Glider#startAnimation\n         * @see Glider#stopAnimation\n         * @function\n         * @example\n         * // Divide the circle line into 6 steps and\n         * // visit every step 330 msec counterclockwise.\n         * var ci = board.create('circle', [[-1,2], [2,1]]);\n         * var gl = board.create('glider', [0,2, ci]);\n         * gl.startAnimation(-1, 6, 330);\n         *\n         * </pre><div id=\"JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG0f35a50e-e99d-11e8-a1ca-04d3b0c2aad3',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     // Divide the circle line into 6 steps and\n         *     // visit every step 330 msec counterclockwise.\n         *     var ci = board.create('circle', [[-1,2], [2,1]]);\n         *     var gl = board.create('glider', [0,2, ci]);\n         *     gl.startAnimation(-1, 6, 330);\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         * @example\n         * // Divide the slider area into 20 steps and\n         * // visit every step 30 msec.\n         * var n = board.create('slider',[[-2,4],[2,4],[1,5,100]],{name:'n'});\n         * n.startAnimation(1, 20, 30);\n         *\n         * </pre><div id=\"JXG40ce04b8-e99c-11e8-a1ca-04d3b0c2aad3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG40ce04b8-e99c-11e8-a1ca-04d3b0c2aad3',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     // Divide the slider area into 20 steps and\n         *     // visit every step 30 msec.\n         *     var n = board.create('slider',[[-2,4],[2,4],[1,5,100]],{name:'n'});\n         *     n.startAnimation(1, 20, 30);\n         *\n         *     })();\n         * </script><pre>\n         *\n         */\n        startAnimation: function (direction, stepCount, delay) {\n            var that = this;\n\n            delay = delay || 250;\n\n            if (this.type === Const.OBJECT_TYPE_GLIDER && !Type.exists(this.intervalCode)) {\n                this.intervalCode = window.setInterval(function () {\n                    that._anim(direction, stepCount);\n                }, delay);\n\n                if (!Type.exists(this.intervalCount)) {\n                    this.intervalCount = 0;\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Stop animation.\n         * @name Glider#stopAnimation\n         * @see Glider#startAnimation\n         * @function\n         * @returns {JXG.CoordsElement} Reference to itself.\n         */\n        stopAnimation: function () {\n            if (Type.exists(this.intervalCode)) {\n                window.clearInterval(this.intervalCode);\n                delete this.intervalCode;\n            }\n\n            return this;\n        },\n\n        /**\n         * Starts an animation which moves the point along a given path in given time.\n         * @param {Array|function} path The path the point is moved on.\n         * This can be either an array of arrays or containing x and y values of the points of\n         * the path, or an array of points, or a function taking the amount of elapsed time since the animation\n         * has started and returns an array containing a x and a y value or NaN.\n         * In case of NaN the animation stops.\n         * @param {Number} time The time in milliseconds in which to finish the animation\n         * @param {Object} [options] Optional settings for the animation.\n         * @param {function} [options.callback] A function that is called as soon as the animation is finished.\n         * @param {Boolean} [options.interpolate=true] If <tt>path</tt> is an array moveAlong()\n         * will interpolate the path\n         * using {@link JXG.Math.Numerics.Neville}. Set this flag to false if you don't want to use interpolation.\n         * @returns {JXG.CoordsElement} Reference to itself.\n         * @see JXG.CoordsElement#moveAlong\n         * @see JXG.CoordsElement#moveTo\n         * @see JXG.GeometryElement#animate\n         */\n        moveAlong: function (path, time, options) {\n            options = options || {};\n\n            var i,\n                neville,\n                interpath = [],\n                p = [],\n                delay = this.board.attr.animationdelay,\n                steps = time / delay,\n                len,\n                pos,\n                part,\n                makeFakeFunction = function (i, j) {\n                    return function () {\n                        return path[i][j];\n                    };\n                };\n\n            if (Type.isArray(path)) {\n                len = path.length;\n                for (i = 0; i < len; i++) {\n                    if (Type.isPoint(path[i])) {\n                        p[i] = path[i];\n                    } else {\n                        p[i] = {\n                            elementClass: Const.OBJECT_CLASS_POINT,\n                            X: makeFakeFunction(i, 0),\n                            Y: makeFakeFunction(i, 1)\n                        };\n                    }\n                }\n\n                time = time || 0;\n                if (time === 0) {\n                    this.setPosition(Const.COORDS_BY_USER, [\n                        p[p.length - 1].X(),\n                        p[p.length - 1].Y()\n                    ]);\n                    return this.board.update(this);\n                }\n\n                if (!Type.exists(options.interpolate) || options.interpolate) {\n                    neville = Numerics.Neville(p);\n                    for (i = 0; i < steps; i++) {\n                        interpath[i] = [];\n                        interpath[i][0] = neville[0](((steps - i) / steps) * neville[3]());\n                        interpath[i][1] = neville[1](((steps - i) / steps) * neville[3]());\n                    }\n                } else {\n                    len = path.length - 1;\n                    for (i = 0; i < steps; ++i) {\n                        pos = Math.floor((i / steps) * len);\n                        part = (i / steps) * len - pos;\n\n                        interpath[i] = [];\n                        interpath[i][0] = (1.0 - part) * p[pos].X() + part * p[pos + 1].X();\n                        interpath[i][1] = (1.0 - part) * p[pos].Y() + part * p[pos + 1].Y();\n                    }\n                    interpath.push([p[len].X(), p[len].Y()]);\n                    interpath.reverse();\n                    /*\n                    for (i = 0; i < steps; i++) {\n                        interpath[i] = [];\n                        interpath[i][0] = path[Math.floor((steps - i) / steps * (path.length - 1))][0];\n                        interpath[i][1] = path[Math.floor((steps - i) / steps * (path.length - 1))][1];\n                    }\n                    */\n                }\n\n                this.animationPath = interpath;\n            } else if (Type.isFunction(path)) {\n                this.animationPath = path;\n                this.animationStart = new Date().getTime();\n            }\n\n            this.animationCallback = options.callback;\n            this.board.addAnimation(this);\n\n            return this;\n        },\n\n        /**\n         * Starts an animated point movement towards the given coordinates <tt>where</tt>.\n         * The animation is done after <tt>time</tt> milliseconds.\n         * If the second parameter is not given or is equal to 0, setPosition() is called, see #setPosition,\n         * i.e. the coordinates are changed without animation.\n         * @param {Array} where Array containing the x and y coordinate of the target location.\n         * @param {Number} [time] Number of milliseconds the animation should last.\n         * @param {Object} [options] Optional settings for the animation\n         * @param {function} [options.callback] A function that is called as soon as the animation is finished.\n         * @param {String} [options.effect='<>'] animation effects like speed fade in and out. possible values are\n         * '<>' for speed increase on start and slow down at the end (default) and '--' for constant speed during\n         * the whole animation.\n         * @returns {JXG.CoordsElement} Reference to itself.\n         * @see JXG.CoordsElement#moveAlong\n         * @see JXG.CoordsElement#visit\n         * @see JXG.GeometryElement#animate\n         */\n        moveTo: function (where, time, options) {\n            options = options || {};\n            where = new Coords(Const.COORDS_BY_USER, where, this.board);\n\n            var i,\n                delay = this.board.attr.animationdelay,\n                steps = Math.ceil(time / delay),\n                coords = [],\n                X = this.coords.usrCoords[1],\n                Y = this.coords.usrCoords[2],\n                dX = where.usrCoords[1] - X,\n                dY = where.usrCoords[2] - Y,\n                /** @ignore */\n                stepFun = function (i) {\n                    if (options.effect && options.effect === \"<>\") {\n                        return Math.pow(Math.sin(((i / steps) * Math.PI) / 2), 2);\n                    }\n                    return i / steps;\n                };\n\n            if (\n                !Type.exists(time) ||\n                time === 0 ||\n                Math.abs(where.usrCoords[0] - this.coords.usrCoords[0]) > Mat.eps\n            ) {\n                this.setPosition(Const.COORDS_BY_USER, where.usrCoords);\n                return this.board.update(this);\n            }\n\n            // In case there is no callback and we are already at the endpoint we can stop here\n            if (\n                !Type.exists(options.callback) &&\n                Math.abs(dX) < Mat.eps &&\n                Math.abs(dY) < Mat.eps\n            ) {\n                return this;\n            }\n\n            for (i = steps; i >= 0; i--) {\n                coords[steps - i] = [\n                    where.usrCoords[0],\n                    X + dX * stepFun(i),\n                    Y + dY * stepFun(i)\n                ];\n            }\n\n            this.animationPath = coords;\n            this.animationCallback = options.callback;\n            this.board.addAnimation(this);\n\n            return this;\n        },\n\n        /**\n         * Starts an animated point movement towards the given coordinates <tt>where</tt>. After arriving at\n         * <tt>where</tt> the point moves back to where it started. The animation is done after <tt>time</tt>\n         * milliseconds.\n         * @param {Array} where Array containing the x and y coordinate of the target location.\n         * @param {Number} time Number of milliseconds the animation should last.\n         * @param {Object} [options] Optional settings for the animation\n         * @param {function} [options.callback] A function that is called as soon as the animation is finished.\n         * @param {String} [options.effect='<>'] animation effects like speed fade in and out. possible values are\n         * '<>' for speed increase on start and slow down at the end (default) and '--' for constant speed during\n         * the whole animation.\n         * @param {Number} [options.repeat=1] How often this animation should be repeated.\n         * @returns {JXG.CoordsElement} Reference to itself.\n         * @see JXG.CoordsElement#moveAlong\n         * @see JXG.CoordsElement#moveTo\n         * @see JXG.GeometryElement#animate\n         */\n        visit: function (where, time, options) {\n            where = new Coords(Const.COORDS_BY_USER, where, this.board);\n\n            var i,\n                j,\n                steps,\n                delay = this.board.attr.animationdelay,\n                coords = [],\n                X = this.coords.usrCoords[1],\n                Y = this.coords.usrCoords[2],\n                dX = where.usrCoords[1] - X,\n                dY = where.usrCoords[2] - Y,\n                /** @ignore */\n                stepFun = function (i) {\n                    var x = i < steps / 2 ? (2 * i) / steps : (2 * (steps - i)) / steps;\n\n                    if (options.effect && options.effect === \"<>\") {\n                        return Math.pow(Math.sin((x * Math.PI) / 2), 2);\n                    }\n\n                    return x;\n                };\n\n            // support legacy interface where the third parameter was the number of repeats\n            if (Type.isNumber(options)) {\n                options = { repeat: options };\n            } else {\n                options = options || {};\n                if (!Type.exists(options.repeat)) {\n                    options.repeat = 1;\n                }\n            }\n\n            steps = Math.ceil(time / (delay * options.repeat));\n\n            for (j = 0; j < options.repeat; j++) {\n                for (i = steps; i >= 0; i--) {\n                    coords[j * (steps + 1) + steps - i] = [\n                        where.usrCoords[0],\n                        X + dX * stepFun(i),\n                        Y + dY * stepFun(i)\n                    ];\n                }\n            }\n            this.animationPath = coords;\n            this.animationCallback = options.callback;\n            this.board.addAnimation(this);\n\n            return this;\n        },\n\n        /**\n         * Animates a glider. Is called by the browser after startAnimation is called.\n         * @param {Number} direction The direction the glider is animated.\n         * @param {Number} stepCount The number of steps in which the parent element is divided.\n         * Must be at least 1.\n         * @see #startAnimation\n         * @see #stopAnimation\n         * @private\n         * @returns {JXG.CoordsElement} Reference to itself.\n         */\n        _anim: function (direction, stepCount) {\n            var dX, dY, alpha, startPoint, newX, radius, sp1c, sp2c, res, d;\n\n            this.intervalCount += 1;\n            if (this.intervalCount > stepCount) {\n                this.intervalCount = 0;\n            }\n\n            if (this.slideObject.elementClass === Const.OBJECT_CLASS_LINE) {\n                sp1c = this.slideObject.point1.coords.scrCoords;\n                sp2c = this.slideObject.point2.coords.scrCoords;\n\n                dX = Math.round(((sp2c[1] - sp1c[1]) * this.intervalCount) / stepCount);\n                dY = Math.round(((sp2c[2] - sp1c[2]) * this.intervalCount) / stepCount);\n                if (direction > 0) {\n                    startPoint = this.slideObject.point1;\n                } else {\n                    startPoint = this.slideObject.point2;\n                    dX *= -1;\n                    dY *= -1;\n                }\n\n                this.coords.setCoordinates(Const.COORDS_BY_SCREEN, [\n                    startPoint.coords.scrCoords[1] + dX,\n                    startPoint.coords.scrCoords[2] + dY\n                ]);\n            } else if (this.slideObject.elementClass === Const.OBJECT_CLASS_CURVE) {\n                if (direction > 0) {\n                    newX = Math.round(\n                        (this.intervalCount / stepCount) * this.board.canvasWidth\n                    );\n                } else {\n                    newX = Math.round(\n                        ((stepCount - this.intervalCount) / stepCount) * this.board.canvasWidth\n                    );\n                }\n\n                this.coords.setCoordinates(Const.COORDS_BY_SCREEN, [newX, 0]);\n                res = Geometry.projectPointToCurve(this, this.slideObject, this.board);\n                this.coords = res[0];\n                this.position = res[1];\n            } else if (this.slideObject.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                alpha = 2 * Math.PI;\n                if (direction < 0) {\n                    alpha *= this.intervalCount / stepCount;\n                } else {\n                    alpha *= (stepCount - this.intervalCount) / stepCount;\n                }\n                radius = this.slideObject.Radius();\n\n                this.coords.setCoordinates(Const.COORDS_BY_USER, [\n                    this.slideObject.center.coords.usrCoords[1] + radius * Math.cos(alpha),\n                    this.slideObject.center.coords.usrCoords[2] + radius * Math.sin(alpha)\n                ]);\n            }\n\n            this.board.update(this);\n            return this;\n        },\n\n        // documented in GeometryElement\n        getTextAnchor: function () {\n            return this.coords;\n        },\n\n        // documented in GeometryElement\n        getLabelAnchor: function () {\n            return this.coords;\n        },\n\n        // documented in element.js\n        getParents: function () {\n            var p = [this.Z(), this.X(), this.Y()];\n\n            if (this.parents.length !== 0) {\n                p = this.parents;\n            }\n\n            if (this.type === Const.OBJECT_TYPE_GLIDER) {\n                p = [this.X(), this.Y(), this.slideObject.id];\n            }\n\n            return p;\n        }\n    }\n);\n\n/**\n * Generic method to create point, text or image.\n * Determines the type of the construction, i.e. free, or constrained by function,\n * transformation or of glider type.\n * @param{Object} Callback Object type, e.g. JXG.Point, JXG.Text or JXG.Image\n * @param{Object} board Link to the board object\n * @param{Array} coords Array with coordinates. This may be: array of numbers, function\n * returning an array of numbers, array of functions returning a number, object and transformation.\n * If the attribute \"slideObject\" exists, a glider element is constructed.\n * @param{Object} attr Attributes object\n * @param{Object} arg1 Optional argument 1: in case of text this is the text content,\n * in case of an image this is the url.\n * @param{Array} arg2 Optional argument 2: in case of image this is an array containing the size of\n * the image.\n * @returns{Object} returns the created object or false.\n */\nJXG.CoordsElement.create = function (Callback, board, coords, attr, arg1, arg2) {\n    var el,\n        isConstrained = false,\n        i;\n\n    for (i = 0; i < coords.length; i++) {\n        if (Type.isFunction(coords[i]) || Type.isString(coords[i])) {\n            isConstrained = true;\n        }\n    }\n\n    if (!isConstrained) {\n        if (Type.isNumber(coords[0]) && Type.isNumber(coords[1])) {\n            el = new Callback(board, coords, attr, arg1, arg2);\n\n            if (Type.exists(attr.slideobject)) {\n                el.makeGlider(attr.slideobject);\n            } else {\n                // Free element\n                el.baseElement = el;\n            }\n            el.isDraggable = true;\n        } else if (Type.isObject(coords[0]) && Type.isTransformationOrArray(coords[1])) {\n            // Transformation\n            // TODO less general specification of isObject\n            el = new Callback(board, [0, 0], attr, arg1, arg2);\n            el.addTransform(coords[0], coords[1]);\n            el.isDraggable = false;\n        } else {\n            return false;\n        }\n    } else {\n        el = new Callback(board, [0, 0], attr, arg1, arg2);\n        el.addConstraint(coords);\n    }\n\n    el.handleSnapToGrid();\n    el.handleSnapToPoints();\n    el.handleAttractors();\n\n    el.addParents(coords);\n    return el;\n};\n\nexport default JXG.CoordsElement;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true, unparam: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport Coords from \"./coords\";\nimport Mat from \"../math/math\";\nimport Statistics from \"../math/statistics\";\nimport Options from \"../options\";\nimport EventEmitter from \"../utils/event\";\nimport Color from \"../utils/color\";\nimport Type from \"../utils/type\";\n\n/**\n * Constructs a new GeometryElement object.\n * @class This is the basic class for geometry elements like points, circles and lines.\n * @constructor\n * @param {JXG.Board} board Reference to the board the element is constructed on.\n * @param {Object} attributes Hash of attributes and their values.\n * @param {Number} type Element type (a <tt>JXG.OBJECT_TYPE_</tt> value).\n * @param {Number} oclass The element's class (a <tt>JXG.OBJECT_CLASS_</tt> value).\n * @borrows JXG.EventEmitter#on as this.on\n * @borrows JXG.EventEmitter#off as this.off\n * @borrows JXG.EventEmitter#triggerEventHandlers as this.triggerEventHandlers\n * @borrows JXG.EventEmitter#eventHandlers as this.eventHandlers\n */\nJXG.GeometryElement = function (board, attributes, type, oclass) {\n    var name, key, attr;\n\n    /**\n     * Controls if updates are necessary\n     * @type Boolean\n     * @default true\n     */\n    this.needsUpdate = true;\n\n    /**\n     * Controls if this element can be dragged. In GEONExT only\n     * free points and gliders can be dragged.\n     * @type Boolean\n     * @default false\n     */\n    this.isDraggable = false;\n\n    /**\n     * If element is in two dimensional real space this is true, else false.\n     * @type Boolean\n     * @default true\n     */\n    this.isReal = true;\n\n    /**\n     * Stores all dependent objects to be updated when this point is moved.\n     * @type Object\n     */\n    this.childElements = {};\n\n    /**\n     * If element has a label subelement then this property will be set to true.\n     * @type Boolean\n     * @default false\n     */\n    this.hasLabel = false;\n\n    /**\n     * True, if the element is currently highlighted.\n     * @type Boolean\n     * @default false\n     */\n    this.highlighted = false;\n\n    /**\n     * Stores all Intersection Objects which in this moment are not real and\n     * so hide this element.\n     * @type Object\n     */\n    this.notExistingParents = {};\n\n    /**\n     * Keeps track of all objects drawn as part of the trace of the element.\n     * @see JXG.GeometryElement#clearTrace\n     * @see JXG.GeometryElement#numTraces\n     * @type Object\n     */\n    this.traces = {};\n\n    /**\n     * Counts the number of objects drawn as part of the trace of the element.\n     * @see JXG.GeometryElement#clearTrace\n     * @see JXG.GeometryElement#traces\n     * @type Number\n     */\n    this.numTraces = 0;\n\n    /**\n     * Stores the  transformations which are applied during update in an array\n     * @type Array\n     * @see JXG.Transformation\n     */\n    this.transformations = [];\n\n    /**\n     * @type JXG.GeometryElement\n     * @default null\n     * @private\n     */\n    this.baseElement = null;\n\n    /**\n     * Elements depending on this element are stored here.\n     * @type Object\n     */\n    this.descendants = {};\n\n    /**\n     * Elements on which this element depends on are stored here.\n     * @type Object\n     */\n    this.ancestors = {};\n\n    /**\n     * Ids of elements on which this element depends directly are stored here.\n     * @type Object\n     */\n    this.parents = [];\n\n    /**\n     * Stores variables for symbolic computations\n     * @type Object\n     */\n    this.symbolic = {};\n\n    /**\n     * Stores the SVG (or VML) rendering node for the element. This enables low-level\n     * access to SVG nodes. The properties of such an SVG node can then be changed\n     * by calling setAttribute(). Note that there are a few elements which consist\n     * of more than one SVG nodes:\n     * <ul>\n     * <li> Elements with arrow tail or head: rendNodeTriangleStart, rendNodeTriangleEnd\n     * <li> SVG (or VML) texts: rendNodeText\n     * <li> Button: rendNodeForm, rendNodeButton, rendNodeTag\n     * <li> Checkbox: rendNodeForm, rendNodeCheckbox, rendNodeLabel, rendNodeTag\n     * <li> Input: rendNodeForm, rendNodeInput, rendNodeLabel, rendNodeTag\n     * </ul>\n     *\n     * Here is are two examples: The first example shows how to access the SVG node,\n     * the second example demonstrates how to change SVG attributes.\n     * @example\n     *     var p1 = board.create('point', [0, 0]);\n     *     console.log(p1.rendNode);\n     *     // returns the full SVG node details of the point p1, something like:\n     *     // &lt;ellipse id='box_jxgBoard1P6' stroke='#ff0000' stroke-opacity='1' stroke-width='2px'\n     *     //   fill='#ff0000' fill-opacity='1' cx='250' cy='250' rx='4' ry='4'\n     *     //   style='position: absolute;'&gt;\n     *     // &lt;/ellipse&gt;\n     *\n     * @example\n     *     var s = board.create('segment', [p1, p2], {strokeWidth: 60});\n     *     s.rendNode.setAttribute('stroke-linecap', 'round');\n     *\n     * @type Object\n     */\n    this.rendNode = null;\n\n    /**\n     * The string used with {@link JXG.Board#create}\n     * @type String\n     */\n    this.elType = \"\";\n\n    /**\n     * The element is saved with an explicit entry in the file (<tt>true</tt>) or implicitly\n     * via a composition.\n     * @type Boolean\n     * @default true\n     */\n    this.dump = true;\n\n    /**\n     * Subs contains the subelements, created during the create method.\n     * @type Object\n     */\n    this.subs = {};\n\n    /**\n     * Inherits contains the subelements, which may have an attribute\n     * (in particular the attribute \"visible\") having value 'inherit'.\n     * @type Object\n     */\n    this.inherits = [];\n\n    /**\n     * The position of this element inside the {@link JXG.Board#objectsList}.\n     * @type Number\n     * @default -1\n     * @private\n     */\n    this._pos = -1;\n\n    /**\n     * [c, b0, b1, a, k, r, q0, q1]\n     *\n     * See\n     * A.E. Middleditch, T.W. Stacey, and S.B. Tor:\n     * \"Intersection Algorithms for Lines and Circles\",\n     * ACM Transactions on Graphics, Vol. 8, 1, 1989, pp 25-40.\n     *\n     * The meaning of the parameters is:\n     * Circle: points p=[p0, p1] on the circle fulfill\n     *  a&lt;p, p&gt; + &lt;b, p&gt; + c = 0\n     * For convenience we also store\n     *  r: radius\n     *  k: discriminant = sqrt(&lt;b,b&gt;-4ac)\n     *  q=[q0, q1] center\n     *\n     * Points have radius = 0.\n     * Lines have radius = infinity.\n     * b: normalized vector, representing the direction of the line.\n     *\n     * Should be put into Coords, when all elements possess Coords.\n     * @type Array\n     * @default [1, 0, 0, 0, 1, 1, 0, 0]\n     */\n    this.stdform = [1, 0, 0, 0, 1, 1, 0, 0];\n\n    /**\n     * The methodMap determines which methods can be called from within JessieCode and under which name it\n     * can be used. The map is saved in an object, the name of a property is the name of the method used in JessieCode,\n     * the value of a property is the name of the method in JavaScript.\n     * @type Object\n     */\n    this.methodMap = {\n        setLabel: \"setLabel\",\n        label: \"label\",\n        setName: \"setName\",\n        getName: \"getName\",\n        addTransform: \"addTransform\",\n        setProperty: \"setAttribute\",\n        setAttribute: \"setAttribute\",\n        addChild: \"addChild\",\n        animate: \"animate\",\n        on: \"on\",\n        off: \"off\",\n        trigger: \"trigger\",\n        addTicks: \"addTicks\",\n        removeTicks: \"removeTicks\",\n        removeAllTicks: \"removeAllTicks\"\n    };\n\n    /**\n     * Quadratic form representation of circles (and conics)\n     * @type Array\n     * @default [[1,0,0],[0,1,0],[0,0,1]]\n     */\n    this.quadraticform = [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ];\n\n    /**\n     * An associative array containing all visual properties.\n     * @type Object\n     * @default empty object\n     */\n    this.visProp = {};\n\n    /**\n     * An associative array containing visual properties which are calculated from\n     * the attribute values (i.e. visProp) and from other constraints.\n     * An example: if an intersection point does not have real coordinates,\n     * visPropCalc.visible is set to false.\n     * Additionally, the user can control visibility with the attribute \"visible\",\n     * even by supplying a functions as value.\n     *\n     * @type Object\n     * @default empty object\n     */\n    this.visPropCalc = {\n        visible: false\n    };\n\n    EventEmitter.eventify(this);\n\n    /**\n     * Is the mouse over this element?\n     * @type Boolean\n     * @default false\n     */\n    this.mouseover = false;\n\n    /**\n     * Time stamp containing the last time this element has been dragged.\n     * @type Date\n     * @default creation time\n     */\n    this.lastDragTime = new Date();\n\n    if (arguments.length > 0) {\n        /**\n         * Reference to the board associated with the element.\n         * @type JXG.Board\n         */\n        this.board = board;\n\n        /**\n         * Type of the element.\n         * @constant\n         * @type Number\n         */\n        this.type = type;\n\n        /**\n         * Original type of the element at construction time. Used for removing glider property.\n         * @constant\n         * @type Number\n         */\n        this._org_type = type;\n\n        /**\n         * The element's class.\n         * @constant\n         * @type Number\n         */\n        this.elementClass = oclass || Const.OBJECT_CLASS_OTHER;\n\n        /**\n         * Unique identifier for the element. Equivalent to id-attribute of renderer element.\n         * @type String\n         */\n        this.id = attributes.id;\n\n        name = attributes.name;\n        /* If name is not set or null or even undefined, generate an unique name for this object */\n        if (!Type.exists(name)) {\n            name = this.board.generateName(this);\n        }\n\n        if (name !== \"\") {\n            this.board.elementsByName[name] = this;\n        }\n\n        /**\n         * Not necessarily unique name for the element.\n         * @type String\n         * @default Name generated by {@link JXG.Board#generateName}.\n         * @see JXG.Board#generateName\n         */\n        this.name = name;\n\n        this.needsRegularUpdate = attributes.needsregularupdate;\n\n        // create this.visPropOld and set default values\n        Type.clearVisPropOld(this);\n\n        attr = this.resolveShortcuts(attributes);\n        for (key in attr) {\n            if (attr.hasOwnProperty(key)) {\n                this._set(key, attr[key]);\n            }\n        }\n\n        this.visProp.draft = attr.draft && attr.draft.draft;\n        //this.visProp.gradientangle = '270';\n        // this.visProp.gradientsecondopacity = Type.evaluate(this.visProp.fillopacity);\n        //this.visProp.gradientpositionx = 0.5;\n        //this.visProp.gradientpositiony = 0.5;\n    }\n};\n\nJXG.extend(\n    JXG.GeometryElement.prototype,\n    /** @lends JXG.GeometryElement.prototype */ {\n        /**\n         * Add an element as a child to the current element. Can be used to model dependencies between geometry elements.\n         * @param {JXG.GeometryElement} obj The dependent object.\n         */\n        addChild: function (obj) {\n            var el, el2;\n\n            this.childElements[obj.id] = obj;\n            this.addDescendants(obj);\n            obj.ancestors[this.id] = this;\n\n            for (el in this.descendants) {\n                if (this.descendants.hasOwnProperty(el)) {\n                    this.descendants[el].ancestors[this.id] = this;\n\n                    for (el2 in this.ancestors) {\n                        if (this.ancestors.hasOwnProperty(el2)) {\n                            this.descendants[el].ancestors[this.ancestors[el2].id] =\n                                this.ancestors[el2];\n                        }\n                    }\n                }\n            }\n\n            for (el in this.ancestors) {\n                if (this.ancestors.hasOwnProperty(el)) {\n                    for (el2 in this.descendants) {\n                        if (this.descendants.hasOwnProperty(el2)) {\n                            this.ancestors[el].descendants[this.descendants[el2].id] =\n                                this.descendants[el2];\n                        }\n                    }\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Adds the given object to the descendants list of this object and all its child objects.\n         * @param {JXG.GeometryElement} obj The element that is to be added to the descendants list.\n         * @private\n         * @return\n         */\n        addDescendants: function (obj) {\n            var el;\n\n            this.descendants[obj.id] = obj;\n            for (el in obj.childElements) {\n                if (obj.childElements.hasOwnProperty(el)) {\n                    this.addDescendants(obj.childElements[el]);\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Adds ids of elements to the array this.parents. This method needs to be called if some dependencies\n         * can not be detected automatically by JSXGraph. For example if a function graph is given by a function\n         * which referes to coordinates of a point, calling addParents() is necessary.\n         *\n         * @param {Array} parents Array of elements or ids of elements.\n         * Alternatively, one can give a list of objects as parameters.\n         * @returns {JXG.Object} reference to the object itself.\n         *\n         * @example\n         * // Movable function graph\n         * var A = board.create('point', [1, 0], {name:'A'}),\n         *     B = board.create('point', [3, 1], {name:'B'}),\n         *     f = board.create('functiongraph', function(x) {\n         *          var ax = A.X(),\n         *              ay = A.Y(),\n         *              bx = B.X(),\n         *              by = B.Y(),\n         *              a = (by - ay) / ( (bx - ax) * (bx - ax) );\n         *           return a * (x - ax) * (x - ax) + ay;\n         *      }, {fixed: false});\n         * f.addParents([A, B]);\n         * </pre><div class=\"jxgbox\" id=\"JXG7c91d4d2-986c-4378-8135-24505027f251\" style=\"width: 400px; height: 400px;\"></div>\n         * <script type=\"text/javascript\">\n         * (function() {\n         *   var board = JXG.JSXGraph.initBoard('JXG7c91d4d2-986c-4378-8135-24505027f251', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n         *   var A = board.create('point', [1, 0], {name:'A'}),\n         *       B = board.create('point', [3, 1], {name:'B'}),\n         *       f = board.create('functiongraph', function(x) {\n         *            var ax = A.X(),\n         *                ay = A.Y(),\n         *                bx = B.X(),\n         *                by = B.Y(),\n         *                a = (by - ay) / ( (bx - ax) * (bx - ax) );\n         *             return a * (x - ax) * (x - ax) + ay;\n         *        }, {fixed: false});\n         *   f.addParents([A, B]);\n         * })();\n         * </script><pre>\n         *\n         **/\n        addParents: function (parents) {\n            var i, len, par;\n\n            if (Type.isArray(parents)) {\n                par = parents;\n            } else {\n                par = arguments;\n            }\n\n            len = par.length;\n            for (i = 0; i < len; ++i) {\n                if (!Type.exists(par[i])) {\n                    continue;\n                }\n                if (Type.isId(this.board, par[i])) {\n                    this.parents.push(par[i]);\n                } else if (Type.exists(par[i].id)) {\n                    this.parents.push(par[i].id);\n                }\n            }\n            this.parents = Type.uniqueArray(this.parents);\n        },\n\n        /**\n         * Sets ids of elements to the array this.parents.\n         * First, this.parents is cleared. See {@link JXG.GeometryElement#addParents}.\n         * @param {Array} parents Array of elements or ids of elements.\n         * Alternatively, one can give a list of objects as parameters.\n         * @returns {JXG.Object} reference to the object itself.\n         **/\n        setParents: function (parents) {\n            this.parents = [];\n            this.addParents(parents);\n        },\n\n        /**\n         * Remove an element as a child from the current element.\n         * @param {JXG.GeometryElement} obj The dependent object.\n         */\n        removeChild: function (obj) {\n            //var el, el2;\n\n            delete this.childElements[obj.id];\n            this.removeDescendants(obj);\n            delete obj.ancestors[this.id];\n\n            /*\n             // I do not know if these addDescendants stuff has to be adapted to removeChild. A.W.\n            for (el in this.descendants) {\n                if (this.descendants.hasOwnProperty(el)) {\n                    delete this.descendants[el].ancestors[this.id];\n\n                    for (el2 in this.ancestors) {\n                        if (this.ancestors.hasOwnProperty(el2)) {\n                            this.descendants[el].ancestors[this.ancestors[el2].id] = this.ancestors[el2];\n                        }\n                    }\n                }\n            }\n\n            for (el in this.ancestors) {\n                if (this.ancestors.hasOwnProperty(el)) {\n                    for (el2 in this.descendants) {\n                        if (this.descendants.hasOwnProperty(el2)) {\n                            this.ancestors[el].descendants[this.descendants[el2].id] = this.descendants[el2];\n                        }\n                    }\n                }\n            }\n            */\n            return this;\n        },\n\n        /**\n         * Removes the given object from the descendants list of this object and all its child objects.\n         * @param {JXG.GeometryElement} obj The element that is to be removed from the descendants list.\n         * @private\n         * @return\n         */\n        removeDescendants: function (obj) {\n            var el;\n\n            delete this.descendants[obj.id];\n            for (el in obj.childElements) {\n                if (obj.childElements.hasOwnProperty(el)) {\n                    this.removeDescendants(obj.childElements[el]);\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Counts the direct children of an object without counting labels.\n         * @private\n         * @returns {number} Number of children\n         */\n        countChildren: function () {\n            var prop,\n                d,\n                s = 0;\n\n            d = this.childElements;\n            for (prop in d) {\n                if (d.hasOwnProperty(prop) && prop.indexOf(\"Label\") < 0) {\n                    s++;\n                }\n            }\n            return s;\n        },\n\n        /**\n         * Returns the elements name. Used in JessieCode.\n         * @returns {String}\n         */\n        getName: function () {\n            return this.name;\n        },\n\n        /**\n         * Add transformations to this element.\n         * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation}\n         * or an array of {@link JXG.Transformation}s.\n         * @returns {JXG.GeometryElement} Reference to the element.\n         */\n        addTransform: function (transform) {\n            return this;\n        },\n\n        /**\n         * Decides whether an element can be dragged. This is used in\n         * {@link JXG.GeometryElement#setPositionDirectly} methods\n         * where all parent elements are checked if they may be dragged, too.\n         * @private\n         * @returns {boolean}\n         */\n        draggable: function () {\n            return (\n                this.isDraggable &&\n                !Type.evaluate(this.visProp.fixed) &&\n                // !this.visProp.frozen &&\n                this.type !== Const.OBJECT_TYPE_GLIDER\n            );\n        },\n\n        /**\n         * Translates the object by <tt>(x, y)</tt>. In case the element is defined by points, the defining points are\n         * translated, e.g. a circle constructed by a center point and a point on the circle line.\n         * @param {Number} method The type of coordinates used here.\n         * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.\n         * @param {Array} coords array of translation vector.\n         * @returns {JXG.GeometryElement} Reference to the element object.\n         */\n        setPosition: function (method, coords) {\n            var parents = [],\n                el,\n                i,\n                len,\n                t;\n\n            if (!Type.exists(this.parents)) {\n                return this;\n            }\n\n            len = this.parents.length;\n            for (i = 0; i < len; ++i) {\n                el = this.board.select(this.parents[i]);\n                if (Type.isPoint(el)) {\n                    if (!el.draggable()) {\n                        return this;\n                    }\n                    parents.push(el);\n                }\n            }\n\n            if (coords.length === 3) {\n                coords = coords.slice(1);\n            }\n\n            t = this.board.create(\"transform\", coords, { type: \"translate\" });\n\n            // We distinguish two cases:\n            // 1) elements which depend on free elements, i.e. arcs and sectors\n            // 2) other elements\n            //\n            // In the first case we simply transform the parents elements\n            // In the second case we add a transform to the element.\n            //\n            len = parents.length;\n            if (len > 0) {\n                t.applyOnce(parents);\n            } else {\n                if (\n                    this.transformations.length > 0 &&\n                    this.transformations[this.transformations.length - 1].isNumericMatrix\n                ) {\n                    this.transformations[this.transformations.length - 1].melt(t);\n                } else {\n                    this.addTransform(t);\n                }\n            }\n\n            /*\n             * If - against the default configuration - defining gliders are marked as\n             * draggable, then their position has to be updated now.\n             */\n            for (i = 0; i < len; ++i) {\n                if (parents[i].type === Const.OBJECT_TYPE_GLIDER) {\n                    parents[i].updateGlider();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Moves an element by the difference of two coordinates.\n         * @param {Number} method The type of coordinates used here.\n         * Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.\n         * @param {Array} coords coordinates in screen/user units\n         * @param {Array} oldcoords previous coordinates in screen/user units\n         * @returns {JXG.GeometryElement} this element\n         */\n        setPositionDirectly: function (method, coords, oldcoords) {\n            var c = new Coords(method, coords, this.board, false),\n                oldc = new Coords(method, oldcoords, this.board, false),\n                dc = Statistics.subtract(c.usrCoords, oldc.usrCoords);\n\n            this.setPosition(Const.COORDS_BY_USER, dc);\n\n            return this;\n        },\n\n        /**\n         * Array of strings containing the polynomials defining the element.\n         * Used for determining geometric loci the groebner way.\n         * @returns {Array} An array containing polynomials describing the locus of the current object.\n         * @public\n         */\n        generatePolynomial: function () {\n            return [];\n        },\n\n        /**\n         * Animates properties for that object like stroke or fill color, opacity and maybe\n         * even more later.\n         * @param {Object} hash Object containing properties with target values for the animation.\n         * @param {number} time Number of milliseconds to complete the animation.\n         * @param {Object} [options] Optional settings for the animation:<ul><li>callback: A function that is called as soon as the animation is finished.</li></ul>\n         * @returns {JXG.GeometryElement} A reference to the object\n         */\n        animate: function (hash, time, options) {\n            options = options || {};\n            var r,\n                p,\n                i,\n                delay = this.board.attr.animationdelay,\n                steps = Math.ceil(time / delay),\n                self = this,\n                animateColor = function (startRGB, endRGB, property) {\n                    var hsv1, hsv2, sh, ss, sv;\n                    hsv1 = Color.rgb2hsv(startRGB);\n                    hsv2 = Color.rgb2hsv(endRGB);\n\n                    sh = (hsv2[0] - hsv1[0]) / steps;\n                    ss = (hsv2[1] - hsv1[1]) / steps;\n                    sv = (hsv2[2] - hsv1[2]) / steps;\n                    self.animationData[property] = [];\n\n                    for (i = 0; i < steps; i++) {\n                        self.animationData[property][steps - i - 1] = Color.hsv2rgb(\n                            hsv1[0] + (i + 1) * sh,\n                            hsv1[1] + (i + 1) * ss,\n                            hsv1[2] + (i + 1) * sv\n                        );\n                    }\n                },\n                animateFloat = function (start, end, property, round) {\n                    var tmp, s;\n\n                    start = parseFloat(start);\n                    end = parseFloat(end);\n\n                    // we can't animate without having valid numbers.\n                    // And parseFloat returns NaN if the given string doesn't contain\n                    // a valid float number.\n                    if (isNaN(start) || isNaN(end)) {\n                        return;\n                    }\n\n                    s = (end - start) / steps;\n                    self.animationData[property] = [];\n\n                    for (i = 0; i < steps; i++) {\n                        tmp = start + (i + 1) * s;\n                        self.animationData[property][steps - i - 1] = round\n                            ? Math.floor(tmp)\n                            : tmp;\n                    }\n                };\n\n            this.animationData = {};\n\n            for (r in hash) {\n                if (hash.hasOwnProperty(r)) {\n                    p = r.toLowerCase();\n\n                    switch (p) {\n                        case \"strokecolor\":\n                        case \"fillcolor\":\n                            animateColor(this.visProp[p], hash[r], p);\n                            break;\n                        case \"size\":\n                            if (!Type.isPoint(this)) {\n                                break;\n                            }\n                            animateFloat(this.visProp[p], hash[r], p, true);\n                            break;\n                        case \"strokeopacity\":\n                        case \"strokewidth\":\n                        case \"fillopacity\":\n                            animateFloat(this.visProp[p], hash[r], p, false);\n                            break;\n                    }\n                }\n            }\n\n            this.animationCallback = options.callback;\n            this.board.addAnimation(this);\n            return this;\n        },\n\n        /**\n         * General update method. Should be overwritten by the element itself.\n         * Can be used sometimes to commit changes to the object.\n         * @return {JXG.GeometryElement} Reference to the element\n         */\n        update: function () {\n            if (Type.evaluate(this.visProp.trace)) {\n                this.cloneToBackground();\n            }\n            return this;\n        },\n\n        /**\n         * Provide updateRenderer method.\n         * @return {JXG.GeometryElement} Reference to the element\n         * @private\n         */\n        updateRenderer: function () {\n            return this;\n        },\n\n        /**\n         * Run through the full update chain of an element.\n         * @param  {Boolean} visible Set visibility in case the elements attribute value is 'inherit'. null is allowed.\n         * @return {JXG.GeometryElement} Reference to the element\n         * @private\n         */\n        fullUpdate: function (visible) {\n            return this.prepareUpdate().update().updateVisibility(visible).updateRenderer();\n        },\n\n        /**\n         * Show the element or hide it. If hidden, it will still exist but not be\n         * visible on the board.\n         * @param  {Boolean} val true: show the element, false: hide the element\n         * @return {JXG.GeometryElement} Reference to the element\n         * @private\n         */\n        setDisplayRendNode: function (val) {\n            var i, len, s, len_s, obj;\n\n            if (val === undefined) {\n                val = this.visPropCalc.visible;\n            }\n\n            if (val === this.visPropOld.visible) {\n                return this;\n            }\n\n            // Set display of the element itself\n            this.board.renderer.display(this, val);\n\n            // Set the visibility of elements which inherit the attribute 'visible'\n            len = this.inherits.length;\n            for (s = 0; s < len; s++) {\n                obj = this.inherits[s];\n                if (Type.isArray(obj)) {\n                    len_s = obj.length;\n                    for (i = 0; i < len_s; i++) {\n                        if (\n                            Type.exists(obj[i]) &&\n                            Type.exists(obj[i].rendNode) &&\n                            Type.evaluate(obj[i].visProp.visible) === \"inherit\"\n                        ) {\n                            obj[i].setDisplayRendNode(val);\n                        }\n                    }\n                } else {\n                    if (\n                        Type.exists(obj) &&\n                        Type.exists(obj.rendNode) &&\n                        Type.evaluate(obj.visProp.visible) === \"inherit\"\n                    ) {\n                        obj.setDisplayRendNode(val);\n                    }\n                }\n            }\n\n            // Set the visibility of the label if it inherits the attribute 'visible'\n            if (this.hasLabel && Type.exists(this.label) && Type.exists(this.label.rendNode)) {\n                if (Type.evaluate(this.label.visProp.visible) === \"inherit\") {\n                    this.label.setDisplayRendNode(val);\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Hide the element. It will still exist but not be visible on the board.\n         * Alias for \"element.setAttribute({visible: false});\"\n         * @return {JXG.GeometryElement} Reference to the element\n         */\n        hide: function () {\n            this.setAttribute({ visible: false });\n            return this;\n        },\n\n        /**\n         * Hide the element. It will still exist but not be visible on the board.\n         * Alias for {@link JXG.GeometryElement#hide}\n         * @returns {JXG.GeometryElement} Reference to the element\n         */\n        hideElement: function () {\n            this.hide();\n            return this;\n        },\n\n        /**\n         * Make the element visible.\n         * Alias for \"element.setAttribute({visible: true});\"\n         * @return {JXG.GeometryElement} Reference to the element\n         */\n        show: function () {\n            this.setAttribute({ visible: true });\n            return this;\n        },\n\n        /**\n         * Make the element visible.\n         * Alias for {@link JXG.GeometryElement#show}\n         * @returns {JXG.GeometryElement} Reference to the element\n         */\n        showElement: function () {\n            this.show();\n            return this;\n        },\n\n        /**\n         * Set the visibility of an element. The visibility is influenced by\n         * (listed in ascending priority):\n         * <ol>\n         * <li> The value of the element's attribute 'visible'\n         * <li> The visibility of a parent element. (Example: label)\n         * This overrules the value of the element's attribute value only if\n         * this attribute value of the element is 'inherit'.\n         * <li> being inside of the canvas\n         * </ol>\n         * <p>\n         * This method is called three times for most elements:\n         * <ol>\n         * <li> between {@link JXG.GeometryElement#update}\n         * and {@link JXG.GeometryElement#updateRenderer}. In case the value is 'inherit', nothing is done.\n         * <li> Recursively, called by itself for child elements. Here, 'inherit' is overruled by the parent's value.\n         * <li> In {@link JXG.GeometryElement#updateRenderer}, if the element is outside of the canvas.\n         * </ol>\n         *\n         * @param  {Boolean} parent_val Visibility of the parent element.\n         * @return {JXG.GeometryElement} Reference to the element.\n         * @private\n         */\n        updateVisibility: function (parent_val) {\n            var i, len, s, len_s, obj, val;\n\n            if (this.needsUpdate) {\n                // Handle the element\n                if (parent_val !== undefined) {\n                    this.visPropCalc.visible = parent_val;\n                } else {\n                    val = Type.evaluate(this.visProp.visible);\n\n                    // infobox uses hiddenByParent\n                    if (Type.exists(this.hiddenByParent) && this.hiddenByParent) {\n                        val = false;\n                    }\n                    if (val !== \"inherit\") {\n                        this.visPropCalc.visible = val;\n                    }\n                }\n\n                // Handle elements which inherit the visibility\n                len = this.inherits.length;\n                for (s = 0; s < len; s++) {\n                    obj = this.inherits[s];\n                    if (Type.isArray(obj)) {\n                        len_s = obj.length;\n                        for (i = 0; i < len_s; i++) {\n                            if (\n                                Type.exists(obj[i]) /*&& Type.exists(obj[i].rendNode)*/ &&\n                                Type.evaluate(obj[i].visProp.visible) === \"inherit\"\n                            ) {\n                                obj[i]\n                                    .prepareUpdate()\n                                    .updateVisibility(this.visPropCalc.visible);\n                            }\n                        }\n                    } else {\n                        if (\n                            Type.exists(obj) /*&& Type.exists(obj.rendNode)*/ &&\n                            Type.evaluate(obj.visProp.visible) === \"inherit\"\n                        ) {\n                            obj.prepareUpdate().updateVisibility(this.visPropCalc.visible);\n                        }\n                    }\n                }\n\n                // Handle the label if it inherits the visibility\n                if (\n                    Type.exists(this.label) &&\n                    Type.exists(this.label.visProp) &&\n                    Type.evaluate(this.label.visProp.visible)\n                ) {\n                    this.label.prepareUpdate().updateVisibility(this.visPropCalc.visible);\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Sets the value of property <tt>property</tt> to <tt>value</tt>.\n         * @param {String} property The property's name.\n         * @param value The new value\n         * @private\n         */\n        _set: function (property, value) {\n            var el;\n\n            property = property.toLocaleLowerCase();\n\n            // Search for entries in visProp with \"color\" as part of the property name\n            // and containing a RGBA string\n            if (\n                this.visProp.hasOwnProperty(property) &&\n                property.indexOf(\"color\") >= 0 &&\n                Type.isString(value) &&\n                value.length === 9 &&\n                value.charAt(0) === \"#\"\n            ) {\n                value = Color.rgba2rgbo(value);\n                this.visProp[property] = value[0];\n                // Previously: *=. But then, we can only decrease opacity.\n                this.visProp[property.replace(\"color\", \"opacity\")] = value[1];\n            } else {\n                if (\n                    value !== null &&\n                    Type.isObject(value) &&\n                    !Type.exists(value.id) &&\n                    !Type.exists(value.name)\n                ) {\n                    // value is of type {prop: val, prop: val,...}\n                    // Convert these attributes to lowercase, too\n                    this.visProp[property] = {};\n                    for (el in value) {\n                        if (value.hasOwnProperty(el)) {\n                            this.visProp[property][el.toLocaleLowerCase()] = value[el];\n                        }\n                    }\n                } else {\n                    this.visProp[property] = value;\n                }\n            }\n        },\n\n        /**\n         * Resolves attribute shortcuts like <tt>color</tt> and expands them, e.g. <tt>strokeColor</tt> and <tt>fillColor</tt>.\n         * Writes the expanded attributes back to the given <tt>attributes</tt>.\n         * @param {Object} attributes object\n         * @returns {Object} The given attributes object with shortcuts expanded.\n         * @private\n         */\n        resolveShortcuts: function (attributes) {\n            var key,\n                i,\n                j,\n                subattr = [\"traceattributes\", \"traceAttributes\"];\n\n            for (key in Options.shortcuts) {\n                if (Options.shortcuts.hasOwnProperty(key)) {\n                    if (Type.exists(attributes[key])) {\n                        for (i = 0; i < Options.shortcuts[key].length; i++) {\n                            if (!Type.exists(attributes[Options.shortcuts[key][i]])) {\n                                attributes[Options.shortcuts[key][i]] = attributes[key];\n                            }\n                        }\n                    }\n                    for (j = 0; j < subattr.length; j++) {\n                        if (Type.isObject(attributes[subattr[j]])) {\n                            attributes[subattr[j]] = this.resolveShortcuts(\n                                attributes[subattr[j]]\n                            );\n                        }\n                    }\n                }\n            }\n            return attributes;\n        },\n\n        /**\n         * Sets a label and its text\n         * If label doesn't exist, it creates one\n         * @param {String} str\n         */\n        setLabel: function (str) {\n            if (!this.hasLabel) {\n                this.setAttribute({ withlabel: true });\n            }\n            this.setLabelText(str);\n        },\n\n        /**\n         * Updates the element's label text, strips all html.\n         * @param {String} str\n         */\n        setLabelText: function (str) {\n            if (Type.exists(this.label)) {\n                str = str.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n                this.label.setText(str);\n            }\n\n            return this;\n        },\n\n        /**\n         * Updates the element's label text and the element's attribute \"name\", strips all html.\n         * @param {String} str\n         */\n        setName: function (str) {\n            str = str.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n            if (this.elType !== \"slider\") {\n                this.setLabelText(str);\n            }\n            this.setAttribute({ name: str });\n        },\n\n        /**\n         * Deprecated alias for {@link JXG.GeometryElement#setAttribute}.\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}.\n         */\n        setProperty: function () {\n            JXG.deprecated(\"setProperty()\", \"setAttribute()\");\n            this.setAttribute.apply(this, arguments);\n        },\n\n        /**\n         * Sets an arbitrary number of attributes. This method has one or more\n         * parameters of the following types:\n         * <ul>\n         * <li> object: {key1:value1,key2:value2,...}\n         * <li> string: \"key1:value\"\n         * <li> array: [key, value]\n         * </ul>\n         * @param {Object} attributes An object with attributes.\n         * @returns {JXG.GeometryElement} A reference to the element.\n         *\n         * @function\n         * @example\n         * // Set property directly on creation of an element using the attributes object parameter\n         * var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 5, 5, 1]};\n         * var p = board.create('point', [2, 2], {visible: false});\n         *\n         * // Now make this point visible and fixed:\n         * p.setAttribute({\n         *     fixed: true,\n         *     visible: true\n         * });\n         */\n        setAttribute: function (attributes) {\n            var i,\n                j,\n                le,\n                key,\n                value,\n                arg,\n                opacity,\n                pair,\n                oldvalue,\n                properties = {};\n\n            // Normalize the user input\n            for (i = 0; i < arguments.length; i++) {\n                arg = arguments[i];\n                if (Type.isString(arg)) {\n                    // pairRaw is string of the form 'key:value'\n                    pair = arg.split(\":\");\n                    properties[Type.trim(pair[0])] = Type.trim(pair[1]);\n                } else if (!Type.isArray(arg)) {\n                    // pairRaw consists of objects of the form {key1:value1,key2:value2,...}\n                    JXG.extend(properties, arg);\n                } else {\n                    // pairRaw consists of array [key,value]\n                    properties[arg[0]] = arg[1];\n                }\n            }\n\n            // Handle shortcuts\n            properties = this.resolveShortcuts(properties);\n\n            for (i in properties) {\n                if (properties.hasOwnProperty(i)) {\n                    key = i.replace(/\\s+/g, \"\").toLowerCase();\n                    value = properties[i];\n\n                    // This handles the subobjects, if the key:value pairs are contained in an object.\n                    // Example:\n                    // ticks.setAttribute({\n                    //      strokeColor: 'blue',\n                    //      label: {\n                    //          visible: false\n                    //      }\n                    // })\n                    // Now, only the supplied label attributes are overwritten.\n                    // Otherwise, the value of label would be {visible:false} only.\n                    if (Type.isObject(value) && Type.exists(this.visProp[key])) {\n                        this.visProp[key] = Type.merge(this.visProp[key], value);\n\n                        // First, handle the special case\n                        // ticks.setAttribute({label: {anchorX: \"right\", ..., visible: true});\n                        if (this.type === Const.OBJECT_TYPE_TICKS && Type.exists(this.labels)) {\n                            le = this.labels.length;\n                            for (j = 0; j < le; j++) {\n                                this.labels[j].setAttribute(value);\n                            }\n                        } else if (Type.exists(this[key])) {\n                            if (Type.isArray(this[key])) {\n                                for (j = 0; j < this[key].length; j++) {\n                                    this[key][j].setAttribute(value);\n                                }\n                            } else {\n                                this[key].setAttribute(value);\n                            }\n                        }\n                        continue;\n                    }\n\n                    oldvalue = this.visProp[key];\n                    switch (key) {\n                        case \"name\":\n                            oldvalue = this.name;\n                            delete this.board.elementsByName[this.name];\n                            this.name = value;\n                            this.board.elementsByName[this.name] = this;\n                            break;\n                        case \"needsregularupdate\":\n                            this.needsRegularUpdate = !(value === \"false\" || value === false);\n                            this.board.renderer.setBuffering(\n                                this,\n                                this.needsRegularUpdate ? \"auto\" : \"static\"\n                            );\n                            break;\n                        case \"labelcolor\":\n                            value = Color.rgba2rgbo(value);\n                            opacity = value[1];\n                            value = value[0];\n                            if (opacity === 0) {\n                                if (Type.exists(this.label) && this.hasLabel) {\n                                    this.label.hideElement();\n                                }\n                            }\n                            if (Type.exists(this.label) && this.hasLabel) {\n                                this.label.visProp.strokecolor = value;\n                                this.board.renderer.setObjectStrokeColor(\n                                    this.label,\n                                    value,\n                                    opacity\n                                );\n                            }\n                            if (this.elementClass === Const.OBJECT_CLASS_TEXT) {\n                                this.visProp.strokecolor = value;\n                                this.visProp.strokeopacity = opacity;\n                                this.board.renderer.setObjectStrokeColor(this, value, opacity);\n                            }\n                            break;\n                        case \"infoboxtext\":\n                            if (Type.isString(value)) {\n                                this.infoboxText = value;\n                            } else {\n                                this.infoboxText = false;\n                            }\n                            break;\n                        case \"visible\":\n                            if (value === \"false\") {\n                                this.visProp.visible = false;\n                            } else if (value === \"true\") {\n                                this.visProp.visible = true;\n                            } else {\n                                this.visProp.visible = value;\n                            }\n\n                            this.setDisplayRendNode(Type.evaluate(this.visProp.visible));\n                            if (\n                                Type.evaluate(this.visProp.visible) &&\n                                Type.exists(this.updateSize)\n                            ) {\n                                this.updateSize();\n                            }\n\n                            break;\n                        case \"face\":\n                            if (Type.isPoint(this)) {\n                                this.visProp.face = value;\n                                this.board.renderer.changePointStyle(this);\n                            }\n                            break;\n                        case \"trace\":\n                            if (value === \"false\" || value === false) {\n                                this.clearTrace();\n                                this.visProp.trace = false;\n                            } else if (value === \"pause\") {\n                                this.visProp.trace = false;\n                            } else {\n                                this.visProp.trace = true;\n                            }\n                            break;\n                        case \"gradient\":\n                            this.visProp.gradient = value;\n                            this.board.renderer.setGradient(this);\n                            break;\n                        case \"gradientsecondcolor\":\n                            value = Color.rgba2rgbo(value);\n                            this.visProp.gradientsecondcolor = value[0];\n                            this.visProp.gradientsecondopacity = value[1];\n                            this.board.renderer.updateGradient(this);\n                            break;\n                        case \"gradientsecondopacity\":\n                            this.visProp.gradientsecondopacity = value;\n                            this.board.renderer.updateGradient(this);\n                            break;\n                        case \"withlabel\":\n                            this.visProp.withlabel = value;\n                            if (!Type.evaluate(value)) {\n                                if (this.label && this.hasLabel) {\n                                    //this.label.hideElement();\n                                    this.label.setAttribute({ visible: false });\n                                }\n                            } else {\n                                if (!this.label) {\n                                    this.createLabel();\n                                }\n                                //this.label.showElement();\n                                this.label.setAttribute({ visible: \"inherit\" });\n                                //this.label.setDisplayRendNode(Type.evaluate(this.visProp.visible));\n                            }\n                            this.hasLabel = value;\n                            break;\n                        case \"radius\":\n                            if (\n                                this.type === Const.OBJECT_TYPE_ANGLE ||\n                                this.type === Const.OBJECT_TYPE_SECTOR\n                            ) {\n                                this.setRadius(value);\n                            }\n                            break;\n                        case \"rotate\":\n                            if (\n                                (this.elementClass === Const.OBJECT_CLASS_TEXT &&\n                                    Type.evaluate(this.visProp.display) === \"internal\") ||\n                                this.type === Const.OBJECT_TYPE_IMAGE\n                            ) {\n                                this.addRotation(value);\n                            }\n                            break;\n                        case \"ticksdistance\":\n                            if (this.type === Const.OBJECT_TYPE_TICKS && Type.isNumber(value)) {\n                                this.ticksFunction = this.makeTicksFunction(value);\n                            }\n                            break;\n                        case \"generatelabelvalue\":\n                            if (\n                                this.type === Const.OBJECT_TYPE_TICKS &&\n                                Type.isFunction(value)\n                            ) {\n                                this.generateLabelValue = value;\n                            }\n                            break;\n                        case \"onpolygon\":\n                            if (this.type === Const.OBJECT_TYPE_GLIDER) {\n                                this.onPolygon = !!value;\n                            }\n                            break;\n                        case \"disabled\":\n                            // button, checkbox, input. Is not available on initial call.\n                            if (Type.exists(this.rendNodeTag)) {\n                                this.rendNodeTag.disabled = !!value;\n                            }\n                            break;\n                        case \"checked\":\n                            // checkbox Is not available on initial call.\n                            if (Type.exists(this.rendNodeTag)) {\n                                this.rendNodeCheckbox.checked = !!value;\n                            }\n                            break;\n                        case \"maxlength\":\n                            // input. Is not available on initial call.\n                            if (Type.exists(this.rendNodeTag)) {\n                                this.rendNodeTag.maxlength = !!value;\n                            }\n                            break;\n                        case \"layer\":\n                            this.board.renderer.setLayer(this, Type.evaluate(value));\n                            this._set(key, value);\n                            break;\n                        case \"tabindex\":\n                            if (Type.exists(this.rendNode)) {\n                                this.rendNode.setAttribute(\"tabindex\", value);\n                                this._set(key, value);\n                            }\n                            break;\n                        default:\n                            if (\n                                Type.exists(this.visProp[key]) &&\n                                (!JXG.Validator[key] ||\n                                    (JXG.Validator[key] && JXG.Validator[key](value)) ||\n                                    (JXG.Validator[key] &&\n                                        Type.isFunction(value) &&\n                                        JXG.Validator[key](value())))\n                            ) {\n                                value =\n                                    value.toLowerCase && value.toLowerCase() === \"false\"\n                                        ? false\n                                        : value;\n                                this._set(key, value);\n                            }\n                            break;\n                    }\n                    this.triggerEventHandlers([\"attribute:\" + key], [oldvalue, value, this]);\n                }\n            }\n\n            this.triggerEventHandlers([\"attribute\"], [properties, this]);\n\n            if (!Type.evaluate(this.visProp.needsregularupdate)) {\n                this.board.fullUpdate();\n            } else {\n                this.board.update(this);\n            }\n\n            return this;\n        },\n\n        /**\n         * Deprecated alias for {@link JXG.GeometryElement#getAttribute}.\n         * @deprecated Use {@link JXG.GeometryElement#getAttribute}.\n         */\n        getProperty: function () {\n            JXG.deprecated(\"getProperty()\", \"getAttribute()\");\n            this.getProperty.apply(this, arguments);\n        },\n\n        /**\n         * Get the value of the property <tt>key</tt>.\n         * @param {String} key The name of the property you are looking for\n         * @returns The value of the property\n         */\n        getAttribute: function (key) {\n            var result;\n            key = key.toLowerCase();\n\n            switch (key) {\n                case \"needsregularupdate\":\n                    result = this.needsRegularUpdate;\n                    break;\n                case \"labelcolor\":\n                    result = this.label.visProp.strokecolor;\n                    break;\n                case \"infoboxtext\":\n                    result = this.infoboxText;\n                    break;\n                case \"withlabel\":\n                    result = this.hasLabel;\n                    break;\n                default:\n                    result = this.visProp[key];\n                    break;\n            }\n\n            return result;\n        },\n\n        /**\n         * Set the dash style of an object. See {@link JXG.GeometryElement#dash}\n         * for a list of available dash styles.\n         * You should use {@link JXG.GeometryElement#setAttribute} instead of this method.\n         *\n         * @param {number} dash Indicates the new dash style\n         * @private\n         */\n        setDash: function (dash) {\n            this.setAttribute({ dash: dash });\n            return this;\n        },\n\n        /**\n         * Notify all child elements for updates.\n         * @private\n         */\n        prepareUpdate: function () {\n            this.needsUpdate = true;\n            return this;\n        },\n\n        /**\n         * Removes the element from the construction.  This only removes the SVG or VML node of the element and its label (if available) from\n         * the renderer, to remove the element completely you should use {@link JXG.Board#removeObject}.\n         */\n        remove: function () {\n            this.board.renderer.remove(this.board.renderer.getElementById(this.id));\n\n            if (this.hasLabel) {\n                this.board.renderer.remove(this.board.renderer.getElementById(this.label.id));\n            }\n            return this;\n        },\n\n        /**\n         * Returns the coords object where a text that is bound to the element shall be drawn.\n         * Differs in some cases from the values that getLabelAnchor returns.\n         * @returns {JXG.Coords} JXG.Coords Place where the text shall be drawn.\n         * @see JXG.GeometryElement#getLabelAnchor\n         */\n        getTextAnchor: function () {\n            return new Coords(Const.COORDS_BY_USER, [0, 0], this.board);\n        },\n\n        /**\n         * Returns the coords object where the label of the element shall be drawn.\n         * Differs in some cases from the values that getTextAnchor returns.\n         * @returns {JXG.Coords} JXG.Coords Place where the text shall be drawn.\n         * @see JXG.GeometryElement#getTextAnchor\n         */\n        getLabelAnchor: function () {\n            return new Coords(Const.COORDS_BY_USER, [0, 0], this.board);\n        },\n\n        /**\n         * Determines whether the element has arrows at start or end of the arc.\n         * If it is set to be a \"typical\" vector, ie lastArrow == true,\n         * then the element.type is set to VECTOR.\n         * @param {Boolean} firstArrow True if there is an arrow at the start of the arc, false otherwise.\n         * @param {Boolean} lastArrow True if there is an arrow at the end of the arc, false otherwise.\n         */\n        setArrow: function (firstArrow, lastArrow) {\n            this.visProp.firstarrow = firstArrow;\n            this.visProp.lastarrow = lastArrow;\n            if (lastArrow) {\n                this.type = Const.OBJECT_TYPE_VECTOR;\n                this.elType = \"arrow\";\n            }\n\n            this.prepareUpdate().update().updateVisibility().updateRenderer();\n            return this;\n        },\n\n        /**\n         * Creates a gradient nodes in the renderer.\n         * @see JXG.SVGRenderer#setGradient\n         * @private\n         */\n        createGradient: function () {\n            var ev_g = Type.evaluate(this.visProp.gradient);\n            if (ev_g === \"linear\" || ev_g === \"radial\") {\n                this.board.renderer.setGradient(this);\n            }\n        },\n\n        /**\n         * Creates a label element for this geometry element.\n         * @see #addLabelToElement\n         */\n        createLabel: function () {\n            var attr,\n                that = this;\n\n            // this is a dirty hack to resolve the text-dependency. If there is no text element available,\n            // just don't create a label. This method is usually not called by a user, so we won't throw\n            // an exception here and simply output a warning via JXG.debug.\n            if (JXG.elements.text) {\n                attr = Type.deepCopy(this.visProp.label, null);\n                attr.id = this.id + \"Label\";\n                attr.isLabel = true;\n                attr.anchor = this;\n                attr.priv = this.visProp.priv;\n\n                if (this.visProp.withlabel) {\n                    this.label = JXG.elements.text(\n                        this.board,\n                        [\n                            0,\n                            0,\n                            function () {\n                                if (Type.isFunction(that.name)) {\n                                    return that.name();\n                                }\n                                return that.name;\n                            }\n                        ],\n                        attr\n                    );\n                    this.label.needsUpdate = true;\n                    this.label.dump = false;\n                    this.label.fullUpdate();\n\n                    this.hasLabel = true;\n                }\n            } else {\n                JXG.debug(\n                    \"JSXGraph: Can't create label: text element is not available. Make sure you include base/text\"\n                );\n            }\n\n            return this;\n        },\n\n        /**\n         * Highlights the element.\n         * @param {Boolean} [force=false] Force the highlighting\n         * @returns {JXG.Board}\n         */\n        highlight: function (force) {\n            force = Type.def(force, false);\n            // I know, we have the JXG.Board.highlightedObjects AND JXG.GeometryElement.highlighted and YES we need both.\n            // Board.highlightedObjects is for the internal highlighting and GeometryElement.highlighted is for user highlighting\n            // initiated by the user, e.g. through custom DOM events. We can't just pick one because this would break user\n            // defined highlighting in many ways:\n            //  * if overriding the highlight() methods the user had to handle the highlightedObjects stuff, otherwise he'd break\n            //    everything (e.g. the pie chart example https://jsxgraph.org/wiki/index.php/Pie_chart (not exactly\n            //    user defined but for this type of chart the highlight method was overridden and not adjusted to the changes in here)\n            //    where it just kept highlighting until the radius of the pie was far beyond infinity...\n            //  * user defined highlighting would get pointless, everytime the user highlights something using .highlight(), it would get\n            //    dehighlighted immediately, because highlight puts the element into highlightedObjects and from there it gets dehighlighted\n            //    through dehighlightAll.\n\n            // highlight only if not highlighted\n            if (Type.evaluate(this.visProp.highlight) && (!this.highlighted || force)) {\n                this.highlighted = true;\n                this.board.highlightedObjects[this.id] = this;\n                this.board.renderer.highlight(this);\n            }\n            return this;\n        },\n\n        /**\n         * Uses the \"normal\" properties of the element.\n         * @returns {JXG.Board}\n         */\n        noHighlight: function () {\n            // see comment in JXG.GeometryElement.highlight()\n\n            // dehighlight only if not highlighted\n            if (this.highlighted) {\n                this.highlighted = false;\n                delete this.board.highlightedObjects[this.id];\n                this.board.renderer.noHighlight(this);\n            }\n            return this;\n        },\n\n        /**\n         * Removes all objects generated by the trace function.\n         */\n        clearTrace: function () {\n            var obj;\n\n            for (obj in this.traces) {\n                if (this.traces.hasOwnProperty(obj)) {\n                    this.board.renderer.remove(this.traces[obj]);\n                }\n            }\n\n            this.numTraces = 0;\n            return this;\n        },\n\n        /**\n         * Copy the element to background. This is used for tracing elements.\n         * @returns {JXG.GeometryElement} A reference to the element\n         */\n        cloneToBackground: function () {\n            return this;\n        },\n\n        /**\n         * Dimensions of the smallest rectangle enclosing the element.\n         * @returns {Array} The coordinates of the enclosing rectangle in a format\n         * like the bounding box in {@link JXG.Board#setBoundingBox}.\n         *\n         * @returns {Array} similar to {@link JXG.Board#setBoundingBox}.\n         */\n        bounds: function () {\n            return [0, 0, 0, 0];\n        },\n\n        /**\n         * Normalize the element's standard form.\n         * @private\n         */\n        normalize: function () {\n            this.stdform = Mat.normalize(this.stdform);\n            return this;\n        },\n\n        /**\n         * EXPERIMENTAL. Generate JSON object code of visProp and other properties.\n         * @type String\n         * @private\n         * @ignore\n         * @returns JSON string containing element's properties.\n         */\n        toJSON: function () {\n            var vis,\n                key,\n                json = ['{\"name\":', this.name];\n\n            json.push(\", \" + '\"id\":' + this.id);\n\n            vis = [];\n            for (key in this.visProp) {\n                if (this.visProp.hasOwnProperty(key)) {\n                    if (Type.exists(this.visProp[key])) {\n                        vis.push('\"' + key + '\":' + this.visProp[key]);\n                    }\n                }\n            }\n            json.push(', \"visProp\":{' + vis.toString() + \"}\");\n            json.push(\"}\");\n\n            return json.join(\"\");\n        },\n\n        /**\n         * Rotate texts or images by a given degree. Works only for texts where JXG.Text#display equal to \"internal\".\n         * @param {number} angle The degree of the rotation (90 means vertical text).\n         * @see JXG.GeometryElement#rotate\n         */\n        addRotation: function (angle) {\n            var tOffInv,\n                tOff,\n                tS,\n                tSInv,\n                tRot,\n                that = this;\n\n            if (\n                ((this.elementClass === Const.OBJECT_CLASS_TEXT &&\n                    Type.evaluate(this.visProp.display) === \"internal\") ||\n                    this.type === Const.OBJECT_TYPE_IMAGE) &&\n                angle !== 0\n            ) {\n                tOffInv = this.board.create(\n                    \"transform\",\n                    [\n                        function () {\n                            return -that.X();\n                        },\n                        function () {\n                            return -that.Y();\n                        }\n                    ],\n                    { type: \"translate\" }\n                );\n\n                tOff = this.board.create(\n                    \"transform\",\n                    [\n                        function () {\n                            return that.X();\n                        },\n                        function () {\n                            return that.Y();\n                        }\n                    ],\n                    { type: \"translate\" }\n                );\n\n                tS = this.board.create(\n                    \"transform\",\n                    [\n                        function () {\n                            return that.board.unitX / that.board.unitY;\n                        },\n                        function () {\n                            return 1;\n                        }\n                    ],\n                    { type: \"scale\" }\n                );\n\n                tSInv = this.board.create(\n                    \"transform\",\n                    [\n                        function () {\n                            return that.board.unitY / that.board.unitX;\n                        },\n                        function () {\n                            return 1;\n                        }\n                    ],\n                    { type: \"scale\" }\n                );\n\n                tRot = this.board.create(\n                    \"transform\",\n                    [\n                        function () {\n                            return (Type.evaluate(angle) * Math.PI) / 180;\n                        }\n                    ],\n                    { type: \"rotate\" }\n                );\n\n                tOffInv.bindTo(this);\n                tS.bindTo(this);\n                tRot.bindTo(this);\n                tSInv.bindTo(this);\n                tOff.bindTo(this);\n            }\n\n            return this;\n        },\n\n        /**\n         * Set the highlightStrokeColor of an element\n         * @param {String} sColor String which determines the stroke color of an object when its highlighted.\n         * @see JXG.GeometryElement#highlightStrokeColor\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        highlightStrokeColor: function (sColor) {\n            JXG.deprecated(\"highlightStrokeColor()\", \"setAttribute()\");\n            this.setAttribute({ highlightStrokeColor: sColor });\n            return this;\n        },\n\n        /**\n         * Set the strokeColor of an element\n         * @param {String} sColor String which determines the stroke color of an object.\n         * @see JXG.GeometryElement#strokeColor\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        strokeColor: function (sColor) {\n            JXG.deprecated(\"strokeColor()\", \"setAttribute()\");\n            this.setAttribute({ strokeColor: sColor });\n            return this;\n        },\n\n        /**\n         * Set the strokeWidth of an element\n         * @param {Number} width Integer which determines the stroke width of an outline.\n         * @see JXG.GeometryElement#strokeWidth\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        strokeWidth: function (width) {\n            JXG.deprecated(\"strokeWidth()\", \"setAttribute()\");\n            this.setAttribute({ strokeWidth: width });\n            return this;\n        },\n\n        /**\n         * Set the fillColor of an element\n         * @param {String} fColor String which determines the fill color of an object.\n         * @see JXG.GeometryElement#fillColor\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        fillColor: function (fColor) {\n            JXG.deprecated(\"fillColor()\", \"setAttribute()\");\n            this.setAttribute({ fillColor: fColor });\n            return this;\n        },\n\n        /**\n         * Set the highlightFillColor of an element\n         * @param {String} fColor String which determines the fill color of an object when its highlighted.\n         * @see JXG.GeometryElement#highlightFillColor\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        highlightFillColor: function (fColor) {\n            JXG.deprecated(\"highlightFillColor()\", \"setAttribute()\");\n            this.setAttribute({ highlightFillColor: fColor });\n            return this;\n        },\n\n        /**\n         * Set the labelColor of an element\n         * @param {String} lColor String which determines the text color of an object's label.\n         * @see JXG.GeometryElement#labelColor\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        labelColor: function (lColor) {\n            JXG.deprecated(\"labelColor()\", \"setAttribute()\");\n            this.setAttribute({ labelColor: lColor });\n            return this;\n        },\n\n        /**\n         * Set the dash type of an element\n         * @param {Number} d Integer which determines the way of dashing an element's outline.\n         * @see JXG.GeometryElement#dash\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        dash: function (d) {\n            JXG.deprecated(\"dash()\", \"setAttribute()\");\n            this.setAttribute({ dash: d });\n            return this;\n        },\n\n        /**\n         * Set the visibility of an element\n         * @param {Boolean} v Boolean which determines whether the element is drawn.\n         * @see JXG.GeometryElement#visible\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        visible: function (v) {\n            JXG.deprecated(\"visible()\", \"setAttribute()\");\n            this.setAttribute({ visible: v });\n            return this;\n        },\n\n        /**\n         * Set the shadow of an element\n         * @param {Boolean} s Boolean which determines whether the element has a shadow or not.\n         * @see JXG.GeometryElement#shadow\n         * @deprecated Use {@link JXG.GeometryElement#setAttribute}\n         */\n        shadow: function (s) {\n            JXG.deprecated(\"shadow()\", \"setAttribute()\");\n            this.setAttribute({ shadow: s });\n            return this;\n        },\n\n        /**\n         * The type of the element as used in {@link JXG.Board#create}.\n         * @returns {String}\n         */\n        getType: function () {\n            return this.elType;\n        },\n\n        /**\n         * List of the element ids resp. values used as parents in {@link JXG.Board#create}.\n         * @returns {Array}\n         */\n        getParents: function () {\n            return Type.isArray(this.parents) ? this.parents : [];\n        },\n\n        /**\n         * Snaps the element to the grid. Only works for points, lines and circles. Points will snap to the grid\n         * as defined in their properties {@link JXG.Point#snapSizeX} and {@link JXG.Point#snapSizeY}. Lines and circles\n         * will snap their parent points to the grid, if they have {@link JXG.Point#snapToGrid} set to true.\n         * @returns {JXG.GeometryElement} Reference to the element.\n         */\n        snapToGrid: function () {\n            return this;\n        },\n\n        /**\n         * Snaps the element to points. Only works for points. Points will snap to the next point\n         * as defined in their properties {@link JXG.Point#attractorDistance} and {@link JXG.Point#attractorUnit}.\n         * Lines and circles\n         * will snap their parent points to points.\n         * @returns {JXG.GeometryElement} Reference to the element.\n         */\n        snapToPoints: function () {\n            return this;\n        },\n\n        /**\n         * Retrieve a copy of the current visProp.\n         * @returns {Object}\n         */\n        getAttributes: function () {\n            var attributes = Type.deepCopy(this.visProp),\n                /*\n                cleanThis = ['attractors', 'snatchdistance', 'traceattributes', 'frozen',\n                    'shadow', 'gradientangle', 'gradientsecondopacity', 'gradientpositionx', 'gradientpositiony',\n                    'needsregularupdate', 'zoom', 'layer', 'offset'],\n                */\n                cleanThis = [],\n                i,\n                len = cleanThis.length;\n\n            attributes.id = this.id;\n            attributes.name = this.name;\n\n            for (i = 0; i < len; i++) {\n                delete attributes[cleanThis[i]];\n            }\n\n            return attributes;\n        },\n\n        /**\n         * Checks whether (x,y) is near the element.\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} True if (x,y) is near the element, False otherwise.\n         */\n        hasPoint: function (x, y) {\n            return false;\n        },\n\n        /**\n         * Adds ticks to this line or curve. Ticks can be added to a curve or any kind of line: line, arrow, and axis.\n         * @param {JXG.Ticks} ticks Reference to a ticks object which is describing the ticks (color, distance, how many, etc.).\n         * @returns {String} Id of the ticks object.\n         */\n        addTicks: function (ticks) {\n            if (ticks.id === \"\" || !Type.exists(ticks.id)) {\n                ticks.id = this.id + \"_ticks_\" + (this.ticks.length + 1);\n            }\n\n            this.board.renderer.drawTicks(ticks);\n            this.ticks.push(ticks);\n\n            return ticks.id;\n        },\n\n        /**\n         * Removes all ticks from a line or curve.\n         */\n        removeAllTicks: function () {\n            var t;\n            if (Type.exists(this.ticks)) {\n                for (t = this.ticks.length - 1; t >= 0; t--) {\n                    this.removeTicks(this.ticks[t]);\n                }\n                this.ticks = [];\n                this.board.update();\n            }\n        },\n\n        /**\n         * Removes ticks identified by parameter named tick from this line or curve.\n         * @param {JXG.Ticks} tick Reference to tick object to remove.\n         */\n        removeTicks: function (tick) {\n            var t, j;\n\n            if (Type.exists(this.defaultTicks) && this.defaultTicks === tick) {\n                this.defaultTicks = null;\n            }\n\n            if (Type.exists(this.ticks)) {\n                for (t = this.ticks.length - 1; t >= 0; t--) {\n                    if (this.ticks[t] === tick) {\n                        this.board.removeObject(this.ticks[t]);\n\n                        if (this.ticks[t].ticks) {\n                            for (j = 0; j < this.ticks[t].ticks.length; j++) {\n                                if (Type.exists(this.ticks[t].labels[j])) {\n                                    this.board.removeObject(this.ticks[t].labels[j]);\n                                }\n                            }\n                        }\n\n                        delete this.ticks[t];\n                        break;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Determine values of snapSizeX and snapSizeY. If the attributes\n         * snapSizex and snapSizeY are greater than zero, these values are taken.\n         * Otherwise, determine the distance between major ticks of the\n         * default axes.\n         * @returns {Array} containing the snap sizes for x and y direction.\n         * @private\n         */\n        getSnapSizes: function () {\n            var sX, sY, ticks;\n\n            sX = Type.evaluate(this.visProp.snapsizex);\n            sY = Type.evaluate(this.visProp.snapsizey);\n\n            if (sX <= 0 && this.board.defaultAxes && this.board.defaultAxes.x.defaultTicks) {\n                ticks = this.board.defaultAxes.x.defaultTicks;\n                sX = ticks.ticksDelta * (Type.evaluate(ticks.visProp.minorticks) + 1);\n            }\n\n            if (sY <= 0 && this.board.defaultAxes && this.board.defaultAxes.y.defaultTicks) {\n                ticks = this.board.defaultAxes.y.defaultTicks;\n                sY = ticks.ticksDelta * (Type.evaluate(ticks.visProp.minorticks) + 1);\n            }\n\n            return [sX, sY];\n        },\n\n        /**\n         * Move an element to its nearest grid point.\n         * The function uses the coords object of the element as\n         * its actual position. If there is no coords object or if the object is fixed, nothing is done.\n         * @param {Boolean} force force snapping independent from what the snaptogrid attribute says\n         * @param {Boolean} fromParent True if the drag comes from a child element. This is the case if a line\n         *    through two points is dragged. In this case we do not try to force the points to stay inside of\n         *    the visible board, but the distance between the two points stays constant.\n         * @returns {JXG.GeometryElement} Reference to this element\n         */\n        handleSnapToGrid: function (force, fromParent) {\n            var x, y, rx, ry, rcoords,\n                mi, ma,\n                boardBB, res, sX, sY,\n                needsSnapToGrid = false,\n                attractToGrid = Type.evaluate(this.visProp.attracttogrid),\n                ev_au = Type.evaluate(this.visProp.attractorunit),\n                ev_ad = Type.evaluate(this.visProp.attractordistance);\n\n            if (!Type.exists(this.coords) || Type.evaluate(this.visProp.fixed)) {\n                return this;\n            }\n\n            needsSnapToGrid =\n                Type.evaluate(this.visProp.snaptogrid) || attractToGrid || force === true;\n\n            if (needsSnapToGrid) {\n                x = this.coords.usrCoords[1];\n                y = this.coords.usrCoords[2];\n                res = this.getSnapSizes();\n                sX = res[0];\n                sY = res[1];\n\n                // If no valid snap sizes are available, don't change the coords.\n                if (sX > 0 && sY > 0) {\n                    boardBB = this.board.getBoundingBox();\n                    rx = Math.round(x / sX) * sX;\n                    ry = Math.round(y / sY) * sY;\n\n                    rcoords = new JXG.Coords(Const.COORDS_BY_USER, [rx, ry], this.board);\n                    if (\n                        !attractToGrid ||\n                        rcoords.distance(\n                            ev_au === \"screen\" ? Const.COORDS_BY_SCREEN : Const.COORDS_BY_USER,\n                            this.coords\n                        ) < ev_ad\n                    ) {\n                        x = rx;\n                        y = ry;\n                        // Checking whether x and y are still within boundingBox.\n                        // If not, adjust them to remain within the board.\n                        // Otherwise a point may become invisible.\n                        if (!fromParent) {\n                            mi = Math.min(boardBB[0], boardBB[2]);\n                            ma = Math.max(boardBB[0], boardBB[2]);\n                            if (x < mi) {\n                                x += sX;\n                            } else if (x > ma) {\n                                x -= sX;\n                            }\n\n                            mi = Math.min(boardBB[1], boardBB[3]);\n                            ma = Math.max(boardBB[1], boardBB[3]);\n                            if (y < mi) {\n                                y += sY;\n                            } else if (y > ma) {\n                                y -= sY;\n                            }\n                        }\n                        this.coords.setCoordinates(Const.COORDS_BY_USER, [x, y]);\n                    }\n                }\n            }\n            return this;\n        },\n\n        getBoundingBox: function () {\n            var i,\n                le,\n                v,\n                x,\n                y,\n                bb = [Infinity, Infinity, -Infinity, -Infinity];\n\n            if (this.type === Const.OBJECT_TYPE_POLYGON) {\n                le = this.vertices.length - 1;\n                if (le <= 0) {\n                    return bb;\n                }\n                for (i = 0; i < le; i++) {\n                    v = this.vertices[i].X();\n                    bb[0] = v < bb[0] ? v : bb[0];\n                    bb[2] = v > bb[2] ? v : bb[2];\n                    v = this.vertices[i].Y();\n                    bb[1] = v < bb[1] ? v : bb[1];\n                    bb[3] = v > bb[3] ? v : bb[3];\n                }\n            } else if (this.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                x = this.center.X();\n                y = this.center.Y();\n                bb = [x - this.radius, y + this.radius, x + this.radius, y - this.radius];\n            } else if (this.elementClass === Const.OBJECT_CLASS_CURVE) {\n                le = this.vertices.length;\n                if (le === 0) {\n                    return bb;\n                }\n                for (i = 0; i < le; i++) {\n                    v = this.points[i].coords.usrCoords[1];\n                    bb[0] = v < bb[0] ? v : bb[0];\n                    bb[2] = v > bb[2] ? v : bb[2];\n                    v = this.points[i].coords.usrCoords[1];\n                    bb[1] = v < bb[1] ? v : bb[1];\n                    bb[3] = v > bb[3] ? v : bb[3];\n                }\n            }\n\n            return bb;\n        },\n\n        /**\n         * Alias of {@link JXG.EventEmitter.on}.\n         *\n         * @name addEvent\n         * @memberof JXG.GeometryElement\n         * @function\n         */\n        addEvent: JXG.shortcut(JXG.GeometryElement.prototype, \"on\"),\n\n        /**\n         * Alias of {@link JXG.EventEmitter.off}.\n         *\n         * @name removeEvent\n         * @memberof JXG.GeometryElement\n         * @function\n         */\n        removeEvent: JXG.shortcut(JXG.GeometryElement.prototype, \"off\"),\n\n        /* **************************\n         *     EVENT DEFINITION\n         * for documentation purposes\n         * ************************** */\n\n        //region Event handler documentation\n        /**\n         * @event\n         * @description This event is fired whenever the user is hovering over an element.\n         * @name JXG.GeometryElement#over\n         * @param {Event} e The browser's event object.\n         */\n        __evt__over: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user puts the mouse over an element.\n         * @name JXG.GeometryElement#mouseover\n         * @param {Event} e The browser's event object.\n         */\n        __evt__mouseover: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is leaving an element.\n         * @name JXG.GeometryElement#out\n         * @param {Event} e The browser's event object.\n         */\n        __evt__out: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user puts the mouse away from an element.\n         * @name JXG.GeometryElement#mouseout\n         * @param {Event} e The browser's event object.\n         */\n        __evt__mouseout: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is moving over an element.\n         * @name JXG.GeometryElement#move\n         * @param {Event} e The browser's event object.\n         */\n        __evt__move: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is moving the mouse over an element.\n         * @name JXG.GeometryElement#mousemove\n         * @param {Event} e The browser's event object.\n         */\n        __evt__mousemove: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user drags an element.\n         * @name JXG.GeometryElement#drag\n         * @param {Event} e The browser's event object.\n         */\n        __evt__drag: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user drags the element with a mouse.\n         * @name JXG.GeometryElement#mousedrag\n         * @param {Event} e The browser's event object.\n         */\n        __evt__mousedrag: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user drags the element with a pen.\n         * @name JXG.GeometryElement#pendrag\n         * @param {Event} e The browser's event object.\n         */\n        __evt__pendrag: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user drags the element on a touch device.\n         * @name JXG.GeometryElement#touchdrag\n         * @param {Event} e The browser's event object.\n         */\n        __evt__touchdrag: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user drags the element by pressing arrow keys \n         * on the keyboard.\n         * @name JXG.GeometryElement#keydrag\n         * @param {Event} e The browser's event object.\n         */\n        __evt__keydrag: function (e) { },\n\n        /**\n         * @event\n         * @description Whenever the user starts to touch or click an element.\n         * @name JXG.GeometryElement#down\n         * @param {Event} e The browser's event object.\n         */\n        __evt__down: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user starts to click an element.\n         * @name JXG.GeometryElement#mousedown\n         * @param {Event} e The browser's event object.\n         */\n        __evt__mousedown: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user taps an element with the pen.\n         * @name JXG.GeometryElement#pendown\n         * @param {Event} e The browser's event object.\n         */\n        __evt__pendown: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user starts to touch an element.\n         * @name JXG.GeometryElement#touchdown\n         * @param {Event} e The browser's event object.\n         */\n        __evt__touchdown: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user stops to touch or click an element.\n         * @name JXG.GeometryElement#up\n         * @param {Event} e The browser's event object.\n         */\n        __evt__up: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user releases the mousebutton over an element.\n         * @name JXG.GeometryElement#mouseup\n         * @param {Event} e The browser's event object.\n         */\n        __evt__mouseup: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user lifts the pen over an element.\n         * @name JXG.GeometryElement#penup\n         * @param {Event} e The browser's event object.\n         */\n        __evt__penup: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user stops touching an element.\n         * @name JXG.GeometryElement#touchup\n         * @param {Event} e The browser's event object.\n         */\n        __evt__touchup: function (e) {},\n\n        /**\n         * @event\n         * @description Notify every time an attribute is changed.\n         * @name JXG.GeometryElement#attribute\n         * @param {Object} o A list of changed attributes and their new value.\n         * @param {Object} el Reference to the element\n         */\n        __evt__attribute: function (o, el) {},\n\n        /**\n         * @event\n         * @description This is a generic event handler. It exists for every possible attribute that can be set for\n         * any element, e.g. if you want to be notified everytime an element's strokecolor is changed, is the event\n         * <tt>attribute:strokecolor</tt>.\n         * @name JXG.GeometryElement#attribute:key\n         * @param val The old value.\n         * @param nval The new value\n         * @param {Object} el Reference to the element\n         */\n        __evt__attribute_: function (val, nval, el) {},\n\n        /**\n         * @ignore\n         */\n        __evt: function () {}\n        //endregion\n    }\n);\n\nexport default JXG.GeometryElement;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the Text element is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport GeometryElement from \"./element\";\nimport GeonextParser from \"../parser/geonext\";\nimport Env from \"../utils/env\";\nimport Type from \"../utils/type\";\nimport Mat from \"../math/math\";\nimport CoordsElement from \"./coordselement\";\n\nvar priv = {\n    HTMLSliderInputEventHandler: function () {\n        this._val = parseFloat(this.rendNodeRange.value);\n        this.rendNodeOut.value = this.rendNodeRange.value;\n        this.board.update();\n    }\n};\n\n/**\n * Construct and handle texts.\n *\n * The coordinates can be relative to the coordinates of an element\n * given in {@link JXG.Options#text.anchor}.\n *\n * MathJax, HTML and GEONExT syntax can be handled.\n * @class Creates a new text object. Do not use this constructor to create a text. Use {@link JXG.Board#create} with\n * type {@link Text} instead.\n * @augments JXG.GeometryElement\n * @augments JXG.CoordsElement\n * @param {string|JXG.Board} board The board the new text is drawn on.\n * @param {Array} coordinates An array with the user coordinates of the text.\n * @param {Object} attributes An object containing visual properties and optional a name and a id.\n * @param {string|function} content A string or a function returning a string.\n *\n */\nJXG.Text = function (board, coords, attributes, content) {\n    this.constructor(board, attributes, Const.OBJECT_TYPE_TEXT, Const.OBJECT_CLASS_TEXT);\n\n    this.element = this.board.select(attributes.anchor);\n    this.coordsConstructor(coords, Type.evaluate(this.visProp.islabel));\n\n    this.content = \"\";\n    this.plaintext = \"\";\n    this.plaintextOld = null;\n    this.orgText = \"\";\n\n    this.needsSizeUpdate = false;\n    // Only used by infobox anymore\n    this.hiddenByParent = false;\n\n    /**\n     * Width and height of the the text element in pixel.\n     *\n     * @private\n     * @type Array\n     */\n    this.size = [1.0, 1.0];\n    this.id = this.board.setId(this, \"T\");\n\n    this.board.renderer.drawText(this);\n    this.board.finalizeAdding(this);\n\n    // Set text before drawing\n    // this._createFctUpdateText(content);\n    // this.updateText();\n\n    this.setText(content);\n\n    if (Type.isString(this.content)) {\n        this.notifyParents(this.content);\n    }\n    this.elType = \"text\";\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        setText: \"setTextJessieCode\",\n        // free: 'free',\n        move: \"setCoords\"\n    });\n};\n\nJXG.Text.prototype = new GeometryElement();\nType.copyPrototypeMethods(JXG.Text, CoordsElement, \"coordsConstructor\");\n\nJXG.extend(\n    JXG.Text.prototype,\n    /** @lends JXG.Text.prototype */ {\n        /**\n         * @private\n         * Test if the the screen coordinates (x,y) are in a small stripe\n         * at the left side or at the right side of the text.\n         * Sensitivity is set in this.board.options.precision.hasPoint.\n         * If dragarea is set to 'all' (default), tests if the the screen\n         * coordinates (x,y) are in within the text boundary.\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {Boolean}\n         */\n        hasPoint: function (x, y) {\n            var lft, rt, top, bot, ax, ay, type, r;\n\n            if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n                type = this.board._inputDevice;\n                r = Type.evaluate(this.visProp.precision[type]);\n            } else {\n                // 'inherit'\n                r = this.board.options.precision.hasPoint;\n            }\n            if (this.transformations.length > 0) {\n                //Transform the mouse/touch coordinates\n                // back to the original position of the text.\n                lft = Mat.matVecMult(\n                    Mat.inverse(this.board.renderer.joinTransforms(this, this.transformations)),\n                    [1, x, y]\n                );\n                x = lft[1];\n                y = lft[2];\n            }\n\n            ax = this.getAnchorX();\n            if (ax === \"right\") {\n                lft = this.coords.scrCoords[1] - this.size[0];\n            } else if (ax === \"middle\") {\n                lft = this.coords.scrCoords[1] - 0.5 * this.size[0];\n            } else {\n                lft = this.coords.scrCoords[1];\n            }\n            rt = lft + this.size[0];\n\n            ay = this.getAnchorY();\n            if (ay === \"top\") {\n                bot = this.coords.scrCoords[2] + this.size[1];\n            } else if (ay === \"middle\") {\n                bot = this.coords.scrCoords[2] + 0.5 * this.size[1];\n            } else {\n                bot = this.coords.scrCoords[2];\n            }\n            top = bot - this.size[1];\n\n            if (Type.evaluate(this.visProp.dragarea) === \"all\") {\n                return x >= lft - r && x < rt + r && y >= top - r && y <= bot + r;\n            }\n            // e.g. 'small'\n            return (\n                y >= top - r &&\n                y <= bot + r &&\n                ((x >= lft - r && x <= lft + 2 * r) || (x >= rt - 2 * r && x <= rt + r))\n            );\n        },\n\n        /**\n         * This sets the updateText function of this element depending on the type of text content passed.\n         * Used by {@link JXG.Text#_setText} and {@link JXG.Text} constructor.\n         * @param {String|Function|Number} text\n         * @private\n         */\n        _createFctUpdateText: function (text) {\n            var updateText,\n                resolvedText,\n                ev_p = Type.evaluate(this.visProp.parse),\n                ev_um = Type.evaluate(this.visProp.usemathjax),\n                ev_uk = Type.evaluate(this.visProp.usekatex),\n                convertJessieCode = false;\n\n            this.orgText = text;\n\n            if (Type.isFunction(text)) {\n                // <value> tags will not be evaluated if text is provided by a function\n                this.updateText = function () {\n                    resolvedText = text().toString(); // Evaluate function\n                    if (ev_p && !ev_um && !ev_uk) {\n                        this.plaintext = this.replaceSub(\n                            this.replaceSup(\n                                this.convertGeonextAndSketchometry2CSS(resolvedText)\n                            )\n                        );\n                    } else {\n                        this.plaintext = resolvedText;\n                    }\n                };\n            } else {\n                if (Type.isNumber(text)) {\n                    this.content = Type.toFixed(text, Type.evaluate(this.visProp.digits));\n                } else if (Type.isString(text) && ev_p) {\n                    if (Type.evaluate(this.visProp.useasciimathml)) {\n                        // ASCIIMathML\n                        this.content = \"'`\" + text + \"`'\";\n                    } else if (ev_um || ev_uk) {\n                        // MathJax or KaTeX\n                        // Replace value-tags by functions\n                        this.content = this.valueTagToJessieCode(text);\n                        this.content = this.content.replace(/\\\\/g, \"\\\\\\\\\"); // Replace single backshlash by double\n                    } else {\n                        // No TeX involved.\n                        // Converts GEONExT syntax into JavaScript string\n                        // Short math is allowed\n                        // Replace value-tags by functions\n                        // Avoid geonext2JS calls\n                        this.content = this.poorMansTeX(this.valueTagToJessieCode(text));\n                    }\n                    convertJessieCode = true;\n                }\n\n                // Generate function which returns the text to be displayed\n                if (convertJessieCode) {\n                    // Convert JessieCode to JS function\n                    updateText = this.board.jc.snippet(this.content, true, \"\", false);\n\n                    // Ticks have been esacped in valueTagToJessieCode\n                    this.updateText = function () {\n                        this.plaintext = this.unescapeTicks(updateText());\n                    };\n                } else {\n                    this.updateText = function () {\n                        this.plaintext = text;\n                    };\n                }\n            }\n        },\n\n        /**\n         * Defines new content. This is used by {@link JXG.Text#setTextJessieCode} and {@link JXG.Text#setText}. This is required because\n         * JessieCode needs to filter all Texts inserted into the DOM and thus has to replace setText by setTextJessieCode.\n         * @param {String|Function|Number} text\n         * @returns {JXG.Text}\n         * @private\n         */\n        _setText: function (text) {\n            this._createFctUpdateText(text);\n\n            // First evaluation of the string.\n            // We need this for display='internal' and Canvas\n            this.updateText();\n            this.fullUpdate();\n\n            // We do not call updateSize for the infobox to speed up rendering\n            if (!this.board.infobox || this.id !== this.board.infobox.id) {\n                this.updateSize(); // updateSize() is called at least once.\n            }\n\n            // This may slow down canvas renderer\n            // if (this.board.renderer.type === 'canvas') {\n            //     this.board.fullUpdate();\n            // }\n\n            return this;\n        },\n\n        /**\n         * Defines new content but converts &lt; and &gt; to HTML entities before updating the DOM.\n         * @param {String|function} text\n         */\n        setTextJessieCode: function (text) {\n            var s;\n\n            this.visProp.castext = text;\n            if (Type.isFunction(text)) {\n                s = function () {\n                    return Type.sanitizeHTML(text());\n                };\n            } else {\n                if (Type.isNumber(text)) {\n                    s = text;\n                } else {\n                    s = Type.sanitizeHTML(text);\n                }\n            }\n\n            return this._setText(s);\n        },\n\n        /**\n         * Defines new content.\n         * @param {String|function} text\n         * @returns {JXG.Text} Reference to the text object.\n         */\n        setText: function (text) {\n            return this._setText(text);\n        },\n\n        /**\n         * Recompute the width and the height of the text box.\n         * Updates the array {@link JXG.Text#size} with pixel values.\n         * The result may differ from browser to browser\n         * by some pixels.\n         * In canvas an old IEs we use a very crude estimation of the dimensions of\n         * the textbox.\n         * JSXGraph needs {@link JXG.Text#size} for applying rotations in IE and\n         * for aligning text.\n         *\n         * @return {[type]} [description]\n         */\n        updateSize: function () {\n            var tmp,\n                that,\n                node,\n                ev_d = Type.evaluate(this.visProp.display);\n\n            if (!Env.isBrowser || this.board.renderer.type === \"no\") {\n                return this;\n            }\n            node = this.rendNode;\n\n            /**\n             * offsetWidth and offsetHeight seem to be supported for internal vml elements by IE10+ in IE8 mode.\n             */\n            if (ev_d === \"html\" || this.board.renderer.type === \"vml\") {\n                if (Type.exists(node.offsetWidth)) {\n                    that = this;\n                    window.setTimeout(function () {\n                        that.size = [node.offsetWidth, node.offsetHeight];\n                        that.needsUpdate = true;\n                        that.updateRenderer();\n                    }, 0);\n                    // In case, there is non-zero padding or borders\n                    // the following approach does not longer work.\n                    // s = [node.offsetWidth, node.offsetHeight];\n                    // if (s[0] === 0 && s[1] === 0) { // Some browsers need some time to set offsetWidth and offsetHeight\n                    //     that = this;\n                    //     window.setTimeout(function () {\n                    //         that.size = [node.offsetWidth, node.offsetHeight];\n                    //         that.needsUpdate = true;\n                    //         that.updateRenderer();\n                    //     }, 0);\n                    // } else {\n                    //     this.size = s;\n                    // }\n                } else {\n                    this.size = this.crudeSizeEstimate();\n                }\n            } else if (ev_d === \"internal\") {\n                if (this.board.renderer.type === \"svg\") {\n                    that = this;\n                    window.setTimeout(function () {\n                        try {\n                            tmp = node.getBBox();\n                            that.size = [tmp.width, tmp.height];\n                            that.needsUpdate = true;\n                            that.updateRenderer();\n                        } catch (e) {}\n                    }, 0);\n                } else if (this.board.renderer.type === \"canvas\") {\n                    this.size = this.crudeSizeEstimate();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * A very crude estimation of the dimensions of the textbox in case nothing else is available.\n         * @returns {Array}\n         */\n        crudeSizeEstimate: function () {\n            var ev_fs = parseFloat(Type.evaluate(this.visProp.fontsize));\n            return [ev_fs * this.plaintext.length * 0.45, ev_fs * 0.9];\n        },\n\n        /**\n         * Decode unicode entities into characters.\n         * @param {String} string\n         * @returns {String}\n         */\n        utf8_decode: function (string) {\n            return string.replace(/&#x(\\w+);/g, function (m, p1) {\n                return String.fromCharCode(parseInt(p1, 16));\n            });\n        },\n\n        /**\n         * Replace _{} by &lt;sub&gt;\n         * @param {String} te String containing _{}.\n         * @returns {String} Given string with _{} replaced by &lt;sub&gt;.\n         */\n        replaceSub: function (te) {\n            if (!te.indexOf) {\n                return te;\n            }\n\n            var j,\n                i = te.indexOf(\"_{\");\n\n            // the regexp in here are not used for filtering but to provide some kind of sugar for label creation,\n            // i.e. replacing _{...} with <sub>...</sub>. What is passed would get out anyway.\n            /*jslint regexp: true*/\n\n            while (i >= 0) {\n                te = te.substr(0, i) + te.substr(i).replace(/_\\{/, \"<sub>\");\n                j = te.substr(i).indexOf(\"}\");\n                if (j >= 0) {\n                    te = te.substr(0, j) + te.substr(j).replace(/\\}/, \"</sub>\");\n                }\n                i = te.indexOf(\"_{\");\n            }\n\n            i = te.indexOf(\"_\");\n            while (i >= 0) {\n                te = te.substr(0, i) + te.substr(i).replace(/_(.?)/, \"<sub>$1</sub>\");\n                i = te.indexOf(\"_\");\n            }\n\n            return te;\n        },\n\n        /**\n         * Replace ^{} by &lt;sup&gt;\n         * @param {String} te String containing ^{}.\n         * @returns {String} Given string with ^{} replaced by &lt;sup&gt;.\n         */\n        replaceSup: function (te) {\n            if (!te.indexOf) {\n                return te;\n            }\n\n            var j,\n                i = te.indexOf(\"^{\");\n\n            // the regexp in here are not used for filtering but to provide some kind of sugar for label creation,\n            // i.e. replacing ^{...} with <sup>...</sup>. What is passed would get out anyway.\n            /*jslint regexp: true*/\n\n            while (i >= 0) {\n                te = te.substr(0, i) + te.substr(i).replace(/\\^\\{/, \"<sup>\");\n                j = te.substr(i).indexOf(\"}\");\n                if (j >= 0) {\n                    te = te.substr(0, j) + te.substr(j).replace(/\\}/, \"</sup>\");\n                }\n                i = te.indexOf(\"^{\");\n            }\n\n            i = te.indexOf(\"^\");\n            while (i >= 0) {\n                te = te.substr(0, i) + te.substr(i).replace(/\\^(.?)/, \"<sup>$1</sup>\");\n                i = te.indexOf(\"^\");\n            }\n\n            return te;\n        },\n\n        /**\n         * Return the width of the text element.\n         * @returns {Array} [width, height] in pixel\n         */\n        getSize: function () {\n            return this.size;\n        },\n\n        /**\n         * Move the text to new coordinates.\n         * @param {number} x\n         * @param {number} y\n         * @returns {object} reference to the text object.\n         */\n        setCoords: function (x, y) {\n            var coordsAnchor, dx, dy;\n            if (Type.isArray(x) && x.length > 1) {\n                y = x[1];\n                x = x[0];\n            }\n\n            if (Type.evaluate(this.visProp.islabel) && Type.exists(this.element)) {\n                coordsAnchor = this.element.getLabelAnchor();\n                dx = (x - coordsAnchor.usrCoords[1]) * this.board.unitX;\n                dy = -(y - coordsAnchor.usrCoords[2]) * this.board.unitY;\n\n                this.relativeCoords.setCoordinates(Const.COORDS_BY_SCREEN, [dx, dy]);\n            } else {\n                /*\n                this.X = function () {\n                    return x;\n                };\n\n                this.Y = function () {\n                    return y;\n                };\n                */\n                this.coords.setCoordinates(Const.COORDS_BY_USER, [x, y]);\n            }\n\n            // this should be a local update, otherwise there might be problems\n            // with the tick update routine resulting in orphaned tick labels\n            this.fullUpdate();\n\n            return this;\n        },\n\n        /**\n         * Evaluates the text.\n         * Then, the update function of the renderer\n         * is called.\n         */\n        update: function (fromParent) {\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            this.updateCoords(fromParent);\n            this.updateText();\n\n            if (Type.evaluate(this.visProp.display) === \"internal\") {\n                if (Type.isString(this.plaintext)) {\n                    this.plaintext = this.utf8_decode(this.plaintext);\n                }\n            }\n\n            this.checkForSizeUpdate();\n            if (this.needsSizeUpdate) {\n                this.updateSize();\n            }\n\n            return this;\n        },\n\n        /**\n         * Used to save updateSize() calls.\n         * Called in JXG.Text.update\n         * That means this.update() has been called.\n         * More tests are in JXG.Renderer.updateTextStyle. The latter tests\n         * are one update off. But this should pose not too many problems, since\n         * it affects fontSize and cssClass changes.\n         *\n         * @private\n         */\n        checkForSizeUpdate: function () {\n            if (this.board.infobox && this.id === this.board.infobox.id) {\n                this.needsSizeUpdate = false;\n            } else {\n                // For some magic reason it is more efficient on the iPad to\n                // call updateSize() for EVERY text element EVERY time.\n                this.needsSizeUpdate = this.plaintextOld !== this.plaintext;\n\n                if (this.needsSizeUpdate) {\n                    this.plaintextOld = this.plaintext;\n                }\n            }\n        },\n\n        /**\n         * The update function of the renderert\n         * is called.\n         * @private\n         */\n        updateRenderer: function () {\n            if (\n                //this.board.updateQuality === this.board.BOARD_QUALITY_HIGH &&\n                Type.evaluate(this.visProp.autoposition)\n            ) {\n                this.setAutoPosition().updateConstraint();\n            }\n            return this.updateRendererGeneric(\"updateText\");\n        },\n\n        /**\n         * Converts shortened math syntax into correct syntax:  3x instead of 3*x or\n         * (a+b)(3+1) instead of (a+b)*(3+1).\n         *\n         * @private\n         * @param{String} expr Math term\n         * @returns {string} expanded String\n         */\n        expandShortMath: function (expr) {\n            var re = /([)0-9.])\\s*([(a-zA-Z_])/g;\n            return expr.replace(re, \"$1*$2\");\n        },\n\n        /**\n         * Converts the GEONExT syntax of the <value> terms into JavaScript.\n         * Also, all Objects whose name appears in the term are searched and\n         * the text is added as child to these objects.\n         * This method is called if the attribute parse==true is set.\n         *\n         * @param{String} contentStr String to be parsed\n         * @param{Boolean} [expand] Optional flag if shortened math syntax is allowed (e.g. 3x instead of 3*x).\n         * @param{Boolean} [avoidGeonext2JS] Optional flag if geonext2JS should be called. For backwards compatibility\n         * this has to be set explicitely to true.\n         * @param{Boolean} [outputTeX] Optional flag which has to be true if the resulting term will be sent to MathJax or KaTeX.\n         * If true, \"_\" and \"^\" are NOT replaced by HTML tags sub and sup. Default: false, i.e. the replacement is done.\n         * This flag allows the combination of &lt;value&gt; tag containing calculations with TeX output.\n         *\n         * @private\n         * @see JXG.GeonextParser.geonext2JS\n         */\n        generateTerm: function (contentStr, expand, avoidGeonext2JS) {\n            var res,\n                term,\n                i,\n                j,\n                plaintext = '\"\"';\n\n            // Revert possible jc replacement\n            contentStr = contentStr || \"\";\n            contentStr = contentStr.replace(/\\r/g, \"\");\n            contentStr = contentStr.replace(/\\n/g, \"\");\n            contentStr = contentStr.replace(/\"/g, \"'\");\n            contentStr = contentStr.replace(/'/g, \"\\\\'\");\n\n            // Old GEONExT syntax, not (yet) supported as TeX output.\n            // Otherwise, the else clause should be used.\n            // That means, i.e. the <arc> tag and <sqrt> tag are not\n            // converted into TeX syntax.\n            contentStr = contentStr.replace(/&amp;arc;/g, \"&ang;\");\n            contentStr = contentStr.replace(/<arc\\s*\\/>/g, \"&ang;\");\n            contentStr = contentStr.replace(/&lt;arc\\s*\\/&gt;/g, \"&ang;\");\n            contentStr = contentStr.replace(/&lt;sqrt\\s*\\/&gt;/g, \"&radic;\");\n\n            contentStr = contentStr.replace(/&lt;value&gt;/g, \"<value>\");\n            contentStr = contentStr.replace(/&lt;\\/value&gt;/g, \"</value>\");\n\n            // Convert GEONExT syntax into  JavaScript syntax\n            i = contentStr.indexOf(\"<value>\");\n            j = contentStr.indexOf(\"</value>\");\n            if (i >= 0) {\n                while (i >= 0) {\n                    plaintext +=\n                        ' + \"' + this.replaceSub(this.replaceSup(contentStr.slice(0, i))) + '\"';\n                    // plaintext += ' + \"' + this.replaceSub(contentStr.slice(0, i)) + '\"';\n\n                    term = contentStr.slice(i + 7, j);\n                    term = term.replace(/\\s+/g, \"\"); // Remove all whitespace\n                    if (expand === true) {\n                        term = this.expandShortMath(term);\n                    }\n                    if (avoidGeonext2JS) {\n                        res = term;\n                    } else {\n                        res = GeonextParser.geonext2JS(term, this.board);\n                    }\n                    res = res.replace(/\\\\\"/g, \"'\");\n                    res = res.replace(/\\\\'/g, \"'\");\n\n                    // GEONExT-Hack: apply rounding once only.\n                    if (res.indexOf(\"toFixed\") < 0) {\n                        // output of a value tag\n                        if (\n                            Type.isNumber(\n                                Type.bind(this.board.jc.snippet(res, true, \"\", false), this)()\n                            )\n                        ) {\n                            // may also be a string\n                            plaintext +=\n                                \"+(\" +\n                                res +\n                                \").toFixed(\" +\n                                Type.evaluate(this.visProp.digits) +\n                                \")\";\n                        } else {\n                            plaintext += \"+(\" + res + \")\";\n                        }\n                    } else {\n                        plaintext += \"+(\" + res + \")\";\n                    }\n\n                    contentStr = contentStr.slice(j + 8);\n                    i = contentStr.indexOf(\"<value>\");\n                    j = contentStr.indexOf(\"</value>\");\n                }\n            }\n\n            plaintext += ' + \"' + this.replaceSub(this.replaceSup(contentStr)) + '\"';\n            plaintext = this.convertGeonextAndSketchometry2CSS(plaintext);\n\n            // This should replace e.g. &amp;pi; by &pi;\n            plaintext = plaintext.replace(/&amp;/g, \"&\");\n            plaintext = plaintext.replace(/\"/g, \"'\");\n\n            return plaintext;\n        },\n\n        valueTagToJessieCode: function (contentStr) {\n            var res,\n                term,\n                i,\n                j,\n                expandShortMath = true,\n                textComps = [],\n                tick = '\"';\n\n            contentStr = contentStr || \"\";\n            contentStr = contentStr.replace(/\\r/g, \"\");\n            contentStr = contentStr.replace(/\\n/g, \"\");\n\n            contentStr = contentStr.replace(/&lt;value&gt;/g, \"<value>\");\n            contentStr = contentStr.replace(/&lt;\\/value&gt;/g, \"</value>\");\n\n            // Convert content of value tag (GEONExT/JessieCode) syntax into JavaScript syntax\n            i = contentStr.indexOf(\"<value>\");\n            j = contentStr.indexOf(\"</value>\");\n            if (i >= 0) {\n                while (i >= 0) {\n                    // Add string fragment before <value> tag\n                    textComps.push(tick + this.escapeTicks(contentStr.slice(0, i)) + tick);\n\n                    term = contentStr.slice(i + 7, j);\n                    term = term.replace(/\\s+/g, \"\"); // Remove all whitespace\n                    if (expandShortMath === true) {\n                        term = this.expandShortMath(term);\n                    }\n                    res = term;\n                    res = res.replace(/\\\\\"/g, \"'\").replace(/\\\\'/g, \"'\");\n\n                    // Hack: apply rounding once only.\n                    if (res.indexOf(\"toFixed\") < 0) {\n                        // Output of a value tag\n                        // Run the JessieCode parser\n                        if (\n                            Type.isNumber(\n                                Type.bind(this.board.jc.snippet(res, true, \"\", false), this)()\n                            )\n                        ) {\n                            // Output is number\n                            textComps.push(\n                                \"(\" +\n                                    res +\n                                    \").toFixed(\" +\n                                    Type.evaluate(this.visProp.digits) +\n                                    \")\"\n                            );\n                        } else {\n                            // Output is a string\n                            textComps.push(\"(\" + res + \")\");\n                        }\n                    } else {\n                        textComps.push(\"(\" + res + \")\");\n                    }\n                    contentStr = contentStr.slice(j + 8);\n                    i = contentStr.indexOf(\"<value>\");\n                    j = contentStr.indexOf(\"</value>\");\n                }\n            }\n            // Add trailing string fragment\n            textComps.push(tick + this.escapeTicks(contentStr) + tick);\n\n            return textComps.join(\" + \").replace(/&amp;/g, \"&\");\n        },\n\n        poorMansTeX: function (s) {\n            s = s\n                .replace(/<arc\\s*\\/*>/g, \"&ang;\")\n                .replace(/&lt;arc\\s*\\/*&gt;/g, \"&ang;\")\n                .replace(/<sqrt\\s*\\/*>/g, \"&radic;\")\n                .replace(/&lt;sqrt\\s*\\/*&gt;/g, \"&radic;\");\n\n            return this.convertGeonextAndSketchometry2CSS(this.replaceSub(this.replaceSup(s)));\n        },\n\n        escapeTicks: function (s) {\n            return s.replace(/\"/g, \"%22\").replace(/'/g, \"%27\");\n        },\n\n        unescapeTicks: function (s) {\n            return s.replace(/%22/g, '\"').replace(/%27/g, \"'\");\n        },\n\n        /**\n         * Converts the GEONExT tags <overline> and <arrow> to\n         * HTML span tags with proper CSS formatting.\n         * @private\n         * @see JXG.Text.generateTerm\n         * @see JXG.Text._setText\n         */\n        convertGeonext2CSS: function (s) {\n            if (Type.isString(s)) {\n                s = s.replace(\n                    /(<|&lt;)overline(>|&gt;)/g,\n                    \"<span style=text-decoration:overline;>\"\n                );\n                s = s.replace(/(<|&lt;)\\/overline(>|&gt;)/g, \"</span>\");\n                s = s.replace(\n                    /(<|&lt;)arrow(>|&gt;)/g,\n                    \"<span style=text-decoration:overline;>\"\n                );\n                s = s.replace(/(<|&lt;)\\/arrow(>|&gt;)/g, \"</span>\");\n            }\n\n            return s;\n        },\n\n        /**\n         * Converts the sketchometry tag <sketchofont> to\n         * HTML span tags with proper CSS formatting.\n         * @private\n         * @see JXG.Text.generateTerm\n         * @see JXG.Text._setText\n         */\n        convertSketchometry2CSS: function (s) {\n            if (Type.isString(s)) {\n                s = s.replace(\n                    /(<|&lt;)sketchofont(>|&gt;)/g,\n                    \"<span style=font-family:sketchometry-light;font-weight:500;>\"\n                );\n                s = s.replace(/(<|&lt;)\\/sketchofont(>|&gt;)/g, \"</span>\");\n                s = s.replace(\n                    /(<|&lt;)sketchometry-light(>|&gt;)/g,\n                    \"<span style=font-family:sketchometry-light;font-weight:500;>\"\n                );\n                s = s.replace(/(<|&lt;)\\/sketchometry-light(>|&gt;)/g, \"</span>\");\n            }\n\n            return s;\n        },\n\n        /**\n         * Alias for convertGeonext2CSS and convertSketchometry2CSS\n         * @private\n         * @see JXG.Text.convertGeonext2CSS\n         * @see JXG.Text.convertSketchometry2CSS\n         */\n        convertGeonextAndSketchometry2CSS: function (s) {\n            s = this.convertGeonext2CSS(s);\n            s = this.convertSketchometry2CSS(s);\n            return s;\n        },\n\n        /**\n         * Finds dependencies in a given term and notifies the parents by adding the\n         * dependent object to the found objects child elements.\n         * @param {String} content String containing dependencies for the given object.\n         * @private\n         */\n        notifyParents: function (content) {\n            var search,\n                res = null;\n\n            // revert possible jc replacement\n            content = content.replace(/&lt;value&gt;/g, \"<value>\");\n            content = content.replace(/&lt;\\/value&gt;/g, \"</value>\");\n\n            do {\n                search = /<value>([\\w\\s*/^\\-+()[\\],<>=!]+)<\\/value>/;\n                res = search.exec(content);\n\n                if (res !== null) {\n                    GeonextParser.findDependencies(this, res[1], this.board);\n                    content = content.substr(res.index);\n                    content = content.replace(search, \"\");\n                }\n            } while (res !== null);\n\n            return this;\n        },\n\n        // documented in element.js\n        getParents: function () {\n            var p;\n            if (this.relativeCoords !== undefined) {\n                // Texts with anchor elements, excluding labels\n                p = [\n                    this.relativeCoords.usrCoords[1],\n                    this.relativeCoords.usrCoords[2],\n                    this.orgText\n                ];\n            } else {\n                // Other texts\n                p = [this.Z(), this.X(), this.Y(), this.orgText];\n            }\n\n            if (this.parents.length !== 0) {\n                p = this.parents;\n            }\n\n            return p;\n        },\n\n        bounds: function () {\n            var c = this.coords.usrCoords;\n\n            if (\n                Type.evaluate(this.visProp.islabel) ||\n                this.board.unitY === 0 ||\n                this.board.unitX === 0\n            ) {\n                return [0, 0, 0, 0];\n            }\n            return [\n                c[1],\n                c[2] + this.size[1] / this.board.unitY,\n                c[1] + this.size[0] / this.board.unitX,\n                c[2]\n            ];\n        },\n\n        getAnchorX: function () {\n            var a = Type.evaluate(this.visProp.anchorx);\n            if (a === \"auto\") {\n                switch (this.visProp.position) {\n                    case \"top\":\n                    case \"bot\":\n                        return \"middle\";\n                    case \"rt\":\n                    case \"lrt\":\n                    case \"urt\":\n                        return \"left\";\n                    case \"lft\":\n                    case \"llft\":\n                    case \"ulft\":\n                    default:\n                        return \"right\";\n                }\n            }\n            return a;\n        },\n\n        getAnchorY: function () {\n            var a = Type.evaluate(this.visProp.anchory);\n            if (a === \"auto\") {\n                switch (this.visProp.position) {\n                    case \"top\":\n                    case \"ulft\":\n                    case \"urt\":\n                        return \"bottom\";\n                    case \"bot\":\n                    case \"lrt\":\n                    case \"llft\":\n                        return \"top\";\n                    case \"rt\":\n                    case \"lft\":\n                    default:\n                        return \"middle\";\n                }\n            }\n            return a;\n        },\n\n        /**\n         * Computes the number of overlaps of a box of w pixels width, h pixels height\n         * and center (x, y)\n         *\n         * @private\n         * @param  {Number} x x-coordinate of the center (screen coordinates)\n         * @param  {Number} y y-coordinate of the center (screen coordinates)\n         * @param  {Number} w width of the box in pixel\n         * @param  {Number} h width of the box in pixel\n         * @return {Number}   Number of overlapping elements\n         */\n        getNumberofConflicts: function (x, y, w, h) {\n            var count = 0,\n                i,\n                obj,\n                le,\n                savePointPrecision;\n\n            // Set the precision of hasPoint to half the max if label isn't too long\n            savePointPrecision = this.board.options.precision.hasPoint;\n            // this.board.options.precision.hasPoint = Math.max(w, h) * 0.5;\n            this.board.options.precision.hasPoint = (w + h) * 0.25;\n            // TODO:\n            // Make it compatible with the objects' visProp.precision attribute\n            for (i = 0, le = this.board.objectsList.length; i < le; i++) {\n                obj = this.board.objectsList[i];\n                if (\n                    obj.visPropCalc.visible &&\n                    obj.elType !== \"axis\" &&\n                    obj.elType !== \"ticks\" &&\n                    obj !== this.board.infobox &&\n                    obj !== this &&\n                    obj.hasPoint(x, y)\n                ) {\n                    count++;\n                }\n            }\n            this.board.options.precision.hasPoint = savePointPrecision;\n\n            return count;\n        },\n\n        /**\n         * Sets the offset of a label element to the position with the least number\n         * of overlaps with other elements, while retaining the distance to its\n         * anchor element. Twelve different angles are possible.\n         *\n         * @returns {JXG.Text} Reference to the text object.\n         */\n        setAutoPosition: function () {\n            var x,\n                y,\n                cx,\n                cy,\n                anchorCoords,\n                // anchorX, anchorY,\n                w = this.size[0],\n                h = this.size[1],\n                start_angle,\n                angle,\n                optimum = {\n                    conflicts: Infinity,\n                    angle: 0,\n                    r: 0\n                },\n                max_r,\n                delta_r,\n                conflicts,\n                offset,\n                r,\n                num_positions = 12,\n                step = (2 * Math.PI) / num_positions,\n                j,\n                dx,\n                dy,\n                co,\n                si;\n\n            if (\n                this === this.board.infobox ||\n                !this.visPropCalc.visible ||\n                !Type.evaluate(this.visProp.islabel) ||\n                !this.element\n            ) {\n                return this;\n            }\n\n            // anchorX = Type.evaluate(this.visProp.anchorx);\n            // anchorY = Type.evaluate(this.visProp.anchory);\n            offset = Type.evaluate(this.visProp.offset);\n            anchorCoords = this.element.getLabelAnchor();\n            cx = anchorCoords.scrCoords[1];\n            cy = anchorCoords.scrCoords[2];\n\n            // Set dx, dy as the relative position of the center of the label\n            // to its anchor element ignoring anchorx and anchory.\n            dx = offset[0];\n            dy = offset[1];\n\n            conflicts = this.getNumberofConflicts(cx + dx, cy - dy, w, h);\n            if (conflicts === 0) {\n                return this;\n            }\n            // console.log(this.id, conflicts, w, h);\n            // r = Geometry.distance([0, 0], offset, 2);\n\n            r = 12;\n            max_r = 28;\n            delta_r = 0.2 * r;\n\n            start_angle = Math.atan2(dy, dx);\n\n            optimum.conflicts = conflicts;\n            optimum.angle = start_angle;\n            optimum.r = r;\n\n            while (optimum.conflicts > 0 && r < max_r) {\n                for (\n                    j = 1, angle = start_angle + step;\n                    j < num_positions && optimum.conflicts > 0;\n                    j++\n                ) {\n                    co = Math.cos(angle);\n                    si = Math.sin(angle);\n\n                    x = cx + r * co;\n                    y = cy - r * si;\n\n                    conflicts = this.getNumberofConflicts(x, y, w, h);\n                    if (conflicts < optimum.conflicts) {\n                        optimum.conflicts = conflicts;\n                        optimum.angle = angle;\n                        optimum.r = r;\n                    }\n                    if (optimum.conflicts === 0) {\n                        break;\n                    }\n                    angle += step;\n                }\n                r += delta_r;\n            }\n            // console.log(this.id, \"after\", optimum)\n            r = optimum.r;\n            co = Math.cos(optimum.angle);\n            si = Math.sin(optimum.angle);\n            this.visProp.offset = [r * co, r * si];\n\n            if (co < -0.2) {\n                this.visProp.anchorx = \"right\";\n            } else if (co > 0.2) {\n                this.visProp.anchorx = \"left\";\n            } else {\n                this.visProp.anchorx = \"middle\";\n            }\n\n            return this;\n        }\n    }\n);\n\n/**\n * @class Construct and handle texts.\n *\n * The coordinates can be relative to the coordinates of an element\n * given in {@link JXG.Options#text.anchor}.\n *\n * MathJaX, HTML and GEONExT syntax can be handled.\n * @pseudo\n * @description\n * @name Text\n * @augments JXG.Text\n * @constructor\n * @type JXG.Text\n *\n * @param {number,function_number,function_number,function_String,function} z_,x,y,str Parent elements for text elements.\n *                     <p>\n *   Parent elements can be two or three elements of type number, a string containing a GEONE<sub>x</sub>T\n *   constraint, or a function which takes no parameter and returns a number. Every parent element determines one coordinate. If a coordinate is\n *   given by a number, the number determines the initial position of a free text. If given by a string or a function that coordinate will be constrained\n *   that means the user won't be able to change the texts's position directly by mouse because it will be calculated automatically depending on the string\n *   or the function's return value. If two parent elements are given the coordinates will be interpreted as 2D affine Euclidean coordinates, if three such\n *   parent elements are given they will be interpreted as homogeneous coordinates.\n *                     <p>\n *                     The text to display may be given as string or as function returning a string.\n *\n * There is the attribute 'display' which takes the values 'html' or 'internal'. In case of 'html' a HTML division tag is created to display\n * the text. In this case it is also possible to use ASCIIMathML. Incase of 'internal', a SVG or VML text element is used to display the text.\n * @see JXG.Text\n * @example\n * // Create a fixed text at position [0,1].\n *   var t1 = board.create('text',[0,1,\"Hello World\"]);\n * </pre><div class=\"jxgbox\" id=\"JXG896013aa-f24e-4e83-ad50-7bc7df23f6b7\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var t1_board = JXG.JSXGraph.initBoard('JXG896013aa-f24e-4e83-ad50-7bc7df23f6b7', {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *   var t1 = t1_board.create('text',[0,1,\"Hello World\"]);\n * </script><pre>\n * @example\n * // Create a variable text at a variable position.\n *   var s = board.create('slider',[[0,4],[3,4],[-2,0,2]]);\n *   var graph = board.create('text',\n *                        [function(x){ return s.Value();}, 1,\n *                         function(){return \"The value of s is\"+JXG.toFixed(s.Value(), 2);}\n *                        ]\n *                     );\n * </pre><div class=\"jxgbox\" id=\"JXG5441da79-a48d-48e8-9e53-75594c384a1c\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var t2_board = JXG.JSXGraph.initBoard('JXG5441da79-a48d-48e8-9e53-75594c384a1c', {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *   var s = t2_board.create('slider',[[0,4],[3,4],[-2,0,2]]);\n *   var t2 = t2_board.create('text',[function(x){ return s.Value();}, 1, function(){return \"The value of s is \"+JXG.toFixed(s.Value(), 2);}]);\n * </script><pre>\n * @example\n * // Create a text bound to the point A\n * var p = board.create('point',[0, 1]),\n *     t = board.create('text',[0, -1,\"Hello World\"], {anchor: p});\n *\n * </pre><div class=\"jxgbox\" id=\"JXGff5a64b2-2b9a-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGff5a64b2-2b9a-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p = board.create('point',[0, 1]),\n *         t = board.create('text',[0, -1,\"Hello World\"], {anchor: p});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createText = function (board, parents, attributes) {\n    var t,\n        attr = Type.copyAttributes(attributes, board.options, \"text\"),\n        coords = parents.slice(0, -1),\n        content = parents[parents.length - 1];\n\n    // downwards compatibility\n    attr.anchor = attr.parent || attr.anchor;\n    t = CoordsElement.create(JXG.Text, board, coords, attr, content);\n\n    if (!t) {\n        throw new Error(\n            \"JSXGraph: Can't create text with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [x,y], [z,x,y], [element,transformation]\"\n        );\n    }\n\n    if (attr.rotate !== 0 && attr.display === \"internal\") {\n        // This is the default value, i.e. no rotation\n        t.addRotation(attr.rotate);\n    }\n\n    return t;\n};\n\nJXG.registerElement(\"text\", JXG.createText);\n\n/**\n * @class Labels are text objects tied to other elements like points, lines and curves.\n * Labels are handled internally by JSXGraph, only. There is NO constructor \"board.create('label', ...)\".\n *\n * @pseudo\n * @description\n * @name Label\n * @augments JXG.Text\n * @constructor\n * @type JXG.Text\n */\n//  See element.js#createLabel\n\n/**\n * [[x,y], [w px, h px], [range]\n */\nJXG.createHTMLSlider = function (board, parents, attributes) {\n    var t,\n        par,\n        attr = Type.copyAttributes(attributes, board.options, \"htmlslider\");\n\n    if (parents.length !== 2 || parents[0].length !== 2 || parents[1].length !== 3) {\n        throw new Error(\n            \"JSXGraph: Can't create htmlslider with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parents are: [[x,y], [min, start, max]]\"\n        );\n    }\n\n    // backwards compatibility\n    attr.anchor = attr.parent || attr.anchor;\n    attr.fixed = attr.fixed || true;\n\n    par = [\n        parents[0][0],\n        parents[0][1],\n        '<form style=\"display:inline\">' +\n            '<input type=\"range\" /><span></span><input type=\"text\" />' +\n            \"</form>\"\n    ];\n\n    t = JXG.createText(board, par, attr);\n    t.type = Type.OBJECT_TYPE_HTMLSLIDER;\n\n    t.rendNodeForm = t.rendNode.childNodes[0];\n\n    t.rendNodeRange = t.rendNodeForm.childNodes[0];\n    t.rendNodeRange.min = parents[1][0];\n    t.rendNodeRange.max = parents[1][2];\n    t.rendNodeRange.step = attr.step;\n    t.rendNodeRange.value = parents[1][1];\n\n    t.rendNodeLabel = t.rendNodeForm.childNodes[1];\n    t.rendNodeLabel.id = t.rendNode.id + \"_label\";\n\n    if (attr.withlabel) {\n        t.rendNodeLabel.innerHTML = t.name + \"=\";\n    }\n\n    t.rendNodeOut = t.rendNodeForm.childNodes[2];\n    t.rendNodeOut.value = parents[1][1];\n\n    try {\n        t.rendNodeForm.id = t.rendNode.id + \"_form\";\n        t.rendNodeRange.id = t.rendNode.id + \"_range\";\n        t.rendNodeOut.id = t.rendNode.id + \"_out\";\n    } catch (e) {\n        JXG.debug(e);\n    }\n\n    t.rendNodeRange.style.width = attr.widthrange + \"px\";\n    t.rendNodeRange.style.verticalAlign = \"middle\";\n    t.rendNodeOut.style.width = attr.widthout + \"px\";\n\n    t._val = parents[1][1];\n\n    if (JXG.supportsVML()) {\n        /*\n         * OnChange event is used for IE browsers\n         * The range element is supported since IE10\n         */\n        Env.addEvent(t.rendNodeForm, \"change\", priv.HTMLSliderInputEventHandler, t);\n    } else {\n        /*\n         * OnInput event is used for non-IE browsers\n         */\n        Env.addEvent(t.rendNodeForm, \"input\", priv.HTMLSliderInputEventHandler, t);\n    }\n\n    t.Value = function () {\n        return this._val;\n    };\n\n    return t;\n};\n\nJXG.registerElement(\"htmlslider\", JXG.createHTMLSlider);\n\nexport default {\n    Text: JXG.Text,\n    createText: JXG.createText,\n    createHTMLSlider: JXG.createHTMLSlider\n};\n","/*\n Copyright 2008-2022\n Matthias Ehmann,\n Michael Gerhaeuser,\n Carsten Miller,\n Bianca Valentin,\n Alfred Wassermann,\n Peter Wilfahrt\n\n This file is part of JSXGraph.\n\n JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n You can redistribute it and/or modify it under the terms of the\n\n * GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version\n OR\n * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n JSXGraph is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License and\n the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, DOMParser: true, ActiveXObject: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Type from \"./type\";\n\n/**\n * Holds browser independent xml parsing routines. Won't work in environments other than browsers.\n * @namespace\n */\nJXG.XML = {\n    /**\n     * Cleans out unneccessary whitespaces in a chunk of xml.\n     * @param {Object} el\n     */\n    cleanWhitespace: function (el) {\n        var cur = el.firstChild;\n\n        while (Type.exists(cur)) {\n            if (cur.nodeType === 3 && !/\\S/.test(cur.nodeValue)) {\n                el.removeChild(cur);\n            } else if (cur.nodeType === 1) {\n                this.cleanWhitespace(cur);\n            }\n            cur = cur.nextSibling;\n        }\n    },\n\n    /**\n     * Converts a given string into a XML tree.\n     * @param {String} str\n     * @returns {Object} The xml tree represented by the root node.\n     */\n    parse: function (str) {\n        var parser, tree, DP;\n\n        // DOMParser is a function in all browsers, except older IE and Safari.\n        // In IE it does not exists (workaround in else branch), in Safari it's an object.\n        if (typeof DOMParser === \"function\" || typeof DOMParser === \"object\") {\n            DP = DOMParser;\n        } else {\n            // IE workaround, since there is no DOMParser\n            DP = function () {\n                this.parseFromString = function (str) {\n                    var d;\n\n                    if (typeof ActiveXObject === \"function\") {\n                        d = new ActiveXObject(\"MSXML.DomDocument\");\n                        d.loadXML(str);\n                    }\n\n                    return d;\n                };\n            };\n        }\n\n        parser = new DP();\n        tree = parser.parseFromString(str, \"text/xml\");\n        this.cleanWhitespace(tree);\n\n        return tree;\n    }\n};\n\nexport default JXG.XML;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Carsten Miller,\n        Andreas Walter,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n/*eslint no-loss-of-precision: off */\n\nimport Mat from \"./math\";\nimport Type from \"../utils/type\";\n\n/**\n * Probability functions, e.g. error function,\n * see: https://en.wikipedia.org/wiki/Error_function\n * Ported from\n * by https://github.com/jeremybarnes/cephes/blob/master/cprob/ndtr.c,\n *\n * Cephes Math Library Release 2.9:  November, 2000\n * Copyright 1984, 1987, 1988, 1992, 2000 by Stephen L. Moshier\n *\n * @name JXG.Math.ProbFuncs\n * @exports Mat.ProbFuncs as JXG.Math.ProbFuncs\n * @namespace\n */\nMat.ProbFuncs = {\n    MAXNUM: 1.701411834604692317316873e38, // 2**127\n    SQRTH: 7.07106781186547524401e-1, // sqrt(2)/2\n    SQRT2: 1.4142135623730950488, // sqrt(2)\n    MAXLOG: 7.08396418532264106224e2, // log 2**1022\n\n    P: [\n        2.46196981473530512524e-10, 5.64189564831068821977e-1, 7.46321056442269912687,\n        4.86371970985681366614e1, 1.96520832956077098242e2, 5.26445194995477358631e2,\n        9.3452852717195760754e2, 1.02755188689515710272e3, 5.57535335369399327526e2\n    ],\n\n    Q: [\n        1.32281951154744992508e1, 8.67072140885989742329e1, 3.54937778887819891062e2,\n        9.75708501743205489753e2, 1.82390916687909736289e3, 2.24633760818710981792e3,\n        1.65666309194161350182e3, 5.57535340817727675546e2\n    ],\n\n    R: [\n        5.64189583547755073984e-1, 1.27536670759978104416, 5.01905042251180477414,\n        6.16021097993053585195, 7.4097426995044893916, 2.9788666537210024067\n    ],\n\n    S: [\n        2.2605286322011727659, 9.39603524938001434673, 1.20489539808096656605e1,\n        1.70814450747565897222e1, 9.60896809063285878198, 3.3690764510008151605\n    ],\n\n    T: [\n        9.60497373987051638749, 9.00260197203842689217e1, 2.23200534594684319226e3,\n        7.00332514112805075473e3, 5.55923013010394962768e4\n    ],\n\n    U: [\n        3.35617141647503099647e1, 5.21357949780152679795e2, 4.59432382970980127987e3,\n        2.26290000613890934246e4, 4.92673942608635921086e4\n    ],\n\n    // UTHRESH: 37.519379347,\n    M: 128.0,\n    MINV: 0.0078125,\n\n    /**\n     *\n     *\tExponential of squared argument\n     *\n     * SYNOPSIS:\n     *\n     * double x, y, expx2();\n     * int sign;\n     *\n     * y = expx2( x, sign );\n     *\n     *\n     *\n     * DESCRIPTION:\n     *\n     * Computes y = exp(x*x) while suppressing error amplification\n     * that would ordinarily arise from the inexactness of the\n     * exponential argument x*x.\n     *\n     * If sign < 0, the result is inverted; i.e., y = exp(-x*x) .\n     *\n     *\n     * ACCURACY:\n     *\n     *                      Relative error:\n     * arithmetic    domain     # trials      peak         rms\n     *   IEEE      -26.6, 26.6    10^7       3.9e-16     8.9e-17\n     *\n     * @private\n     * @param  {Number} x\n     * @param  {Number} sign (int)\n     * @returns {Number}\n     */\n    expx2: function (x, sign) {\n        // double x;\n        // int sign;\n        var u, u1, m, f;\n\n        x = Math.abs(x);\n        if (sign < 0) {\n            x = -x;\n        }\n\n        // Represent x as an exact multiple of M plus a residual.\n        //    M is a power of 2 chosen so that exp(m * m) does not overflow\n        //    or underflow and so that |x - m| is small.\n        m = this.MINV * Math.floor(this.M * x + 0.5);\n        f = x - m;\n\n        // x^2 = m^2 + 2mf + f^2\n        u = m * m;\n        u1 = 2 * m * f + f * f;\n\n        if (sign < 0) {\n            u = -u;\n            u1 = -u1;\n        }\n\n        if (u + u1 > this.MAXLOG) {\n            return Infinity;\n        }\n\n        // u is exact, u1 is small.\n        u = Math.exp(u) * Math.exp(u1);\n        return u;\n    },\n\n    /**\n     *\n     *\tEvaluate polynomial\n     *\n     * SYNOPSIS:\n     *\n     * int N;\n     * double x, y, coef[N+1], polevl[];\n     *\n     * y = polevl( x, coef, N );\n     *\n     * DESCRIPTION:\n     *\n     * Evaluates polynomial of degree N:\n     *\n     *                     2          N\n     * y  =  C  + C x + C x  +...+ C x\n     *        0    1     2          N\n     *\n     * Coefficients are stored in reverse order:\n     *\n     * coef[0] = C  , ..., coef[N] = C  .\n     *            N                   0\n     *\n     *  The function p1evl() assumes that coef[N] = 1.0 and is\n     * omitted from the array.  Its calling arguments are\n     * otherwise the same as polevl().\n     *\n     *\n     * SPEED:\n     *\n     * In the interest of speed, there are no checks for out\n     * of bounds arithmetic.  This routine is used by most of\n     * the functions in the library.  Depending on available\n     * equipment features, the user may wish to rewrite the\n     * program in microcode or assembly language.\n     *\n     * @private\n     * @param  {Number} x\n     * @param  {Number} coef\n     * @param  {Number} N\n     * @returns {Number}\n     */\n    polevl: function (x, coef, N) {\n        var ans, i;\n\n        if (Type.exists(coef.reduce)) {\n            return coef.reduce(function (acc, c) {\n                return acc * x + c;\n            }, 0);\n        }\n        // Polyfill\n        for (i = 0, ans = 0; i <= N; i++) {\n            ans = ans * x + coef[i];\n        }\n        return ans;\n    },\n\n    /**\n     * Evaluate polynomial when coefficient of x is 1.0.\n     * Otherwise same as polevl.\n     *\n     * @private\n     * @param  {Number} x\n     * @param  {Number} coef\n     * @param  {Number} N\n     * @returns {Number}\n     */\n    p1evl: function (x, coef, N) {\n        var ans, i;\n\n        if (Type.exists(coef.reduce)) {\n            return coef.reduce(function (acc, c) {\n                return acc * x + c;\n            }, 1);\n        }\n        // Polyfill\n        for (i = 0, ans = 1; i < N; i++) {\n            ans = ans * x + coef[i];\n        }\n        return ans;\n    },\n\n    /**\n     *\n     *\tNormal distribution function\n     *\n     * SYNOPSIS:\n     *\n     * y = ndtr( x );\n     *\n     * DESCRIPTION:\n     *\n     * Returns the area under the Gaussian probability density\n     * function, integrated from minus infinity to x:\n     *\n     *                            x\n     *                             -\n     *                   1        | |          2\n     *    ndtr(x)  = ---------    |    exp( - t /2 ) dt\n     *               sqrt(2pi)  | |\n     *                           -\n     *                          -inf.\n     *\n     *             =  ( 1 + erf(z) ) / 2\n     *             =  erfc(z) / 2\n     *\n     * where z = x/sqrt(2). Computation is via the functions\n     * erf and erfc with care to avoid error amplification in computing exp(-x^2).\n     *\n     *\n     * ACCURACY:\n     *\n     *                      Relative error:\n     * arithmetic   domain     # trials      peak         rms\n     *    IEEE     -13,0        30000       1.3e-15     2.2e-16\n     *\n     *\n     * ERROR MESSAGES:\n     *\n     *   message         condition         value returned\n     * erfc underflow    x > 37.519379347       0.0\n     *\n     * @param  {Number} a\n     * @returns {Number}\n     */\n    ndtr: function (a) {\n        // a: double, return double\n        var x, y, z;\n\n        x = a * this.SQRTH;\n        z = Math.abs(x);\n\n        if (z < 1.0) {\n            y = 0.5 + 0.5 * this.erf(x);\n        } else {\n            y = 0.5 * this.erfce(z);\n            /* Multiply by exp(-x^2 / 2)  */\n            z = this.expx2(a, -1);\n            y = y * Math.sqrt(z);\n            if (x > 0) {\n                y = 1.0 - y;\n            }\n        }\n        return y;\n    },\n\n    /**\n     * @private\n     * @param  {Number} a\n     * @returns {Number}\n     */\n    _underflow: function (a) {\n        console.log(\"erfc\", \"UNDERFLOW\");\n        if (a < 0) {\n            return 2.0;\n        }\n        return 0.0;\n    },\n\n    /**\n     *\n     *\tComplementary error function\n     *\n     * SYNOPSIS:\n     *\n     * double x, y, erfc();\n     *\n     * y = erfc( x );\n     *\n     *\n     *\n     * DESCRIPTION:\n     *\n     *\n     *  1 - erf(x) =\n     *\n     *                           inf.\n     *                             -\n     *                  2         | |          2\n     *   erfc(x)  =  --------     |    exp( - t  ) dt\n     *               sqrt(pi)   | |\n     *                           -\n     *                            x\n     *\n     *\n     * For small x, erfc(x) = 1 - erf(x); otherwise rational\n     * approximations are computed.\n     *\n     * A special function expx2.c is used to suppress error amplification\n     * in computing exp(-x^2).\n     *\n     *\n     * ACCURACY:\n     *\n     *                      Relative error:\n     * arithmetic   domain     # trials      peak         rms\n     *    IEEE      0,26.6417   30000       1.3e-15     2.2e-16\n     *\n     *\n     * ERROR MESSAGES:\n     *\n     *   message         condition              value returned\n     * erfc underflow    x > 9.231948545 (DEC)       0.0\n     *\n     * @param  {Number} a\n     * @returns {Number}\n     */\n    erfc: function (a) {\n        var p, q, x, y, z;\n\n        if (a < 0.0) {\n            x = -a;\n        } else {\n            x = a;\n        }\n        if (x < 1.0) {\n            return 1.0 - this.erf(a);\n        }\n\n        z = -a * a;\n        if (z < -this.MAXLOG) {\n            return this._underflow(a);\n        }\n\n        z = this.expx2(a, -1); // Compute z = exp(z).\n\n        if (x < 8.0) {\n            p = this.polevl(x, this.P, 8);\n            q = this.p1evl(x, this.Q, 8);\n        } else {\n            p = this.polevl(x, this.R, 5);\n            q = this.p1evl(x, this.S, 6);\n        }\n\n        y = (z * p) / q;\n\n        if (a < 0) {\n            y = 2.0 - y;\n        }\n\n        if (y === 0.0) {\n            return this._underflow(a);\n        }\n\n        return y;\n    },\n\n    /**\n     * Exponentially scaled erfc function\n     *   exp(x^2) erfc(x)\n     *   valid for x > 1.\n     *   Use with ndtr and expx2.\n     *\n     * @private\n     * @param {Number} x\n     * @returns {Number}\n     */\n    erfce: function (x) {\n        var p, q;\n\n        if (x < 8.0) {\n            p = this.polevl(x, this.P, 8);\n            q = this.p1evl(x, this.Q, 8);\n        } else {\n            p = this.polevl(x, this.R, 5);\n            q = this.p1evl(x, this.S, 6);\n        }\n        return p / q;\n    },\n\n    /**\n     *\tError function\n     *\n     * SYNOPSIS:\n     *\n     * double x, y, erf();\n     *\n     * y = erf( x );\n     *\n     *\n     *\n     * DESCRIPTION:\n     *\n     * The integral is\n     *\n     *                           x\n     *                            -\n     *                 2         | |          2\n     *   erf(x)  =  --------     |    exp( - t  ) dt.\n     *              sqrt(pi)   | |\n     *                          -\n     *                           0\n     *\n     * For 0 <= |x| < 1, erf(x) = x * P4(x**2)/Q5(x**2); otherwise\n     * erf(x) = 1 - erfc(x).\n     *\n     *\n     * ACCURACY:\n     *\n     *                      Relative error:\n     * arithmetic   domain     # trials      peak         rms\n     *    DEC       0,1         14000       4.7e-17     1.5e-17\n     *    IEEE      0,1         30000       3.7e-16     1.0e-16\n     *\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    erf: function (x) {\n        var y, z;\n\n        if (Math.abs(x) > 1.0) {\n            return 1.0 - this.erfc(x);\n        }\n        z = x * x;\n        y = (x * this.polevl(z, this.T, 4)) / this.p1evl(z, this.U, 5);\n        return y;\n    },\n\n    s2pi: 2.50662827463100050242, // sqrt(2pi)\n\n    // approximation for 0 <= |y - 0.5| <= 3/8 */\n    P0: [\n        -5.99633501014107895267e1, 9.80010754185999661536e1, -5.66762857469070293439e1,\n        1.39312609387279679503e1, -1.23916583867381258016\n    ],\n\n    Q0: [\n        1.95448858338141759834, 4.67627912898881538453, 8.63602421390890590575e1,\n        -2.25462687854119370527e2, 2.00260212380060660359e2, -8.20372256168333339912e1,\n        1.59056225126211695515e1, -1.18331621121330003142\n    ],\n\n    //  Approximation for interval z = sqrt(-2 log y ) between 2 and 8\n    //  i.e., y between exp(-2) = .135 and exp(-32) = 1.27e-14.\n    P1: [\n        4.05544892305962419923, 3.15251094599893866154e1, 5.71628192246421288162e1,\n        4.408050738932008347e1, 1.46849561928858024014e1, 2.18663306850790267539,\n        -1.40256079171354495875e-1, -3.50424626827848203418e-2, -8.57456785154685413611e-4\n    ],\n\n    Q1: [\n        1.57799883256466749731e1, 4.53907635128879210584e1, 4.1317203825467203044e1,\n        1.50425385692907503408e1, 2.50464946208309415979, -1.42182922854787788574e-1,\n        -3.80806407691578277194e-2, -9.33259480895457427372e-4\n    ],\n\n    // Approximation for interval z = sqrt(-2 log y ) between 8 and 64\n    // i.e., y between exp(-32) = 1.27e-14 and exp(-2048) = 3.67e-890.\n    P2: [\n        3.2377489177694603597, 6.91522889068984211695, 3.93881025292474443415,\n        1.33303460815807542389, 2.01485389549179081538e-1, 1.23716634817820021358e-2,\n        3.01581553508235416007e-4, 2.65806974686737550832e-6, 6.2397453918498329373e-9\n    ],\n\n    Q2: [\n        6.02427039364742014255, 3.67983563856160859403, 1.37702099489081330271,\n        2.1623699359449663589e-1, 1.34204006088543189037e-2, 3.28014464682127739104e-4,\n        2.89247864745380683936e-6, 6.79019408009981274425e-9\n    ],\n\n    /**\n     *\n     *\tInverse of Normal distribution function\n     *\n     * SYNOPSIS:\n     *\n     * double x, y, ndtri();\n     *\n     * x = ndtri( y );\n     *\n     * DESCRIPTION:\n     *\n     * Returns the argument, x, for which the area under the\n     * Gaussian probability density function (integrated from\n     * minus infinity to x) is equal to y.\n     *\n     *\n     * For small arguments 0 < y < exp(-2), the program computes\n     * z = sqrt( -2.0 * log(y) );  then the approximation is\n     * x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z).\n     * There are two rational functions P/Q, one for 0 < y < exp(-32)\n     * and the other for y up to exp(-2).  For larger arguments,\n     * w = y - 0.5, and  x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2)).\n     *\n     *\n     * ACCURACY:\n     *\n     *                      Relative error:\n     * arithmetic   domain        # trials      peak         rms\n     *    DEC      0.125, 1         5500       9.5e-17     2.1e-17\n     *    DEC      6e-39, 0.135     3500       5.7e-17     1.3e-17\n     *    IEEE     0.125, 1        20000       7.2e-16     1.3e-16\n     *    IEEE     3e-308, 0.135   50000       4.6e-16     9.8e-17\n     *\n     *\n     * ERROR MESSAGES:\n     *\n     *   message         condition    value returned\n     * ndtri domain       x <= 0        -MAXNUM\n     * ndtri domain       x >= 1         MAXNUM\n     *\n     * @param  {Number} y0\n     * @returns {Number}\n     */\n    ndtri: function (y0) {\n        var x, y, z, y2, x0, x1, code;\n\n        if (y0 <= 0.0) {\n            //console.log(\"ndtri\", \"DOMAIN \");\n            return -Infinity; // -this.MAXNUM;\n        }\n        if (y0 >= 1.0) {\n            // console.log(\"ndtri\", \"DOMAIN\");\n            return Infinity; // this.MAXNUM;\n        }\n\n        code = 1;\n        y = y0;\n        if (y > 1.0 - 0.13533528323661269189) {\n            // 0.135... = exp(-2)\n            y = 1.0 - y;\n            code = 0;\n        }\n\n        if (y > 0.13533528323661269189) {\n            y = y - 0.5;\n            y2 = y * y;\n            x = y + y * ((y2 * this.polevl(y2, this.P0, 4)) / this.p1evl(y2, this.Q0, 8));\n            x = x * this.s2pi;\n            return x;\n        }\n\n        x = Math.sqrt(-2.0 * Math.log(y));\n        x0 = x - Math.log(x) / x;\n\n        z = 1.0 / x;\n        if (x < 8.0) {\n            // y > exp(-32) = 1.2664165549e-14\n            x1 = (z * this.polevl(z, this.P1, 8)) / this.p1evl(z, this.Q1, 8);\n        } else {\n            x1 = (z * this.polevl(z, this.P2, 8)) / this.p1evl(z, this.Q2, 8);\n        }\n        x = x0 - x1;\n        if (code !== 0) {\n            x = -x;\n        }\n        return x;\n    },\n\n    /**\n     * Inverse of error function erf.\n     *\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    erfi: function (x) {\n        return this.ndtri((x + 1) * 0.5) * this.SQRTH;\n    }\n};\n\nexport default Mat.ProbFuncs;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport Mat from \"./math\";\n\n/**\n * Functions for extrapolation of sequences. Used for finding limits of sequences which is used for curve plotting.\n * @name JXG.Math.Extrapolate\n * @exports Mat.Extrapolate as JXG.Math.Extrapolate\n * @namespace\n */\nMat.Extrapolate = {\n    upper: 15,\n    infty: 1e4,\n\n    /**\n     * Wynn's epsilon algorithm. Ported from the FORTRAN version in\n     * Ernst Joachim Weniger, \"Nonlinear sequence transformations for the acceleration of convergence\n     * and the summation of divergent series\", Computer Physics Reports Vol. 10, 189-371 (1989).\n     *\n     * @param {Number} s_n next value of sequence, i.e. n-th element of sequence\n     * @param {Number} n index of s_n in the sequence\n     * @param {Array} e One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.\n     * @returns {Number} New estimate of the limit of the sequence.\n     *\n     * @memberof JXG.Math.Extrapolate\n     */\n    wynnEps: function (s_n, n, e) {\n        var HUGE = 1e20,\n            TINY = 1e-15,\n            f0 = 1, // f0 may be changed to other values, see vanden Broeck, Schwartz (1979)\n            f,\n            j,\n            aux1,\n            aux2,\n            diff,\n            estlim;\n\n        e[n] = s_n;\n        if (n === 0) {\n            estlim = s_n;\n        } else {\n            aux2 = 0.0;\n            for (j = n; j > 0; j--) {\n                aux1 = aux2;\n                aux2 = e[j - 1];\n                diff = e[j] - aux2;\n                if (Math.abs(diff) <= TINY) {\n                    e[j - 1] = HUGE;\n                } else {\n                    f = (n - j + 1) % 2 === 1 ? f0 : 1;\n                    e[j - 1] = aux1 * f + 1 / diff;\n                }\n            }\n            estlim = e[n % 2];\n        }\n\n        return estlim;\n    },\n\n    // wynnRho: function(s_n, n, e) {\n    //     var HUGE = 1.e+20,\n    //         TINY = 1.e-15,\n    //         j, f,\n    //         aux1, aux2, diff, estlim;\n\n    //     e[n] = s_n;\n    //     if (n === 0) {\n    //         estlim = s_n;\n    //     } else {\n    //         aux2 = 0.0;\n    //         for (j = n; j >= 1; j--) {\n    //             aux1 = aux2;\n    //             aux2 = e[j - 1];\n    //             diff = e[j] - aux2;\n    //             if (Math.abs(diff) <= TINY) {\n    //                 e[j - 1] = HUGE;\n    //             } else {\n    //                 f = ((n - j + 1) % 2 === 1) ? n - j + 1  : 1;\n    //                 e[j - 1] = aux1 + f / diff;\n    //             }\n    //         }\n    //         estlim = e[n % 2];\n    //     }\n\n    //     return estlim;\n    // },\n\n    /**\n     * Aitken transformation. Ported from the FORTRAN version in\n     * Ernst Joachim Weniger, \"Nonlinear sequence transformations for the acceleration of convergence\n     * and the summation of divergent series\", Computer Physics Reports Vol. 10, 189-371 (1989).\n     *\n     * @param {Number} s_n next value of sequence, i.e. n-th element of sequence\n     * @param {Number} n index of s_n in the sequence\n     * @param {Array} a One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.\n     * @returns {Number} New estimate of the limit of the sequence.\n     *\n     * @memberof JXG.Math.Extrapolate\n     */\n    aitken: function (s_n, n, a) {\n        var estlim,\n            HUGE = 1e20,\n            TINY = 1e-15,\n            denom,\n            v,\n            lowmax,\n            j,\n            m;\n\n        a[n] = s_n;\n        if (n < 2) {\n            estlim = s_n;\n        } else {\n            lowmax = n / 2;\n            for (j = 1; j <= lowmax; j++) {\n                m = n - 2 * j;\n                denom = a[m + 2] - 2 * a[m + 1] + a[m];\n                if (Math.abs(denom) < TINY) {\n                    a[m] = HUGE;\n                } else {\n                    v = a[m] - a[m + 1];\n                    a[m] -= (v * v) / denom;\n                }\n            }\n            estlim = a[n % 2];\n        }\n        return estlim;\n    },\n\n    /**\n     * Iterated Brezinski transformation. Ported from the FORTRAN version in\n     * Ernst Joachim Weniger, \"Nonlinear sequence transformations for the acceleration of convergence\n     * and the summation of divergent series\", Computer Physics Reports Vol. 10, 189-371 (1989).\n     *\n     * @param {Number} s_n next value of sequence, i.e. n-th element of sequence\n     * @param {Number} n index of s_n in the sequence\n     * @param {Array} a One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.\n     * @returns {Number} New estimate of the limit of the sequence.\n     *\n     * @memberof JXG.Math.Extrapolate\n     */\n    brezinski: function (s_n, n, a) {\n        var estlim,\n            HUGE = 1e20,\n            TINY = 1e-15,\n            denom,\n            d0,\n            d1,\n            d2,\n            lowmax,\n            j,\n            m;\n\n        a[n] = s_n;\n        if (n < 3) {\n            estlim = s_n;\n        } else {\n            lowmax = n / 3;\n            m = n;\n            for (j = 1; j <= lowmax; j++) {\n                m -= 3;\n                d0 = a[m + 1] - a[m];\n                d1 = a[m + 2] - a[m + 1];\n                d2 = a[m + 3] - a[m + 2];\n                denom = d2 * (d1 - d0) - d0 * (d2 - d1);\n                if (Math.abs(denom) < TINY) {\n                    a[m] = HUGE;\n                } else {\n                    a[m] = a[m + 1] - (d0 * d1 * (d2 - d1)) / denom;\n                }\n            }\n            estlim = a[n % 3];\n        }\n        return estlim;\n    },\n\n    /**\n     * Extrapolated iteration to approximate the value f(x_0).\n     *\n     * @param {Number} x0 Value for which the limit of f is to be determined. f(x0) may or may not exist.\n     * @param {Number} h0 Initial (signed) distance from x0.\n     * @param {Function} f Function for which the limit at x0 is to be determined\n     * @param {String} method String to choose the method. Available values: \"wynnEps\", \"aitken\", \"brezinski\"\n     * @param {Number} step_type Approximation method. step_type = 0 uses the sequence x0 + h0/n; step_type = 1 uses the sequence x0 + h0 * 2^(-n)\n     *\n     * @returns {Array} Array of length 3. Position 0: estimated value for f(x0), position 1: 'finite', 'infinite', or 'NaN'.\n     * Position 2: value between 0 and 1 judging the reliability of the result (1: high, 0: not successful).\n     *\n     * @memberof JXG.Math.Extrapolate\n     * @see JXG.Math.Extrapolate.limit\n     * @see JXG.Math.Extrapolate.wynnEps\n     * @see JXG.Math.Extrapolate.aitken\n     * @see JXG.Math.Extrapolate.brezinski\n     */\n    iteration: function (x0, h0, f, method, step_type) {\n        var n,\n            v,\n            w,\n            estlim = NaN,\n            diff,\n            r = 0.5,\n            E = [],\n            result = \"finite\",\n            h = h0;\n\n        step_type = step_type || 0;\n\n        for (n = 1; n <= this.upper; n++) {\n            h = step_type === 0 ? h0 / (n + 1) : h * r;\n            v = f(x0 + h, true);\n\n            w = this[method](v, n - 1, E);\n            //console.log(n, x0 + h, v, w);\n            if (isNaN(w)) {\n                result = \"NaN\";\n                break;\n            }\n            if (v !== 0 && w / v > this.infty) {\n                estlim = w;\n                result = \"infinite\";\n                break;\n            }\n            diff = w - estlim;\n            if (Math.abs(diff) < 1e-7) {\n                break;\n            }\n            estlim = w;\n        }\n        return [estlim, result, 1 - (n - 1) / this.upper];\n    },\n\n    /**\n     * Levin transformation. See Numerical Recipes, ed. 3.\n     * Not yet ready for use.\n     *\n     * @param {Number} s_n next value of sequence, i.e. n-th element of sequence\n     * @param {Number} n index of s_n in the sequence\n     * @param {Array} numer One-dimensional array containing the extrapolation data for the numerator. Has to be supplied by the calling routine.\n     * @param {Array} denom One-dimensional array containing the extrapolation data for the denominator. Has to be supplied by the calling routine.\n     *\n     * @memberof JXG.Math.Extrapolate\n     */\n    levin: function (s_n, n, omega, beta, numer, denom) {\n        var HUGE = 1e20,\n            TINY = 1e-15,\n            j,\n            fact,\n            ratio,\n            term,\n            estlim;\n\n        term = 1.0 / (beta + n);\n        numer[n] = s_n / omega;\n        denom[n] = 1 / omega;\n        if (n > 0) {\n            numer[n - 1] = numer[n] - numer[n - 1];\n            denom[n - 1] = denom[n] - denom[n - 1];\n            if (n > 1) {\n                ratio = (beta + n - 1) * term;\n                for (j = 2; j <= n; j++) {\n                    fact = (beta + n - j) * Math.pow(ratio, j - 2) * term;\n                    numer[n - j] = numer[n - j + 1] - fact * numer[n - j];\n                    denom[n - j] = denom[n - j + 1] - fact * denom[n - j];\n                    term *= ratio;\n                }\n            }\n        }\n        if (Math.abs(denom[0]) < TINY) {\n            estlim = HUGE;\n        } else {\n            estlim = numer[0] / denom[0];\n        }\n        return estlim;\n    },\n\n    iteration_levin: function (x0, h0, f, step_type) {\n        var n,\n            v,\n            w,\n            estlim = NaN,\n            v_prev,\n            delta,\n            diff,\n            omega,\n            beta = 1,\n            r = 0.5,\n            numer = [],\n            denom = [],\n            result = \"finite\",\n            h = h0,\n            transform = \"u\";\n\n        step_type = step_type || 0;\n\n        v_prev = f(x0 + h0, true);\n        for (n = 1; n <= this.upper; n++) {\n            h = step_type === 0 ? h0 / (n + 1) : h * r;\n            v = f(x0 + h, true);\n            delta = v - v_prev;\n            if (Math.abs(delta) < 1) {\n                transform = \"u\";\n            } else {\n                transform = \"t\";\n            }\n            if (transform === \"u\") {\n                omega = (beta + n) * delta; // u transformation\n            } else {\n                omega = delta; // t transformation\n            }\n\n            v_prev = v;\n            w = this.levin(v, n - 1, omega, beta, numer, denom);\n            diff = w - estlim;\n            // console.log(n, delta, transform, x0 + h, v, w, diff);\n\n            if (isNaN(w)) {\n                result = \"NaN\";\n                break;\n            }\n            if (v !== 0 && w / v > this.infty) {\n                estlim = w;\n                result = \"infinite\";\n                break;\n            }\n            if (Math.abs(diff) < 1e-7) {\n                break;\n            }\n            estlim = w;\n        }\n        return [estlim, result, 1 - (n - 1) / this.upper];\n    },\n\n    /**\n     *\n     * @param {Number} x0 Value for which the limit of f is to be determined. f(x0) may or may not exist.\n     * @param {Number} h0 Initial (signed) distance from x0.\n     * @param {Function} f Function for which the limit at x0 is to be determined\n     *\n     * @returns {Array} Array of length 3. Position 0: estimated value for f(x0), position 1: 'finite', 'infinite', or 'NaN'.\n     * Position 2: value between 0 and 1 judging the reliability of the result (1: high, 0: not successful).\n     * In case that the extrapolation fails, position 1 and 2 contain 'direct' and 0.\n     *\n     * @example\n     * var f1 = (x) => Math.log(x),\n     *     f2 = (x) => Math.tan(x - Math.PI * 0.5),\n     *     f3 = (x) => 4 / x;\n     *\n     * var x0 = 0.0000001;\n     * var h = 0.1;\n     * for (let f of [f1, f2, f3]) {\n     *     console.log(\"x0=\", x0, f.toString());\n     *     console.log(JXG.Math.Extrapolate.limit(x0, h, f));\n     *  }\n     *\n     * </pre><div id=\"JXG5e8c6a7e-eeae-43fb-a669-26b5c9e40cab\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG5e8c6a7e-eeae-43fb-a669-26b5c9e40cab',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var f1 = (x) => Math.log(x),\n     *         f2 = (x) => Math.tan(x - Math.PI * 0.5),\n     *         f3 = (x) => 4 / x;\n     *\n     *     var x0 = 0.0000001;\n     *     var h = 0.1;\n     *     for (let f of [f1, f2, f3]) {\n     *         console.log(\"x0=\", x0, f.toString());\n     *         console.log(JXG.Math.Extrapolate.limit(x0, h, f));\n     *      }\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     *\n     * @see JXG.Math.Extrapolate.iteration\n     * @memberof JXG.Math.Extrapolate\n     */\n    limit: function (x0, h0, f) {\n        return this.iteration_levin(x0, h0, f, 0);\n        //return this.iteration(x0, h0, f, 'wynnEps', 1);\n\n        // var algs = ['wynnEps', 'levin'], //, 'wynnEps', 'levin', 'aitken', 'brezinski'],\n        //     le = algs.length,\n        //     i, t, res;\n        // for (i = 0; i < le; i++) {\n        //     for (t = 0; t < 1; t++) {\n        //         if (algs[i] === 'levin') {\n        //             res = this.iteration_levin(x0, h0, f, t);\n        //         } else {\n        //             res = this.iteration(x0, h0, f, algs[i], t);\n        //         }\n        //         if (res[2] > 0.6) {\n        //             return res;\n        //         }\n        //         console.log(algs[i], t, res)\n        //     }\n        // }\n        // return [f(x0 + Math.sign(h0) * Math.sqrt(Mat.eps)), 'direct', 0];\n    }\n};\n\nexport default Mat.Extrapolate;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG:true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport Mat from \"./math\";\nimport Type from \"../utils/type\";\n\n/**\n * Instantiate a new quad tree.\n *\n * @name JXG.Math.Quadtree\n * @exports Mat.Quadtree as JXG.Math.Quadtree\n * @param {Array} bbox Bounding box of the new quad (sub)tree.\n * @constructor\n */\nMat.Quadtree = function (bbox) {\n    /**\n     * The maximum number of points stored in a quad tree node\n     * before it is subdivided.\n     * @type Number\n     * @default 10\n     */\n    this.capacity = 10;\n\n    /**\n     * Point storage.\n     * @name JXG.Math.Quadtree#points\n     * @type Array\n     */\n    this.points = [];\n    this.xlb = bbox[0];\n    this.xub = bbox[2];\n    this.ylb = bbox[3];\n    this.yub = bbox[1];\n\n    /**\n     * In a subdivided quad tree this represents the top left subtree.\n     * @name JXG.Math.Quadtree#northWest\n     * @type JXG.Math.Quadtree\n     */\n    this.northWest = null;\n\n    /**\n     * In a subdivided quad tree this represents the top right subtree.\n     * @name JXG.Math.Quadtree#northEast\n     * @type JXG.Math.Quadtree\n     */\n    this.northEast = null;\n\n    /**\n     * In a subdivided quad tree this represents the bottom right subtree.\n     * @name JXG.Math.Quadtree#southEast\n     * @type JXG.Math.Quadtree\n     */\n    this.southEast = null;\n\n    /**\n     * In a subdivided quad tree this represents the bottom left subtree.\n     * @name JXG.Math.Quadtree#southWest\n     * @type JXG.Math.Quadtree\n     */\n    this.southWest = null;\n};\n\nType.extend(\n    Mat.Quadtree.prototype,\n    /** @lends JXG.Math.Quadtree.prototype */ {\n        /**\n         * Checks if the given coordinates are inside the quad tree.\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {Boolean}\n         */\n        contains: function (x, y) {\n            return this.xlb < x && x <= this.xub && this.ylb < y && y <= this.yub;\n        },\n\n        /**\n         * Insert a new point into this quad tree.\n         * @param {JXG.Coords} p\n         * @returns {Boolean}\n         */\n        insert: function (p) {\n            if (!this.contains(p.usrCoords[1], p.usrCoords[2])) {\n                return false;\n            }\n\n            if (this.points.length < this.capacity) {\n                this.points.push(p);\n                return true;\n            }\n\n            if (this.northWest === null) {\n                this.subdivide();\n            }\n\n            if (this.northWest.insert(p)) {\n                return true;\n            }\n\n            if (this.northEast.insert(p)) {\n                return true;\n            }\n\n            if (this.southEast.insert(p)) {\n                return true;\n            }\n\n            return !!this.southWest.insert(p);\n        },\n\n        /**\n         * Subdivide the quad tree.\n         */\n        subdivide: function () {\n            var i,\n                l = this.points.length,\n                mx = this.xlb + (this.xub - this.xlb) / 2,\n                my = this.ylb + (this.yub - this.ylb) / 2;\n\n            this.northWest = new Mat.Quadtree([this.xlb, this.yub, mx, my]);\n            this.northEast = new Mat.Quadtree([mx, this.yub, this.xub, my]);\n            this.southEast = new Mat.Quadtree([this.xlb, my, mx, this.ylb]);\n            this.southWest = new Mat.Quadtree([mx, my, this.xub, this.ylb]);\n\n            for (i = 0; i < l; i += 1) {\n                this.northWest.insert(this.points[i]);\n                this.northEast.insert(this.points[i]);\n                this.southEast.insert(this.points[i]);\n                this.southWest.insert(this.points[i]);\n            }\n        },\n\n        /**\n         * Internal _query method that lacks adjustment of the parameter.\n         * @name JXG.Math.Quadtree#_query\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {Boolean|JXG.Quadtree} The quad tree if the point is found, false\n         * if none of the quad trees contains the point (i.e. the point is not inside\n         * the root tree's AABB).\n         * @private\n         */\n        _query: function (x, y) {\n            var r;\n\n            if (this.contains(x, y)) {\n                if (this.northWest === null) {\n                    return this;\n                }\n\n                r = this.northWest._query(x, y);\n                if (r) {\n                    return r;\n                }\n\n                r = this.northEast._query(x, y);\n                if (r) {\n                    return r;\n                }\n\n                r = this.southEast._query(x, y);\n                if (r) {\n                    return r;\n                }\n\n                r = this.southWest._query(x, y);\n                if (r) {\n                    return r;\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Retrieve the smallest quad tree that contains the given point.\n         * @name JXG.Math.Quadtree#_query\n         * @param {JXG.Coords|Number} xp\n         * @param {Number} y\n         * @returns {Boolean|JXG.Quadtree} The quad tree if the point is found, false\n         * if none of the quad trees contains the point (i.e. the point is not inside\n         * the root tree's AABB).\n         * @private\n         */\n        query: function (xp, y) {\n            var _x, _y;\n\n            if (Type.exists(y)) {\n                _x = xp;\n                _y = y;\n            } else {\n                _x = xp.usrCoords[1];\n                _y = xp.usrCoords[2];\n            }\n\n            return this._query(_x, _y);\n        }\n    }\n);\n\nexport default Mat.Quadtree;\n","/*\n Copyright 2008-2022\n Matthias Ehmann,\n Carsten Miller,\n Reinhard Oldenburg,\n Andreas Walter,\n Alfred Wassermann\n\n This file is part of JSXGraph.\n\n JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n You can redistribute it and/or modify it under the terms of the\n\n * GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version\n OR\n * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n JSXGraph is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License and\n the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n and <http://opensource.org/licenses/MIT/>.\n\n This is a port of jcobyla\n\n - to JavaScript by Reihard Oldenburg and\n - to JSXGraph by Alfred Wassermann\n - optimized by Andreas Walter\n */\n/*\n * jcobyla\n *\n * The MIT License\n *\n * Copyright (c) 2012 Anders Gustafsson, Cureos AB.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Remarks:\n *\n * The original Fortran 77 version of this code was by Michael Powell (M.J.D.Powell @ damtp.cam.ac.uk)\n * The Fortran 90 version was by Alan Miller (Alan.Miller @ vic.cmis.csiro.au). Latest revision - 30 October 1998\n */\n\n/**\n * Constrained Optimization BY Linear Approximation in Java.\n *\n * COBYLA2 is an implementation of Powell's nonlinear derivative free constrained optimization that uses\n * a linear approximation approach. The algorithm is a sequential trust region algorithm that employs linear\n * approximations to the objective and constraint functions, where the approximations are formed by linear\n * interpolation at n + 1 points in the space of the variables and tries to maintain a regular shaped simplex\n * over iterations.\n *\n * It solves nonsmooth NLP with a moderate number of variables (about 100). Inequality constraints only.\n *\n * The initial point X is taken as one vertex of the initial simplex with zero being another, so, X should\n * not be entered as the zero vector.\n *\n * @author Anders Gustafsson, Cureos AB. Translation to Javascript by Reinhard Oldenburg, Goethe-University\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true, continue: true*/\n\nimport JXG from \"../jxg\";\n// import Type from \"../utils/type\";\n\n/**\n * The JXG.Math.Nlp namespace holds numerical algorithms for non-linear optimization.\n * @name JXG.Math.Nlp\n * @namespace\n *\n */\nJXG.Math.Nlp = {\n    arr: function (n) {\n        // Is 0 initialized\n        return new Float64Array(n);\n    },\n\n    arr2: function (n, m) {\n        var i = 0,\n            a = new Array(n);\n\n        while (i < n) {\n            a[i] = this.arr(m);\n            i++;\n        }\n        return a;\n    },\n\n    arraycopy: function (x, a, iox, b, n) {\n        var i = 0;\n        while (i < n) {\n            iox[i + b] = x[i + a];\n            i++;\n        }\n    },\n\n    lastNumberOfEvaluations: 0,\n    GetLastNumberOfEvaluations: function () {\n        return this.lastNumberOfEvaluations;\n    },\n    // status Variables\n    Normal: 0,\n    MaxIterationsReached: 1,\n    DivergingRoundingErrors: 2,\n\n    /**\n     * Minimizes the objective function F with respect to a set of inequality constraints CON,\n     * and returns the optimal variable array. F and CON may be non-linear, and should preferably be smooth.\n     * Calls {@link JXG.Math.Nlp#cobylb}.\n     *\n     * @param calcfc Interface implementation for calculating objective function and constraints.\n     * @param n Number of variables.\n     * @param m Number of constraints.\n     * @param x On input initial values of the variables (zero-based array). On output\n     * optimal values of the variables obtained in the COBYLA minimization.\n     * @param rhobeg Initial size of the simplex.\n     * @param rhoend Final value of the simplex.\n     * @param iprint Print level, 0 <= iprint <= 3, where 0 provides no output and\n     * 3 provides full output to the console.\n     * @param maxfun Maximum number of function evaluations before terminating.\n     * @param [testForRoundingErrors=false]\n     * @returns {Number} Exit status of the COBYLA2 optimization.\n     */\n    FindMinimum: function (calcfc, n, m, x, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors) {\n        // CobylaExitStatus FindMinimum(final Calcfc calcfc, int n, int m, double[] x, double rhobeg, double rhoend, int iprint, int maxfun)\n        //     This subroutine minimizes an objective function F(X) subject to M\n        //     inequality constraints on X, where X is a vector of variables that has\n        //     N components.  The algorithm employs linear approximations to the\n        //     objective and constraint functions, the approximations being formed by\n        //     linear interpolation at N+1 points in the space of the variables.\n        //     We regard these interpolation points as vertices of a simplex.  The\n        //     parameter RHO controls the size of the simplex and it is reduced\n        //     automatically from RHOBEG to RHOEND.  For each RHO the subroutine tries\n        //     to achieve a good vector of variables for the current size, and then\n        //     RHO is reduced until the value RHOEND is reached.  Therefore RHOBEG and\n        //     RHOEND should be set to reasonable initial changes to and the required\n        //     accuracy in the variables respectively, but this accuracy should be\n        //     viewed as a subject for experimentation because it is not guaranteed.\n        //     The subroutine has an advantage over many of its competitors, however,\n        //     which is that it treats each constraint individually when calculating\n        //     a change to the variables, instead of lumping the constraints together\n        //     into a single penalty function.  The name of the subroutine is derived\n        //     from the phrase Constrained Optimization BY Linear Approximations.\n\n        //     The user must set the values of N, M, RHOBEG and RHOEND, and must\n        //     provide an initial vector of variables in X.  Further, the value of\n        //     IPRINT should be set to 0, 1, 2 or 3, which controls the amount of\n        //     printing during the calculation. Specifically, there is no output if\n        //     IPRINT=0 and there is output only at the end of the calculation if\n        //     IPRINT=1.  Otherwise each new value of RHO and SIGMA is printed.\n        //     Further, the vector of variables and some function information are\n        //     given either when RHO is reduced or when each new value of F(X) is\n        //     computed in the cases IPRINT=2 or IPRINT=3 respectively. Here SIGMA\n        //     is a penalty parameter, it being assumed that a change to X is an\n        //     improvement if it reduces the merit function\n        //                F(X)+SIGMA*MAX(0.0, - C1(X), - C2(X),..., - CM(X)),\n        //     where C1,C2,...,CM denote the constraint functions that should become\n        //     nonnegative eventually, at least to the precision of RHOEND. In the\n        //     printed output the displayed term that is multiplied by SIGMA is\n        //     called MAXCV, which stands for 'MAXimum Constraint Violation'.  The\n        //     argument ITERS is an integer variable that must be set by the user to a\n        //     limit on the number of calls of CALCFC, the purpose of this routine being\n        //     given below.  The value of ITERS will be altered to the number of calls\n        //     of CALCFC that are made.\n        //     In order to define the objective and constraint functions, we require\n        //     a subroutine that has the name and arguments\n        //                SUBROUTINE CALCFC (N,M,X,F,CON)\n        //                DIMENSION X(:),CON(:)  .\n        //     The values of N and M are fixed and have been defined already, while\n        //     X is now the current vector of variables. The subroutine should return\n        //     the objective and constraint functions at X in F and CON(1),CON(2),\n        //     ...,CON(M).  Note that we are trying to adjust X so that F(X) is as\n        //     small as possible subject to the constraint functions being nonnegative.\n\n        // Local variables\n        var mpp = m + 2,\n            status,\n            // Internal base-1 X array\n            iox = this.arr(n + 1),\n            that = this,\n            fcalcfc;\n\n        this.lastNumberOfEvaluations = 0;\n\n        if (testForRoundingErrors) {\n            console.log(\"Experimental feature 'testForRoundingErrors' is activated.\");\n        }\n\n        iox[0] = 0.0;\n        this.arraycopy(x, 0, iox, 1, n);\n\n        // Internal representation of the objective and constraints calculation method,\n        // accounting for that X and CON arrays in the cobylb method are base-1 arrays.\n        fcalcfc = function (n, m, thisx, con) {\n            // int n, int m, double[] x, double[] con\n            var ix = that.arr(n),\n                ocon, f;\n\n            that.lastNumberOfEvaluations = that.lastNumberOfEvaluations + 1;\n            that.arraycopy(thisx, 1, ix, 0, n);\n            ocon = that.arr(m);\n            f = calcfc(n, m, ix, ocon);\n            that.arraycopy(ocon, 0, con, 1, m);\n            return f;\n        };\n\n        status = this.cobylb(fcalcfc, n, m, mpp, iox, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors);\n        this.arraycopy(iox, 1, x, 0, n);\n\n        return status;\n    },\n\n    //    private static CobylaExitStatus cobylb(Calcfc calcfc, int n, int m, int mpp, double[] x,\n    //      double rhobeg, double rhoend, int iprint, int maxfun)\n    /**\n     * JavaScript implementation of the non-linear optimization method COBYLA.\n     * @param {Function} calcfc\n     * @param {Number} n\n     * @param {Number} m\n     * @param {Number} mpp\n     * @param {Number} x\n     * @param {Number} rhobeg\n     * @param {Number} rhoend\n     * @param {Number} iprint\n     * @param {Number} maxfun\n     * @param {Boolean} [testForRoundingErrors=false]\n     * @returns {Number} Exit status of the COBYLA2 optimization\n     */\n    cobylb: function (calcfc, n, m, mpp, x, rhobeg, rhoend, iprint, maxfun, testForRoundingErrors) {\n        // calcf ist funktion die aufgerufen wird wie calcfc(n, m, ix, ocon)\n        // N.B. Arguments CON, SIM, SIMI, DATMAT, A, VSIG, VETA, SIGBAR, DX, W & IACT\n        //      have been removed.\n\n        //     Set the initial values of some parameters. The last column of SIM holds\n        //     the optimal vertex of the current simplex, and the preceding N columns\n        //     hold the displacements from the optimal vertex to the other vertices.\n        //     Further, SIMI holds the inverse of the matrix that is contained in the\n        //     first N columns of SIM.\n\n        // Local variables\n        var status = -1,\n            alpha = 0.25,\n            beta = 2.1,\n            gamma = 0.5,\n            delta = 1.1,\n            f = 0.0,\n            resmax = 0.0,\n            total,\n            np = n + 1,\n            mp = m + 1,\n            rho = rhobeg,\n            parmu = 0.0,\n            iflag = false,\n            ifull = false,\n            parsig = 0.0,\n            prerec = 0.0,\n            prerem = 0.0,\n            con = this.arr(1 + mpp),\n            sim = this.arr2(1 + n, 1 + np),\n            simi = this.arr2(1 + n, 1 + n),\n            datmat = this.arr2(1 + mpp, 1 + np),\n            a = this.arr2(1 + n, 1 + mp),\n            vsig = this.arr(1 + n),\n            veta = this.arr(1 + n),\n            sigbar = this.arr(1 + n),\n            dx = this.arr(1 + n),\n            w = this.arr(1 + n),\n            i, j, k, l,\n            temp, tempa,\n            nfvals, jdrop, ibrnch, skipVertexIdent,\n            phimin, nbest, error, pareta, wsig, weta,\n            cvmaxp, cvmaxm, dxsign, resnew, barmu,\n            phi, vmold, vmnew, trured, ratio, edgmax,\n            cmin, cmax, denom,\n            endless = true;\n\n        if (iprint >= 2) {\n            console.log(\"The initial value of RHO is \" + rho + \" and PARMU is set to zero.\");\n        }\n\n        nfvals = 0;\n        temp = 1.0 / rho;\n\n        for (i = 1; i <= n; ++i) {\n            sim[i][np] = x[i];\n            sim[i][i] = rho;\n            simi[i][i] = temp;\n        }\n\n        jdrop = np;\n        ibrnch = false;\n\n        //     Make the next call of the user-supplied subroutine CALCFC. These\n        //     instructions are also used for calling CALCFC during the iterations of\n        //     the algorithm.\n        //alert(\"Iteration \"+nfvals+\" x=\"+x);\n        L_40: do {\n            if (nfvals >= maxfun && nfvals > 0) {\n                status = this.MaxIterationsReached;\n                break L_40;\n            }\n\n            ++nfvals;\n            f = calcfc(n, m, x, con);\n            resmax = 0.0;\n            for (k = 1; k <= m; ++k) {\n                resmax = Math.max(resmax, -con[k]);\n            }\n            //alert(    \"   f=\"+f+\"  resmax=\"+resmax);\n\n            if (nfvals === iprint - 1 || iprint === 3) {\n                this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);\n            }\n\n            con[mp] = f;\n            con[mpp] = resmax;\n\n            //     Set the recently calculated function values in a column of DATMAT. This\n            //     array has a column for each vertex of the current simplex, the entries of\n            //     each column being the values of the constraint functions (if any)\n            //     followed by the objective function and the greatest constraint violation\n            //     at the vertex.\n            skipVertexIdent = true;\n            if (!ibrnch) {\n                skipVertexIdent = false;\n\n                for (i = 1; i <= mpp; ++i) {\n                    datmat[i][jdrop] = con[i];\n                }\n\n                if (nfvals <= np) {\n                    //     Exchange the new vertex of the initial simplex with the optimal vertex if\n                    //     necessary. Then, if the initial simplex is not complete, pick its next\n                    //     vertex and calculate the function values there.\n\n                    if (jdrop <= n) {\n                        if (datmat[mp][np] <= f) {\n                            x[jdrop] = sim[jdrop][np];\n                        } else {\n                            sim[jdrop][np] = x[jdrop];\n                            for (k = 1; k <= mpp; ++k) {\n                                datmat[k][jdrop] = datmat[k][np];\n                                datmat[k][np] = con[k];\n                            }\n                            for (k = 1; k <= jdrop; ++k) {\n                                sim[jdrop][k] = -rho;\n                                temp = 0.0;\n                                for (i = k; i <= jdrop; ++i) {\n                                    temp -= simi[i][k];\n                                }\n                                simi[jdrop][k] = temp;\n                            }\n                        }\n                    }\n                    if (nfvals <= n) {\n                        jdrop = nfvals;\n                        x[jdrop] += rho;\n                        continue L_40;\n                    }\n                }\n                ibrnch = true;\n            }\n\n            L_140: do {\n                L_550: do {\n                    if (!skipVertexIdent) {\n                        //     Identify the optimal vertex of the current simplex.\n                        phimin = datmat[mp][np] + parmu * datmat[mpp][np];\n                        nbest = np;\n\n                        for (j = 1; j <= n; ++j) {\n                            temp = datmat[mp][j] + parmu * datmat[mpp][j];\n                            if (temp < phimin) {\n                                nbest = j;\n                                phimin = temp;\n                            } else if (\n                                temp === phimin &&\n                                parmu === 0.0 &&\n                                datmat[mpp][j] < datmat[mpp][nbest]\n                            ) {\n                                nbest = j;\n                            }\n                        }\n\n                        //     Switch the best vertex into pole position if it is not there already,\n                        //     and also update SIM, SIMI and DATMAT.\n                        if (nbest <= n) {\n                            for (i = 1; i <= mpp; ++i) {\n                                temp = datmat[i][np];\n                                datmat[i][np] = datmat[i][nbest];\n                                datmat[i][nbest] = temp;\n                            }\n                            for (i = 1; i <= n; ++i) {\n                                temp = sim[i][nbest];\n                                sim[i][nbest] = 0.0;\n                                sim[i][np] += temp;\n\n                                tempa = 0.0;\n                                for (k = 1; k <= n; ++k) {\n                                    sim[i][k] -= temp;\n                                    tempa -= simi[k][i];\n                                }\n                                simi[nbest][i] = tempa;\n                            }\n                        }\n\n                        //     Make an error return if SIGI is a poor approximation to the inverse of\n                        //     the leading N by N submatrix of SIG.\n                        error = 0.0;\n                        if (testForRoundingErrors) {\n                            for (i = 1; i <= n; ++i) {\n                                for (j = 1; j <= n; ++j) {\n                                    temp =\n                                        this.DOT_PRODUCT_ROW_COL(simi, i, sim, j, 1, n) -\n                                        (i === j ? 1.0 : 0.0);\n                                    // temp = this.DOT_PRODUCT(\n                                    //     this.PART(this.ROW(simi, i), 1, n),\n                                    //     this.PART(this.COL(sim, j), 1, n)\n                                    // ) - (i === j ? 1.0 : 0.0);\n\n                                    error = Math.max(error, Math.abs(temp));\n                                }\n                            }\n                        }\n                        if (error > 0.1) {\n                            status = this.DivergingRoundingErrors;\n                            break L_40;\n                        }\n\n                        //     Calculate the coefficients of the linear approximations to the objective\n                        //     and constraint functions, placing minus the objective function gradient\n                        //     after the constraint gradients in the array A. The vector W is used for\n                        //     working space.\n                        for (k = 1; k <= mp; ++k) {\n                            con[k] = -datmat[k][np];\n                            for (j = 1; j <= n; ++j) {\n                                w[j] = datmat[k][j] + con[k];\n                            }\n\n                            for (i = 1; i <= n; ++i) {\n                                a[i][k] =\n                                    (k === mp ? -1.0 : 1.0) *\n                                    this.DOT_PRODUCT_ROW_COL(w, -1, simi, i, 1, n);\n                                // this.DOT_PRODUCT(this.PART(w, 1, n), this.PART(this.COL(simi, i), 1, n));\n                            }\n                        }\n\n                        //     Calculate the values of sigma and eta, and set IFLAG = 0 if the current\n                        //     simplex is not acceptable.\n                        iflag = true;\n                        parsig = alpha * rho;\n                        pareta = beta * rho;\n\n                        for (j = 1; j <= n; ++j) {\n                            wsig = 0.0;\n                            weta = 0.0;\n                            for (k = 1; k <= n; ++k) {\n                                wsig += simi[j][k] * simi[j][k];\n                                weta += sim[k][j] * sim[k][j];\n                            }\n                            vsig[j] = 1.0 / Math.sqrt(wsig);\n                            veta[j] = Math.sqrt(weta);\n                            if (vsig[j] < parsig || veta[j] > pareta) {\n                                iflag = false;\n                            }\n                        }\n\n                        //     If a new vertex is needed to improve acceptability, then decide which\n                        //     vertex to drop from the simplex.\n                        if (!ibrnch && !iflag) {\n                            jdrop = 0;\n                            temp = pareta;\n                            for (j = 1; j <= n; ++j) {\n                                if (veta[j] > temp) {\n                                    jdrop = j;\n                                    temp = veta[j];\n                                }\n                            }\n                            if (jdrop === 0) {\n                                for (j = 1; j <= n; ++j) {\n                                    if (vsig[j] < temp) {\n                                        jdrop = j;\n                                        temp = vsig[j];\n                                    }\n                                }\n                            }\n\n                            //     Calculate the step to the new vertex and its sign.\n                            temp = gamma * rho * vsig[jdrop];\n                            for (k = 1; k <= n; ++k) {\n                                dx[k] = temp * simi[jdrop][k];\n                            }\n                            cvmaxp = 0.0;\n                            cvmaxm = 0.0;\n                            total = 0.0;\n                            for (k = 1; k <= mp; ++k) {\n                                // total = this.DOT_PRODUCT(this.PART(this.COL(a, k), 1, n), this.PART(dx, 1, n));\n                                total = this.DOT_PRODUCT_ROW_COL(dx, -1, a, k, 1, n);\n                                if (k < mp) {\n                                    temp = datmat[k][np];\n                                    cvmaxp = Math.max(cvmaxp, -total - temp);\n                                    cvmaxm = Math.max(cvmaxm, total - temp);\n                                }\n                            }\n                            dxsign = parmu * (cvmaxp - cvmaxm) > 2.0 * total ? -1.0 : 1.0;\n\n                            //     Update the elements of SIM and SIMI, and set the next X.\n                            temp = 0.0;\n                            for (i = 1; i <= n; ++i) {\n                                dx[i] = dxsign * dx[i];\n                                sim[i][jdrop] = dx[i];\n                                temp += simi[jdrop][i] * dx[i];\n                            }\n                            for (k = 1; k <= n; ++k) {\n                                simi[jdrop][k] /= temp;\n                            }\n\n                            for (j = 1; j <= n; ++j) {\n                                if (j !== jdrop) {\n                                    // temp = this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n));\n                                    temp = this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n);\n                                    for (k = 1; k <= n; ++k) {\n                                        simi[j][k] -= temp * simi[jdrop][k];\n                                    }\n                                }\n                                x[j] = sim[j][np] + dx[j];\n                            }\n                            continue L_40;\n                        }\n\n                        //     Calculate DX = x(*)-x(0).\n                        //     Branch if the length of DX is less than 0.5*RHO.\n                        ifull = this.trstlp(n, m, a, con, rho, dx);\n                        if (!ifull) {\n                            temp = 0.0;\n                            for (k = 1; k <= n; ++k) {\n                                temp += dx[k] * dx[k];\n                            }\n                            if (temp < 0.25 * rho * rho) {\n                                ibrnch = true;\n                                break L_550;\n                            }\n                        }\n\n                        //     Predict the change to F and the new maximum constraint violation if the\n                        //     variables are altered from x(0) to x(0) + DX.\n                        total = 0.0;\n                        resnew = 0.0;\n                        con[mp] = 0.0;\n                        for (k = 1; k <= mp; ++k) {\n                            //total = con[k] - this.DOT_PRODUCT(this.PART(this.COL(a, k), 1, n), this.PART(dx, 1, n));\n                            total = con[k] - this.DOT_PRODUCT_ROW_COL(dx, -1, a, k, 1, n);\n                            if (k < mp) {\n                                resnew = Math.max(resnew, total);\n                            }\n                        }\n\n                        //     Increase PARMU if necessary and branch back if this change alters the\n                        //     optimal vertex. Otherwise PREREM and PREREC will be set to the predicted\n                        //     reductions in the merit function and the maximum constraint violation\n                        //     respectively.\n                        prerec = datmat[mpp][np] - resnew;\n                        barmu = prerec > 0.0 ? total / prerec : 0.0;\n                        if (parmu < 1.5 * barmu) {\n                            parmu = 2.0 * barmu;\n                            if (iprint >= 2) {\n                                console.log(\"Increase in PARMU to \" + parmu);\n                            }\n                            phi = datmat[mp][np] + parmu * datmat[mpp][np];\n                            for (j = 1; j <= n; ++j) {\n                                temp = datmat[mp][j] + parmu * datmat[mpp][j];\n                                if (\n                                    temp < phi ||\n                                    (temp === phi &&\n                                        parmu === 0.0 &&\n                                        datmat[mpp][j] < datmat[mpp][np])\n                                ) {\n                                    continue L_140;\n                                }\n                            }\n                        }\n                        prerem = parmu * prerec - total;\n\n                        //     Calculate the constraint and objective functions at x(*).\n                        //     Then find the actual reduction in the merit function.\n                        for (k = 1; k <= n; ++k) {\n                            x[k] = sim[k][np] + dx[k];\n                        }\n                        ibrnch = true;\n                        continue L_40;\n                    }\n\n                    skipVertexIdent = false;\n                    vmold = datmat[mp][np] + parmu * datmat[mpp][np];\n                    vmnew = f + parmu * resmax;\n                    trured = vmold - vmnew;\n                    if (parmu === 0.0 && f === datmat[mp][np]) {\n                        prerem = prerec;\n                        trured = datmat[mpp][np] - resmax;\n                    }\n\n                    //     Begin the operations that decide whether x(*) should replace one of the\n                    //     vertices of the current simplex, the change being mandatory if TRURED is\n                    //     positive. Firstly, JDROP is set to the index of the vertex that is to be\n                    //     replaced.\n                    ratio = trured <= 0.0 ? 1.0 : 0.0;\n                    jdrop = 0;\n                    for (j = 1; j <= n; ++j) {\n                        // temp = Math.abs(this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n)));\n                        temp = Math.abs(this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n));\n                        if (temp > ratio) {\n                            jdrop = j;\n                            ratio = temp;\n                        }\n                        sigbar[j] = temp * vsig[j];\n                    }\n\n                    //     Calculate the value of ell.\n                    edgmax = delta * rho;\n                    l = 0;\n                    for (j = 1; j <= n; ++j) {\n                        if (sigbar[j] >= parsig || sigbar[j] >= vsig[j]) {\n                            temp = veta[j];\n                            if (trured > 0.0) {\n                                temp = 0.0;\n                                for (k = 1; k <= n; ++k) {\n                                    temp += Math.pow(dx[k] - sim[k][j], 2.0);\n                                }\n                                temp = Math.sqrt(temp);\n                            }\n                            if (temp > edgmax) {\n                                l = j;\n                                edgmax = temp;\n                            }\n                        }\n                    }\n                    if (l > 0) {\n                        jdrop = l;\n                    }\n\n                    if (jdrop !== 0) {\n                        //     Revise the simplex by updating the elements of SIM, SIMI and DATMAT.\n                        temp = 0.0;\n                        for (i = 1; i <= n; ++i) {\n                            sim[i][jdrop] = dx[i];\n                            temp += simi[jdrop][i] * dx[i];\n                        }\n                        for (k = 1; k <= n; ++k) {\n                            simi[jdrop][k] /= temp;\n                        }\n                        for (j = 1; j <= n; ++j) {\n                            if (j !== jdrop) {\n                                // temp = this.DOT_PRODUCT(this.PART(this.ROW(simi, j), 1, n), this.PART(dx, 1, n));\n                                temp = this.DOT_PRODUCT_ROW_COL(simi, j, dx, -1, 1, n);\n                                for (k = 1; k <= n; ++k) {\n                                    simi[j][k] -= temp * simi[jdrop][k];\n                                }\n                            }\n                        }\n                        for (k = 1; k <= mpp; ++k) {\n                            datmat[k][jdrop] = con[k];\n                        }\n\n                        //     Branch back for further iterations with the current RHO.\n                        if (trured > 0.0 && trured >= 0.1 * prerem) {\n                            continue L_140;\n                        }\n                    }\n                    // If we end up here, we drop out.\n                } while (!endless);\n\n                if (!iflag) {\n                    ibrnch = false;\n                    continue L_140;\n                }\n\n                if (rho <= rhoend) {\n                    status = this.Normal;\n                    break L_40;\n                }\n\n                //     Otherwise reduce RHO if it is not at its least value and reset PARMU.\n                cmin = 0.0;\n                cmax = 0.0;\n                rho *= 0.5;\n                if (rho <= 1.5 * rhoend) {\n                    rho = rhoend;\n                }\n                if (parmu > 0.0) {\n                    denom = 0.0;\n                    for (k = 1; k <= mp; ++k) {\n                        cmin = datmat[k][np];\n                        cmax = cmin;\n                        for (i = 1; i <= n; ++i) {\n                            cmin = Math.min(cmin, datmat[k][i]);\n                            cmax = Math.max(cmax, datmat[k][i]);\n                        }\n                        if (k <= m && cmin < 0.5 * cmax) {\n                            temp = Math.max(cmax, 0.0) - cmin;\n                            denom = denom <= 0.0 ? temp : Math.min(denom, temp);\n                        }\n                    }\n                    if (denom === 0.0) {\n                        parmu = 0.0;\n                    } else if (cmax - cmin < parmu * denom) {\n                        parmu = (cmax - cmin) / denom;\n                    }\n                }\n                if (iprint >= 2) {\n                    console.log(\"Reduction in RHO to \" + rho + \"  and PARMU = \" + parmu);\n                }\n                if (iprint === 2) {\n                    this.PrintIterationResult(\n                        nfvals,\n                        datmat[mp][np],\n                        datmat[mpp][np],\n                        this.COL(sim, np),\n                        n,\n                        iprint\n                    );\n                }\n            } while (endless);\n        } while (endless);\n\n        switch (status) {\n            case this.Normal:\n                if (iprint >= 1) {\n                    console.log(\"%nNormal return from subroutine COBYLA%n\");\n                }\n                if (ifull) {\n                    if (iprint >= 1) {\n                        this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);\n                    }\n                    return status;\n                }\n                break;\n            case this.MaxIterationsReached:\n                if (iprint >= 1) {\n                    console.log(\n                        \"%nReturn from subroutine COBYLA because the MAXFUN limit has been reached.%n\"\n                    );\n                }\n                break;\n            case this.DivergingRoundingErrors:\n                if (iprint >= 1) {\n                    console.log(\n                        \"%nReturn from subroutine COBYLA because rounding errors are becoming damaging.%n\"\n                    );\n                }\n                break;\n        }\n\n        for (k = 1; k <= n; ++k) {\n            x[k] = sim[k][np];\n        }\n        f = datmat[mp][np];\n        resmax = datmat[mpp][np];\n        if (iprint >= 1) {\n            this.PrintIterationResult(nfvals, f, resmax, x, n, iprint);\n        }\n\n        return status;\n    },\n\n    trstlp: function (n, m, a, b, rho, dx) {\n        //(int n, int m, double[][] a, double[] b, double rho, double[] dx)\n        // N.B. Arguments Z, ZDOTA, VMULTC, SDIRN, DXNEW, VMULTD & IACT have been removed.\n\n        //     This subroutine calculates an N-component vector DX by applying the\n        //     following two stages. In the first stage, DX is set to the shortest\n        //     vector that minimizes the greatest violation of the constraints\n        //       A(1,K)*DX(1)+A(2,K)*DX(2)+...+A(N,K)*DX(N) .GE. B(K), K = 2,3,...,M,\n        //     subject to the Euclidean length of DX being at most RHO. If its length is\n        //     strictly less than RHO, then we use the resultant freedom in DX to\n        //     minimize the objective function\n        //              -A(1,M+1)*DX(1) - A(2,M+1)*DX(2) - ... - A(N,M+1)*DX(N)\n        //     subject to no increase in any greatest constraint violation. This\n        //     notation allows the gradient of the objective function to be regarded as\n        //     the gradient of a constraint. Therefore the two stages are distinguished\n        //     by MCON .EQ. M and MCON .GT. M respectively. It is possible that a\n        //     degeneracy may prevent DX from attaining the target length RHO. Then the\n        //     value IFULL = 0 would be set, but usually IFULL = 1 on return.\n        //\n        //     In general NACT is the number of constraints in the active set and\n        //     IACT(1),...,IACT(NACT) are their indices, while the remainder of IACT\n        //     contains a permutation of the remaining constraint indices.  Further, Z\n        //     is an orthogonal matrix whose first NACT columns can be regarded as the\n        //     result of Gram-Schmidt applied to the active constraint gradients.  For\n        //     J = 1,2,...,NACT, the number ZDOTA(J) is the scalar product of the J-th\n        //     column of Z with the gradient of the J-th active constraint.  DX is the\n        //     current vector of variables and here the residuals of the active\n        //     constraints should be zero. Further, the active constraints have\n        //     nonnegative Lagrange multipliers that are held at the beginning of\n        //     VMULTC. The remainder of this vector holds the residuals of the inactive\n        //     constraints at DX, the ordering of the components of VMULTC being in\n        //     agreement with the permutation of the indices of the constraints that is\n        //     in IACT. All these residuals are nonnegative, which is achieved by the\n        //     shift RESMAX that makes the least residual zero.\n\n        //     Initialize Z and some other variables. The value of RESMAX will be\n        //     appropriate to DX = 0, while ICON will be the index of a most violated\n        //     constraint if RESMAX is positive. Usually during the first stage the\n        //     vector SDIRN gives a search direction that reduces all the active\n        //     constraint violations by one simultaneously.\n\n        // Local variables\n\n        var temp = 0,\n            nactx = 0,\n            resold = 0.0,\n            z = this.arr2(1 + n, 1 + n),\n            zdota = this.arr(2 + m),\n            vmultc = this.arr(2 + m),\n            sdirn = this.arr(1 + n),\n            dxnew = this.arr(1 + n),\n            vmultd = this.arr(2 + m),\n            iact = this.arr(2 + m),\n            mcon = m,\n            nact = 0,\n            icon, resmax,\n            i, k, first, optold, icount,\n            step, stpful, optnew, ratio,\n            isave, vsave, total,\n            kp, kk, sp, alpha, beta, tot, spabs,\n            acca, accb, zdotv, zdvabs, kw,\n            dd, ss, sd,\n            zdotw, zdwabs, kl, sumabs, tempa,\n            endless = true;\n\n        for (i = 1; i <= n; ++i) {\n            z[i][i] = 1.0;\n            dx[i] = 0.0;\n        }\n\n        icon = 0;\n        resmax = 0.0;\n        if (m >= 1) {\n            for (k = 1; k <= m; ++k) {\n                if (b[k] > resmax) {\n                    resmax = b[k];\n                    icon = k;\n                }\n            }\n            for (k = 1; k <= m; ++k) {\n                iact[k] = k;\n                vmultc[k] = resmax - b[k];\n            }\n        }\n\n        //     End the current stage of the calculation if 3 consecutive iterations\n        //     have either failed to reduce the best calculated value of the objective\n        //     function or to increase the number of active constraints since the best\n        //     value was calculated. This strategy prevents cycling, but there is a\n        //     remote possibility that it will cause premature termination.\n\n        first = true;\n        do {\n            L_60: do {\n                if (!first || (first && resmax === 0.0)) {\n                    mcon = m + 1;\n                    icon = mcon;\n                    iact[mcon] = mcon;\n                    vmultc[mcon] = 0.0;\n                }\n                first = false;\n\n                optold = 0.0;\n                icount = 0;\n                step = 0;\n                stpful = 0;\n\n                L_70: do {\n                    // optnew = (mcon === m) ? resmax : -this.DOT_PRODUCT(this.PART(dx, 1, n), this.PART(this.COL(a, mcon), 1, n));\n                    optnew =\n                        mcon === m ? resmax : -this.DOT_PRODUCT_ROW_COL(dx, -1, a, mcon, 1, n);\n\n                    if (icount === 0 || optnew < optold) {\n                        optold = optnew;\n                        nactx = nact;\n                        icount = 3;\n                    } else if (nact > nactx) {\n                        nactx = nact;\n                        icount = 3;\n                    } else {\n                        --icount;\n                    }\n                    if (icount === 0) {\n                        break L_60;\n                    }\n\n                    //     If ICON exceeds NACT, then we add the constraint with index IACT(ICON) to\n                    //     the active set. Apply Givens rotations so that the last N-NACT-1 columns\n                    //     of Z are orthogonal to the gradient of the new constraint, a scalar\n                    //     product being set to zero if its nonzero value could be due to computer\n                    //     rounding errors. The array DXNEW is used for working space.\n                    ratio = 0;\n                    if (icon <= nact) {\n                        if (icon < nact) {\n                            //     Delete the constraint that has the index IACT(ICON) from the active set.\n\n                            isave = iact[icon];\n                            vsave = vmultc[icon];\n                            k = icon;\n                            do {\n                                kp = k + 1;\n                                kk = iact[kp];\n                                sp = this.DOT_PRODUCT(\n                                    this.PART(this.COL(z, k), 1, n),\n                                    this.PART(this.COL(a, kk), 1, n)\n                                );\n                                temp = Math.sqrt(sp * sp + zdota[kp] * zdota[kp]);\n                                alpha = zdota[kp] / temp;\n                                beta = sp / temp;\n                                zdota[kp] = alpha * zdota[k];\n                                zdota[k] = temp;\n                                for (i = 1; i <= n; ++i) {\n                                    temp = alpha * z[i][kp] + beta * z[i][k];\n                                    z[i][kp] = alpha * z[i][k] - beta * z[i][kp];\n                                    z[i][k] = temp;\n                                }\n                                iact[k] = kk;\n                                vmultc[k] = vmultc[kp];\n                                k = kp;\n                            } while (k < nact);\n\n                            iact[k] = isave;\n                            vmultc[k] = vsave;\n                        }\n                        --nact;\n\n                        //     If stage one is in progress, then set SDIRN to the direction of the next\n                        //     change to the current vector of variables.\n                        if (mcon > m) {\n                            //     Pick the next search direction of stage two.\n                            temp = 1.0 / zdota[nact];\n                            for (k = 1; k <= n; ++k) {\n                                sdirn[k] = temp * z[k][nact];\n                            }\n                        } else {\n                            // temp = this.DOT_PRODUCT(this.PART(sdirn, 1, n), this.PART(this.COL(z, nact + 1), 1, n));\n                            temp = this.DOT_PRODUCT_ROW_COL(sdirn, -1, z, nact + 1, 1, n);\n                            for (k = 1; k <= n; ++k) {\n                                sdirn[k] -= temp * z[k][nact + 1];\n                            }\n                        }\n                    } else {\n                        kk = iact[icon];\n                        for (k = 1; k <= n; ++k) {\n                            dxnew[k] = a[k][kk];\n                        }\n                        tot = 0.0;\n\n                        // {\n                        k = n;\n                        while (k > nact) {\n                            sp = 0.0;\n                            spabs = 0.0;\n                            for (i = 1; i <= n; ++i) {\n                                temp = z[i][k] * dxnew[i];\n                                sp += temp;\n                                spabs += Math.abs(temp);\n                            }\n                            acca = spabs + 0.1 * Math.abs(sp);\n                            accb = spabs + 0.2 * Math.abs(sp);\n                            if (spabs >= acca || acca >= accb) {\n                                sp = 0.0;\n                            }\n                            if (tot === 0.0) {\n                                tot = sp;\n                            } else {\n                                kp = k + 1;\n                                temp = Math.sqrt(sp * sp + tot * tot);\n                                alpha = sp / temp;\n                                beta = tot / temp;\n                                tot = temp;\n                                for (i = 1; i <= n; ++i) {\n                                    temp = alpha * z[i][k] + beta * z[i][kp];\n                                    z[i][kp] = alpha * z[i][kp] - beta * z[i][k];\n                                    z[i][k] = temp;\n                                }\n                            }\n                            --k;\n                        }\n                        // }\n\n                        if (tot === 0.0) {\n                            //     The next instruction is reached if a deletion has to be made from the\n                            //     active set in order to make room for the new active constraint, because\n                            //     the new constraint gradient is a linear combination of the gradients of\n                            //     the old active constraints.  Set the elements of VMULTD to the multipliers\n                            //     of the linear combination.  Further, set IOUT to the index of the\n                            //     constraint to be deleted, but branch if no suitable index can be found.\n\n                            ratio = -1.0;\n                            //{\n                            k = nact;\n                            do {\n                                zdotv = 0.0;\n                                zdvabs = 0.0;\n\n                                for (i = 1; i <= n; ++i) {\n                                    temp = z[i][k] * dxnew[i];\n                                    zdotv += temp;\n                                    zdvabs += Math.abs(temp);\n                                }\n                                acca = zdvabs + 0.1 * Math.abs(zdotv);\n                                accb = zdvabs + 0.2 * Math.abs(zdotv);\n                                if (zdvabs < acca && acca < accb) {\n                                    temp = zdotv / zdota[k];\n                                    if (temp > 0.0 && iact[k] <= m) {\n                                        tempa = vmultc[k] / temp;\n                                        if (ratio < 0.0 || tempa < ratio) {\n                                            ratio = tempa;\n                                        }\n                                    }\n\n                                    if (k >= 2) {\n                                        kw = iact[k];\n                                        for (i = 1; i <= n; ++i) {\n                                            dxnew[i] -= temp * a[i][kw];\n                                        }\n                                    }\n                                    vmultd[k] = temp;\n                                } else {\n                                    vmultd[k] = 0.0;\n                                }\n                            } while (--k > 0);\n                            //}\n                            if (ratio < 0.0) {\n                                break L_60;\n                            }\n\n                            //     Revise the Lagrange multipliers and reorder the active constraints so\n                            //     that the one to be replaced is at the end of the list. Also calculate the\n                            //     new value of ZDOTA(NACT) and branch if it is not acceptable.\n\n                            for (k = 1; k <= nact; ++k) {\n                                vmultc[k] = Math.max(0.0, vmultc[k] - ratio * vmultd[k]);\n                            }\n                            if (icon < nact) {\n                                isave = iact[icon];\n                                vsave = vmultc[icon];\n                                k = icon;\n                                do {\n                                    kp = k + 1;\n                                    kw = iact[kp];\n                                    sp = this.DOT_PRODUCT(\n                                        this.PART(this.COL(z, k), 1, n),\n                                        this.PART(this.COL(a, kw), 1, n)\n                                    );\n                                    temp = Math.sqrt(sp * sp + zdota[kp] * zdota[kp]);\n                                    alpha = zdota[kp] / temp;\n                                    beta = sp / temp;\n                                    zdota[kp] = alpha * zdota[k];\n                                    zdota[k] = temp;\n                                    for (i = 1; i <= n; ++i) {\n                                        temp = alpha * z[i][kp] + beta * z[i][k];\n                                        z[i][kp] = alpha * z[i][k] - beta * z[i][kp];\n                                        z[i][k] = temp;\n                                    }\n                                    iact[k] = kw;\n                                    vmultc[k] = vmultc[kp];\n                                    k = kp;\n                                } while (k < nact);\n                                iact[k] = isave;\n                                vmultc[k] = vsave;\n                            }\n                            temp = this.DOT_PRODUCT(\n                                this.PART(this.COL(z, nact), 1, n),\n                                this.PART(this.COL(a, kk), 1, n)\n                            );\n                            if (temp === 0.0) {\n                                break L_60;\n                            }\n                            zdota[nact] = temp;\n                            vmultc[icon] = 0.0;\n                            vmultc[nact] = ratio;\n                        } else {\n                            //     Add the new constraint if this can be done without a deletion from the\n                            //     active set.\n\n                            ++nact;\n                            zdota[nact] = tot;\n                            vmultc[icon] = vmultc[nact];\n                            vmultc[nact] = 0.0;\n                        }\n\n                        //     Update IACT and ensure that the objective function continues to be\n                        //     treated as the last active constraint when MCON>M.\n\n                        iact[icon] = iact[nact];\n                        iact[nact] = kk;\n                        if (mcon > m && kk !== mcon) {\n                            k = nact - 1;\n                            sp = this.DOT_PRODUCT(\n                                this.PART(this.COL(z, k), 1, n),\n                                this.PART(this.COL(a, kk), 1, n)\n                            );\n                            temp = Math.sqrt(sp * sp + zdota[nact] * zdota[nact]);\n                            alpha = zdota[nact] / temp;\n                            beta = sp / temp;\n                            zdota[nact] = alpha * zdota[k];\n                            zdota[k] = temp;\n                            for (i = 1; i <= n; ++i) {\n                                temp = alpha * z[i][nact] + beta * z[i][k];\n                                z[i][nact] = alpha * z[i][k] - beta * z[i][nact];\n                                z[i][k] = temp;\n                            }\n                            iact[nact] = iact[k];\n                            iact[k] = kk;\n                            temp = vmultc[k];\n                            vmultc[k] = vmultc[nact];\n                            vmultc[nact] = temp;\n                        }\n\n                        //     If stage one is in progress, then set SDIRN to the direction of the next\n                        //     change to the current vector of variables.\n                        if (mcon > m) {\n                            //     Pick the next search direction of stage two.\n                            temp = 1.0 / zdota[nact];\n                            for (k = 1; k <= n; ++k) {\n                                sdirn[k] = temp * z[k][nact];\n                            }\n                        } else {\n                            kk = iact[nact];\n                            // temp = (this.DOT_PRODUCT(this.PART(sdirn, 1, n),this.PART(this.COL(a, kk), 1, n)) - 1.0) / zdota[nact];\n                            temp =\n                                (this.DOT_PRODUCT_ROW_COL(sdirn, -1, a, kk, 1, n) - 1.0) /\n                                zdota[nact];\n                            for (k = 1; k <= n; ++k) {\n                                sdirn[k] -= temp * z[k][nact];\n                            }\n                        }\n                    }\n\n                    //     Calculate the step to the boundary of the trust region or take the step\n                    //     that reduces RESMAX to zero. The two statements below that include the\n                    //     factor 1.0E-6 prevent some harmless underflows that occurred in a test\n                    //     calculation. Further, we skip the step if it could be zero within a\n                    //     reasonable tolerance for computer rounding errors.\n                    dd = rho * rho;\n                    sd = 0.0;\n                    ss = 0.0;\n                    for (i = 1; i <= n; ++i) {\n                        if (Math.abs(dx[i]) >= 1.0e-6 * rho) {\n                            dd -= dx[i] * dx[i];\n                        }\n                        sd += dx[i] * sdirn[i];\n                        ss += sdirn[i] * sdirn[i];\n                    }\n                    if (dd <= 0.0) {\n                        break L_60;\n                    }\n                    temp = Math.sqrt(ss * dd);\n                    if (Math.abs(sd) >= 1.0e-6 * temp) {\n                        temp = Math.sqrt(ss * dd + sd * sd);\n                    }\n                    stpful = dd / (temp + sd);\n                    step = stpful;\n                    if (mcon === m) {\n                        acca = step + 0.1 * resmax;\n                        accb = step + 0.2 * resmax;\n                        if (step >= acca || acca >= accb) {\n                            break L_70;\n                        }\n                        step = Math.min(step, resmax);\n                    }\n\n                    //     Set DXNEW to the new variables if STEP is the steplength, and reduce\n                    //     RESMAX to the corresponding maximum residual if stage one is being done.\n                    //     Because DXNEW will be changed during the calculation of some Lagrange\n                    //     multipliers, it will be restored to the following value later.\n                    for (k = 1; k <= n; ++k) {\n                        dxnew[k] = dx[k] + step * sdirn[k];\n                    }\n                    if (mcon === m) {\n                        resold = resmax;\n                        resmax = 0.0;\n                        for (k = 1; k <= nact; ++k) {\n                            kk = iact[k];\n                            // temp = b[kk] - this.DOT_PRODUCT(this.PART(this.COL(a, kk), 1, n), this.PART(dxnew, 1, n));\n                            temp = b[kk] - this.DOT_PRODUCT_ROW_COL(dxnew, -1, a, kk, 1, n);\n                            resmax = Math.max(resmax, temp);\n                        }\n                    }\n\n                    //     Set VMULTD to the VMULTC vector that would occur if DX became DXNEW. A\n                    //     device is included to force VMULTD(K) = 0.0 if deviations from this value\n                    //     can be attributed to computer rounding errors. First calculate the new\n                    //     Lagrange multipliers.\n                    //{\n                    k = nact;\n                    do {\n                        zdotw = 0.0;\n                        zdwabs = 0.0;\n                        for (i = 1; i <= n; ++i) {\n                            temp = z[i][k] * dxnew[i];\n                            zdotw += temp;\n                            zdwabs += Math.abs(temp);\n                        }\n                        acca = zdwabs + 0.1 * Math.abs(zdotw);\n                        accb = zdwabs + 0.2 * Math.abs(zdotw);\n                        if (zdwabs >= acca || acca >= accb) {\n                            zdotw = 0.0;\n                        }\n                        vmultd[k] = zdotw / zdota[k];\n                        if (k >= 2) {\n                            kk = iact[k];\n                            for (i = 1; i <= n; ++i) {\n                                dxnew[i] -= vmultd[k] * a[i][kk];\n                            }\n                        }\n                    } while (k-- >= 2);\n                    if (mcon > m) {\n                        vmultd[nact] = Math.max(0.0, vmultd[nact]);\n                    }\n                    //}\n\n                    //     Complete VMULTC by finding the new constraint residuals.\n\n                    for (k = 1; k <= n; ++k) {\n                        dxnew[k] = dx[k] + step * sdirn[k];\n                    }\n                    if (mcon > nact) {\n                        kl = nact + 1;\n                        for (k = kl; k <= mcon; ++k) {\n                            kk = iact[k];\n                            total = resmax - b[kk];\n                            sumabs = resmax + Math.abs(b[kk]);\n                            for (i = 1; i <= n; ++i) {\n                                temp = a[i][kk] * dxnew[i];\n                                total += temp;\n                                sumabs += Math.abs(temp);\n                            }\n                            acca = sumabs + 0.1 * Math.abs(total);\n                            accb = sumabs + 0.2 * Math.abs(total);\n                            if (sumabs >= acca || acca >= accb) {\n                                total = 0.0;\n                            }\n                            vmultd[k] = total;\n                        }\n                    }\n\n                    //     Calculate the fraction of the step from DX to DXNEW that will be taken.\n\n                    ratio = 1.0;\n                    icon = 0;\n                    for (k = 1; k <= mcon; ++k) {\n                        if (vmultd[k] < 0.0) {\n                            temp = vmultc[k] / (vmultc[k] - vmultd[k]);\n                            if (temp < ratio) {\n                                ratio = temp;\n                                icon = k;\n                            }\n                        }\n                    }\n\n                    //     Update DX, VMULTC and RESMAX.\n\n                    temp = 1.0 - ratio;\n                    for (k = 1; k <= n; ++k) {\n                        dx[k] = temp * dx[k] + ratio * dxnew[k];\n                    }\n                    for (k = 1; k <= mcon; ++k) {\n                        vmultc[k] = Math.max(0.0, temp * vmultc[k] + ratio * vmultd[k]);\n                    }\n                    if (mcon === m) {\n                        resmax = resold + ratio * (resmax - resold);\n                    }\n\n                    //     If the full step is not acceptable then begin another iteration.\n                    //     Otherwise switch to stage two or end the calculation.\n                } while (icon > 0);\n\n                if (step === stpful) {\n                    return true;\n                }\n            } while (endless);\n\n            //     We employ any freedom that may be available to reduce the objective\n            //     function before returning a DX whose length is less than RHO.\n        } while (mcon === m);\n\n        return false;\n    },\n\n    PrintIterationResult: function (nfvals, f, resmax, x, n, iprint) {\n        if (iprint > 1) {\n            console.log(\"NFVALS = \" + nfvals + \"  F = \" + f + \"  MAXCV = \" + resmax);\n        }\n        if (iprint > 1) {\n            console.log(\"X = \" + this.PART(x, 1, n));\n        }\n    },\n\n    ROW: function (src, rowidx) {\n        return src[rowidx].slice();\n        // var col,\n        //     cols = src[0].length,\n        //     dest = this.arr(cols);\n\n        // for (col = 0; col < cols; ++col) {\n        //     dest[col] = src[rowidx][col];\n        // }\n        // return dest;\n    },\n\n    COL: function (src, colidx) {\n        var row,\n            rows = src.length,\n            dest = []; // this.arr(rows);\n\n        for (row = 0; row < rows; ++row) {\n            dest[row] = src[row][colidx];\n        }\n        return dest;\n    },\n\n    PART: function (src, from, to) {\n        return src.slice(from, to + 1);\n        // var srcidx,\n        //     dest = this.arr(to - from + 1),\n        //     destidx = 0;\n        // for (srcidx = from; srcidx <= to; ++srcidx, ++destidx) {\n        //     dest[destidx] = src[srcidx];\n        // }\n        // return dest;\n    },\n\n    FORMAT: function (x) {\n        return x.join(\",\");\n        // var i, fmt = \"\";\n        // for (i = 0; i < x.length; ++i) {\n        //     fmt += \", \" + x[i];\n        // }\n        // return fmt;\n    },\n\n    DOT_PRODUCT: function (lhs, rhs) {\n        var i,\n            sum = 0.0,\n            len = lhs.length;\n        for (i = 0; i < len; ++i) {\n            sum += lhs[i] * rhs[i];\n        }\n        return sum;\n    },\n\n    DOT_PRODUCT_ROW_COL: function (lhs, row, rhs, col, start, end) {\n        var i,\n            sum = 0.0;\n\n        if (row === -1) {\n            // lhs is vector\n            for (i = start; i <= end; ++i) {\n                sum += lhs[i] * rhs[i][col];\n            }\n        } else {\n            // lhs is row of matrix\n            if (col === -1) {\n                // rhs is vector\n                for (i = start; i <= end; ++i) {\n                    sum += lhs[row][i] * rhs[i];\n                }\n            } else {\n                // rhs is column of matrix\n                for (i = start; i <= end; ++i) {\n                    sum += lhs[row][i] * rhs[i][col];\n                }\n            }\n        }\n\n        return sum;\n    }\n};\n\nexport default JXG.Math.Nlp;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Extrapolate from \"./extrapolate\";\nimport Numerics from \"./numerics\";\nimport Statistics from \"./statistics\";\nimport Geometry from \"./geometry\";\nimport IntervalArithmetic from \"./ia\";\nimport Type from \"../utils/type\";\n\n/**\n * Functions for plotting of curves.\n * @name JXG.Math.Plot\n * @exports Mat.Plot as JXG.Math.Plot\n * @namespace\n */\nMat.Plot = {\n    /**\n     * Check if at least one point on the curve is finite and real.\n     **/\n    checkReal: function (points) {\n        var b = false,\n            i,\n            p,\n            len = points.length;\n\n        for (i = 0; i < len; i++) {\n            p = points[i].usrCoords;\n            if (!isNaN(p[1]) && !isNaN(p[2]) && Math.abs(p[0]) > Mat.eps) {\n                b = true;\n                break;\n            }\n        }\n        return b;\n    },\n\n    //----------------------------------------------------------------------\n    // Plot algorithm v0\n    //----------------------------------------------------------------------\n    /**\n     * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#doadvancedplot} is <tt>false</tt>.\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} mi Left bound of curve\n     * @param {Number} ma Right bound of curve\n     * @param {Number} len Number of data points\n     * @returns {JXG.Curve} Reference to the curve object.\n     */\n    updateParametricCurveNaive: function (curve, mi, ma, len) {\n        var i,\n            t,\n            suspendUpdate = false,\n            stepSize = (ma - mi) / len;\n\n        for (i = 0; i < len; i++) {\n            t = mi + i * stepSize;\n            // The last parameter prevents rounding in usr2screen().\n            curve.points[i].setCoordinates(\n                Const.COORDS_BY_USER,\n                [curve.X(t, suspendUpdate), curve.Y(t, suspendUpdate)],\n                false\n            );\n            curve.points[i]._t = t;\n            suspendUpdate = true;\n        }\n        return curve;\n    },\n\n    //----------------------------------------------------------------------\n    // Plot algorithm v1\n    //----------------------------------------------------------------------\n    /**\n     * Crude and cheap test if the segment defined by the two points <tt>(x0, y0)</tt> and <tt>(x1, y1)</tt> is\n     * outside the viewport of the board. All parameters have to be given in screen coordinates.\n     *\n     * @private\n     * @deprecated\n     * @param {Number} x0\n     * @param {Number} y0\n     * @param {Number} x1\n     * @param {Number} y1\n     * @param {JXG.Board} board\n     * @returns {Boolean} <tt>true</tt> if the given segment is outside the visible area.\n     */\n    isSegmentOutside: function (x0, y0, x1, y1, board) {\n        return (\n            (y0 < 0 && y1 < 0) ||\n            (y0 > board.canvasHeight && y1 > board.canvasHeight) ||\n            (x0 < 0 && x1 < 0) ||\n            (x0 > board.canvasWidth && x1 > board.canvasWidth)\n        );\n    },\n\n    /**\n     * Compares the absolute value of <tt>dx</tt> with <tt>MAXX</tt> and the absolute value of <tt>dy</tt>\n     * with <tt>MAXY</tt>.\n     *\n     * @private\n     * @deprecated\n     * @param {Number} dx\n     * @param {Number} dy\n     * @param {Number} MAXX\n     * @param {Number} MAXY\n     * @returns {Boolean} <tt>true</tt>, if <tt>|dx| &lt; MAXX</tt> and <tt>|dy| &lt; MAXY</tt>.\n     */\n    isDistOK: function (dx, dy, MAXX, MAXY) {\n        return Math.abs(dx) < MAXX && Math.abs(dy) < MAXY && !isNaN(dx + dy);\n    },\n\n    /**\n     * @private\n     * @deprecated\n     */\n    isSegmentDefined: function (x0, y0, x1, y1) {\n        return !(isNaN(x0 + y0) && isNaN(x1 + y1));\n    },\n\n    /**\n     * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#doadvancedplot} is <tt>true</tt>.\n     * Since 0.99 this algorithm is deprecated. It still can be used if {@link JXG.Curve#doadvancedplotold} is <tt>true</tt>.\n     *\n     * @deprecated\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} mi Left bound of curve\n     * @param {Number} ma Right bound of curve\n     * @returns {JXG.Curve} Reference to the curve object.\n     */\n    updateParametricCurveOld: function (curve, mi, ma) {\n        var i,\n            t,\n            d,\n            x,\n            y,\n            t0,\n            x0,\n            y0,\n            top,\n            depth,\n            MAX_DEPTH,\n            MAX_XDIST,\n            MAX_YDIST,\n            suspendUpdate = false,\n            po = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false),\n            dyadicStack = [],\n            depthStack = [],\n            pointStack = [],\n            divisors = [],\n            distOK = false,\n            j = 0,\n            distFromLine = function (p1, p2, p0) {\n                var lbda,\n                    d,\n                    x0 = p0[1] - p1[1],\n                    y0 = p0[2] - p1[2],\n                    x1 = p2[0] - p1[1],\n                    y1 = p2[1] - p1[2],\n                    den = x1 * x1 + y1 * y1;\n\n                if (den >= Mat.eps) {\n                    lbda = (x0 * x1 + y0 * y1) / den;\n                    if (lbda > 0) {\n                        if (lbda <= 1) {\n                            x0 -= lbda * x1;\n                            y0 -= lbda * y1;\n                            // lbda = 1.0;\n                        } else {\n                            x0 -= x1;\n                            y0 -= y1;\n                        }\n                    }\n                }\n                d = x0 * x0 + y0 * y0;\n                return Math.sqrt(d);\n            };\n\n        JXG.deprecated(\"Curve.updateParametricCurveOld()\");\n\n        if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {\n            MAX_DEPTH = 15;\n            MAX_XDIST = 10; // 10\n            MAX_YDIST = 10; // 10\n        } else {\n            MAX_DEPTH = 21;\n            MAX_XDIST = 0.7; // 0.7\n            MAX_YDIST = 0.7; // 0.7\n        }\n\n        divisors[0] = ma - mi;\n        for (i = 1; i < MAX_DEPTH; i++) {\n            divisors[i] = divisors[i - 1] * 0.5;\n        }\n\n        i = 1;\n        dyadicStack[0] = 1;\n        depthStack[0] = 0;\n\n        t = mi;\n        po.setCoordinates(\n            Const.COORDS_BY_USER,\n            [curve.X(t, suspendUpdate), curve.Y(t, suspendUpdate)],\n            false\n        );\n\n        // Now, there was a first call to the functions defining the curve.\n        // Defining elements like sliders have been evaluated.\n        // Therefore, we can set suspendUpdate to false, so that these defining elements\n        // need not be evaluated anymore for the rest of the plotting.\n        suspendUpdate = true;\n        x0 = po.scrCoords[1];\n        y0 = po.scrCoords[2];\n        t0 = t;\n\n        t = ma;\n        po.setCoordinates(\n            Const.COORDS_BY_USER,\n            [curve.X(t, suspendUpdate), curve.Y(t, suspendUpdate)],\n            false\n        );\n        x = po.scrCoords[1];\n        y = po.scrCoords[2];\n\n        pointStack[0] = [x, y];\n\n        top = 1;\n        depth = 0;\n\n        curve.points = [];\n        curve.points[j++] = new Coords(Const.COORDS_BY_SCREEN, [x0, y0], curve.board, false);\n\n        do {\n            distOK =\n                this.isDistOK(x - x0, y - y0, MAX_XDIST, MAX_YDIST) ||\n                this.isSegmentOutside(x0, y0, x, y, curve.board);\n            while (\n                depth < MAX_DEPTH &&\n                (!distOK || depth < 6) &&\n                (depth <= 7 || this.isSegmentDefined(x0, y0, x, y))\n            ) {\n                // We jump out of the loop if\n                // * depth>=MAX_DEPTH or\n                // * (depth>=6 and distOK) or\n                // * (depth>7 and segment is not defined)\n\n                dyadicStack[top] = i;\n                depthStack[top] = depth;\n                pointStack[top] = [x, y];\n                top += 1;\n\n                i = 2 * i - 1;\n                // Here, depth is increased and may reach MAX_DEPTH\n                depth++;\n                // In that case, t is undefined and we will see a jump in the curve.\n                t = mi + i * divisors[depth];\n\n                po.setCoordinates(\n                    Const.COORDS_BY_USER,\n                    [curve.X(t, suspendUpdate), curve.Y(t, suspendUpdate)],\n                    false,\n                    true\n                );\n                x = po.scrCoords[1];\n                y = po.scrCoords[2];\n                distOK =\n                    this.isDistOK(x - x0, y - y0, MAX_XDIST, MAX_YDIST) ||\n                    this.isSegmentOutside(x0, y0, x, y, curve.board);\n            }\n\n            if (j > 1) {\n                d = distFromLine(\n                    curve.points[j - 2].scrCoords,\n                    [x, y],\n                    curve.points[j - 1].scrCoords\n                );\n                if (d < 0.015) {\n                    j -= 1;\n                }\n            }\n\n            curve.points[j] = new Coords(Const.COORDS_BY_SCREEN, [x, y], curve.board, false);\n            curve.points[j]._t = t;\n            j += 1;\n\n            x0 = x;\n            y0 = y;\n            t0 = t;\n\n            top -= 1;\n            x = pointStack[top][0];\n            y = pointStack[top][1];\n            depth = depthStack[top] + 1;\n            i = dyadicStack[top] * 2;\n        } while (top > 0 && j < 500000);\n\n        curve.numberPoints = curve.points.length;\n\n        return curve;\n    },\n\n    //----------------------------------------------------------------------\n    // Plot algorithm v2\n    //----------------------------------------------------------------------\n\n    /**\n     * Add a point to the curve plot. If the new point is too close to the previously inserted point,\n     * it is skipped.\n     * Used in {@link JXG.Curve._plotRecursive}.\n     *\n     * @private\n     * @param {JXG.Coords} pnt Coords to add to the list of points\n     */\n    _insertPoint_v2: function (curve, pnt, t) {\n        var lastReal = !isNaN(this._lastCrds[1] + this._lastCrds[2]), // The last point was real\n            newReal = !isNaN(pnt.scrCoords[1] + pnt.scrCoords[2]), // New point is real point\n            cw = curve.board.canvasWidth,\n            ch = curve.board.canvasHeight,\n            off = 500;\n\n        newReal =\n            newReal &&\n            pnt.scrCoords[1] > -off &&\n            pnt.scrCoords[2] > -off &&\n            pnt.scrCoords[1] < cw + off &&\n            pnt.scrCoords[2] < ch + off;\n\n        /*\n         * Prevents two consecutive NaNs or points wich are too close\n         */\n        if (\n            (!newReal && lastReal) ||\n            (newReal &&\n                (!lastReal ||\n                    Math.abs(pnt.scrCoords[1] - this._lastCrds[1]) > 0.7 ||\n                    Math.abs(pnt.scrCoords[2] - this._lastCrds[2]) > 0.7))\n        ) {\n            pnt._t = t;\n            curve.points.push(pnt);\n            this._lastCrds = pnt.copy(\"scrCoords\");\n        }\n    },\n\n    /**\n     * Check if there is a single NaN function value at t0.\n     * @param {*} curve\n     * @param {*} t0\n     * @returns {Boolean} true if there is a second NaN point close by, false otherwise\n     */\n    neighborhood_isNaN_v2: function (curve, t0) {\n        var is_undef,\n            pnt = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false),\n            t,\n            p;\n\n        t = t0 + Mat.eps;\n        pnt.setCoordinates(Const.COORDS_BY_USER, [curve.X(t, true), curve.Y(t, true)], false);\n        p = pnt.usrCoords;\n        is_undef = isNaN(p[1] + p[2]);\n        if (!is_undef) {\n            t = t0 - Mat.eps;\n            pnt.setCoordinates(\n                Const.COORDS_BY_USER,\n                [curve.X(t, true), curve.Y(t, true)],\n                false\n            );\n            p = pnt.usrCoords;\n            is_undef = isNaN(p[1] + p[2]);\n            if (!is_undef) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    /**\n     * Investigate a function term at the bounds of intervals where\n     * the function is not defined, e.g. log(x) at x = 0.\n     *\n     * c is inbetween a and b\n     * @private\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Array} a Screen coordinates of the left interval bound\n     * @param {Array} b Screen coordinates of the right interval bound\n     * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2\n     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates\n     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates\n     * @param {Number} tc (ta + tb) / 2 = tc. Parameter which evaluates to b, i.e. [1, X(tc), Y(tc)] = c in screen coordinates\n     * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.\n     * @returns {JXG.Boolean} true if the point is inserted and the recursion should stop, false otherwise.\n     */\n    _borderCase: function (curve, a, b, c, ta, tb, tc, depth) {\n        var t,\n            pnt,\n            p,\n            p_good = null,\n            j,\n            max_it = 30,\n            is_undef = false,\n            t_nan,\n            t_real,\n            t_real2,\n            vx,\n            vy,\n            vx2,\n            vy2,\n            dx,\n            dy;\n        // asymptote;\n\n        if (depth <= 1) {\n            pnt = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false);\n            // Test if there is a single undefined point.\n            // If yes, we ignore it.\n            if (\n                isNaN(a[1] + a[2]) &&\n                !isNaN(c[1] + c[2]) &&\n                !this.neighborhood_isNaN_v2(curve, ta)\n            ) {\n                return false;\n            }\n            if (\n                isNaN(b[1] + b[2]) &&\n                !isNaN(c[1] + c[2]) &&\n                !this.neighborhood_isNaN_v2(curve, tb)\n            ) {\n                return false;\n            }\n            if (\n                isNaN(c[1] + c[2]) &&\n                (!isNaN(a[1] + a[2]) || !isNaN(b[1] + b[2])) &&\n                !this.neighborhood_isNaN_v2(curve, tc)\n            ) {\n                return false;\n            }\n\n            j = 0;\n            // Bisect a, b and c until the point t_real is inside of the definition interval\n            // and as close as possible at the boundary.\n            // t_real2 is the second closest point.\n            do {\n                // There are four cases:\n                //  a  |  c  |  b\n                // ---------------\n                // inf | R   | R\n                // R   | R   | inf\n                // inf | inf | R\n                // R   | inf | inf\n                //\n                if (isNaN(a[1] + a[2]) && !isNaN(c[1] + c[2])) {\n                    t_nan = ta;\n                    t_real = tc;\n                    t_real2 = tb;\n                } else if (isNaN(b[1] + b[2]) && !isNaN(c[1] + c[2])) {\n                    t_nan = tb;\n                    t_real = tc;\n                    t_real2 = ta;\n                } else if (isNaN(c[1] + c[2]) && !isNaN(b[1] + b[2])) {\n                    t_nan = tc;\n                    t_real = tb;\n                    t_real2 = tb + (tb - tc);\n                } else if (isNaN(c[1] + c[2]) && !isNaN(a[1] + a[2])) {\n                    t_nan = tc;\n                    t_real = ta;\n                    t_real2 = ta - (tc - ta);\n                } else {\n                    return false;\n                }\n                t = 0.5 * (t_nan + t_real);\n                pnt.setCoordinates(\n                    Const.COORDS_BY_USER,\n                    [curve.X(t, true), curve.Y(t, true)],\n                    false\n                );\n                p = pnt.usrCoords;\n\n                is_undef = isNaN(p[1] + p[2]);\n                if (is_undef) {\n                    t_nan = t;\n                } else {\n                    t_real2 = t_real;\n                    t_real = t;\n                }\n                ++j;\n            } while (is_undef && j < max_it);\n\n            // If bisection was successful, take this point.\n            // Useful only for general curves, for function graph\n            // the code below overwrite p_good from here.\n            if (j < max_it) {\n                p_good = p.slice();\n                c = p.slice();\n                t_real = t;\n            }\n\n            // OK, bisection has been done now.\n            // t_real contains the closest inner point to the border of the interval we could find.\n            // t_real2 is the second nearest point to this boundary.\n            // Now we approximate the derivative by computing the slope of the line through these two points\n            // and test if it is \"infinite\", i.e larger than 400 in absolute values.\n            //\n            vx = curve.X(t_real, true);\n            vx2 = curve.X(t_real2, true);\n            dx = (vx - vx2) / (t_real - t_real2);\n            vy = curve.Y(t_real, true);\n            vy2 = curve.Y(t_real2, true);\n            dy = (vy - vy2) / (t_real - t_real2);\n\n            if (p_good !== null) {\n                this._insertPoint_v2(\n                    curve,\n                    new Coords(Const.COORDS_BY_USER, p_good, curve.board, false)\n                );\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Recursive interval bisection algorithm for curve plotting.\n     * Used in {@link JXG.Curve.updateParametricCurve}.\n     * @private\n     * @deprecated\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Array} a Screen coordinates of the left interval bound\n     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates\n     * @param {Array} b Screen coordinates of the right interval bound\n     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates\n     * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.\n     * @param {Number} delta If the distance of the bisection point at (ta + tb) / 2 from the point (a + b) / 2 is less then delta,\n     *                 the segment [a,b] is regarded as straight line.\n     * @returns {JXG.Curve} Reference to the curve object.\n     */\n    _plotRecursive_v2: function (curve, a, ta, b, tb, depth, delta) {\n        var tc,\n            c,\n            ds,\n            mindepth = 0,\n            isSmooth,\n            isJump,\n            isCusp,\n            cusp_threshold = 0.5,\n            jump_threshold = 0.99,\n            pnt = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false);\n\n        if (curve.numberPoints > 65536) {\n            return;\n        }\n\n        // Test if the function is undefined in an interval\n        if (depth < this.nanLevel && this._isUndefined(curve, a, ta, b, tb)) {\n            return this;\n        }\n\n        if (depth < this.nanLevel && this._isOutside(a, ta, b, tb, curve.board)) {\n            return this;\n        }\n\n        tc = (ta + tb) * 0.5;\n        pnt.setCoordinates(Const.COORDS_BY_USER, [curve.X(tc, true), curve.Y(tc, true)], false);\n        c = pnt.scrCoords;\n\n        if (this._borderCase(curve, a, b, c, ta, tb, tc, depth)) {\n            return this;\n        }\n\n        ds = this._triangleDists(a, b, c); // returns [d_ab, d_ac, d_cb, d_cd]\n\n        isSmooth = depth < this.smoothLevel && ds[3] < delta;\n\n        isJump =\n            depth < this.jumpLevel &&\n            (ds[2] > jump_threshold * ds[0] ||\n                ds[1] > jump_threshold * ds[0] ||\n                ds[0] === Infinity ||\n                ds[1] === Infinity ||\n                ds[2] === Infinity);\n\n        isCusp = depth < this.smoothLevel + 2 && ds[0] < cusp_threshold * (ds[1] + ds[2]);\n\n        if (isCusp) {\n            mindepth = 0;\n            isSmooth = false;\n        }\n\n        --depth;\n\n        if (isJump) {\n            this._insertPoint_v2(\n                curve,\n                new Coords(Const.COORDS_BY_SCREEN, [NaN, NaN], curve.board, false),\n                tc\n            );\n        } else if (depth <= mindepth || isSmooth) {\n            this._insertPoint_v2(curve, pnt, tc);\n            //if (this._borderCase(a, b, c, ta, tb, tc, depth)) {}\n        } else {\n            this._plotRecursive_v2(curve, a, ta, c, tc, depth, delta);\n\n            if (!isNaN(pnt.scrCoords[1] + pnt.scrCoords[2])) {\n                this._insertPoint_v2(curve, pnt, tc);\n            }\n\n            this._plotRecursive_v2(curve, c, tc, b, tb, depth, delta);\n        }\n\n        return this;\n    },\n\n    /**\n     * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#plotVersion} is <tt>3</tt>.\n     *\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} mi Left bound of curve\n     * @param {Number} ma Right bound of curve\n     * @returns {JXG.Curve} Reference to the curve object.\n     */\n    updateParametricCurve_v2: function (curve, mi, ma) {\n        var ta,\n            tb,\n            a,\n            b,\n            suspendUpdate = false,\n            pa = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false),\n            pb = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false),\n            depth,\n            delta,\n            w2,\n            h2,\n            bbox,\n            ret_arr;\n\n        //console.time(\"plot\");\n        if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {\n            depth = Type.evaluate(curve.visProp.recursiondepthlow) || 13;\n            delta = 2;\n            // this.smoothLevel = 5; //depth - 7;\n            this.smoothLevel = depth - 6;\n            this.jumpLevel = 3;\n        } else {\n            depth = Type.evaluate(curve.visProp.recursiondepthhigh) || 17;\n            delta = 2;\n            // smoothLevel has to be small for graphs in a huge interval.\n            // this.smoothLevel = 3; //depth - 7; // 9\n            this.smoothLevel = depth - 9; // 9\n            this.jumpLevel = 2;\n        }\n        this.nanLevel = depth - 4;\n\n        curve.points = [];\n\n        if (this.xterm === \"x\") {\n            // For function graphs we can restrict the plot interval\n            // to the visible area +plus margin\n            bbox = curve.board.getBoundingBox();\n            w2 = (bbox[2] - bbox[0]) * 0.3;\n            h2 = (bbox[1] - bbox[3]) * 0.3;\n            ta = Math.max(mi, bbox[0] - w2);\n            tb = Math.min(ma, bbox[2] + w2);\n        } else {\n            ta = mi;\n            tb = ma;\n        }\n        pa.setCoordinates(\n            Const.COORDS_BY_USER,\n            [curve.X(ta, suspendUpdate), curve.Y(ta, suspendUpdate)],\n            false\n        );\n\n        // The first function calls of X() and Y() are done. We can now\n        // switch `suspendUpdate` on. If supported by the functions, this\n        // avoids for the rest of the plotting algorithm, evaluation of any\n        // parent elements.\n        suspendUpdate = true;\n\n        pb.setCoordinates(\n            Const.COORDS_BY_USER,\n            [curve.X(tb, suspendUpdate), curve.Y(tb, suspendUpdate)],\n            false\n        );\n\n        // Find start and end points of the visible area (plus a certain margin)\n        ret_arr = this._findStartPoint(curve, pa.scrCoords, ta, pb.scrCoords, tb);\n        pa.setCoordinates(Const.COORDS_BY_SCREEN, ret_arr[0], false);\n        ta = ret_arr[1];\n        ret_arr = this._findStartPoint(curve, pb.scrCoords, tb, pa.scrCoords, ta);\n        pb.setCoordinates(Const.COORDS_BY_SCREEN, ret_arr[0], false);\n        tb = ret_arr[1];\n\n        // Save the visible area.\n        // This can be used in Curve.hasPoint().\n        this._visibleArea = [ta, tb];\n\n        // Start recursive plotting algorithm\n        a = pa.copy(\"scrCoords\");\n        b = pb.copy(\"scrCoords\");\n        pa._t = ta;\n        curve.points.push(pa);\n        this._lastCrds = pa.copy(\"scrCoords\"); // Used in _insertPoint\n        this._plotRecursive_v2(curve, a, ta, b, tb, depth, delta);\n        pb._t = tb;\n        curve.points.push(pb);\n\n        curve.numberPoints = curve.points.length;\n        //console.timeEnd(\"plot\");\n\n        return curve;\n    },\n\n    //----------------------------------------------------------------------\n    // Plot algorithm v3\n    //----------------------------------------------------------------------\n    /**\n     *\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {*} pnt\n     * @param {*} t\n     * @param {*} depth\n     * @param {*} limes\n     * @private\n     */\n    _insertLimesPoint: function (curve, pnt, t, depth, limes) {\n        var p0, p1, p2;\n\n        // Ignore jump point if it follows limes\n        if (\n            (Math.abs(this._lastUsrCrds[1]) === Infinity &&\n                Math.abs(limes.left_x) === Infinity) ||\n            (Math.abs(this._lastUsrCrds[2]) === Infinity && Math.abs(limes.left_y) === Infinity)\n        ) {\n            // console.log(\"SKIP:\", pnt.usrCoords, this._lastUsrCrds, limes);\n            return;\n        }\n\n        // // Ignore jump left from limes\n        // if (Math.abs(limes.left_x) > 100 * Math.abs(this._lastUsrCrds[1])) {\n        //     x = Math.sign(limes.left_x) * Infinity;\n        // } else {\n        //     x = limes.left_x;\n        // }\n        // if (Math.abs(limes.left_y) > 100 * Math.abs(this._lastUsrCrds[2])) {\n        //     y = Math.sign(limes.left_y) * Infinity;\n        // } else {\n        //     y = limes.left_y;\n        // }\n        // //pnt.setCoordinates(Const.COORDS_BY_USER, [x, y], false);\n\n        // Add points at a jump. pnt contains [NaN, NaN]\n        //console.log(\"Add\", t, pnt.usrCoords, limes, depth)\n        p0 = new Coords(Const.COORDS_BY_USER, [limes.left_x, limes.left_y], curve.board);\n        p0._t = t;\n        curve.points.push(p0);\n\n        if (\n            !isNaN(limes.left_x) &&\n            !isNaN(limes.left_y) &&\n            !isNaN(limes.right_x) &&\n            !isNaN(limes.right_y) &&\n            (Math.abs(limes.left_x - limes.right_x) > Mat.eps ||\n                Math.abs(limes.left_y - limes.right_y) > Mat.eps)\n        ) {\n            p1 = new Coords(Const.COORDS_BY_SCREEN, pnt, curve.board);\n            p1._t = t;\n            curve.points.push(p1);\n        }\n\n        p2 = new Coords(Const.COORDS_BY_USER, [limes.right_x, limes.right_y], curve.board);\n        p2._t = t;\n        curve.points.push(p2);\n        this._lastScrCrds = p2.copy(\"scrCoords\");\n        this._lastUsrCrds = p2.copy(\"usrCoords\");\n    },\n\n    /**\n     * Add a point to the curve plot. If the new point is too close to the previously inserted point,\n     * it is skipped.\n     * Used in {@link JXG.Curve._plotRecursive}.\n     *\n     * @private\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {JXG.Coords} pnt Coords to add to the list of points\n     */\n    _insertPoint: function (curve, pnt, t, depth, limes) {\n        var last_is_real = !isNaN(this._lastScrCrds[1] + this._lastScrCrds[2]), // The last point was real\n            point_is_real = !isNaN(pnt[1] + pnt[2]), // New point is real point\n            cw = curve.board.canvasWidth,\n            ch = curve.board.canvasHeight,\n            p,\n            near = 0.8,\n            off = 500;\n\n        if (Type.exists(limes)) {\n            this._insertLimesPoint(curve, pnt, t, depth, limes);\n            return;\n        }\n\n        // Check if point has real coordinates and\n        // coordinates are not too far away from canvas.\n        point_is_real =\n            point_is_real &&\n            pnt[1] > -off &&\n            pnt[2] > -off &&\n            pnt[1] < cw + off &&\n            pnt[2] < ch + off;\n\n        // Prevent two consecutive NaNs\n        if (!last_is_real && !point_is_real) {\n            return;\n        }\n\n        // Prevent two consecutive points which are too close\n        if (\n            point_is_real &&\n            last_is_real &&\n            Math.abs(pnt[1] - this._lastScrCrds[1]) < near &&\n            Math.abs(pnt[2] - this._lastScrCrds[2]) < near\n        ) {\n            return;\n        }\n\n        // Prevent two consecutive points at infinity (either direction)\n        if (\n            (Math.abs(pnt[1]) === Infinity && Math.abs(this._lastUsrCrds[1]) === Infinity) ||\n            (Math.abs(pnt[2]) === Infinity && Math.abs(this._lastUsrCrds[2]) === Infinity)\n        ) {\n            return;\n        }\n\n        //console.log(\"add\", t, pnt.usrCoords, depth)\n        // Add regular point\n        p = new Coords(Const.COORDS_BY_SCREEN, pnt, curve.board);\n        p._t = t;\n        curve.points.push(p);\n        this._lastScrCrds = p.copy(\"scrCoords\");\n        this._lastUsrCrds = p.copy(\"usrCoords\");\n    },\n\n    /**\n     * Compute distances in screen coordinates between the points ab,\n     * ac, cb, and cd, where d = (a + b)/2.\n     * cd is used for the smoothness test, ab, ac, cb are used to detect jumps, cusps and poles.\n     *\n     * @private\n     * @param {Array} a Screen coordinates of the left interval bound\n     * @param {Array} b Screen coordinates of the right interval bound\n     * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2\n     * @returns {Array} array of distances in screen coordinates between: ab, ac, cb, and cd.\n     */\n    _triangleDists: function (a, b, c) {\n        var d, d_ab, d_ac, d_cb, d_cd;\n\n        d = [a[0] * b[0], (a[1] + b[1]) * 0.5, (a[2] + b[2]) * 0.5];\n\n        d_ab = Geometry.distance(a, b, 3);\n        d_ac = Geometry.distance(a, c, 3);\n        d_cb = Geometry.distance(c, b, 3);\n        d_cd = Geometry.distance(c, d, 3);\n\n        return [d_ab, d_ac, d_cb, d_cd];\n    },\n\n    /**\n     * Test if the function is undefined on an interval:\n     * If the interval borders a and b are undefined, 20 random values\n     * are tested if they are undefined, too.\n     * Only if all values are undefined, we declare the function to be undefined in this interval.\n     *\n     * @private\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Array} a Screen coordinates of the left interval bound\n     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates\n     * @param {Array} b Screen coordinates of the right interval bound\n     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates\n     */\n    _isUndefined: function (curve, a, ta, b, tb) {\n        var t, i, pnt;\n\n        if (!isNaN(a[1] + a[2]) || !isNaN(b[1] + b[2])) {\n            return false;\n        }\n\n        pnt = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false);\n\n        for (i = 0; i < 20; ++i) {\n            t = ta + Math.random() * (tb - ta);\n            pnt.setCoordinates(\n                Const.COORDS_BY_USER,\n                [curve.X(t, true), curve.Y(t, true)],\n                false\n            );\n            if (!isNaN(pnt.scrCoords[0] + pnt.scrCoords[1] + pnt.scrCoords[2])) {\n                return false;\n            }\n        }\n\n        return true;\n    },\n\n    /**\n     * Decide if a path segment is too far from the canvas that we do not need to draw it.\n     * @private\n     * @param  {Array}  a  Screen coordinates of the start point of the segment\n     * @param  {Array}  ta Curve parameter of a  (unused).\n     * @param  {Array}  b  Screen coordinates of the end point of the segment\n     * @param  {Array}  tb Curve parameter of b (unused).\n     * @param  {JXG.Board} board\n     * @returns {Boolean}   True if the segment is too far away from the canvas, false otherwise.\n     */\n    _isOutside: function (a, ta, b, tb, board) {\n        var off = 500,\n            cw = board.canvasWidth,\n            ch = board.canvasHeight;\n\n        return !!(\n            (a[1] < -off && b[1] < -off) ||\n            (a[2] < -off && b[2] < -off) ||\n            (a[1] > cw + off && b[1] > cw + off) ||\n            (a[2] > ch + off && b[2] > ch + off)\n        );\n    },\n\n    /**\n     * Decide if a point of a curve is too far from the canvas that we do not need to draw it.\n     * @private\n     * @param {Array}  a  Screen coordinates of the point\n     * @param {JXG.Board} board\n     * @returns {Boolean}  True if the point is too far away from the canvas, false otherwise.\n     */\n    _isOutsidePoint: function (a, board) {\n        var off = 500,\n            cw = board.canvasWidth,\n            ch = board.canvasHeight;\n\n        return !!(a[1] < -off || a[2] < -off || a[1] > cw + off || a[2] > ch + off);\n    },\n\n    /**\n     * For a curve c(t) defined on the interval [ta, tb] find the first point\n     * which is in the visible area of the board (plus some outside margin).\n     * <p>\n     * This method is necessary to restrict the recursive plotting algorithm\n     * {@link JXG.Curve._plotRecursive} to the visible area and not waste\n     * recursion to areas far outside of the visible area.\n     * <p>\n     * This method can also be used to find the last visible point\n     * by reversing the input parameters.\n     *\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param  {Array}  ta Curve parameter of a.\n     * @param  {Array}  b  Screen coordinates of the end point of the segment (unused)\n     * @param  {Array}  tb Curve parameter of b\n     * @return {Array}  Array of length two containing the screen ccordinates of\n     * the starting point and the curve parameter at this point.\n     * @private\n     */\n    _findStartPoint: function (curve, a, ta, b, tb) {\n        // The code below is too unstable.\n        // E.g. [function(t) { return Math.pow(t, 2) * (t + 5) * Math.pow(t - 5, 2); }, -8, 8]\n        // Therefore, we return here.\n        return [a, ta];\n\n        // var i,\n        //     delta,\n        //     tc,\n        //     td,\n        //     z,\n        //     isFound,\n        //     w2,\n        //     h2,\n        //     pnt = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false),\n        //     steps = 40,\n        //     eps = 0.01,\n        //     fnX1,\n        //     fnX2,\n        //     fnY1,\n        //     fnY2,\n        //     bbox = curve.board.getBoundingBox();\n\n        // if (true || !this._isOutsidePoint(a, curve.board)) {\n        //     return [a, ta];\n        // }\n        // w2 = (bbox[2] - bbox[0]) * 0.3;\n        // h2 = (bbox[1] - bbox[3]) * 0.3;\n        // bbox[0] -= w2;\n        // bbox[1] += h2;\n        // bbox[2] += w2;\n        // bbox[3] -= h2;\n\n        // delta = (tb - ta) / steps;\n        // tc = ta + delta;\n        // isFound = false;\n\n        // fnX1 = function (t) {\n        //     return curve.X(t, true) - bbox[0];\n        // };\n        // fnY1 = function (t) {\n        //     return curve.Y(t, true) - bbox[1];\n        // };\n        // fnX2 = function (t) {\n        //     return curve.X(t, true) - bbox[2];\n        // };\n        // fnY2 = function (t) {\n        //     return curve.Y(t, true) - bbox[3];\n        // };\n        // for (i = 0; i < steps; ++i) {\n        //     // Left border\n        //     z = bbox[0];\n        //     td = Numerics.root(fnX1, [tc - delta, tc], curve);\n        //     // td = Numerics.fzero(fnX1, [tc - delta, tc], this);\n        //     // console.log(\"A\", tc - delta, tc, td, Math.abs(this.X(td, true) - z));\n        //     if (Math.abs(curve.X(td, true) - z) < eps) {\n        //         //} * Math.abs(z)) {\n        //         isFound = true;\n        //         break;\n        //     }\n        //     // Top border\n        //     z = bbox[1];\n        //     td = Numerics.root(fnY1, [tc - delta, tc], curve);\n        //     // td = Numerics.fzero(fnY1, [tc - delta, tc], this);\n        //     // console.log(\"B\", tc - delta, tc, td, Math.abs(this.Y(td, true) - z));\n        //     if (Math.abs(curve.Y(td, true) - z) < eps) {\n        //         // * Math.abs(z)) {\n        //         isFound = true;\n        //         break;\n        //     }\n        //     // Right border\n        //     z = bbox[2];\n        //     td = Numerics.root(fnX2, [tc - delta, tc], curve);\n        //     // td = Numerics.fzero(fnX2, [tc - delta, tc], this);\n        //     // console.log(\"C\", tc - delta, tc, td, Math.abs(this.X(td, true) - z));\n        //     if (Math.abs(curve.X(td, true) - z) < eps) {\n        //         // * Math.abs(z)) {\n        //         isFound = true;\n        //         break;\n        //     }\n        //     // Bottom border\n        //     z = bbox[3];\n        //     td = Numerics.root(fnY2, [tc - delta, tc], curve);\n        //     // td = Numerics.fzero(fnY2, [tc - delta, tc], this);\n        //     // console.log(\"D\", tc - delta, tc, td, Math.abs(this.Y(td, true) - z));\n        //     if (Math.abs(curve.Y(td, true) - z) < eps) {\n        //         // * Math.abs(z)) {\n        //         isFound = true;\n        //         break;\n        //     }\n        //     tc += delta;\n        // }\n        // if (isFound) {\n        //     pnt.setCoordinates(\n        //         Const.COORDS_BY_USER,\n        //         [curve.X(td, true), curve.Y(td, true)],\n        //         false\n        //     );\n        //     return [pnt.scrCoords, td];\n        // }\n        // console.log(\"TODO _findStartPoint\", curve.Y.toString(), tc);\n        // pnt.setCoordinates(Const.COORDS_BY_USER, [curve.X(ta, true), curve.Y(ta, true)], false);\n        // return [pnt.scrCoords, ta];\n    },\n\n    /**\n     * Investigate a function term at the bounds of intervals where\n     * the function is not defined, e.g. log(x) at x = 0.\n     *\n     * c is inbetween a and b\n     *\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Array} a Screen coordinates of the left interval bound\n     * @param {Array} b Screen coordinates of the right interval bound\n     * @param {Array} c Screen coordinates of the bisection point at (ta + tb) / 2\n     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates\n     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates\n     * @param {Number} tc (ta + tb) / 2 = tc. Parameter which evaluates to b, i.e. [1, X(tc), Y(tc)] = c in screen coordinates\n     * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.\n     * @returns {JXG.Boolean} true if the point is inserted and the recursion should stop, false otherwise.\n     *\n     * @private\n     */\n    _getBorderPos: function (curve, ta, a, tc, c, tb, b) {\n        var t,\n            pnt,\n            p,\n            j,\n            max_it = 30,\n            is_undef = false,\n            t_real2,\n            t_good,\n            t_bad;\n\n        pnt = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false);\n        j = 0;\n        // Bisect a, b and c until the point t_real is inside of the definition interval\n        // and as close as possible at the boundary.\n        // t_real2 is the second closest point.\n        // There are four cases:\n        //  a  |  c  |  b\n        // ---------------\n        // inf | R   | R\n        // R   | R   | inf\n        // inf | inf | R\n        // R   | inf | inf\n        //\n        if (isNaN(a[1] + a[2]) && !isNaN(c[1] + c[2])) {\n            t_bad = ta;\n            t_good = tc;\n            t_real2 = tb;\n        } else if (isNaN(b[1] + b[2]) && !isNaN(c[1] + c[2])) {\n            t_bad = tb;\n            t_good = tc;\n            t_real2 = ta;\n        } else if (isNaN(c[1] + c[2]) && !isNaN(b[1] + b[2])) {\n            t_bad = tc;\n            t_good = tb;\n            t_real2 = tb + (tb - tc);\n        } else if (isNaN(c[1] + c[2]) && !isNaN(a[1] + a[2])) {\n            t_bad = tc;\n            t_good = ta;\n            t_real2 = ta - (tc - ta);\n        } else {\n            return false;\n        }\n        do {\n            t = 0.5 * (t_good + t_bad);\n            pnt.setCoordinates(\n                Const.COORDS_BY_USER,\n                [curve.X(t, true), curve.Y(t, true)],\n                false\n            );\n            p = pnt.usrCoords;\n            is_undef = isNaN(p[1] + p[2]);\n            if (is_undef) {\n                t_bad = t;\n            } else {\n                t_real2 = t_good;\n                t_good = t;\n            }\n            ++j;\n        } while (j < max_it && Math.abs(t_good - t_bad) > Mat.eps);\n        return t;\n    },\n\n    /**\n     *\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} ta\n     * @param {Number} tb\n     */\n    _getCuspPos: function (curve, ta, tb) {\n        var a = [curve.X(ta, true), curve.Y(ta, true)],\n            b = [curve.X(tb, true), curve.Y(tb, true)],\n            max_func = function (t) {\n                var c = [curve.X(t, true), curve.Y(t, true)];\n                return -(\n                    Math.sqrt((a[0] - c[0]) * (a[0] - c[0]) + (a[1] - c[1]) * (a[1] - c[1])) +\n                    Math.sqrt((b[0] - c[0]) * (b[0] - c[0]) + (b[1] - c[1]) * (b[1] - c[1]))\n                );\n            };\n\n        return Numerics.fminbr(max_func, [ta, tb], curve);\n    },\n\n    /**\n     *\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} ta\n     * @param {Number} tb\n     */\n    _getJumpPos: function (curve, ta, tb) {\n        var max_func = function (t) {\n            var e = Mat.eps * Mat.eps,\n                c1 = [curve.X(t, true), curve.Y(t, true)],\n                c2 = [curve.X(t + e, true), curve.Y(t + e, true)];\n            return -Math.abs((c2[1] - c1[1]) / (c2[0] - c1[0]));\n        };\n\n        return Numerics.fminbr(max_func, [ta, tb], curve);\n    },\n\n    /**\n     *\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} t\n     * @private\n     */\n    _getLimits: function (curve, t) {\n        var res,\n            step = 2 / (curve.maxX() - curve.minX()),\n            x_l,\n            x_r,\n            y_l,\n            y_r;\n\n        // From left\n        res = Extrapolate.limit(t, -step, curve.X);\n        x_l = res[0];\n        if (res[1] === \"infinite\") {\n            x_l = Math.sign(x_l) * Infinity;\n        }\n\n        res = Extrapolate.limit(t, -step, curve.Y);\n        y_l = res[0];\n        if (res[1] === \"infinite\") {\n            y_l = Math.sign(y_l) * Infinity;\n        }\n\n        // From right\n        res = Extrapolate.limit(t, step, curve.X);\n        x_r = res[0];\n        if (res[1] === \"infinite\") {\n            x_r = Math.sign(x_r) * Infinity;\n        }\n\n        res = Extrapolate.limit(t, step, curve.Y);\n        y_r = res[0];\n        if (res[1] === \"infinite\") {\n            y_r = Math.sign(y_r) * Infinity;\n        }\n\n        return {\n            left_x: x_l,\n            left_y: y_l,\n            right_x: x_r,\n            right_y: y_r,\n            t: t\n        };\n    },\n\n    /**\n     *\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Array} a\n     * @param {Number} tc\n     * @param {Array} c\n     * @param {Number} tb\n     * @param {Array} b\n     * @param {String} may_be_special\n     * @param {Number} depth\n     * @private\n     */\n    _getLimes: function (curve, ta, a, tc, c, tb, b, may_be_special, depth) {\n        var t;\n\n        if (may_be_special === \"border\") {\n            t = this._getBorderPos(curve, ta, a, tc, c, tb, b);\n        } else if (may_be_special === \"cusp\") {\n            t = this._getCuspPos(curve, ta, tb);\n        } else if (may_be_special === \"jump\") {\n            t = this._getJumpPos(curve, ta, tb);\n        }\n        return this._getLimits(curve, t);\n    },\n\n    /**\n     * Recursive interval bisection algorithm for curve plotting.\n     * Used in {@link JXG.Curve.updateParametricCurve}.\n     * @private\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Array} a Screen coordinates of the left interval bound\n     * @param {Number} ta Parameter which evaluates to a, i.e. [1, X(ta), Y(ta)] = a in screen coordinates\n     * @param {Array} b Screen coordinates of the right interval bound\n     * @param {Number} tb Parameter which evaluates to b, i.e. [1, X(tb), Y(tb)] = b in screen coordinates\n     * @param {Number} depth Actual recursion depth. The recursion stops if depth is equal to 0.\n     * @param {Number} delta If the distance of the bisection point at (ta + tb) / 2 from the point (a + b) / 2 is less then delta,\n     *                 the segment [a,b] is regarded as straight line.\n     * @returns {JXG.Curve} Reference to the curve object.\n     */\n    _plotNonRecursive: function (curve, a, ta, b, tb, d) {\n        var tc,\n            c,\n            ds,\n            mindepth = 0,\n            limes = null,\n            a_nan,\n            b_nan,\n            isSmooth = false,\n            may_be_special = \"\",\n            x,\n            y,\n            oc,\n            depth,\n            ds0,\n            stack = [],\n            stack_length = 0,\n            item;\n\n        oc = curve.board.origin.scrCoords;\n        stack[stack_length++] = [a, ta, b, tb, d, Infinity];\n        while (stack_length > 0) {\n            // item = stack.pop();\n            item = stack[--stack_length];\n            a = item[0];\n            ta = item[1];\n            b = item[2];\n            tb = item[3];\n            depth = item[4];\n            ds0 = item[5];\n\n            isSmooth = false;\n            may_be_special = \"\";\n            limes = null;\n            //console.log(stack.length, item)\n\n            if (curve.points.length > 65536) {\n                return;\n            }\n\n            if (depth < this.nanLevel) {\n                // Test if the function is undefined in the whole interval [ta, tb]\n                if (this._isUndefined(curve, a, ta, b, tb)) {\n                    continue;\n                }\n                // Test if the graph is far outside the visible are for the interval [ta, tb]\n                if (this._isOutside(a, ta, b, tb, curve.board)) {\n                    continue;\n                }\n            }\n\n            tc = (ta + tb) * 0.5;\n\n            // Screen coordinates of point at tc\n            x = curve.X(tc, true);\n            y = curve.Y(tc, true);\n            c = [1, oc[1] + x * curve.board.unitX, oc[2] - y * curve.board.unitY];\n            ds = this._triangleDists(a, b, c); // returns [d_ab, d_ac, d_cb, d_cd]\n\n            a_nan = isNaN(a[1] + a[2]);\n            b_nan = isNaN(b[1] + b[2]);\n            if ((a_nan && !b_nan) || (!a_nan && b_nan)) {\n                may_be_special = \"border\";\n            } else if (\n                ds[0] > 0.66 * ds0 ||\n                ds[0] < this.cusp_threshold * (ds[1] + ds[2]) ||\n                ds[1] > 5 * ds[2] ||\n                ds[2] > 5 * ds[1]\n            ) {\n                may_be_special = \"cusp\";\n            } else if (\n                ds[2] > this.jump_threshold * ds[0] ||\n                ds[1] > this.jump_threshold * ds[0] ||\n                ds[0] === Infinity ||\n                ds[1] === Infinity ||\n                ds[2] === Infinity\n            ) {\n                may_be_special = \"jump\";\n            }\n            isSmooth =\n                may_be_special === \"\" &&\n                depth < this.smoothLevel &&\n                ds[3] < this.smooth_threshold;\n\n            if (depth < this.testLevel && !isSmooth) {\n                if (may_be_special === \"\") {\n                    isSmooth = true;\n                } else {\n                    limes = this._getLimes(curve, ta, a, tc, c, tb, b, may_be_special, depth);\n                }\n            }\n\n            if (limes !== null) {\n                c = [1, NaN, NaN];\n                this._insertPoint(curve, c, tc, depth, limes);\n            } else if (depth <= mindepth || isSmooth) {\n                this._insertPoint(curve, c, tc, depth, null);\n            } else {\n                stack[stack_length++] = [c, tc, b, tb, depth - 1, ds[0]];\n                stack[stack_length++] = [a, ta, c, tc, depth - 1, ds[0]];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Updates the data points of a parametric curve. This version is used if {@link JXG.Curve#plotVersion} is <tt>3</tt>.\n     * This is an experimental plot version, <b>not recommended</b> to be used.\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} mi Left bound of curve\n     * @param {Number} ma Right bound of curve\n     * @returns {JXG.Curve} Reference to the curve object.\n     */\n    updateParametricCurve_v3: function (curve, mi, ma) {\n        var ta,\n            tb,\n            a,\n            b,\n            suspendUpdate = false,\n            pa = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false),\n            pb = new Coords(Const.COORDS_BY_USER, [0, 0], curve.board, false),\n            depth,\n            w2, // h2,\n            bbox,\n            ret_arr;\n\n        // console.log(\"-----------------------------------------------------------\");\n        // console.time(\"plot\");\n        if (curve.board.updateQuality === curve.board.BOARD_QUALITY_LOW) {\n            depth = Type.evaluate(curve.visProp.recursiondepthlow) || 14;\n        } else {\n            depth = Type.evaluate(curve.visProp.recursiondepthhigh) || 17;\n        }\n\n        // smoothLevel has to be small for graphs in a huge interval.\n        this.smoothLevel = 7; //depth - 10;\n        this.nanLevel = depth - 4;\n        this.testLevel = 4;\n        this.cusp_threshold = 0.5;\n        this.jump_threshold = 0.99;\n        this.smooth_threshold = 2;\n\n        curve.points = [];\n\n        if (curve.xterm === \"x\") {\n            // For function graphs we can restrict the plot interval\n            // to the visible area +plus margin\n            bbox = curve.board.getBoundingBox();\n            w2 = (bbox[2] - bbox[0]) * 0.3;\n            //h2 = (bbox[1] - bbox[3]) * 0.3;\n            ta = Math.max(mi, bbox[0] - w2);\n            tb = Math.min(ma, bbox[2] + w2);\n        } else {\n            ta = mi;\n            tb = ma;\n        }\n        pa.setCoordinates(\n            Const.COORDS_BY_USER,\n            [curve.X(ta, suspendUpdate), curve.Y(ta, suspendUpdate)],\n            false\n        );\n\n        // The first function calls of X() and Y() are done. We can now\n        // switch `suspendUpdate` on. If supported by the functions, this\n        // avoids for the rest of the plotting algorithm, evaluation of any\n        // parent elements.\n        suspendUpdate = true;\n\n        pb.setCoordinates(\n            Const.COORDS_BY_USER,\n            [curve.X(tb, suspendUpdate), curve.Y(tb, suspendUpdate)],\n            false\n        );\n\n        // Find start and end points of the visible area (plus a certain margin)\n        ret_arr = this._findStartPoint(curve, pa.scrCoords, ta, pb.scrCoords, tb);\n        pa.setCoordinates(Const.COORDS_BY_SCREEN, ret_arr[0], false);\n        ta = ret_arr[1];\n        ret_arr = this._findStartPoint(curve, pb.scrCoords, tb, pa.scrCoords, ta);\n        pb.setCoordinates(Const.COORDS_BY_SCREEN, ret_arr[0], false);\n        tb = ret_arr[1];\n\n        // Save the visible area.\n        // This can be used in Curve.hasPoint().\n        this._visibleArea = [ta, tb];\n\n        // Start recursive plotting algorithm\n        a = pa.copy(\"scrCoords\");\n        b = pb.copy(\"scrCoords\");\n        pa._t = ta;\n        curve.points.push(pa);\n        this._lastScrCrds = pa.copy(\"scrCoords\"); // Used in _insertPoint\n        this._lastUsrCrds = pa.copy(\"usrCoords\"); // Used in _insertPoint\n\n        this._plotNonRecursive(curve, a, ta, b, tb, depth);\n\n        pb._t = tb;\n        curve.points.push(pb);\n\n        curve.numberPoints = curve.points.length;\n        // console.timeEnd(\"plot\");\n        // console.log(\"number of points:\", this.numberPoints);\n\n        return curve;\n    },\n\n    //----------------------------------------------------------------------\n    // Plot algorithm v4\n    //----------------------------------------------------------------------\n\n    _criticalInterval: function (vec, le, level) {\n        var i,\n            j,\n            le1,\n            med,\n            sgn,\n            sgnChange,\n            isGroup = false,\n            abs_vec,\n            last = -Infinity,\n            very_small = false,\n            smooth = false,\n            group = 0,\n            groups = [],\n            types = [],\n            positions = [];\n\n        abs_vec = Statistics.abs(vec);\n        med = Statistics.median(abs_vec);\n\n        if (med < 1.0e-7) {\n            med = 1.0e-7;\n            very_small = true;\n        } else {\n            med *= this.criticalThreshold;\n        }\n\n        //console.log(\"Median\", med);\n        for (i = 0; i < le; i++) {\n            // Start a group if not yet done and\n            // add position to group\n            if (abs_vec[i] > med /*&& abs_vec[i] > 0.01*/) {\n                positions.push({ i: i, v: vec[i], group: group });\n                last = i;\n                if (!isGroup) {\n                    isGroup = true;\n                }\n            } else {\n                if (isGroup && i > last + 4) {\n                    // End the group\n                    if (positions.length > 0) {\n                        groups.push(positions.slice(0));\n                    }\n                    positions = [];\n                    isGroup = false;\n                    group++;\n                }\n            }\n        }\n        if (isGroup) {\n            if (positions.length > 1) {\n                groups.push(positions.slice(0));\n            }\n        }\n\n        if (very_small && groups.length === 0) {\n            smooth = true;\n        }\n\n        // Decide if there is a singular critical point\n        // or if a whole interval is problematic.\n        // The latter is the case if the differences have many sign changes.\n        for (j = 0; j < groups.length; j++) {\n            types[j] = \"point\";\n            le1 = groups[j].length;\n            if (le1 < 64) {\n                continue;\n            }\n            sgnChange = 0;\n            sgn = Math.sign(groups[j][0].v);\n            for (i = 1; i < le1; i++) {\n                if (Math.sign(groups[j][i].v) !== sgn) {\n                    sgnChange++;\n                    sgn = Math.sign(groups[j][i].v);\n                }\n            }\n            if (sgnChange * 6 > le1) {\n                types[j] = \"interval\";\n            }\n        }\n\n        return { smooth: smooth, groups: groups, types: types };\n    },\n\n    Component: function () {\n        this.left_isNaN = false;\n        this.right_isNaN = false;\n        this.left_t = null;\n        this.right_t = null;\n        this.t_values = [];\n        this.x_values = [];\n        this.y_values = [];\n        this.len = 0;\n    },\n\n    findComponents: function (curve, mi, ma, steps) {\n        var i,\n            t,\n            le,\n            h,\n            x,\n            y,\n            components = [],\n            comp,\n            comp_nr = 0,\n            cnt = 0,\n            cntNaNs = 0,\n            comp_started = false,\n            suspended = false;\n\n        h = (ma - mi) / steps;\n        components[comp_nr] = new this.Component();\n        comp = components[comp_nr];\n\n        for (i = 0, t = mi; i <= steps; i++, t += h) {\n            x = curve.X(t, suspended);\n            y = curve.Y(t, suspended);\n\n            if (isNaN(x) || isNaN(y)) {\n                cntNaNs++;\n                // Wait for - at least - two consecutive NaNs\n                // This avoids starting a new component if\n                // the function value has infinity as intermediate value.\n                if (cntNaNs > 1 && comp_started) {\n                    // Finalize a component\n                    comp.right_isNaN = true;\n                    comp.right_t = t - h;\n                    comp.len = cnt;\n\n                    // Prepare a new component\n                    comp_started = false;\n                    comp_nr++;\n                    components[comp_nr] = new this.Component();\n                    comp = components[comp_nr];\n                    cntNaNs = 0;\n                }\n            } else {\n                // Now there is a non-NaN entry.\n                if (!comp_started) {\n                    // Start the component\n                    comp_started = true;\n                    cnt = 0;\n                    if (cntNaNs > 0) {\n                        comp.left_t = t - h;\n                        comp.left_isNaN = true;\n                    }\n                }\n                cntNaNs = 0;\n                // Add the value to the component\n                comp.t_values[cnt] = t;\n                comp.x_values[cnt] = x;\n                comp.y_values[cnt] = y;\n                cnt++;\n            }\n            if (i === 0) {\n                suspended = true;\n            }\n        }\n        if (comp_started) {\n            comp.len = cnt;\n        } else {\n            components.pop();\n        }\n\n        return components;\n    },\n\n    getPointType: function (curve, pos, t_approx, t_values, x_table, y_table, len) {\n        var x_values = x_table[0],\n            y_values = y_table[0],\n            full_len = t_values.length,\n            result = {\n                idx: pos,\n                t: t_approx, //t_values[pos],\n                x: x_values[pos],\n                y: y_values[pos],\n                type: \"other\"\n            };\n\n        if (pos < 5) {\n            result.type = \"borderleft\";\n            result.idx = 0;\n            result.t = t_values[0];\n            result.x = x_values[0];\n            result.y = y_values[0];\n\n            // console.log('Border left', result.t);\n            return result;\n        }\n        if (pos > len - 6) {\n            result.type = \"borderright\";\n            result.idx = full_len - 1;\n            result.t = t_values[full_len - 1];\n            result.x = x_values[full_len - 1];\n            result.y = y_values[full_len - 1];\n\n            // console.log('Border right', result.t, full_len - 1);\n            return result;\n        }\n\n        return result;\n    },\n\n    newtonApprox: function (idx, t, h, level, table) {\n        var i,\n            s = 0.0;\n        for (i = level; i > 0; i--) {\n            s = ((s + table[i][idx]) * (t - (i - 1) * h)) / i;\n        }\n        return s + table[0][idx];\n    },\n\n    thiele: function (t, recip, t_values, idx, degree) {\n        var i,\n            v = 0.0;\n        for (i = degree; i > 1; i--) {\n            v = (t - t_values[idx + i]) / (recip[i][idx + 1] - recip[i - 2][idx + 1] + v);\n        }\n        return recip[0][idx + 1] + (t - t_values[idx + 1]) / (recip[1][idx + 1] + v);\n    },\n\n    differenceMethodExperiments: function (component, curve) {\n        var i,\n            level,\n            le,\n            up,\n            t_values = component.t_values,\n            x_values = component.x_values,\n            y_values = component.y_values,\n            x_diffs = [],\n            y_diffs = [],\n            x_slopes = [],\n            y_slopes = [],\n            x_table = [],\n            y_table = [],\n            x_recip = [],\n            y_recip = [],\n            h,\n            numerator,\n            // x_med, y_med,\n            foundCriticalPoint = 0,\n            pos,\n            ma,\n            j,\n            v,\n            groups,\n            criticalPoints = [];\n\n        h = t_values[1] - t_values[0];\n        x_table.push([]);\n        y_table.push([]);\n        x_recip.push([]);\n        y_recip.push([]);\n        le = y_values.length;\n        for (i = 0; i < le; i++) {\n            x_table[0][i] = x_values[i];\n            y_table[0][i] = y_values[i];\n            x_recip[0][i] = x_values[i];\n            y_recip[0][i] = y_values[i];\n        }\n\n        x_table.push([]);\n        y_table.push([]);\n        x_recip.push([]);\n        y_recip.push([]);\n        numerator = h;\n        le = y_values.length - 1;\n        for (i = 0; i < le; i++) {\n            x_diffs[i] = x_values[i + 1] - x_values[i];\n            y_diffs[i] = y_values[i + 1] - y_values[i];\n            x_slopes[i] = x_diffs[i];\n            y_slopes[i] = y_diffs[i];\n            x_table[1][i] = x_diffs[i];\n            y_table[1][i] = y_diffs[i];\n            x_recip[1][i] = numerator / x_diffs[i];\n            y_recip[1][i] = numerator / y_diffs[i];\n        }\n        le--;\n\n        up = Math.min(8, y_values.length - 1);\n        for (level = 1; level < up; level++) {\n            x_table.push([]);\n            y_table.push([]);\n            x_recip.push([]);\n            y_recip.push([]);\n            numerator *= h;\n            for (i = 0; i < le; i++) {\n                x_diffs[i] = x_diffs[i + 1] - x_diffs[i];\n                y_diffs[i] = y_diffs[i + 1] - y_diffs[i];\n                x_table[level + 1][i] = x_diffs[i];\n                y_table[level + 1][i] = y_diffs[i];\n                x_recip[level + 1][i] =\n                    numerator / (x_recip[level][i + 1] - x_recip[level][i]) +\n                    x_recip[level - 1][i + 1];\n                y_recip[level + 1][i] =\n                    numerator / (y_recip[level][i + 1] - y_recip[level][i]) +\n                    y_recip[level - 1][i + 1];\n            }\n\n            // if (level == 1) {\n            //     console.log(\"bends level=\", level, y_diffs.toString());\n            // }\n\n            // Store point location which may be centered around\n            // critical points.\n            // If the lebvel is suitable, step out of the loop.\n            groups = this._criticalPoints(y_diffs, le, level);\n            if (groups === false) {\n                // Its seems, the degree of the polynomial is equal to level\n                console.log(\"Polynomial of degree\", level);\n                groups = [];\n                break;\n            }\n            if (groups.length > 0) {\n                foundCriticalPoint++;\n                if (foundCriticalPoint > 1 && level % 2 === 0) {\n                    break;\n                }\n            }\n            le--;\n        }\n\n        // console.log(\"Last diffs\", y_diffs, \"level\", level);\n\n        // Analyze the groups which have been found.\n        for (i = 0; i < groups.length; i++) {\n            // console.log(\"Group\", i, groups[i])\n            // Identify the maximum difference, i.e. the center of the \"problem\"\n            ma = -Infinity;\n            for (j = 0; j < groups[i].length; j++) {\n                v = Math.abs(groups[i][j].v);\n                if (v > ma) {\n                    ma = v;\n                    pos = j;\n                }\n            }\n            pos = Math.floor(groups[i][pos].i + level / 2);\n            // Analyze the critical point\n            criticalPoints.push(\n                this.getPointType(\n                    curve,\n                    pos,\n                    t_values,\n                    x_values,\n                    y_values,\n                    x_slopes,\n                    y_slopes,\n                    le + 1\n                )\n            );\n        }\n\n        return [criticalPoints, x_table, y_table, x_recip, y_recip];\n    },\n\n    getCenterOfCriticalInterval: function (group, degree, t_values) {\n        var ma,\n            j,\n            pos,\n            v,\n            num = 0.0,\n            den = 0.0,\n            h = t_values[1] - t_values[0],\n            pos_mean,\n            range = [];\n\n        // Identify the maximum difference, i.e. the center of the \"problem\"\n        // If there are several equal maxima, store the positions\n        // in the array range and determine the center of the array.\n\n        ma = -Infinity;\n        range = [];\n        for (j = 0; j < group.length; j++) {\n            v = Math.abs(group[j].v);\n            if (v > ma) {\n                range = [j];\n                ma = v;\n                pos = j;\n            } else if (ma === v) {\n                range.push(j);\n            }\n        }\n        if (range.length > 0) {\n            pos_mean =\n                range.reduce(function (total, val) {\n                    return total + val;\n                }, 0) / range.length;\n            pos = Math.floor(pos_mean);\n            pos_mean += group[0].i;\n        }\n\n        if (ma < Infinity) {\n            for (j = 0; j < group.length; j++) {\n                num += Math.abs(group[j].v) * group[j].i;\n                den += Math.abs(group[j].v);\n            }\n            pos_mean = num / den;\n        }\n        pos_mean += degree / 2;\n        return [\n            group[pos].i + degree / 2,\n            pos_mean,\n            t_values[Math.floor(pos_mean)] + h * (pos_mean - Math.floor(pos_mean))\n        ];\n    },\n\n    differenceMethod: function (component, curve) {\n        var i,\n            level,\n            le,\n            up,\n            t_values = component.t_values,\n            x_values = component.x_values,\n            y_values = component.y_values,\n            x_table = [],\n            y_table = [],\n            foundCriticalPoint = 0,\n            degree_x = -1,\n            degree_y = -1,\n            pos,\n            res,\n            res_x,\n            res_y,\n            t_approx,\n            groups = [],\n            types,\n            criticalPoints = [];\n\n        le = y_values.length;\n        // x_table.push([]);\n        // y_table.push([]);\n        // for (i = 0; i < le; i++) {\n        //     x_table[0][i] = x_values[i];\n        //     y_table[0][i] = y_values[i];\n        // }\n        x_table.push(new Float64Array(x_values));\n        y_table.push(new Float64Array(y_values));\n\n        le--;\n        up = Math.min(12, le);\n        for (level = 0; level < up; level++) {\n            // Old style method:\n            // x_table.push([]);\n            // y_table.push([]);\n            // for (i = 0; i < le; i++) {\n            //     x_table[level + 1][i] = x_table[level][i + 1] - x_table[level][i];\n            //     y_table[level + 1][i] = y_table[level][i + 1] - y_table[level][i];\n            // }\n            // New method:\n            x_table.push(new Float64Array(le));\n            y_table.push(new Float64Array(le));\n            x_table[level + 1] = x_table[level].map(function (v, idx, arr) {\n                return arr[idx + 1] - v;\n            });\n            y_table[level + 1] = y_table[level].map(function (v, idx, arr) {\n                return arr[idx + 1] - v;\n            });\n\n            // Store point location which may be centered around critical points.\n            // If the level is suitable, step out of the loop.\n            res_y = this._criticalInterval(y_table[level + 1], le, level);\n            if (res_y.smooth === true) {\n                // Its seems, the degree of the polynomial is equal to level\n                // If the values in level + 1 are zero, it might be a polynomial of degree level.\n                // Seems to work numerically stable until degree 6.\n                degree_y = level;\n                groups = [];\n            }\n            res_x = this._criticalInterval(x_table[level + 1], le, level);\n            if (degree_x === -1 && res_x.smooth === true) {\n                // Its seems, the degree of the polynomial is equal to level\n                // If the values in level + 1 are zero, it might be a polynomial of degree level.\n                // Seems to work numerically stable until degree 6.\n                degree_x = level;\n            }\n            if (degree_y >= 0) {\n                break;\n            }\n\n            if (res_y.groups.length > 0) {\n                foundCriticalPoint++;\n                if (foundCriticalPoint > 2 && (level + 1) % 2 === 0) {\n                    groups = res_y.groups;\n                    types = res_y.types;\n                    break;\n                }\n            }\n            le--;\n        }\n\n        // console.log(\"Last diffs\", y_table[Math.min(level + 1, up)], \"level\", level + 1);\n        // Analyze the groups which have been found.\n        for (i = 0; i < groups.length; i++) {\n            if (types[i] === \"interval\") {\n                continue;\n            }\n            // console.log(\"Group\", i, groups[i], types[i], level + 1)\n            res = this.getCenterOfCriticalInterval(groups[i], level + 1, t_values);\n            pos = res_y[0];\n            pos = Math.floor(res[1]);\n            t_approx = res[2];\n            // console.log(\"Critical points:\", groups, res, pos)\n\n            // Analyze the type of the critical point\n            // Result is of type 'borderleft', borderright', 'other'\n            criticalPoints.push(\n                this.getPointType(curve, pos, t_approx, t_values, x_table, y_table, le + 1)\n            );\n        }\n\n        // if (level === up) {\n        //     console.log(\"No convergence!\");\n        // } else {\n        //     console.log(\"Convergence level\", level);\n        // }\n        return [criticalPoints, x_table, y_table, degree_x, degree_y];\n    },\n\n    _insertPoint_v4: function (curve, crds, t, doLog) {\n        var p,\n            prev = null,\n            x,\n            y,\n            near = 0.8;\n\n        if (curve.points.length > 0) {\n            prev = curve.points[curve.points.length - 1].scrCoords;\n        }\n\n        // Add regular point\n        p = new Coords(Const.COORDS_BY_USER, crds, curve.board);\n\n        if (prev !== null) {\n            x = p.scrCoords[1] - prev[1];\n            y = p.scrCoords[2] - prev[2];\n            if (x * x + y * y < near * near) {\n                // Math.abs(p.scrCoords[1] - prev[1]) < near &&\n                // Math.abs(p.scrCoords[2] - prev[2]) < near) {\n                return;\n            }\n        }\n\n        p._t = t;\n        curve.points.push(p);\n    },\n\n    getInterval: function (curve, ta, tb) {\n        var t_int, x_int, y_int;\n\n        //console.log('critical point', ta, tb);\n        IntervalArithmetic.disable();\n\n        t_int = IntervalArithmetic.Interval(ta, tb);\n        curve.board.mathLib = IntervalArithmetic;\n        curve.board.mathLibJXG = IntervalArithmetic;\n        x_int = curve.X(t_int, true);\n        y_int = curve.Y(t_int, true);\n        curve.board.mathLib = Math;\n        curve.board.mathLibJXG = JXG.Math;\n\n        //console.log(x_int, y_int);\n        return y_int;\n    },\n\n    sign: function (v) {\n        if (v < 0) {\n            return -1;\n        }\n        if (v > 0) {\n            return 1;\n        }\n        return 0;\n    },\n\n    handleBorder: function (curve, comp, group, x_table, y_table) {\n        var idx = group.idx,\n            t,\n            t1,\n            t2,\n            size = 32,\n            y_int,\n            x,\n            y,\n            lo,\n            hi,\n            i,\n            components2,\n            le,\n            h;\n\n        // console.log(\"HandleBorder at t =\", t_approx);\n        // console.log(\"component:\", comp)\n        // console.log(\"Group:\", group);\n\n        h = comp.t_values[1] - comp.t_values[0];\n        if (group.type === \"borderleft\") {\n            t = comp.left_isNaN ? comp.left_t : group.t - h;\n            t1 = t;\n            t2 = t1 + h;\n        } else if (group.type === \"borderright\") {\n            t = comp.right_isNaN ? comp.right_t : group.t + h;\n            t2 = t;\n            t1 = t2 - h;\n        } else {\n            console.log(\"No bordercase!!!\");\n        }\n\n        components2 = this.findComponents(curve, t1, t2, size);\n        if (components2.length === 0) {\n            return;\n        }\n        if (group.type === \"borderleft\") {\n            t1 = components2[0].left_t;\n            t2 = components2[0].t_values[0];\n            h = components2[0].t_values[1] - components2[0].t_values[0];\n            t1 = t1 === null ? t2 - h : t1;\n            t = t1;\n            y_int = this.getInterval(curve, t1, t2);\n            if (Type.isObject(y_int)) {\n                lo = y_int.lo;\n                hi = y_int.hi;\n\n                x = curve.X(t, true);\n                y = y_table[1][idx] < 0 ? hi : lo;\n                this._insertPoint_v4(curve, [1, x, y], t);\n            }\n        }\n\n        le = components2[0].t_values.length;\n        for (i = 0; i < le; i++) {\n            t = components2[0].t_values[i];\n            x = components2[0].x_values[i];\n            y = components2[0].y_values[i];\n            this._insertPoint_v4(curve, [1, x, y], t);\n        }\n\n        if (group.type === \"borderright\") {\n            t1 = components2[0].t_values[le - 1];\n            t2 = components2[0].right_t;\n            h = components2[0].t_values[1] - components2[0].t_values[0];\n            t2 = t2 === null ? t1 + h : t2;\n\n            t = t2;\n            y_int = this.getInterval(curve, t1, t2);\n            if (Type.isObject(y_int)) {\n                lo = y_int.lo;\n                hi = y_int.hi;\n                x = curve.X(t, true);\n                y = y_table[1][idx] > 0 ? hi : lo;\n                this._insertPoint_v4(curve, [1, x, y], t);\n            }\n        }\n    },\n\n    _seconditeration_v4: function (curve, comp, group, x_table, y_table) {\n        var i, t1, t2, ret, components2, comp2, idx, groups2, g, x_table2, y_table2, start, le;\n\n        // Look at two points, hopefully left and right from the critical point\n        t1 = comp.t_values[group.idx - 2];\n        t2 = comp.t_values[group.idx + 2];\n        components2 = this.findComponents(curve, t1, t2, 64);\n        for (idx = 0; idx < components2.length; idx++) {\n            comp2 = components2[idx];\n            ret = this.differenceMethod(comp2, curve);\n            groups2 = ret[0];\n            x_table2 = ret[1];\n            y_table2 = ret[2];\n            start = 0;\n            for (g = 0; g <= groups2.length; g++) {\n                if (g === groups2.length) {\n                    le = comp2.len;\n                } else {\n                    le = groups2[g].idx;\n                }\n\n                // Insert all uncritical points until next critical point\n                for (i = start; i < le; i++) {\n                    if (!isNaN(comp2.x_values[i]) && !isNaN(comp2.y_values[i])) {\n                        this._insertPoint_v4(\n                            curve,\n                            [1, comp2.x_values[i], comp2.y_values[i]],\n                            comp2.t_values[i]\n                        );\n                    }\n                }\n                // Handle next critical point\n                if (g < groups2.length) {\n                    this.handleSingularity(curve, comp2, groups2[g], x_table2, y_table2);\n                    start = groups2[g].idx + 1;\n                }\n            }\n            le = comp2.len;\n            if (idx < components2.length - 1) {\n                this._insertPoint_v4(curve, [1, NaN, NaN], comp2.right_t);\n            }\n        }\n        return this;\n    },\n\n    _recurse_v4: function (curve, t1, t2, x1, y1, x2, y2, level) {\n        var tol = 2,\n            t = (t1 + t2) * 0.5,\n            x = curve.X(t, true),\n            y = curve.Y(t, true),\n            dx,\n            dy;\n\n        //console.log(\"Level\", level)\n        if (level === 0) {\n            this._insertPoint_v4(curve, [1, NaN, NaN], t);\n            return;\n        }\n        // console.log(\"R\", t1, t2)\n        dx = (x - x1) * curve.board.unitX;\n        dy = (y - y1) * curve.board.unitY;\n        // console.log(\"D1\", Math.sqrt(dx * dx + dy * dy))\n        if (Math.sqrt(dx * dx + dy * dy) > tol) {\n            this._recurse_v4(curve, t1, t, x1, y1, x, y, level - 1);\n        } else {\n            this._insertPoint_v4(curve, [1, x, y], t);\n        }\n        dx = (x - x2) * curve.board.unitX;\n        dy = (y - y2) * curve.board.unitY;\n        // console.log(\"D2\", Math.sqrt(dx * dx + dy * dy), x-x2, y-y2)\n        if (Math.sqrt(dx * dx + dy * dy) > tol) {\n            this._recurse_v4(curve, t, t2, x, y, x2, y2, level - 1);\n        } else {\n            this._insertPoint_v4(curve, [1, x, y], t);\n        }\n    },\n\n    handleSingularity: function (curve, comp, group, x_table, y_table) {\n        var idx = group.idx,\n            t,\n            t1,\n            t2,\n            y_int,\n            i1,\n            i2,\n            x,\n            y,\n            lo,\n            hi,\n            d_lft,\n            d_rgt,\n            d_thresh = 100,\n            di1 = 5,\n            di2 = 3,\n            d1,\n            d2;\n\n        t = group.t;\n        console.log(\"HandleSingularity at t =\", t);\n        // console.log(comp.t_values[idx - 1], comp.y_values[idx - 1], comp.t_values[idx + 1], comp.y_values[idx + 1]);\n        // console.log(group);\n\n        // Look at two points, hopefully left and right from the critical point\n        t1 = comp.t_values[idx - di1];\n        t2 = comp.t_values[idx + di1];\n\n        y_int = this.getInterval(curve, t1, t2);\n        if (Type.isObject(y_int)) {\n            lo = y_int.lo;\n            hi = y_int.hi;\n        } else {\n            if (y_table[0][idx - 1] < y_table[0][idx + 1]) {\n                lo = y_table[0][idx - 1];\n                hi = y_table[0][idx + 1];\n            } else {\n                lo = y_table[0][idx + 1];\n                hi = y_table[0][idx - 1];\n            }\n        }\n\n        x = curve.X(t, true);\n\n        d_lft =\n            (y_table[0][idx - di2] - y_table[0][idx - di1]) /\n            (comp.t_values[idx - di2] - comp.t_values[idx - di1]);\n        d_rgt =\n            (y_table[0][idx + di2] - y_table[0][idx + di1]) /\n            (comp.t_values[idx + di2] - comp.t_values[idx + di1]);\n\n        console.log(\":::\", d_lft, d_rgt);\n\n        //this._insertPoint_v4(curve, [1, NaN, NaN], 0);\n\n        if (d_lft < -d_thresh) {\n            // Left branch very steep downwards -> add the minimum\n            this._insertPoint_v4(curve, [1, x, lo], t, true);\n            if (d_rgt <= d_thresh) {\n                // Right branch not very steep upwards -> interrupt the curve\n                // I.e. it looks like -infty / (finite or infty) and not like -infty / -infty\n                this._insertPoint_v4(curve, [1, NaN, NaN], t);\n            }\n        } else if (d_lft > d_thresh) {\n            // Left branch very steep upwards -> add the maximum\n            this._insertPoint_v4(curve, [1, x, hi], t);\n            if (d_rgt >= -d_thresh) {\n                // Right branch not very steep downwards -> interrupt the curve\n                // I.e. it looks like infty / (finite or -infty) and not like infty / infty\n                this._insertPoint_v4(curve, [1, NaN, NaN], t);\n            }\n        } else {\n            if (lo === -Infinity) {\n                this._insertPoint_v4(curve, [1, x, lo], t, true);\n                this._insertPoint_v4(curve, [1, NaN, NaN], t);\n            }\n            if (hi === Infinity) {\n                this._insertPoint_v4(curve, [1, NaN, NaN], t);\n                this._insertPoint_v4(curve, [1, x, hi], t, true);\n            }\n\n            if (group.t < comp.t_values[idx]) {\n                i1 = idx - 1;\n                i2 = idx;\n            } else {\n                i1 = idx;\n                i2 = idx + 1;\n            }\n            t1 = comp.t_values[i1];\n            t2 = comp.t_values[i2];\n            this._recurse_v4(\n                curve,\n                t1,\n                t2,\n                x_table[0][i1],\n                y_table[0][i1],\n                x_table[0][i2],\n                y_table[0][i2],\n                10\n            );\n\n            // x = (x_table[0][idx] - x_table[0][idx - 1]) * curve.board.unitX;\n            // y = (y_table[0][idx] - y_table[0][idx - 1]) * curve.board.unitY;\n            // d1 = Math.sqrt(x * x + y * y);\n            // x = (x_table[0][idx + 1] - x_table[0][idx]) * curve.board.unitX;\n            // y = (y_table[0][idx + 1] - y_table[0][idx]) * curve.board.unitY;\n            // d2 = Math.sqrt(x * x + y * y);\n\n            // console.log(\"end\", t1, t2, t);\n            // if (true || (d1 > 2 || d2 > 2)) {\n\n            // console.log(d1, d2, y_table[0][idx])\n            //                     // Finite jump\n            //                     this._insertPoint_v4(curve, [1, NaN, NaN], t);\n            //                 } else {\n            //                     if (lo !== -Infinity && hi !== Infinity) {\n            //                         // Critical point which can be ignored\n            //                         this._insertPoint_v4(curve, [1, x_table[0][idx], y_table[0][idx]], comp.t_values[idx]);\n            //                     } else {\n            //                         if (lo === -Infinity) {\n            //                             this._insertPoint_v4(curve, [1, x, lo], t, true);\n            //                             this._insertPoint_v4(curve, [1, NaN, NaN], t);\n            //                         }\n            //                         if (hi === Infinity) {\n            //                             this._insertPoint_v4(curve, [1, NaN, NaN], t);\n            //                             this._insertPoint_v4(curve, [1, x, hi], t, true);\n            //                         }\n            //                     }\n            // }\n        }\n        if (d_rgt < -d_thresh) {\n            // Right branch very steep downwards -> add the maximum\n            this._insertPoint_v4(curve, [1, x, hi], t);\n        } else if (d_rgt > d_thresh) {\n            // Right branch very steep upwards -> add the minimum\n            this._insertPoint_v4(curve, [1, x, lo], t);\n        }\n    },\n\n    /**\n     * Number of equidistant points where the function is evaluated\n     */\n    steps: 1021, //2053, // 1021,\n\n    /**\n     * If the absolute maximum of the set of differences is larger than\n     * criticalThreshold * median of these values, it is regarded as critical point.\n     * @see JXG.Math.Plot#_criticalInterval\n     */\n    criticalThreshold: 1000,\n\n    plot_v4: function (curve, ta, tb, steps) {\n        var i,\n            j,\n            le,\n            components,\n            idx,\n            comp,\n            groups,\n            g,\n            start,\n            ret,\n            x_table,\n            y_table,\n            t,\n            t1,\n            t2,\n            good,\n            bad,\n            x_int,\n            y_int,\n            degree_x,\n            degree_y,\n            h = (tb - ta) / steps,\n            Ypl = function (x) {\n                return curve.Y(x, true);\n            },\n            Ymi = function (x) {\n                return -curve.Y(x, true);\n            },\n            h2 = h * 0.5;\n\n        components = this.findComponents(curve, ta, tb, steps);\n        for (idx = 0; idx < components.length; idx++) {\n            comp = components[idx];\n            ret = this.differenceMethod(comp, curve);\n            groups = ret[0];\n            x_table = ret[1];\n            y_table = ret[2];\n            degree_x = ret[3];\n            degree_y = ret[4];\n\n            // if (degree_x >= 0) {\n            //     console.log(\"x polynomial of degree\", degree_x);\n            // }\n            // if (degree_y >= 0) {\n            //     console.log(\"y polynomial of degree\", degree_y);\n            // }\n            if (groups.length === 0 || groups[0].type !== \"borderleft\") {\n                groups.unshift({\n                    idx: 0,\n                    t: comp.t_values[0],\n                    x: comp.x_values[0],\n                    y: comp.y_values[0],\n                    type: \"borderleft\"\n                });\n            }\n            if (groups[groups.length - 1].type !== \"borderright\") {\n                le = comp.t_values.length;\n                groups.push({\n                    idx: le - 1,\n                    t: comp.t_values[le - 1],\n                    x: comp.x_values[le - 1],\n                    y: comp.y_values[le - 1],\n                    type: \"borderright\"\n                });\n            }\n\n            start = 0;\n            for (g = 0; g <= groups.length; g++) {\n                if (g === groups.length) {\n                    le = comp.len;\n                } else {\n                    le = groups[g].idx - 1;\n                }\n\n                good = 0;\n                bad = 0;\n                // Insert all uncritical points until next critical point\n                for (i = start; i < le - 2; i++) {\n                    this._insertPoint_v4(\n                        curve,\n                        [1, comp.x_values[i], comp.y_values[i]],\n                        comp.t_values[i]\n                    );\n                    j = Math.max(0, i - 2);\n                    // Add more points in critical intervals\n                    if (\n                        true &&\n                        //degree_y === -1 && // No polynomial\n                        i >= start + 3 &&\n                        i < le - 3 && // Do not do this if too close to a critical point\n                        y_table.length > 3 &&\n                        Math.abs(y_table[2][i]) > 0.2 * Math.abs(y_table[0][i])\n                    ) {\n                        t = comp.t_values[i];\n                        h2 = h * 0.25;\n                        y_int = this.getInterval(curve, t, t + h);\n                        if (Type.isObject(y_int)) {\n                            if (y_table[2][i] > 0) {\n                                this._insertPoint_v4(curve, [1, t + h2, y_int.lo], t + h2);\n                            } else {\n                                this._insertPoint_v4(\n                                    curve,\n                                    [1, t + h - h2, y_int.hi],\n                                    t + h - h2\n                                );\n                            }\n                        } else {\n                            t1 = Numerics.fminbr(Ypl, [t, t + h]);\n                            t2 = Numerics.fminbr(Ymi, [t, t + h]);\n                            if (t1 < t2) {\n                                this._insertPoint_v4(\n                                    curve,\n                                    [1, curve.X(t1, true), curve.Y(t1, true)],\n                                    t1\n                                );\n                                this._insertPoint_v4(\n                                    curve,\n                                    [1, curve.X(t2, true), curve.Y(t2, true)],\n                                    t2\n                                );\n                            } else {\n                                this._insertPoint_v4(\n                                    curve,\n                                    [1, curve.X(t2, true), curve.Y(t2, true)],\n                                    t2\n                                );\n                                this._insertPoint_v4(\n                                    curve,\n                                    [1, curve.X(t1, true), curve.Y(t1, true)],\n                                    t1\n                                );\n                            }\n                        }\n                        bad++;\n                    } else {\n                        good++;\n                    }\n                }\n                // console.log(\"GOOD\", good, \"BAD\", bad);\n\n                // Handle next critical point\n                if (g < groups.length) {\n                    //console.log(\"critical point / interval\", groups[g]);\n\n                    i = groups[g].idx;\n                    if (groups[g].type === \"borderleft\" || groups[g].type === \"borderright\") {\n                        this.handleBorder(curve, comp, groups[g], x_table, y_table);\n                    } else {\n                        this._seconditeration_v4(curve, comp, groups[g], x_table, y_table);\n                    }\n\n                    start = groups[g].idx + 1 + 1;\n                }\n            }\n\n            le = comp.len;\n            if (idx < components.length - 1) {\n                this._insertPoint_v4(curve, [1, NaN, NaN], comp.right_t);\n            }\n        }\n    },\n\n    /**\n     * Updates the data points of a parametric curve, plotVersion 4. This version is used if {@link JXG.Curve#plotVersion} is <tt>4</tt>.\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} mi Left bound of curve\n     * @param {Number} ma Right bound of curve\n     * @returns {JXG.Curve} Reference to the curve object.\n     */\n    updateParametricCurve_v4: function (curve, mi, ma) {\n        var ta, tb, w2, bbox;\n\n        if (curve.xterm === \"x\") {\n            // For function graphs we can restrict the plot interval\n            // to the visible area +plus margin\n            bbox = curve.board.getBoundingBox();\n            w2 = (bbox[2] - bbox[0]) * 0.3;\n            // h2 = (bbox[1] - bbox[3]) * 0.3;\n            ta = Math.max(mi, bbox[0] - w2);\n            tb = Math.min(ma, bbox[2] + w2);\n        } else {\n            ta = mi;\n            tb = ma;\n        }\n\n        curve.points = [];\n\n        //console.log(\"--------------------\");\n        this.plot_v4(curve, ta, tb, this.steps);\n\n        curve.numberPoints = curve.points.length;\n        //console.log(curve.numberPoints);\n    },\n\n    //----------------------------------------------------------------------\n    // Plot algorithm alias\n    //----------------------------------------------------------------------\n\n    /**\n     * Updates the data points of a parametric curve, alias for {@link JXG.Curve#updateParametricCurve_v2}.\n     * This is needed for backwards compatibility, if this method has been\n     * used directly in an application.\n     * @param {JXG.Curve} curve JSXGraph curve element\n     * @param {Number} mi Left bound of curve\n     * @param {Number} ma Right bound of curve\n     * @returns {JXG.Curve} Reference to the curve object.\n     *\n     * @see JXG.Curve#updateParametricCurve_v2\n     */\n    updateParametricCurve: function (curve, mi, ma) {\n        return this.updateParametricCurve_v2(curve, mi, ma);\n    }\n};\n\nexport default Mat.Plot;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n\n\n    Metapost/Hobby curves, see e.g. https://bosker.wordpress.com/2013/11/13/beyond-bezier-curves/\n\n    * Ported to Python for the project PyX. Copyright (C) 2011 Michael Schindler <m-schindler@users.sourceforge.net>\n    * Ported to javascript from the PyX implementation (http://pyx.sourceforge.net/) by Vlad-X.\n    * Adapted to JSXGraph and some code changes by Alfred Wassermann 2020.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n    Internal functions of MetaPost\n    This file re-implements some of the functionality of MetaPost\n    (http://tug.org/metapost). MetaPost was developed by John D. Hobby and\n    others. The code of Metapost is in the public domain, which we understand as\n    an implicit permission to reuse the code here (see the comment at\n    http://www.gnu.org/licenses/license-list.html)\n\n    This file is based on the MetaPost version distributed by TeXLive:\n    svn://tug.org/texlive/trunk/Build/source/texk/web2c/mplibdir revision 22737 #\n    (2011-05-31)\n*/\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the namespace Math.Metapost is defined which holds algorithms translated from Metapost\n * by D.E. Knuth and J.D. Hobby.\n */\n\nimport Type from \"../utils/type\";\nimport Mat from \"./math\";\n\n/**\n * The JXG.Math.Metapost namespace holds algorithms translated from Metapost\n * by D.E. Knuth and J.D. Hobby.\n *\n * @name JXG.Math.Metapost\n * @exports Mat.Metapost as JXG.Math.Metapost\n * @namespace\n */\nMat.Metapost = {\n    MP_ENDPOINT: 0,\n    MP_EXPLICIT: 1,\n    MP_GIVEN: 2,\n    MP_CURL: 3,\n    MP_OPEN: 4,\n    MP_END_CYCLE: 5,\n\n    UNITY: 1.0,\n    // two: 2,\n    // fraction_half: 0.5,\n    FRACTION_ONE: 1.0,\n    FRACTION_THREE: 3.0,\n    ONE_EIGHTY_DEG: Math.PI,\n    THREE_SIXTY_DEG: 2 * Math.PI,\n    // EPSILON: 1e-5,\n    EPS_SQ: 1e-5 * 1e-5,\n\n    /**\n     * @private\n     */\n    make_choices: function (knots) {\n        var dely, h, k, delx, n, q, p, s, cosine, t, sine, delta_x, delta_y, delta, psi,\n            endless = true;\n\n        p = knots[0];\n        do {\n            if (!p) {\n                break;\n            }\n            q = p.next;\n\n            // Join two identical knots by setting the control points to the same\n            // coordinates.\n            // MP 291\n            if (\n                p.rtype > this.MP_EXPLICIT &&\n                (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y) < this.EPS_SQ\n            ) {\n                p.rtype = this.MP_EXPLICIT;\n                if (p.ltype === this.MP_OPEN) {\n                    p.ltype = this.MP_CURL;\n                    p.set_left_curl(this.UNITY);\n                }\n\n                q.ltype = this.MP_EXPLICIT;\n                if (q.rtype === this.MP_OPEN) {\n                    q.rtype = this.MP_CURL;\n                    q.set_right_curl(this.UNITY);\n                }\n\n                p.rx = p.x;\n                q.lx = p.x;\n                p.ry = p.y;\n                q.ly = p.y;\n            }\n            p = q;\n        } while (p !== knots[0]);\n\n        // Find the first breakpoint, h, on the path\n        // MP 292\n        h = knots[0];\n        while (endless) {\n            if (h.ltype !== this.MP_OPEN || h.rtype !== this.MP_OPEN) {\n                break;\n            }\n            h = h.next;\n            if (h === knots[0]) {\n                h.ltype = this.MP_END_CYCLE;\n                break;\n            }\n        }\n\n        p = h;\n        while (endless) {\n            if (!p) {\n                break;\n            }\n\n            // Fill in the control points between p and the next breakpoint,\n            // then advance p to that breakpoint\n            // MP 299\n            q = p.next;\n            if (p.rtype >= this.MP_GIVEN) {\n                while (q.ltype === this.MP_OPEN && q.rtype === this.MP_OPEN) {\n                    q = q.next;\n                }\n\n                // Calculate the turning angles psi_ k and the distances d_{k,k+1};\n                // set n to the length of the path\n                // MP 302\n                k = 0;\n                s = p;\n                n = knots.length;\n\n                delta_x = [];\n                delta_y = [];\n                delta = [];\n                psi = [null];\n\n                // tuple([]) = tuple([[], [], [], [null]]);\n                while (endless) {\n                    t = s.next;\n                    // None;\n                    delta_x.push(t.x - s.x);\n                    delta_y.push(t.y - s.y);\n                    delta.push(this.mp_pyth_add(delta_x[k], delta_y[k]));\n                    if (k > 0) {\n                        sine = delta_y[k - 1] / delta[k - 1];\n                        cosine = delta_x[k - 1] / delta[k - 1];\n                        psi.push(\n                            Math.atan2(\n                                delta_y[k] * cosine - delta_x[k] * sine,\n                                delta_x[k] * cosine + delta_y[k] * sine\n                            )\n                        );\n                    }\n                    k++;\n                    s = t;\n                    if (s === q) {\n                        n = k;\n                    }\n                    if (k >= n && s.ltype !== this.MP_END_CYCLE) {\n                        break;\n                    }\n                }\n                if (k === n) {\n                    psi.push(0);\n                } else {\n                    psi.push(psi[1]);\n                }\n\n                // Remove open types at the breakpoints\n                // MP 303\n                if (q.ltype === this.MP_OPEN) {\n                    delx = q.rx - q.x;\n                    dely = q.ry - q.y;\n                    if (delx * delx + dely * dely < this.EPS_SQ) {\n                        q.ltype = this.MP_CURL;\n                        q.set_left_curl(this.UNITY);\n                    } else {\n                        q.ltype = this.MP_GIVEN;\n                        q.set_left_given(Math.atan2(dely, delx));\n                    }\n                }\n                if (p.rtype === this.MP_OPEN && p.ltype === this.MP_EXPLICIT) {\n                    delx = p.x - p.lx;\n                    dely = p.y - p.ly;\n                    if (delx * delx + dely * dely < this.EPS_SQ) {\n                        p.rtype = this.MP_CURL;\n                        p.set_right_curl(this.UNITY);\n                    } else {\n                        p.rtype = this.MP_GIVEN;\n                        p.set_right_given(Math.atan2(dely, delx));\n                    }\n                }\n                this.mp_solve_choices(p, q, n, delta_x, delta_y, delta, psi);\n            } else if (p.rtype === this.MP_ENDPOINT) {\n                // MP 294\n                p.rx = p.x;\n                p.ry = p.y;\n                q.lx = q.x;\n                q.ly = q.y;\n            }\n            p = q;\n\n            if (p === h) {\n                break;\n            }\n        }\n    },\n\n    /**\n     * Implements solve_choices form metapost\n     * MP 305\n     * @private\n     */\n    mp_solve_choices: function (p, q, n, delta_x, delta_y, delta, psi) {\n        var aa, acc, vv, bb, ldelta, ee, k,\n            s, ww, uu, lt, r, t, ff,\n            theta, rt, dd, cc, ct_st,\n            ct, st, cf_sf, cf, sf, i, k_idx,\n            endless = true;\n\n        ldelta = delta.length + 1;\n        uu = new Array(ldelta);\n        ww = new Array(ldelta);\n        vv = new Array(ldelta);\n        theta = new Array(ldelta);\n        for (i = 0; i < ldelta; i++) {\n            theta[i] = vv[i] = ww[i] = uu[i] = 0;\n        }\n        k = 0;\n        s = p;\n        r = 0;\n        while (endless) {\n            t = s.next;\n            if (k === 0) {\n                // MP 306\n                if (s.rtype === this.MP_GIVEN) {\n                    // MP 314\n                    if (t.ltype === this.MP_GIVEN) {\n                        aa = Math.atan2(delta_y[0], delta_x[0]);\n                        ct_st = this.mp_n_sin_cos(p.right_given() - aa);\n                        ct = ct_st[0];\n                        st = ct_st[1];\n                        cf_sf = this.mp_n_sin_cos(q.left_given() - aa);\n                        cf = cf_sf[0];\n                        sf = cf_sf[1];\n                        this.mp_set_controls(p, q, delta_x[0], delta_y[0], st, ct, -sf, cf);\n                        return;\n                    }\n                    vv[0] = s.right_given() - Math.atan2(delta_y[0], delta_x[0]);\n                    vv[0] = this.reduce_angle(vv[0]);\n                    uu[0] = 0;\n                    ww[0] = 0;\n                } else if (s.rtype === this.MP_CURL) {\n                    // MP 315\n                    if (t.ltype === this.MP_CURL) {\n                        p.rtype = this.MP_EXPLICIT;\n                        q.ltype = this.MP_EXPLICIT;\n                        lt = Math.abs(q.left_tension());\n                        rt = Math.abs(p.right_tension());\n                        ff = this.UNITY / (3.0 * rt);\n                        p.rx = p.x + delta_x[0] * ff;\n                        p.ry = p.y + delta_y[0] * ff;\n                        ff = this.UNITY / (3.0 * lt);\n                        q.lx = q.x - delta_x[0] * ff;\n                        q.ly = q.y - delta_y[0] * ff;\n                        return;\n                    }\n                    cc = s.right_curl();\n                    lt = Math.abs(t.left_tension());\n                    rt = Math.abs(s.right_tension());\n                    uu[0] = this.mp_curl_ratio(cc, rt, lt);\n                    vv[0] = -psi[1] * uu[0];\n                    ww[0] = 0;\n                } else {\n                    if (s.rtype === this.MP_OPEN) {\n                        uu[0] = 0;\n                        vv[0] = 0;\n                        ww[0] = this.FRACTION_ONE;\n                    }\n                }\n            } else {\n                if (s.ltype === this.MP_END_CYCLE || s.ltype === this.MP_OPEN) {\n                    // MP 308\n                    aa = this.UNITY / (3.0 * Math.abs(r.right_tension()) - this.UNITY);\n                    dd =\n                        delta[k] *\n                        (this.FRACTION_THREE - this.UNITY / Math.abs(r.right_tension()));\n                    bb = this.UNITY / (3 * Math.abs(t.left_tension()) - this.UNITY);\n                    ee =\n                        delta[k - 1] *\n                        (this.FRACTION_THREE - this.UNITY / Math.abs(t.left_tension()));\n                    cc = this.FRACTION_ONE - uu[k - 1] * aa;\n                    dd = dd * cc;\n                    lt = Math.abs(s.left_tension());\n                    rt = Math.abs(s.right_tension());\n                    if (lt < rt) {\n                        dd *= Math.pow(lt / rt, 2);\n                    } else {\n                        if (lt > rt) {\n                            ee *= Math.pow(rt / lt, 2);\n                        }\n                    }\n                    ff = ee / (ee + dd);\n                    uu[k] = ff * bb;\n                    acc = -psi[k + 1] * uu[k];\n                    if (r.rtype === this.MP_CURL) {\n                        ww[k] = 0;\n                        vv[k] = acc - psi[1] * (this.FRACTION_ONE - ff);\n                    } else {\n                        ff = (this.FRACTION_ONE - ff) / cc;\n                        acc = acc - psi[k] * ff;\n                        ff = ff * aa;\n                        vv[k] = acc - vv[k - 1] * ff;\n                        ww[k] = -ww[k - 1] * ff;\n                    }\n                    if (s.ltype === this.MP_END_CYCLE) {\n                        aa = 0;\n                        bb = this.FRACTION_ONE;\n                        while (endless) {\n                            k -= 1;\n                            if (k === 0) {\n                                k = n;\n                            }\n                            aa = vv[k] - aa * uu[k];\n                            bb = ww[k] - bb * uu[k];\n                            if (k === n) {\n                                break;\n                            }\n                        }\n                        aa = aa / (this.FRACTION_ONE - bb);\n                        theta[n] = aa;\n                        vv[0] = aa;\n                        // k_val = range(1, n);\n                        // for (k_idx in k_val) {\n                        // k = k_val[k_idx];\n                        for (k_idx = 1; k_idx < n; k_idx++) {\n                            vv[k_idx] = vv[k_idx] + aa * ww[k_idx];\n                        }\n                        break;\n                    }\n                } else {\n                    if (s.ltype === this.MP_CURL) {\n                        cc = s.left_curl();\n                        lt = Math.abs(s.left_tension());\n                        rt = Math.abs(r.right_tension());\n                        ff = this.mp_curl_ratio(cc, lt, rt);\n                        theta[n] = -(vv[n - 1] * ff) / (this.FRACTION_ONE - ff * uu[n - 1]);\n                        break;\n                    }\n                    if (s.ltype === this.MP_GIVEN) {\n                        theta[n] = s.left_given() - Math.atan2(delta_y[n - 1], delta_x[n - 1]);\n                        theta[n] = this.reduce_angle(theta[n]);\n                        break;\n                    }\n                }\n            }\n            r = s;\n            s = t;\n            k += 1;\n        }\n\n        // MP 318\n        for (k = n - 1; k > -1; k--) {\n            theta[k] = vv[k] - theta[k + 1] * uu[k];\n        }\n\n        s = p;\n        k = 0;\n        while (endless) {\n            t = s.next;\n            ct_st = this.mp_n_sin_cos(theta[k]);\n            ct = ct_st[0];\n            st = ct_st[1];\n            cf_sf = this.mp_n_sin_cos(-psi[k + 1] - theta[k + 1]);\n            cf = cf_sf[0];\n            sf = cf_sf[1];\n            this.mp_set_controls(s, t, delta_x[k], delta_y[k], st, ct, sf, cf);\n            k++;\n            s = t;\n            if (k === n) {\n                break;\n            }\n        }\n    },\n\n    /**\n     * @private\n     */\n    mp_n_sin_cos: function (z) {\n        return [Math.cos(z), Math.sin(z)];\n    },\n\n    /**\n     * @private\n     */\n    mp_set_controls: function (p, q, delta_x, delta_y, st, ct, sf, cf) {\n        var rt, ss, lt, sine, rr;\n        lt = Math.abs(q.left_tension());\n        rt = Math.abs(p.right_tension());\n        rr = this.mp_velocity(st, ct, sf, cf, rt);\n        ss = this.mp_velocity(sf, cf, st, ct, lt);\n\n        // console.log('lt rt rr ss', lt, rt, rr, ss);\n        if (p.right_tension() < 0 || q.left_tension() < 0) {\n            if ((st >= 0 && sf >= 0) || (st <= 0 && sf <= 0)) {\n                sine = Math.abs(st) * cf + Math.abs(sf) * ct;\n                if (sine > 0) {\n                    sine *= 1.00024414062;\n                    if (p.right_tension() < 0) {\n                        if (this.mp_ab_vs_cd(Math.abs(sf), this.FRACTION_ONE, rr, sine) < 0) {\n                            rr = Math.abs(sf) / sine;\n                        }\n                    }\n                    if (q.left_tension() < 0) {\n                        if (this.mp_ab_vs_cd(Math.abs(st), this.FRACTION_ONE, ss, sine) < 0) {\n                            ss = Math.abs(st) / sine;\n                        }\n                    }\n                }\n            }\n        }\n        p.rx = p.x + (delta_x * ct - delta_y * st) * rr;\n        p.ry = p.y + (delta_y * ct + delta_x * st) * rr;\n        q.lx = q.x - (delta_x * cf + delta_y * sf) * ss;\n        q.ly = q.y - (delta_y * cf - delta_x * sf) * ss;\n        p.rtype = this.MP_EXPLICIT;\n        q.ltype = this.MP_EXPLICIT;\n    },\n\n    /**\n     * @private\n     */\n    mp_pyth_add: function (a, b) {\n        return Math.sqrt(a * a + b * b);\n    },\n\n    /**\n     *\n     * @private\n     */\n    mp_curl_ratio: function (gamma, a_tension, b_tension) {\n        var alpha = 1.0 / a_tension,\n            beta = 1.0 / b_tension;\n\n        return Math.min(\n            4.0,\n            ((3.0 - alpha) * alpha * alpha * gamma + beta * beta * beta) /\n                (alpha * alpha * alpha * gamma + (3.0 - beta) * beta * beta)\n        );\n    },\n\n    /**\n     * @private\n     */\n    mp_ab_vs_cd: function (a, b, c, d) {\n        if (a * b === c * d) {\n            return 0;\n        }\n        if (a * b > c * d) {\n            return 1;\n        }\n        return -1;\n    },\n\n    /**\n     * @private\n     */\n    mp_velocity: function (st, ct, sf, cf, t) {\n        return Math.min(\n            4.0,\n            (2.0 + Math.sqrt(2) * (st - sf / 16.0) * (sf - st / 16.0) * (ct - cf)) /\n                (1.5 * t * (2 + (Math.sqrt(5) - 1) * ct + (3 - Math.sqrt(5)) * cf))\n        );\n    },\n\n    /**\n     * @private\n     * @param {Number} A\n     */\n    reduce_angle: function (A) {\n        if (Math.abs(A) > this.ONE_EIGHTY_DEG) {\n            if (A > 0) {\n                A -= this.THREE_SIXTY_DEG;\n            } else {\n                A += this.THREE_SIXTY_DEG;\n            }\n        }\n        return A;\n    },\n\n    /**\n     *\n     * @private\n     * @param {Array} p\n     * @param {Number} tension\n     * @param {Boolean} cycle\n     */\n    makeknots: function (p, tension, cycle) {\n        var i,\n            len,\n            knots = [];\n\n        tension = tension || 1;\n\n        len = p.length;\n        for (i = 0; i < len; i++) {\n            knots.push({\n                x: p[i][0],\n                y: p[i][1],\n                ltype: this.MP_OPEN,\n                rtype: this.MP_OPEN,\n                ly: tension,\n                ry: tension,\n                lx: tension,\n                rx: tension,\n                left_curl: function () {\n                    return this.lx || 0;\n                },\n                right_curl: function () {\n                    return this.rx || 0;\n                },\n                left_tension: function () {\n                    if (!this.ly) {\n                        this.ly = 1;\n                    }\n                    return this.ly;\n                },\n                right_tension: function () {\n                    if (!this.ry) {\n                        this.ry = 1;\n                    }\n                    return this.ry;\n                },\n                set_right_curl: function (x) {\n                    this.rx = x || 0;\n                },\n                set_left_curl: function (x) {\n                    this.lx = x || 0;\n                }\n            });\n        }\n        len = knots.length;\n        for (i = 0; i < len; i++) {\n            knots[i].next = knots[i + 1] || knots[i];\n            knots[i].set_right_given = knots[i].set_right_curl;\n            knots[i].set_left_given = knots[i].set_left_curl;\n            knots[i].right_given = knots[i].right_curl;\n            knots[i].left_given = knots[i].left_curl;\n        }\n        knots[len - 1].next = knots[0];\n\n        if (!cycle) {\n            knots[len - 1].rtype = this.MP_ENDPOINT;\n\n            knots[len - 1].ltype = this.MP_CURL;\n            knots[0].rtype = this.MP_CURL;\n        }\n\n        return knots;\n    },\n\n    /**\n     *\n     * @param {Array} point_list\n     * @param {Object} controls\n     *\n     * @returns {Array}\n     */\n    curve: function (point_list, controls) {\n        var knots,\n            len,\n            i,\n            val,\n            x = [],\n            y = [];\n\n        controls = controls || {\n            tension: 1,\n            direction: {},\n            curl: {},\n            isClosed: false\n        };\n\n        knots = this.makeknots(point_list, Type.evaluate(controls.tension), controls.isClosed);\n\n        len = knots.length;\n        for (i in controls.direction) {\n            if (controls.direction.hasOwnProperty(i)) {\n                val = Type.evaluate(controls.direction[i]);\n                if (Type.isArray(val)) {\n                    if (val[0] !== false) {\n                        knots[i].lx = (val[0] * Math.PI) / 180;\n                        knots[i].ltype = this.MP_GIVEN;\n                    }\n                    if (val[1] !== false) {\n                        knots[i].rx = (val[1] * Math.PI) / 180;\n                        knots[i].rtype = this.MP_GIVEN;\n                    }\n                } else {\n                    knots[i].lx = (val * Math.PI) / 180;\n                    knots[i].rx = (val * Math.PI) / 180;\n                    knots[i].ltype = knots[i].rtype = this.MP_GIVEN;\n                }\n            }\n        }\n        for (i in controls.curl) {\n            if (controls.curl.hasOwnProperty(i)) {\n                val = Type.evaluate(controls.curl[i]);\n                if (parseInt(i, 10) === 0) {\n                    knots[i].rtype = this.MP_CURL;\n                    knots[i].set_right_curl(val);\n                } else if (parseInt(i, 10) === len - 1) {\n                    knots[i].ltype = this.MP_CURL;\n                    knots[i].set_left_curl(val);\n                }\n            }\n        }\n\n        this.make_choices(knots);\n\n        for (i = 0; i < len - 1; i++) {\n            x.push(knots[i].x);\n            x.push(knots[i].rx);\n            x.push(knots[i + 1].lx);\n            y.push(knots[i].y);\n            y.push(knots[i].ry);\n            y.push(knots[i + 1].ly);\n        }\n        x.push(knots[len - 1].x);\n        y.push(knots[len - 1].y);\n\n        if (controls.isClosed) {\n            x.push(knots[len - 1].rx);\n            y.push(knots[len - 1].ry);\n            x.push(knots[0].lx);\n            y.push(knots[0].ly);\n            x.push(knots[0].x);\n            y.push(knots[0].y);\n        }\n\n        return [x, y];\n    }\n};\n\nexport default Mat.Metapost;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph and JSXCompressor.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n    JSXCompressor is free software dual licensed under the GNU LGPL or Apache License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n      OR\n      * Apache License Version 2.0\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License, Apache\n    License, and the MIT License along with JSXGraph. If not, see\n    <http://www.gnu.org/licenses/>, <https://www.apache.org/licenses/LICENSE-2.0.html>,\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\n/**\n * @fileoverview Utilities for uncompressing and base64 decoding\n */\n\nimport JXG from \"../jxg\";\n\n// Zip routine constants\n\nvar bitReverse = [\n        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0,\n        0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8,\n        0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94,\n        0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,\n        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2,\n        0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca,\n        0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86,\n        0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\n        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe,\n        0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1,\n        0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99,\n        0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,\n        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad,\n        0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3,\n        0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b,\n        0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\n        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7,\n        0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf,\n        0x3f, 0xbf, 0x7f, 0xff\n    ],\n    cplens = [\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99,\n        115, 131, 163, 195, 227, 258, 0, 0\n    ],\n    cplext = [\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n        99, 99\n    ] /* 99==invalid */,\n    cpdist = [\n        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021,\n        0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601,\n        0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001\n    ],\n    cpdext = [\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12,\n        12, 13, 13\n    ],\n    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    NAMEMAX = 256;\n\n// Util namespace\nJXG.Util = JXG.Util || {};\n\n/**\n * @class Unzip class\n * Class for gunzipping, unzipping and base64 decoding of files.\n * It is used for reading GEONExT, Geogebra and Intergeo files.\n *\n * Only Huffman codes are decoded in gunzip.\n * The code is based on the source code for gunzip.c by Pasi Ojala\n * @see http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c\n * @see http://www.cs.tut.fi/~albert\n */\nJXG.Util.Unzip = function (barray) {\n    var gpflags,\n        crc,\n        SIZE,\n        fileout,\n        flens,\n        fmax,\n        outputArr = [],\n        output = \"\",\n        debug = false,\n        files = 0,\n        unzipped = [],\n        buf32k = new Array(32768),\n        bIdx = 0,\n        modeZIP = false,\n        barraylen = barray.length,\n        bytepos = 0,\n        bitpos = 0,\n        bb = 1,\n        bits = 0,\n        literalTree = new Array(288),\n        distanceTree = new Array(32),\n        treepos = 0,\n        Places = null,\n        Places2 = null,\n        impDistanceTree = new Array(64),\n        impLengthTree = new Array(64),\n        len = 0,\n        fpos = new Array(17),\n        nameBuf = [];\n\n    fpos[0] = 0;\n\n    function readByte() {\n        bits += 8;\n\n        if (bytepos < barraylen) {\n            return barray[bytepos++];\n        }\n\n        return -1;\n    }\n\n    function byteAlign() {\n        bb = 1;\n    }\n\n    function readBit() {\n        var carry;\n\n        // Prevent problems on iOS7 with >>\n        try {\n            bits++;\n            carry = bb & 1;\n            bb >>= 1;\n\n            if (bb === 0) {\n                bb = readByte();\n                carry = bb & 1;\n                bb = (bb >> 1) | 0x80;\n            }\n        } catch (e) {\n            console.log(\"Probably problems on iOS7 with >>\");\n            throw e;\n        }\n\n        return carry;\n    }\n\n    function readBits(a) {\n        var res = 0,\n            i = a;\n\n        // Prevent problems on iOS7 with >>\n        try {\n            while (i--) {\n                res = (res << 1) | readBit();\n            }\n\n            if (a) {\n                res = bitReverse[res] >> (8 - a);\n            }\n        } catch (e) {\n            console.log(\"Probably problems on iOS7 with >>\");\n            throw e;\n        }\n        return res;\n    }\n\n    function flushBuffer() {\n        bIdx = 0;\n    }\n\n    function addBuffer(a) {\n        SIZE++;\n        buf32k[bIdx++] = a;\n        outputArr.push(String.fromCharCode(a));\n\n        if (bIdx === 0x8000) {\n            bIdx = 0;\n        }\n    }\n\n    function HufNode() {\n        this.b0 = 0;\n        this.b1 = 0;\n        this.jump = null;\n        this.jumppos = -1;\n    }\n\n    function isPat() {\n        var endless = true;\n        while (endless) {\n            if (fpos[len] >= fmax) {\n                return -1;\n            }\n\n            if (flens[fpos[len]] === len) {\n                return fpos[len]++;\n            }\n\n            fpos[len]++;\n        }\n    }\n\n    function rec() {\n        var curplace = Places[treepos],\n            tmp;\n\n        if (len === 17) {\n            return -1;\n        }\n        treepos++;\n        len++;\n\n        tmp = isPat();\n\n        if (tmp >= 0) {\n            /* leaf cell for 0-bit */\n            curplace.b0 = tmp;\n        } else {\n            /* Not a Leaf cell */\n            curplace.b0 = 0x8000;\n\n            if (rec()) {\n                return -1;\n            }\n        }\n\n        tmp = isPat();\n\n        if (tmp >= 0) {\n            /* leaf cell for 1-bit */\n            curplace.b1 = tmp;\n            /* Just for the display routine */\n            curplace.jump = null;\n        } else {\n            /* Not a Leaf cell */\n            curplace.b1 = 0x8000;\n            curplace.jump = Places[treepos];\n            curplace.jumppos = treepos;\n            if (rec()) {\n                return -1;\n            }\n        }\n        len--;\n\n        return 0;\n    }\n\n    function createTree(currentTree, numval, lengths, show) {\n        var i;\n\n        Places = currentTree;\n        treepos = 0;\n        flens = lengths;\n        fmax = numval;\n\n        for (i = 0; i < 17; i++) {\n            fpos[i] = 0;\n        }\n        len = 0;\n\n        if (rec()) {\n            return -1;\n        }\n\n        return 0;\n    }\n\n    function decodeValue(currentTree) {\n        var len,\n            i, b,\n            endless = true,\n            xtreepos = 0,\n            X = currentTree[xtreepos];\n\n        /* decode one symbol of the data */\n        while (endless) {\n            b = readBit();\n\n            if (b) {\n                if (!(X.b1 & 0x8000)) {\n                    /* If leaf node, return data */\n                    return X.b1;\n                }\n\n                X = X.jump;\n                len = currentTree.length;\n\n                for (i = 0; i < len; i++) {\n                    if (currentTree[i] === X) {\n                        xtreepos = i;\n                        break;\n                    }\n                }\n            } else {\n                if (!(X.b0 & 0x8000)) {\n                    /* If leaf node, return data */\n                    return X.b0;\n                }\n                xtreepos++;\n                X = currentTree[xtreepos];\n            }\n        }\n    }\n\n    function deflateLoop() {\n        var last, c, type, i, j, l, ll, ll2,\n            len, blockLen, dist, cSum, n, z,\n            literalCodes, distCodes, lenCodes,\n            endless = true;\n\n        do {\n            last = readBit();\n            type = readBits(2);\n\n            if (type === 0) {\n                // Stored\n                byteAlign();\n                blockLen = readByte();\n                blockLen |= readByte() << 8;\n\n                cSum = readByte();\n                cSum |= readByte() << 8;\n\n                if ((blockLen ^ ~cSum) & 0xffff) {\n                    JXG.debug(\"BlockLen checksum mismatch\\n\");\n                }\n\n                while (blockLen--) {\n                    c = readByte();\n                    addBuffer(c);\n                }\n            } else if (type === 1) {\n                /* Fixed Huffman tables -- fixed decode routine */\n                while (endless) {\n                    /*\n                         256    0000000        0\n                         :   :     :\n                         279    0010111        23\n                         0   00110000    48\n                         :    :      :\n                         143    10111111    191\n                         280 11000000    192\n                         :    :      :\n                         287 11000111    199\n                         144    110010000    400\n                         :    :       :\n                         255    111111111    511\n\n                         Note the bit order!\n                         */\n\n                    j = bitReverse[readBits(7)] >> 1;\n\n                    if (j > 23) {\n                        j = (j << 1) | readBit(); /* 48..255 */\n\n                        if (j > 199) {\n                            /* 200..255 */\n                            j -= 128; /*  72..127 */\n                            j = (j << 1) | readBit(); /* 144..255 << */\n                        } else {\n                            /*  48..199 */\n                            j -= 48; /*   0..151 */\n                            if (j > 143) {\n                                j = j + 136; /* 280..287 << */\n                                /*   0..143 << */\n                            }\n                        }\n                    } else {\n                        /*   0..23 */\n                        j += 256; /* 256..279 << */\n                    }\n\n                    if (j < 256) {\n                        addBuffer(j);\n                    } else if (j === 256) {\n                        /* EOF */\n                        break;\n                    } else {\n                        j -= 256 + 1; /* bytes + EOF */\n                        len = readBits(cplext[j]) + cplens[j];\n                        j = bitReverse[readBits(5)] >> 3;\n\n                        if (cpdext[j] > 8) {\n                            dist = readBits(8);\n                            dist |= readBits(cpdext[j] - 8) << 8;\n                        } else {\n                            dist = readBits(cpdext[j]);\n                        }\n\n                        dist += cpdist[j];\n\n                        for (j = 0; j < len; j++) {\n                            c = buf32k[(bIdx - dist) & 0x7fff];\n                            addBuffer(c);\n                        }\n                    }\n                } // while\n            } else if (type === 2) {\n                // \"static\" just to preserve stack\n                ll = new Array(288 + 32);\n\n                // Dynamic Huffman tables\n                literalCodes = 257 + readBits(5);\n                distCodes = 1 + readBits(5);\n                lenCodes = 4 + readBits(4);\n\n                for (j = 0; j < 19; j++) {\n                    ll[j] = 0;\n                }\n\n                // Get the decode tree code lengths\n\n                for (j = 0; j < lenCodes; j++) {\n                    ll[border[j]] = readBits(3);\n                }\n                len = distanceTree.length;\n\n                for (i = 0; i < len; i++) {\n                    distanceTree[i] = new HufNode();\n                }\n\n                if (createTree(distanceTree, 19, ll, 0)) {\n                    flushBuffer();\n                    return 1;\n                }\n\n                //read in literal and distance code lengths\n                n = literalCodes + distCodes;\n                i = 0;\n                z = -1;\n\n                while (i < n) {\n                    z++;\n                    j = decodeValue(distanceTree);\n\n                    // length of code in bits (0..15)\n                    if (j < 16) {\n                        ll[i++] = j;\n                        // repeat last length 3 to 6 times\n                    } else if (j === 16) {\n                        j = 3 + readBits(2);\n\n                        if (i + j > n) {\n                            flushBuffer();\n                            return 1;\n                        }\n                        l = i ? ll[i - 1] : 0;\n\n                        while (j--) {\n                            ll[i++] = l;\n                        }\n                    } else {\n                        // 3 to 10 zero length codes\n                        if (j === 17) {\n                            j = 3 + readBits(3);\n                            // j == 18: 11 to 138 zero length codes\n                        } else {\n                            j = 11 + readBits(7);\n                        }\n\n                        if (i + j > n) {\n                            flushBuffer();\n                            return 1;\n                        }\n\n                        while (j--) {\n                            ll[i++] = 0;\n                        }\n                    }\n                }\n\n                // Can overwrite tree decode tree as it is not used anymore\n                len = literalTree.length;\n                for (i = 0; i < len; i++) {\n                    literalTree[i] = new HufNode();\n                }\n\n                if (createTree(literalTree, literalCodes, ll, 0)) {\n                    flushBuffer();\n                    return 1;\n                }\n\n                len = literalTree.length;\n\n                for (i = 0; i < len; i++) {\n                    distanceTree[i] = new HufNode();\n                }\n\n                ll2 = [];\n\n                for (i = literalCodes; i < ll.length; i++) {\n                    ll2[i - literalCodes] = ll[i];\n                }\n\n                if (createTree(distanceTree, distCodes, ll2, 0)) {\n                    flushBuffer();\n                    return 1;\n                }\n\n                while (endless) {\n                    j = decodeValue(literalTree);\n\n                    // In C64: if carry set\n                    if (j >= 256) {\n                        j -= 256;\n                        if (j === 0) {\n                            // EOF\n                            break;\n                        }\n\n                        j -= 1;\n                        len = readBits(cplext[j]) + cplens[j];\n                        j = decodeValue(distanceTree);\n\n                        if (cpdext[j] > 8) {\n                            dist = readBits(8);\n                            dist |= readBits(cpdext[j] - 8) << 8;\n                        } else {\n                            dist = readBits(cpdext[j]);\n                        }\n\n                        dist += cpdist[j];\n\n                        while (len--) {\n                            c = buf32k[(bIdx - dist) & 0x7fff];\n                            addBuffer(c);\n                        }\n                    } else {\n                        addBuffer(j);\n                    }\n                }\n            }\n        } while (!last);\n\n        flushBuffer();\n        byteAlign();\n\n        return 0;\n    }\n\n    /**\n     * nextFile:\n     * Extract the next file from the compressed archive.\n     * Calls skipdir() to proceed recursively.\n     *\n     * @return {Boolean}  false if the end of files' data section has baseElement\n     * reached. Then, then all recursive functions are stopped immediately.\n     *\n     */\n    function nextFile() {\n        var i,\n            c,\n            extralen,\n            filelen,\n            size,\n            compSize,\n            crc,\n            method,\n            tmp = [];\n\n        // Prevent problems on iOS7 with >>\n        try {\n            outputArr = [];\n            modeZIP = false;\n            tmp[0] = readByte();\n            tmp[1] = readByte();\n\n            //GZIP\n            if (tmp[0] === 0x78 && tmp[1] === 0xda) {\n                deflateLoop();\n                unzipped[files] = [outputArr.join(\"\"), \"geonext.gxt\"];\n                files++;\n            }\n\n            //GZIP\n            if (tmp[0] === 0x1f && tmp[1] === 0x8b) {\n                skipdir();\n                unzipped[files] = [outputArr.join(\"\"), \"file\"];\n                files++;\n            }\n\n            //ZIP\n            if (tmp[0] === 0x50 && tmp[1] === 0x4b) {\n                modeZIP = true;\n                tmp[2] = readByte();\n                tmp[3] = readByte();\n\n                if (tmp[2] === 0x03 && tmp[3] === 0x04) {\n                    //MODE_ZIP\n                    tmp[0] = readByte();\n                    tmp[1] = readByte();\n\n                    gpflags = readByte();\n                    gpflags |= readByte() << 8;\n\n                    method = readByte();\n                    method |= readByte() << 8;\n\n                    readByte();\n                    readByte();\n                    readByte();\n                    readByte();\n\n                    crc = readByte();\n                    crc |= readByte() << 8;\n                    crc |= readByte() << 16;\n                    crc |= readByte() << 24;\n\n                    compSize = readByte();\n                    compSize |= readByte() << 8;\n                    compSize |= readByte() << 16;\n                    compSize |= readByte() << 24;\n\n                    size = readByte();\n                    size |= readByte() << 8;\n                    size |= readByte() << 16;\n                    size |= readByte() << 24;\n\n                    filelen = readByte();\n                    filelen |= readByte() << 8;\n\n                    extralen = readByte();\n                    extralen |= readByte() << 8;\n\n                    i = 0;\n                    nameBuf = [];\n\n                    while (filelen--) {\n                        c = readByte();\n                        if ((c === \"/\") | (c === \":\")) {\n                            i = 0;\n                        } else if (i < NAMEMAX - 1) {\n                            nameBuf[i++] = String.fromCharCode(c);\n                        }\n                    }\n\n                    if (!fileout) {\n                        fileout = nameBuf;\n                    }\n\n                    i = 0;\n                    while (i < extralen) {\n                        c = readByte();\n                        i++;\n                    }\n\n                    SIZE = 0;\n                    if (method === 8) {\n                        deflateLoop();\n                        unzipped[files] = new Array(2);\n                        unzipped[files][0] = outputArr.join(\"\");\n                        unzipped[files][1] = nameBuf.join(\"\");\n                        files++;\n                    }\n\n                    if (skipdir()) {\n                        // We are beyond the files' data in the zip archive.\n                        // Let's get out immediately...\n                        return false;\n                    }\n                }\n                return true;\n            }\n        } catch (e) {\n            console.log(\"Probably problems on iOS7 with >>\");\n            throw e;\n        }\n        return false;\n    }\n\n    /**\n     * Test if the end of the files' data part of the archive has baseElement\n     * reached. If not, uncompressing is resumed.\n     *\n     * @return {Boolean}  true if the end of the files' data sections have\n     * been reached.\n     *\n     * @private\n     */\n    function skipdir() {\n        var crc, compSize, size, os, i, c,\n            tmp = [];\n\n        if (gpflags & 8) {\n            tmp[0] = readByte();\n            tmp[1] = readByte();\n            tmp[2] = readByte();\n            tmp[3] = readByte();\n\n            // signature for data descriptor record: 0x08074b50\n            // 12 bytes:\n            //  crc 4 bytes\n            //  compressed size 4 bytes\n            // uncompressed size 4 bytes\n            if (tmp[0] === 0x50 && tmp[1] === 0x4b && tmp[2] === 0x07 && tmp[3] === 0x08) {\n                crc = readByte();\n                crc |= readByte() << 8;\n                crc |= readByte() << 16;\n                crc |= readByte() << 24;\n            } else {\n                crc = tmp[0] | (tmp[1] << 8) | (tmp[2] << 16) | (tmp[3] << 24);\n            }\n\n            compSize = readByte();\n            compSize |= readByte() << 8;\n            compSize |= readByte() << 16;\n            compSize |= readByte() << 24;\n\n            size = readByte();\n            size |= readByte() << 8;\n            size |= readByte() << 16;\n            size |= readByte() << 24;\n        }\n\n        if (modeZIP) {\n            if (nextFile()) {\n                // A file has been decompressed, we have to proceed\n                return false;\n            }\n        }\n\n        tmp[0] = readByte();\n        if (tmp[0] !== 8) {\n            // It seems, we are beyond the files' data in the zip archive.\n            // We'll skip the rest..\n            return true;\n        }\n\n        // There is another file in the zip file. We proceed...\n        gpflags = readByte();\n\n        readByte();\n        readByte();\n        readByte();\n        readByte();\n\n        readByte();\n        os = readByte();\n\n        if (gpflags & 4) {\n            tmp[0] = readByte();\n            tmp[2] = readByte();\n            len = tmp[0] + 256 * tmp[1];\n            for (i = 0; i < len; i++) {\n                readByte();\n            }\n        }\n\n        if (gpflags & 8) {\n            i = 0;\n            nameBuf = [];\n\n            c = readByte();\n            while (c) {\n                if (c === \"7\" || c === \":\") {\n                    i = 0;\n                }\n\n                if (i < NAMEMAX - 1) {\n                    nameBuf[i++] = c;\n                }\n\n                c = readByte();\n            }\n        }\n\n        if (gpflags & 16) {\n            c = readByte();\n            while (c) {\n                c = readByte();\n            }\n        }\n\n        if (gpflags & 2) {\n            readByte();\n            readByte();\n        }\n\n        deflateLoop();\n\n        crc = readByte();\n        crc |= readByte() << 8;\n        crc |= readByte() << 16;\n        crc |= readByte() << 24;\n\n        size = readByte();\n        size |= readByte() << 8;\n        size |= readByte() << 16;\n        size |= readByte() << 24;\n\n        if (modeZIP) {\n            if (nextFile()) {\n                // A file has been decompressed, we have to proceed\n                return false;\n            }\n        }\n\n        // We are here in non-ZIP-files only,\n        // In that case the eturn value doesn't matter\n        return false;\n    }\n\n    JXG.Util.Unzip.prototype.unzipFile = function (name) {\n        var i;\n\n        this.unzip();\n\n        for (i = 0; i < unzipped.length; i++) {\n            if (unzipped[i][1] === name) {\n                return unzipped[i][0];\n            }\n        }\n\n        return \"\";\n    };\n\n    JXG.Util.Unzip.prototype.unzip = function () {\n        nextFile();\n        return unzipped;\n    };\n};\n\nexport default JXG.Util;\n","/*global JXG: true, define: true, escape: true, unescape: true*/\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\nimport JXG from \"../jxg\";\n\n// constants\nvar UTF8_ACCEPT = 0,\n    UTF8_REJECT = 12,\n    UTF8D = [\n        // The first part of the table maps bytes to character classes that\n        // to reduce the size of the transition table and create bitmasks.\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9,\n        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 4, 3, 3, 11, 6, 6, 6, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n\n        // The second part is a transition table that maps a combination\n        // of a state of the automaton and a character class to a state.\n        0, 12, 24, 36, 60, 96, 84, 12, 12, 12, 48, 72, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n        12, 12, 12, 0, 12, 12, 12, 12, 12, 0, 12, 0, 12, 12, 12, 24, 12, 12, 12, 12, 12, 24, 12,\n        24, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12, 24, 12, 12, 12, 12, 12,\n        12, 12, 24, 12, 12, 12, 12, 12, 12, 12, 12, 12, 36, 12, 36, 12, 12, 12, 36, 12, 12, 12,\n        12, 12, 36, 12, 36, 12, 12, 12, 36, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12\n    ];\n\n// Util namespace\nJXG.Util = JXG.Util || {};\n\n/**\n * UTF8 encoding routines\n * @namespace\n */\nJXG.Util.UTF8 = {\n    /**\n     * Encode a string to utf-8.\n     * @param {String} string\n     * @returns {String} utf8 encoded string\n     */\n    encode: function (string) {\n        var n,\n            c,\n            utftext = \"\",\n            len = string.length;\n\n        string = string.replace(/\\r\\n/g, \"\\n\");\n\n        // See\n        // http://ecmanaut.blogspot.ca/2006/07/encoding-decoding-utf8-in-javascript.html\n        // http://monsur.hossa.in/2012/07/20/utf-8-in-javascript.html\n        if (typeof unescape === \"function\" && typeof encodeURIComponent === \"function\") {\n            return unescape(encodeURIComponent(string));\n        }\n\n        for (n = 0; n < len; n++) {\n            c = string.charCodeAt(n);\n\n            if (c < 128) {\n                utftext += String.fromCharCode(c);\n            } else if (c > 127 && c < 2048) {\n                utftext += String.fromCharCode((c >> 6) | 192);\n                utftext += String.fromCharCode((c & 63) | 128);\n            } else {\n                utftext += String.fromCharCode((c >> 12) | 224);\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n        }\n\n        return utftext;\n    },\n\n    /**\n     * Decode a string from utf-8.\n     * @param {String} utftext to decode\n     * @returns {String} utf8 decoded string\n     */\n    decode: function (utftext) {\n        /*\n                 The following code is a translation from C99 to JavaScript.\n\n                 The original C99 code can be found at\n                 http://bjoern.hoehrmann.de/utf-8/decoder/dfa/\n\n                 Original copyright note:\n\n                 Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>\n\n                 License: MIT License (see LICENSE.MIT)\n            */\n\n        var i,\n            charCode,\n            type,\n            j = 0,\n            codepoint = 0,\n            state = UTF8_ACCEPT,\n            chars = [],\n            len = utftext.length,\n            results = [];\n\n        for (i = 0; i < len; i++) {\n            charCode = utftext.charCodeAt(i);\n            type = UTF8D[charCode];\n\n            if (state !== UTF8_ACCEPT) {\n                codepoint = (charCode & 0x3f) | (codepoint << 6);\n            } else {\n                codepoint = (0xff >> type) & charCode;\n            }\n\n            state = UTF8D[256 + state + type];\n\n            if (state === UTF8_ACCEPT) {\n                if (codepoint > 0xffff) {\n                    chars.push(0xd7c0 + (codepoint >> 10), 0xdc00 + (codepoint & 0x3ff));\n                } else {\n                    chars.push(codepoint);\n                }\n\n                j++;\n\n                if (j % 10000 === 0) {\n                    results.push(String.fromCharCode.apply(null, chars));\n                    chars = [];\n                }\n            }\n        }\n        results.push(String.fromCharCode.apply(null, chars));\n        return results.join(\"\");\n    },\n\n    /**\n     * Extends the standard charCodeAt() method of the String class to find the ASCII char code of\n     * a character at a given position in a UTF8 encoded string.\n     * @param {String} str\n     * @param {Number} i position of the character\n     * @returns {Number}\n     */\n    asciiCharCodeAt: function (str, i) {\n        var c = str.charCodeAt(i);\n\n        if (c > 255) {\n            switch (c) {\n                case 8364:\n                    c = 128;\n                    break;\n                case 8218:\n                    c = 130;\n                    break;\n                case 402:\n                    c = 131;\n                    break;\n                case 8222:\n                    c = 132;\n                    break;\n                case 8230:\n                    c = 133;\n                    break;\n                case 8224:\n                    c = 134;\n                    break;\n                case 8225:\n                    c = 135;\n                    break;\n                case 710:\n                    c = 136;\n                    break;\n                case 8240:\n                    c = 137;\n                    break;\n                case 352:\n                    c = 138;\n                    break;\n                case 8249:\n                    c = 139;\n                    break;\n                case 338:\n                    c = 140;\n                    break;\n                case 381:\n                    c = 142;\n                    break;\n                case 8216:\n                    c = 145;\n                    break;\n                case 8217:\n                    c = 146;\n                    break;\n                case 8220:\n                    c = 147;\n                    break;\n                case 8221:\n                    c = 148;\n                    break;\n                case 8226:\n                    c = 149;\n                    break;\n                case 8211:\n                    c = 150;\n                    break;\n                case 8212:\n                    c = 151;\n                    break;\n                case 732:\n                    c = 152;\n                    break;\n                case 8482:\n                    c = 153;\n                    break;\n                case 353:\n                    c = 154;\n                    break;\n                case 8250:\n                    c = 155;\n                    break;\n                case 339:\n                    c = 156;\n                    break;\n                case 382:\n                    c = 158;\n                    break;\n                case 376:\n                    c = 159;\n                    break;\n                default:\n                    break;\n            }\n        }\n        return c;\n    }\n};\n\nexport default JXG.Util.UTF8;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\nimport JXG from \"../jxg\";\nimport Encoding from \"./encoding\";\n\nvar alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    pad = \"=\";\n\n// Util namespace\nJXG.Util = JXG.Util || {};\n\n/**\n * Base64 routines\n * @namespace\n */\nJXG.Util.Base64 = {\n    // Local helper functions\n    /**\n     * Extracts one byte from a string and ensures the result is less than or equal to 255.\n     * @param {String} s\n     * @param {Number} i\n     * @returns {Number} <= 255\n     * @private\n     */\n    _getByte: function(s, i) {\n        return s.charCodeAt(i) & 0xff;\n    },\n\n    /**\n     * Determines the index of a base64 character in the base64 alphabet.\n     * @param {String} s\n     * @param {Number} i\n     * @returns {Number}\n     * @throws {Error} If the character can not be found in the alphabet.\n     * @private\n     */\n    _getIndex: function(s, i) {\n        return alphabet.indexOf(s.charAt(i));\n    },\n\n    /**\n     * Encode the given string.\n     * @param {String} input\n     * @returns {string} base64 encoded version of the input string.\n     */\n    encode: function (input) {\n        var i,\n            bin,\n            len,\n            padLen,\n            encInput,\n            buffer = [];\n\n        encInput = Encoding.encode(input);\n        len = encInput.length;\n        padLen = len % 3;\n\n        for (i = 0; i < len - padLen; i += 3) {\n            bin =\n                (this._getByte(encInput, i) << 16) |\n                (this._getByte(encInput, i + 1) << 8) |\n                this._getByte(encInput, i + 2);\n            buffer.push(\n                alphabet.charAt(bin >> 18),\n                alphabet.charAt((bin >> 12) & 63),\n                alphabet.charAt((bin >> 6) & 63),\n                alphabet.charAt(bin & 63)\n            );\n        }\n\n        switch (padLen) {\n            case 1:\n                bin = this._getByte(encInput, len - 1);\n                buffer.push(\n                    alphabet.charAt(bin >> 2),\n                    alphabet.charAt((bin << 4) & 63),\n                    pad,\n                    pad\n                );\n                break;\n            case 2:\n                bin = (this._getByte(encInput, len - 2) << 8) | this._getByte(encInput, len - 1);\n                buffer.push(\n                    alphabet.charAt(bin >> 10),\n                    alphabet.charAt((bin >> 4) & 63),\n                    alphabet.charAt((bin << 2) & 63),\n                    pad\n                );\n                break;\n        }\n\n        return buffer.join(\"\");\n    },\n\n    /**\n     * Decode from Base64\n     * @param {String} input Base64 encoded data\n     * @param {Boolean} utf8 In case this parameter is true {@link JXG.Util.UTF8.decode} will be applied to\n     * the result of the base64 decoder.\n     * @throws {Error} If the string has the wrong length.\n     * @returns {String}\n     */\n    decode: function (input, utf8) {\n        var encInput,\n            i,\n            len,\n            padLen,\n            bin,\n            output,\n            result = [],\n            buffer = [];\n\n        // deactivate regexp linting. Our regex is secure, because we replace everything with ''\n        /*jslint regexp:true*/\n        encInput = input.replace(/[^A-Za-z0-9+/=]/g, \"\");\n        /*jslint regexp:false*/\n\n        len = encInput.length;\n\n        if (len % 4 !== 0) {\n            throw new Error(\n                \"JSXGraph/utils/base64: Can't decode string (invalid input length).\"\n            );\n        }\n\n        if (encInput.charAt(len - 1) === pad) {\n            padLen = 1;\n\n            if (encInput.charAt(len - 2) === pad) {\n                padLen = 2;\n            }\n\n            // omit the last four bytes (taken care of after the for loop)\n            len -= 4;\n        }\n\n        for (i = 0; i < len; i += 4) {\n            bin =\n                (this._getIndex(encInput, i) << 18) |\n                (this._getIndex(encInput, i + 1) << 12) |\n                (this._getIndex(encInput, i + 2) << 6) |\n                this._getIndex(encInput, i + 3);\n            buffer.push(bin >> 16, (bin >> 8) & 255, bin & 255);\n\n            // flush the buffer, if it gets too big fromCharCode will crash\n            if (i % 10000 === 0) {\n                result.push(String.fromCharCode.apply(null, buffer));\n                buffer = [];\n            }\n        }\n\n        switch (padLen) {\n            case 1:\n                bin =\n                    (this._getIndex(encInput, len) << 12) |\n                    (this._getIndex(encInput, len + 1) << 6) |\n                    this._getIndex(encInput, len + 2);\n                buffer.push(bin >> 10, (bin >> 2) & 255);\n                break;\n\n            case 2:\n                bin = (this._getIndex(encInput, i) << 6) | this._getIndex(encInput, i + 1);\n                buffer.push(bin >> 4);\n                break;\n        }\n\n        result.push(String.fromCharCode.apply(null, buffer));\n        output = result.join(\"\");\n\n        if (utf8) {\n            output = Encoding.decode(output);\n        }\n\n        return output;\n    },\n\n    /**\n     * Decode the base64 input data as an array\n     * @param {string} input\n     * @returns {Array}\n     */\n    decodeAsArray: function (input) {\n        var i,\n            dec = this.decode(input),\n            ar = [],\n            len = dec.length;\n\n        for (i = 0; i < len; i++) {\n            ar[i] = dec.charCodeAt(i);\n        }\n\n        return ar;\n    }\n};\n\nexport default JXG.Util.Base64;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, escape:true, window:true, ActiveXObject:true, XMLHttpRequest:true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The JXG.Server is a wrapper for a smoother integration of server side calculations. on the\n * server side a python plugin system is used.\n */\n\nimport JXG from \"../jxg\";\nimport Zip from \"../utils/zip\";\nimport Base64 from \"../utils/base64\";\nimport Type from \"../utils/type\";\n\n/**\n * @namespace\n * JXG.Server namespace holding functions to load JXG server modules.\n */\nJXG.Server = {\n    /**\n     * This is where all of a module's handlers are accessed from. If you're loading a module named JXGModule which\n     * provides a handler called ImaHandler, then this handler can be called by invoking JXG.Server.modules.JXGModule.ImaHandler().\n     * @namespace\n     */\n    modules: {},\n\n    /**\n     * Stores all asynchronous calls to server which aren't finished yet.\n     * @private\n     */\n    runningCalls: {},\n\n    /**\n     * Handles errors, just a default implementation, can be overwritten by you, if you want to handle errors by yourself.\n     * @param {object} data An object holding a field of type string named message handling the error described in the message string.\n     */\n    handleError: function (data) {\n        JXG.debug(\"error occured, server says: \" + data.message);\n    },\n\n    /**\n     * The main method of JXG.Server. Actually makes the calls to the server and parses the feedback.\n     * @param {String} action Can be 'load' or 'exec'.\n     * @param {function} callback Function pointer or anonymous function which takes as it's only argument an\n     * object containing the data from the server. The fields of this object depend on the reply of the server\n     * module. See the correspondings server module readme.\n     * @param {Object} data What is to be sent to the server.\n     * @param {Boolean} sync If the call should be synchronous or not.\n     */\n    callServer: function (action, callback, data, sync) {\n        var fileurl, passdata, AJAX, params, id, dataJSONStr, k;\n\n        sync = sync || false;\n\n        params = \"\";\n        for (k in data) {\n            if (data.hasOwnProperty(k)) {\n                params += \"&\" + escape(k) + \"=\" + escape(data[k]);\n            }\n        }\n\n        dataJSONStr = Type.toJSON(data);\n\n        // generate id\n        do {\n            id = action + Math.floor(Math.random() * 4096);\n        } while (Type.exists(this.runningCalls[id]));\n\n        // store information about the calls\n        this.runningCalls[id] = { action: action };\n        if (Type.exists(data.module)) {\n            this.runningCalls[id].module = data.module;\n        }\n\n        fileurl = JXG.serverBase + \"JXGServer.py\";\n        passdata =\n            \"action=\" +\n            escape(action) +\n            \"&id=\" +\n            id +\n            \"&dataJSON=\" +\n            escape(Base64.encode(dataJSONStr));\n\n        this.cbp = function (d) {\n            /*jslint evil:true*/\n            var str, data, tmp, inject, paramlist, id, i, j;\n\n            str = new Zip.Unzip(Base64.decodeAsArray(d)).unzip();\n            if (Type.isArray(str) && str.length > 0) {\n                str = str[0][0];\n            }\n\n            if (!Type.exists(str)) {\n                return;\n            }\n\n            data =\n                window.JSON && window.JSON.parse\n                    ? window.JSON.parse(str)\n                    : new Function(\"return \" + str)();\n\n            if (data.type === \"error\") {\n                this.handleError(data);\n            } else if (data.type === \"response\") {\n                id = data.id;\n\n                // inject fields\n                for (i = 0; i < data.fields.length; i++) {\n                    tmp = data.fields[i];\n                    inject =\n                        tmp.namespace +\n                        (typeof new Function(\"return \" + tmp.namespace)() === \"object\"\n                            ? \".\"\n                            : \".prototype.\") +\n                        tmp.name +\n                        \" = \" +\n                        tmp.value;\n                    new Function(inject)();\n                }\n\n                // inject handlers\n                for (i = 0; i < data.handler.length; i++) {\n                    tmp = data.handler[i];\n                    paramlist = [];\n\n                    for (j = 0; j < tmp.parameters.length; j++) {\n                        paramlist[j] = '\"' + tmp.parameters[j] + '\": ' + tmp.parameters[j];\n                    }\n                    // insert subnamespace named after module.\n                    inject =\n                        \"if(typeof JXG.Server.modules.\" +\n                        this.runningCalls[id].module +\n                        ' == \"undefined\")' +\n                        \"JXG.Server.modules.\" +\n                        this.runningCalls[id].module +\n                        \" = {};\";\n\n                    // insert callback method which fetches and uses the server's data for calculation in JavaScript\n                    inject +=\n                        \"JXG.Server.modules.\" +\n                        this.runningCalls[id].module +\n                        \".\" +\n                        tmp.name +\n                        \"_cb = \" +\n                        tmp.callback +\n                        \";\";\n\n                    // insert handler as JXG.Server.modules.<module name>.<handler name>\n                    inject +=\n                        \"JXG.Server.modules.\" +\n                        this.runningCalls[id].module +\n                        \".\" +\n                        tmp.name +\n                        \" = function (\" +\n                        tmp.parameters.join(\",\") +\n                        \", __JXGSERVER_CB__, __JXGSERVER_SYNC) {\" +\n                        'if(typeof __JXGSERVER_CB__ == \"undefined\") __JXGSERVER_CB__ = JXG.Server.modules.' +\n                        this.runningCalls[id].module +\n                        \".\" +\n                        tmp.name +\n                        \"_cb;\" +\n                        \"var __JXGSERVER_PAR__ = {\" +\n                        paramlist.join(\",\") +\n                        ', \"module\": \"' +\n                        this.runningCalls[id].module +\n                        '\", \"handler\": \"' +\n                        tmp.name +\n                        '\" };' +\n                        'JXG.Server.callServer(\"exec\", __JXGSERVER_CB__, __JXGSERVER_PAR__, __JXGSERVER_SYNC);' +\n                        \"};\";\n                    new Function(inject)();\n                }\n\n                delete this.runningCalls[id];\n\n                // handle data\n                callback(data.data);\n            }\n        };\n\n        // bind cbp callback method to JXG.Server to get access to JXG.Server fields from within cpb\n        this.cb = JXG.bind(this.cbp, this);\n\n        // We are using our own XMLHttpRequest object in here because of a/sync and POST\n        if (window.XMLHttpRequest) {\n            AJAX = new XMLHttpRequest();\n            AJAX.overrideMimeType(\"text/plain; charset=iso-8859-1\");\n        } else {\n            AJAX = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n        if (AJAX) {\n            // POST is required if data sent to server is too long for a url.\n            // some browsers/http servers don't accept long urls.\n            AJAX.open(\"POST\", fileurl, !sync);\n            AJAX.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n\n            if (!sync) {\n                // Define function to fetch data received from server\n                // that function returning a function is required to make this.cb known to the function.\n                AJAX.onreadystatechange = (function (cb) {\n                    return function () {\n                        if (AJAX.readyState === 4 && AJAX.status === 200) {\n                            cb(AJAX.responseText);\n                            return true;\n                        }\n                        return false;\n                    };\n                })(this.cb);\n            }\n\n            // send the data\n            AJAX.send(passdata);\n            if (sync) {\n                this.cb(AJAX.responseText);\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    /**\n     * Callback for the default action 'load'.\n     */\n    loadModule_cb: function (data) {\n        var i;\n        for (i = 0; i < data.length; i++) {\n            JXG.debug(data[i].name + \": \" + data[i].value);\n        }\n    },\n\n    /**\n     * Loads a module from the server.\n     * @param {string} module A string containing the module. Has to match the filename of the Python module on the server exactly including\n     * lower and upper case letters without the file ending .py.\n     */\n    loadModule: function (module) {\n        return JXG.Server.callServer(\n            \"load\",\n            JXG.Server.loadModule_cb,\n            { module: module },\n            true\n        );\n    }\n};\n\nJXG.Server.load = JXG.Server.loadModule;\n\nexport default JXG.Server;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the namespace Math.Symbolic is defined, which holds methods\n * and algorithms for symbolic computations.\n * @author graphjs\n */\n\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Geometry from \"./geometry\";\nimport Server from \"../server/server\";\nimport Type from \"../utils/type\";\n\nvar undef;\n\n/**\n * The JXG.Math.Symbolic namespace holds algorithms for symbolic computations.\n * @name JXG.Math.Symbolic\n * @exports Mat.Symbolic as JXG.Math.Symbolic\n * @namespace\n */\nMat.Symbolic = {\n    /**\n     * Generates symbolic coordinates for the part of a construction including all the elements from that\n     * a specific element depends of. These coordinates will be stored in GeometryElement.symbolic.\n     * @param {JXG.Board} board The board that's element get some symbolic coordinates.\n     * @param {JXG.GeometryElement} element All ancestor of this element get symbolic coordinates.\n     * @param {String} variable Name for the coordinates, e.g. x or u.\n     * @param {String} append Method for how to append the number of the coordinates. Possible values are\n     *                        'underscore' (e.g. x_2), 'none' (e.g. x2), 'brace' (e.g. x[2]).\n     * @returns {Number} Number of coordinates given.\n     * @memberof JXG.Math.Symbolic\n     */\n    generateSymbolicCoordinatesPartial: function (board, element, variable, append) {\n        var t_num,\n            t,\n            k,\n            list = element.ancestors,\n            count = 0,\n            makeCoords = function (num) {\n                var r;\n\n                if (append === \"underscore\") {\n                    r = variable + \"_{\" + num + \"}\";\n                } else if (append === \"brace\") {\n                    r = variable + \"[\" + num + \"]\";\n                } else {\n                    r = variable + num;\n                }\n\n                return r;\n            };\n\n        board.listOfFreePoints = [];\n        board.listOfDependantPoints = [];\n\n        for (t in list) {\n            if (list.hasOwnProperty(t)) {\n                t_num = 0;\n\n                if (Type.isPoint(list[t])) {\n                    for (k in list[t].ancestors) {\n                        if (list[t].ancestors.hasOwnProperty(k)) {\n                            t_num++;\n                        }\n                    }\n\n                    if (t_num === 0) {\n                        list[t].symbolic.x = list[t].coords.usrCoords[1];\n                        list[t].symbolic.y = list[t].coords.usrCoords[2];\n                        board.listOfFreePoints.push(list[t]);\n                    } else {\n                        count += 1;\n                        list[t].symbolic.x = makeCoords(count);\n                        count += 1;\n                        list[t].symbolic.y = makeCoords(count);\n                        board.listOfDependantPoints.push(list[t]);\n                    }\n                }\n            }\n        }\n\n        if (Type.isPoint(element)) {\n            element.symbolic.x = \"x\";\n            element.symbolic.y = \"y\";\n        }\n\n        return count;\n    },\n\n    /**\n     * Clears all .symbolic.x and .symbolic.y members on every point of a given board.\n     * @param {JXG.Board} board The board that's points get cleared their symbolic coordinates.\n     * @memberof JXG.Math.Symbolic\n     */\n    clearSymbolicCoordinates: function (board) {\n        var clear = function (list) {\n            var t,\n                l = (list && list.length) || 0;\n\n            for (t = 0; t < l; t++) {\n                if (Type.isPoint(list[t])) {\n                    list[t].symbolic.x = \"\";\n                    list[t].symbolic.y = \"\";\n                }\n            }\n        };\n\n        clear(board.listOfFreePoints);\n        clear(board.listOfDependantPoints);\n\n        delete board.listOfFreePoints;\n        delete board.listOfDependantPoints;\n    },\n\n    /**\n     * Generates polynomials for a part of the construction including all the points from that\n     * a specific element depends of.\n     * @param {JXG.Board} board The board that's points polynomials will be generated.\n     * @param {JXG.GeometryElement} element All points in the set of ancestors of this element are used to generate the set of polynomials.\n     * @param {Boolean} generateCoords\n     * @returns {Array} An array of polynomials as strings.\n     * @memberof JXG.Math.Symbolic\n     */\n    generatePolynomials: function (board, element, generateCoords) {\n        var t,\n            k,\n            i,\n            list = element.ancestors,\n            number_of_ancestors,\n            pgs = [],\n            result = [];\n\n        if (generateCoords) {\n            this.generateSymbolicCoordinatesPartial(board, element, \"u\", \"brace\");\n        }\n\n        list[element.id] = element;\n\n        for (t in list) {\n            if (list.hasOwnProperty(t)) {\n                number_of_ancestors = 0;\n                pgs = [];\n\n                if (Type.isPoint(list[t])) {\n                    for (k in list[t].ancestors) {\n                        if (list[t].ancestors.hasOwnProperty(k)) {\n                            number_of_ancestors++;\n                        }\n                    }\n                    if (number_of_ancestors > 0) {\n                        pgs = list[t].generatePolynomial();\n\n                        for (i = 0; i < pgs.length; i++) {\n                            result.push(pgs[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (generateCoords) {\n            this.clearSymbolicCoordinates(board);\n        }\n\n        return result;\n    },\n\n    /**\n     * Calculate geometric locus of a point given on a board. Invokes python script on server.\n     * @param {JXG.Board} board The board on which the point lies.\n     * @param {JXG.Point} point The point that will be traced.\n     * @returns {Array} An array of points.\n     * @memberof JXG.Math.Symbolic\n     */\n    geometricLocusByGroebnerBase: function (board, point) {\n        var poly,\n            polyStr,\n            result,\n            P1,\n            P2,\n            i,\n            xs,\n            xe,\n            ys,\n            ye,\n            c,\n            s,\n            tx,\n            bol = board.options.locus,\n            oldRadius = {},\n            numDependent = this.generateSymbolicCoordinatesPartial(board, point, \"u\", \"brace\"),\n            xsye = new Coords(Const.COORDS_BY_USR, [0, 0], board),\n            xeys = new Coords(\n                Const.COORDS_BY_USR,\n                [board.canvasWidth, board.canvasHeight],\n                board\n            ),\n            sf = 1,\n            transx = 0,\n            transy = 0,\n            rot = 0;\n\n        if (Server.modules.geoloci === undef) {\n            Server.loadModule(\"geoloci\");\n        }\n\n        if (Server.modules.geoloci === undef) {\n            throw new Error(\"JSXGraph: Unable to load JXG.Server module 'geoloci.py'.\");\n        }\n\n        xs = xsye.usrCoords[1];\n        xe = xeys.usrCoords[1];\n        ys = xeys.usrCoords[2];\n        ye = xsye.usrCoords[2];\n\n        // Optimizations - but only if the user wants to\n        //   Step 1: Translate all related points, such that one point P1 (board.options.locus.toOrigin if set\n        //     or a random point otherwise) is moved to (0, 0)\n        //   Step 2: Rotate the construction around the new P1, such that another point P2 (board.options.locus.to10 if set\n        //     or a random point \\neq P1 otherwise) is moved onto the positive x-axis\n        //  Step 3: Dilate the construction, such that P2 is moved to (1, 0)\n        //  Step 4: Give the scale factor (sf), the rotation (rot) and the translation vector (transx, transy) to\n        //    the server, which retransforms the plot (if any).\n\n        // Step 1\n        if (bol.translateToOrigin && board.listOfFreePoints.length > 0) {\n            if (\n                bol.toOrigin !== undef &&\n                bol.toOrigin !== null &&\n                Type.isInArray(board.listOfFreePoints, bol.toOrigin.id)\n            ) {\n                P1 = bol.toOrigin;\n            } else {\n                P1 = board.listOfFreePoints[0];\n            }\n\n            transx = P1.symbolic.x;\n            transy = P1.symbolic.y;\n            // translate the whole construction\n            for (i = 0; i < board.listOfFreePoints.length; i++) {\n                board.listOfFreePoints[i].symbolic.x -= transx;\n                board.listOfFreePoints[i].symbolic.y -= transy;\n            }\n\n            xs -= transx;\n            xe -= transx;\n            ys -= transy;\n            ye -= transy;\n\n            // Step 2\n            if (bol.translateTo10 && board.listOfFreePoints.length > 1) {\n                if (\n                    bol.to10 !== undef &&\n                    bol.to10 !== null &&\n                    bol.to10.id !== bol.toOrigin.id &&\n                    Type.isInArray(board.listOfFreePoints, bol.to10.id)\n                ) {\n                    P2 = bol.to10;\n                } else {\n                    if (board.listOfFreePoints[0].id === P1.id) {\n                        P2 = board.listOfFreePoints[1];\n                    } else {\n                        P2 = board.listOfFreePoints[0];\n                    }\n                }\n\n                rot = Geometry.rad([1, 0], [0, 0], [P2.symbolic.x, P2.symbolic.y]);\n                c = Math.cos(-rot);\n                s = Math.sin(-rot);\n\n                for (i = 0; i < board.listOfFreePoints.length; i++) {\n                    tx = board.listOfFreePoints[i].symbolic.x;\n                    board.listOfFreePoints[i].symbolic.x =\n                        c * board.listOfFreePoints[i].symbolic.x -\n                        s * board.listOfFreePoints[i].symbolic.y;\n                    board.listOfFreePoints[i].symbolic.y =\n                        s * tx + c * board.listOfFreePoints[i].symbolic.y;\n                }\n\n                // thanks to the rotation this is zero\n                P2.symbolic.y = 0;\n\n                tx = xs;\n                xs = c * xs - s * ys;\n                ys = s * tx + c * ys;\n                tx = xe;\n                xe = c * xe - s * ye;\n                ye = s * tx + c * ye;\n\n                // Step 3\n                if (bol.stretch && Math.abs(P2.symbolic.x) > Mat.eps) {\n                    sf = P2.symbolic.x;\n\n                    for (i = 0; i < board.listOfFreePoints.length; i++) {\n                        board.listOfFreePoints[i].symbolic.x /= sf;\n                        board.listOfFreePoints[i].symbolic.y /= sf;\n                    }\n\n                    for (i = 0; i < board.objectsList.length; i++) {\n                        if (\n                            board.objectsList[i].elementClass === Const.OBJECT_CLASS_CIRCLE &&\n                            board.objectsList[i].method === \"pointRadius\"\n                        ) {\n                            oldRadius[i] = board.objectsList[i].radius;\n                            board.objectsList[i].radius /= sf;\n                        }\n                    }\n\n                    xs /= sf;\n                    xe /= sf;\n                    ys /= sf;\n                    ye /= sf;\n\n                    // this is now 1\n                    P2.symbolic.x = 1;\n                }\n            }\n\n            // make the coordinates \"as rational as possible\"\n            for (i = 0; i < board.listOfFreePoints.length; i++) {\n                tx = board.listOfFreePoints[i].symbolic.x;\n\n                if (Math.abs(tx) < Mat.eps) {\n                    board.listOfFreePoints[i].symbolic.x = 0;\n                }\n\n                if (Math.abs(tx - Math.round(tx)) < Mat.eps) {\n                    board.listOfFreePoints[i].symbolic.x = Math.round(tx);\n                }\n\n                tx = board.listOfFreePoints[i].symbolic.y;\n\n                if (Math.abs(tx) < Mat.eps) {\n                    board.listOfFreePoints[i].symbolic.y = 0;\n                }\n\n                if (Math.abs(tx - Math.round(tx)) < Mat.eps) {\n                    board.listOfFreePoints[i].symbolic.y = Math.round(tx);\n                }\n            }\n        }\n\n        // end of optimizations\n\n        poly = this.generatePolynomials(board, point);\n        polyStr = poly.join(\",\");\n\n        this.cbp = function (data) {\n            result = data;\n        };\n\n        this.cb = Type.bind(this.cbp, this);\n\n        Server.modules.geoloci.lociCoCoA(\n            xs,\n            xe,\n            ys,\n            ye,\n            numDependent,\n            polyStr,\n            sf,\n            rot,\n            transx,\n            transy,\n            this.cb,\n            true\n        );\n\n        this.clearSymbolicCoordinates(board);\n\n        for (i in oldRadius) {\n            if (oldRadius.hasOwnProperty(i)) {\n                board.objects[i].radius = oldRadius[i];\n            }\n        }\n\n        return result;\n    }\n};\n\nexport default Mat.Symbolic;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\nconsole.log(\"P:\", P.coords.usrCoords, P.data.type)\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains the Math.Clip namespace for clipping and computing boolean operations\n * on polygons and curves\n *\n * // TODO:\n * * Check if input polygons are closed. If not, handle this case.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Geometry from \"./geometry\";\nimport Type from \"../utils/type\";\n\n/**\n * Math.Clip namespace definition. This namespace contains algorithms for Boolean operations on paths, i.e.\n * intersection, union and difference of paths. Base is the Greiner-Hormann algorithm.\n * @name JXG.Math.Clip\n * @exports Mat.Clip as JXG.Math.Clip\n * @namespace\n */\n// Mat.Clip = function () {\n// };\n\n// JXG.extend(Mat.Clip.prototype, /** @lends JXG.Curve.prototype */ {\n\nMat.Clip = {\n    _isSeparator: function (node) {\n        return isNaN(node.coords.usrCoords[1]) && isNaN(node.coords.usrCoords[2]);\n    },\n\n    /**\n     * Add pointers to an array S such that it is a circular doubly-linked list.\n     *\n     * @private\n     * @param  {Array} S Array\n     * @return {Array} return containing the starter indices of each component.\n     */\n    makeDoublyLinkedList: function (S) {\n        var i,\n            first = null,\n            components = [],\n            le = S.length;\n\n        if (le > 0) {\n            for (i = 0; i < le; i++) {\n                // S[i]._next = S[(i + 1) % le];\n                // S[i]._prev = S[(le + i - 1) % le];\n\n                // If S[i] is component separator we proceed with the next node.\n                if (this._isSeparator(S[i])) {\n                    S[i]._next = S[(i + 1) % le];\n                    S[i]._prev = S[(le + i - 1) % le];\n                    continue;\n                }\n\n                // Now we know that S[i] is a path component\n                if (first === null) {\n                    // Start the component if it is not yet started.\n                    first = i;\n                    components.push(first);\n                }\n                if (this._isSeparator(S[(i + 1) % le]) || i === le - 1) {\n                    // If the next node is a component separator or if the node is the last node,\n                    // then we close the loop\n\n                    S[i]._next = S[first];\n                    S[first]._prev = S[i];\n                    S[i]._end = true;\n                    first = null;\n                } else {\n                    // Here, we are not at the end of component\n                    S[i]._next = S[(i + 1) % le];\n                    S[first]._prev = S[i];\n                }\n                if (!this._isSeparator(S[(le + i - 1) % le])) {\n                    S[i]._prev = S[(le + i - 1) % le];\n                }\n            }\n        }\n        return components;\n    },\n\n    /**\n     * JavaScript object containing the intersection of two paths. Every intersection point is on one path, but\n     * comes with a neighbour point having the same coordinates and being on the other path.\n     *\n     * The intersection point is inserted into the doubly linked list of the path.\n     *\n     * @private\n     * @param  {JXG.Coords} coords JSXGraph Coords object conatining the coordinates of the intersection\n     * @param  {Number} i        Number of the segment of the subject path (first path) containing the intersection.\n     * @param  {Number} alpha    The intersection is a p_1 + alpha*(p_2 - p_1), where p_1 and p_2 are the end points\n     *      of the i-th segment.\n     * @param  {Array} path      Pointer to the path containing the intersection point\n     * @param  {String} pathname Name of the path: 'S' or 'C'.\n     */\n    Vertex: function (coords, i, alpha, path, pathname, type) {\n        this.pos = i;\n        this.intersection = true;\n        this.coords = coords;\n        this.elementClass = Const.OBJECT_CLASS_POINT;\n\n        this.data = {\n            alpha: alpha,\n            path: path,\n            pathname: pathname,\n            done: false,\n            type: type,\n            idx: 0\n        };\n\n        // Set after initialisation\n        this.neighbour = null;\n        this.entry_exit = false;\n    },\n\n    _addToList: function (list, coords, pos) {\n        var len = list.length,\n            eps = Mat.eps * Mat.eps;\n\n        if (\n            len > 0 &&\n            Math.abs(list[len - 1].coords.usrCoords[0] - coords.usrCoords[0]) < eps &&\n            Math.abs(list[len - 1].coords.usrCoords[1] - coords.usrCoords[1]) < eps &&\n            Math.abs(list[len - 1].coords.usrCoords[2] - coords.usrCoords[2]) < eps\n        ) {\n            // Skip point\n            return;\n        }\n        list.push({\n            pos: pos,\n            intersection: false,\n            coords: coords,\n            elementClass: Const.OBJECT_CLASS_POINT\n        });\n    },\n\n    /**\n     * Sort the intersection points into their path.\n     * @private\n     * @param  {Array} P_crossings Array of arrays. Each array contains the intersections of the path\n     *      with one segment of the other path.\n     * @return {Array}  Array of intersection points ordered by first occurrence in the path.\n     */\n    sortIntersections: function (P_crossings) {\n        var i,\n            j,\n            P,\n            Q,\n            last,\n            next_node,\n            P_intersect = [],\n            P_le = P_crossings.length;\n\n        for (i = 0; i < P_le; i++) {\n            P_crossings[i].sort(function (a, b) {\n                return a.data.alpha > b.data.alpha ? 1 : -1;\n            });\n\n            if (P_crossings[i].length > 0) {\n                // console.log(\"Crossings\", P_crossings[i])\n                last = P_crossings[i].length - 1;\n                P = P_crossings[i][0];\n\n                //console.log(\"SORT\", P.coords.usrCoords)\n                Q = P.data.path[P.pos];\n                next_node = Q._next; // Store the next \"normal\" node\n\n                if (i === P_le - 1) {\n                    Q._end = false;\n                }\n\n                if (P.data.alpha === 0.0 && P.data.type === \"T\") {\n                    // console.log(\"SKIP\", P.coords.usrCoords, P.data.type, P.neighbour.data.type);\n                    Q.intersection = true;\n                    Q.data = P.data;\n                    Q.neighbour = P.neighbour;\n                    Q.neighbour.neighbour = Q;\n                    Q.entry_exit = false;\n                    P_crossings[i][0] = Q;\n                } else {\n                    // Insert the first intersection point\n                    P._prev = Q;\n                    P._prev._next = P;\n                }\n\n                // Insert the other intersection points, but the last\n                for (j = 1; j <= last; j++) {\n                    P = P_crossings[i][j];\n                    P._prev = P_crossings[i][j - 1];\n                    P._prev._next = P;\n                }\n\n                // Link last intersection point to the next node\n                P = P_crossings[i][last];\n                P._next = next_node;\n                P._next._prev = P;\n\n                if (i === P_le - 1) {\n                    P._end = true;\n                    //console.log(\"END\", P._end, P.coords.usrCoords, P._prev.coords.usrCoords, P._next.coords.usrCoords);\n                }\n\n                P_intersect = P_intersect.concat(P_crossings[i]);\n            }\n        }\n        return P_intersect;\n    },\n\n    _inbetween: function (q, p1, p2) {\n        var alpha,\n            eps = Mat.eps * Mat.eps,\n            px = p2[1] - p1[1],\n            py = p2[2] - p1[2],\n            qx = q[1] - p1[1],\n            qy = q[2] - p1[2];\n\n        if (px === 0 && py === 0 && qx === 0 && qy === 0) {\n            // All three points are equal\n            return true;\n        }\n        if (Math.abs(qx) < eps && Math.abs(px) < eps) {\n            alpha = qy / py;\n        } else {\n            alpha = qx / px;\n        }\n        if (Math.abs(alpha) < eps) {\n            alpha = 0.0;\n        }\n        return alpha;\n    },\n\n    _print_array: function (arr) {\n        var i, end;\n        for (i = 0; i < arr.length; i++) {\n            //console.log(i, arr[i].coords.usrCoords,  arr[i].data.type);\n            try {\n                end = \"\";\n                if (arr[i]._end) {\n                    end = \" end\";\n                }\n                console.log(\n                    i,\n                    arr[i].coords.usrCoords,\n                    arr[i].data.type,\n                    \"\\t\",\n                    \"prev\",\n                    arr[i]._prev.coords.usrCoords,\n                    \"next\",\n                    arr[i]._next.coords.usrCoords + end\n                );\n            } catch (e) {\n                console.log(i, arr[i].coords.usrCoords);\n            }\n        }\n    },\n\n    _print_list: function (P) {\n        var cnt = 0,\n            alpha;\n        while (cnt < 100) {\n            if (P.data) {\n                alpha = P.data.alpha;\n            } else {\n                alpha = \"-\";\n            }\n            console.log(\n                \"\\t\",\n                P.coords.usrCoords,\n                \"\\n\\t\\tis:\",\n                P.intersection,\n                \"end:\",\n                P._end,\n                alpha,\n                \"\\n\\t\\t-:\",\n                P._prev.coords.usrCoords,\n                \"\\n\\t\\t+:\",\n                P._next.coords.usrCoords,\n                \"\\n\\t\\tn:\",\n                P.intersection ? P.neighbour.coords.usrCoords : \"-\"\n            );\n            if (P._end) {\n                break;\n            }\n            P = P._next;\n            cnt++;\n        }\n    },\n\n    _noOverlap: function (p1, p2, q1, q2) {\n        var k,\n            eps = Math.sqrt(Mat.eps),\n            minp,\n            maxp,\n            minq,\n            maxq,\n            no_overlap = false;\n\n        for (k = 0; k < 3; k++) {\n            minp = Math.min(p1[k], p2[k]);\n            maxp = Math.max(p1[k], p2[k]);\n            minq = Math.min(q1[k], q2[k]);\n            maxq = Math.max(q1[k], q2[k]);\n            if (maxp < minq - eps || minp > maxq + eps) {\n                no_overlap = true;\n                break;\n            }\n        }\n        return no_overlap;\n    },\n\n    /**\n     * Find all intersections between two paths.\n     * @private\n     * @param  {Array} S     Subject path\n     * @param  {Array} C     Clip path\n     * @param  {JXG.Board} board JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}  Array containing two arrays. The first array contains the intersection vertices\n     * of the subject path and the second array contains the intersection vertices of the clip path.\n     * @see JXG.Clip#Vertex\n     */\n    findIntersections: function (S, C, board) {\n        var res = [],\n            eps = Mat.eps,\n            i,\n            j,\n            crds,\n            S_le = S.length,\n            C_le = C.length,\n            Si,\n            Si1,\n            Cj,\n            Cj1,\n            d1,\n            d2,\n            alpha,\n            type,\n            IS,\n            IC,\n            S_intersect = [],\n            C_intersect = [],\n            S_crossings = [],\n            C_crossings = [],\n            hasMultCompsS = false,\n            hasMultCompsC = false,\n            DEBUG = false;\n\n        for (j = 0; j < C_le; j++) {\n            C_crossings.push([]);\n        }\n\n        // Run through the subject path.\n        for (i = 0; i < S_le; i++) {\n            S_crossings.push([]);\n\n            // Test if S[i] or its successor is a path separator.\n            // If yes, we know that the path consists of multiple components.\n            // We immediately jump to the next segment.\n            if (this._isSeparator(S[i]) || this._isSeparator(S[(i + 1) % S_le])) {\n                hasMultCompsS = true;\n                continue;\n            }\n\n            // If the path consists of multiple components then there is\n            // no path-closing segment between the last node and the first\n            // node. In this case we can leave the loop now.\n            if (hasMultCompsS && i === S_le - 1) {\n                break;\n            }\n\n            Si = S[i].coords.usrCoords;\n            Si1 = S[(i + 1) % S_le].coords.usrCoords;\n            // Run through the clip path.\n            for (j = 0; j < C_le; j++) {\n                // Test if C[j] or its successor is a path separator.\n                // If yes, we know that the path consists of multiple components.\n                // We immediately jump to the next segment.\n                if (this._isSeparator(C[j]) || this._isSeparator(C[(j + 1) % C_le])) {\n                    hasMultCompsC = true;\n                    continue;\n                }\n\n                // If the path consists of multiple components then there is\n                // no path-closing segment between the last node and the first\n                // node. In this case we can leave the loop now.\n                if (hasMultCompsC && j === C_le - 1) {\n                    break;\n                }\n\n                // Test if bounding boxes of the two curve segments overlap\n                // If not, the expensive intersection test can be skipped.\n                Cj = C[j].coords.usrCoords;\n                Cj1 = C[(j + 1) % C_le].coords.usrCoords;\n\n                if (this._noOverlap(Si, Si1, Cj, Cj1)) {\n                    continue;\n                }\n\n                // Intersection test\n                res = Geometry.meetSegmentSegment(Si, Si1, Cj, Cj1);\n\n                d1 = Geometry.distance(Si, Si1, 3);\n                d2 = Geometry.distance(Cj, Cj1, 3);\n\n                // Found an intersection point\n                if (\n                    // \"Regular\" intersection\n                    (res[1] * d1 > -eps &&\n                        res[1] < 1 - eps / d1 &&\n                        res[2] * d2 > -eps &&\n                        res[2] < 1 - eps / d2) ||\n                    // Collinear segments\n                    (res[1] === Infinity && res[2] === Infinity && Mat.norm(res[0], 3) < eps)\n                ) {\n                    crds = new Coords(Const.COORDS_BY_USER, res[0], board);\n                    type = \"X\";\n\n                    // Handle degenerated cases\n                    if (Math.abs(res[1]) * d1 < eps || Math.abs(res[2]) * d2 < eps) {\n                        // Crossing / bouncing at vertex or\n                        // end of delayed crossing / bouncing\n                        type = \"T\";\n                        if (Math.abs(res[1]) * d1 < eps) {\n                            res[1] = 0;\n                        }\n                        if (Math.abs(res[2]) * d2 < eps) {\n                            res[2] = 0;\n                        }\n                        if (res[1] === 0) {\n                            crds = new Coords(Const.COORDS_BY_USER, Si, board);\n                        } else {\n                            crds = new Coords(Const.COORDS_BY_USER, Cj, board);\n                        }\n\n                        if (DEBUG) {\n                            console.log(\n                                \"Degenerate case I\",\n                                res[1],\n                                res[2],\n                                crds.usrCoords,\n                                \"type\",\n                                type\n                            );\n                        }\n                    } else if (\n                        res[1] === Infinity &&\n                        res[2] === Infinity &&\n                        Mat.norm(res[0], 3) < eps\n                    ) {\n                        // console.log(C_intersect);\n\n                        // Collinear segments\n                        // Here, there might be two intersection points to be added\n\n                        alpha = this._inbetween(Si, Cj, Cj1);\n                        if (DEBUG) {\n                            // console.log(\"alpha Si\", alpha, Si);\n                            // console.log(j, Cj)\n                            // console.log((j + 1) % C_le, Cj1)\n                        }\n                        if (alpha >= 0 && alpha < 1) {\n                            type = \"T\";\n                            crds = new Coords(Const.COORDS_BY_USER, Si, board);\n                            res[1] = 0;\n                            res[2] = alpha;\n                            IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n                            IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n                            IS.neighbour = IC;\n                            IC.neighbour = IS;\n                            S_crossings[i].push(IS);\n                            C_crossings[j].push(IC);\n                            if (DEBUG) {\n                                console.log(\n                                    \"Degenerate case II\",\n                                    res[1],\n                                    res[2],\n                                    crds.usrCoords,\n                                    \"type T\"\n                                );\n                            }\n                        }\n                        alpha = this._inbetween(Cj, Si, Si1);\n                        if (DEBUG) {\n                            // console.log(\"alpha Cj\", alpha, Si, Geometry.distance(Si, Cj, 3));\n                        }\n                        if (Geometry.distance(Si, Cj, 3) > eps && alpha >= 0 && alpha < 1) {\n                            type = \"T\";\n                            crds = new Coords(Const.COORDS_BY_USER, Cj, board);\n                            res[1] = alpha;\n                            res[2] = 0;\n                            IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n                            IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n                            IS.neighbour = IC;\n                            IC.neighbour = IS;\n                            S_crossings[i].push(IS);\n                            C_crossings[j].push(IC);\n                            if (DEBUG) {\n                                console.log(\n                                    \"Degenerate case III\",\n                                    res[1],\n                                    res[2],\n                                    crds.usrCoords,\n                                    \"type T\"\n                                );\n                            }\n                        }\n                        continue;\n                    }\n                    if (DEBUG) {\n                        console.log(\"IS\", i, j, crds.usrCoords, type);\n                    }\n\n                    IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n                    IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n                    IS.neighbour = IC;\n                    IC.neighbour = IS;\n\n                    S_crossings[i].push(IS);\n                    C_crossings[j].push(IC);\n                }\n            }\n        }\n\n        // For both paths, sort their intersection points\n        S_intersect = this.sortIntersections(S_crossings);\n\n        if (DEBUG) {\n            console.log(\">>>>>> Intersections \");\n            console.log(\"S_intersect\");\n            this._print_array(S_intersect);\n            console.log(\"----------\");\n        }\n        for (i = 0; i < S_intersect.length; i++) {\n            S_intersect[i].data.idx = i;\n            S_intersect[i].neighbour.data.idx = i;\n        }\n        C_intersect = this.sortIntersections(C_crossings);\n\n        if (DEBUG) {\n            console.log(\"C_intersect\");\n            this._print_array(C_intersect);\n            console.log(\"<<<<<< Phase 1 done\");\n        }\n        return [S_intersect, C_intersect];\n    },\n\n    /**\n     * It is testedd if the point q lies to the left or right\n     * of the poylgonal chain [p1, p2, p3].\n     * @param {Array} q User coords array\n     * @param {Array} p1 User coords array\n     * @param {Array} p2 User coords array\n     * @param {Array} p3 User coords array\n     * @returns string 'left' or 'right'\n     * @private\n     */\n    _getPosition: function (q, p1, p2, p3) {\n        var s1 = Geometry.det3p(q, p1, p2),\n            s2 = Geometry.det3p(q, p2, p3),\n            s3 = Geometry.det3p(p1, p2, p3);\n\n        // Left turn\n        if (s3 >= 0) {\n            if (s1 >= 0 && s2 >= 0) {\n                return \"left\";\n            }\n            return \"right\";\n        }\n        // Right turn\n        if (s1 >= 0 || s2 >= 0) {\n            return \"left\";\n        }\n        return \"right\";\n    },\n\n    /**\n     * Determine the delayed status of degenerated intersection points.\n     * It is of the form\n     *   ['on|left|right', 'on|left|right']\n     * <p>\n     * If all four determinants are zero, we add random noise to the point.\n     *\n     * @param {JXG.Math.Clip.Vertex} P Start of path\n     * @private\n     * @see JXG.Math.Clip#markEntryExit\n     * @see JXG.Math.Clip#_handleIntersectionChains\n     */\n    _classifyDegenerateIntersections: function (P) {\n        var Pp, Pm, Qp, Qm,  Q,\n            side, cnt, tmp, det,\n            oppositeDir,\n            s1, s2, s3, s4,\n            endless = true,\n            DEBUG = false;\n\n        if (DEBUG) {\n            console.log(\n                \"\\n-------------- _classifyDegenerateIntersections()\",\n                Type.exists(P.data) ? P.data.pathname : \" \"\n            );\n        }\n        det = Geometry.det3p;\n        cnt = 0;\n        P._tours = 0;\n        while (endless) {\n            if (DEBUG) {\n                console.log(\"Inspect P:\", P.coords.usrCoords, P.data ? P.data.type : \" \");\n            }\n            if (P.intersection && P.data.type === \"T\") {\n                // Handle the degenerate cases\n                // Decide if they are (delayed) bouncing or crossing intersections\n                Pp = P._next.coords.usrCoords; // P+\n                Pm = P._prev.coords.usrCoords; // P-\n\n                // If the intersection point is degenerated and\n                // equal to the start and end of one component,\n                // then there will be two adjacent points with\n                // the same coordinate.\n                // In that case, we proceed to the next node.\n                if (Geometry.distance(P.coords.usrCoords, Pp, 3) < Mat.eps) {\n                    Pp = P._next._next.coords.usrCoords;\n                }\n                if (Geometry.distance(P.coords.usrCoords, Pm, 3) < Mat.eps) {\n                    Pm = P._prev._prev.coords.usrCoords;\n                }\n\n                Q = P.neighbour;\n                Qm = Q._prev.coords.usrCoords; // Q-\n                Qp = Q._next.coords.usrCoords; // Q+\n                if (Geometry.distance(Q.coords.usrCoords, Qp, 3) < Mat.eps) {\n                    Qp = Q._next._next.coords.usrCoords;\n                }\n                if (Geometry.distance(Q.coords.usrCoords, Qm, 3) < Mat.eps) {\n                    Qm = Q._prev._prev.coords.usrCoords;\n                }\n\n                if (DEBUG) {\n                    console.log(\"P chain:\", Pm, P.coords.usrCoords, Pp);\n                    console.log(\"Q chain:\", Qm, P.neighbour.coords.usrCoords, Qp);\n                    console.log(\"Pm\", this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp));\n                    console.log(\"Pp\", this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp));\n                }\n\n                s1 = det(P.coords.usrCoords, Pm, Qm);\n                s2 = det(P.coords.usrCoords, Pp, Qp);\n                s3 = det(P.coords.usrCoords, Pm, Qp);\n                s4 = det(P.coords.usrCoords, Pp, Qm);\n\n                if (s1 === 0 && s2 === 0 && s3 === 0 && s4 === 0) {\n                    P.coords.usrCoords[1] *= 1 + Math.random() * Mat.eps;\n                    P.coords.usrCoords[2] *= 1 + Math.random() * Mat.eps;\n                    Q.coords.usrCoords[1] = P.coords.usrCoords[1];\n                    Q.coords.usrCoords[2] = P.coords.usrCoords[2];\n                    s1 = det(P.coords.usrCoords, Pm, Qm);\n                    s2 = det(P.coords.usrCoords, Pp, Qp);\n                    s3 = det(P.coords.usrCoords, Pm, Qp);\n                    s4 = det(P.coords.usrCoords, Pp, Qm);\n                    if (DEBUG) {\n                        console.log(\"Random shift\", P.coords.usrCoords);\n                        console.log(s1, s2, s3, s4, s2 === 0);\n                        console.log(\n                            this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp),\n                            this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)\n                        );\n                    }\n                }\n                oppositeDir = false;\n                if (s1 === 0) {\n                    // Q-, Q=P, P- on straight line\n                    if (Geometry.affineRatio(P.coords.usrCoords, Pm, Qm) < 0) {\n                        oppositeDir = true;\n                    }\n                } else if (s2 === 0) {\n                    if (Geometry.affineRatio(P.coords.usrCoords, Pp, Qp) < 0) {\n                        oppositeDir = true;\n                    }\n                } else if (s3 === 0) {\n                    if (Geometry.affineRatio(P.coords.usrCoords, Pm, Qp) > 0) {\n                        oppositeDir = true;\n                    }\n                } else if (s4 === 0) {\n                    if (Geometry.affineRatio(P.coords.usrCoords, Pp, Qm) > 0) {\n                        oppositeDir = true;\n                    }\n                }\n                if (oppositeDir) {\n                    // Swap Qm and Qp\n                    // Then Qm Q Qp has the same direction as Pm P Pp\n                    tmp = Qm;\n                    Qm = Qp;\n                    Qp = tmp;\n                    tmp = s1;\n                    s1 = s3;\n                    s3 = tmp;\n                    tmp = s2;\n                    s2 = s4;\n                    s4 = tmp;\n                }\n\n                if (DEBUG) {\n                    console.log(s1, s2, s3, s4, oppositeDir);\n                }\n\n                if (!Type.exists(P.delayedStatus)) {\n                    P.delayedStatus = [];\n                }\n\n                if (s1 === 0 && s2 === 0) {\n                    // Line [P-,P] equals [Q-,Q] and line [P,P+] equals [Q,Q+]\n                    // Interior of delayed crossing / bouncing\n                    P.delayedStatus = [\"on\", \"on\"];\n                } else if (s1 === 0) {\n                    // P- on line [Q-,Q], P+ not on line [Q,Q+]\n                    // Begin / end of delayed crossing / bouncing\n                    side = this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp);\n                    P.delayedStatus = [\"on\", side];\n                } else if (s2 === 0) {\n                    // P+ on line [Q,Q+], P- not on line [Q-,Q]\n                    // Begin / end of delayed crossing / bouncing\n                    side = this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp);\n                    P.delayedStatus = [side, \"on\"];\n                } else {\n                    // Neither P+ on line [Q,Q+], nor P- on line [Q-,Q]\n                    // No delayed crossing / bouncing\n                    if (P.delayedStatus.length === 0) {\n                        if (\n                            this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp) !==\n                            this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)\n                        ) {\n                            P.data.type = \"X\";\n                        } else {\n                            P.data.type = \"B\";\n                        }\n                    }\n                }\n\n                if (DEBUG) {\n                    console.log(\n                        \">>>> P:\",\n                        P.coords.usrCoords,\n                        \"delayedStatus:\",\n                        P.delayedStatus.toString(),\n                        P.data ? P.data.type : \" \",\n                        \"\\n---\"\n                    );\n                }\n            }\n\n            if (Type.exists(P._tours)) {\n                P._tours++;\n            }\n\n            if (P._tours > 3 || P._end || cnt > 1000) {\n                // Jump out if either\n                // - we reached the end\n                // - there are more than 1000 intersection points\n                // - P._tours > 3: We went already 4 times through this path.\n                if (cnt > 1000) {\n                    console.log(\"Clipping: _classifyDegenerateIntersections exit\");\n                }\n                if (Type.exists(P._tours)) {\n                    delete P._tours;\n                }\n                break;\n            }\n            if (P.intersection) {\n                cnt++;\n            }\n            P = P._next;\n        }\n        if (DEBUG) {\n            console.log(\"------------------------\");\n        }\n    },\n\n    /**\n     * At this point the degenerated intersections have been classified.\n     * Now we decide if the intersection chains of the given path\n     * ultimatively cross the other path or bounce.\n     *\n     * @param {JXG.Math.Clip.Vertex} P Start of path\n     *\n     * @see JXG.Math.Clip#markEntryExit\n     * @see JXG.Math.Clip#_classifyDegenerateIntersections\n     * @private\n     */\n    _handleIntersectionChains: function (P) {\n        var cnt = 0,\n            start_status = \"Null\",\n            P_start,\n            endless = true,\n            intersection_chain = false,\n            wait_for_exit = false,\n            DEBUG = false;\n\n        if (DEBUG) {\n            console.log(\n                \"\\n-------------- _handleIntersectionChains()\",\n                Type.exists(P.data) ? P.data.pathname : \" \"\n            );\n        }\n        while (endless) {\n            if (P.intersection === true) {\n                if (DEBUG) {\n                    if (P.data.type === \"T\") {\n                        console.log(\n                            \"Degenerate point\",\n                            P.coords.usrCoords,\n                            P.data.type,\n                            P.data.type === \"T\" ? P.delayedStatus : \" \"\n                        );\n                    } else {\n                        console.log(\"Intersection point\", P.coords.usrCoords, P.data.type);\n                    }\n                }\n                if (P.data.type === \"T\") {\n                    if (P.delayedStatus[0] !== \"on\" && P.delayedStatus[1] === \"on\") {\n                        // First point of intersection chain\n                        intersection_chain = true;\n                        P_start = P;\n                        start_status = P.delayedStatus[0];\n                    } else if (\n                        intersection_chain &&\n                        P.delayedStatus[0] === \"on\" &&\n                        P.delayedStatus[1] === \"on\"\n                    ) {\n                        // Interior of intersection chain\n                        P.data.type = \"B\";\n                        if (DEBUG) {\n                            console.log(\"Interior\", P.coords.usrCoords);\n                        }\n                    } else if (\n                        intersection_chain &&\n                        P.delayedStatus[0] === \"on\" &&\n                        P.delayedStatus[1] !== \"on\"\n                    ) {\n                        // Last point of intersection chain\n                        intersection_chain = false;\n                        if (start_status === P.delayedStatus[1]) {\n                            // Intersection chain is delayed bouncing\n                            P_start.data.type = \"DB\";\n                            P.data.type = \"DB\";\n                            if (DEBUG) {\n                                console.log(\n                                    \"Chain: delayed bouncing\",\n                                    P_start.coords.usrCoords,\n                                    \"...\",\n                                    P.coords.usrCoords\n                                );\n                            }\n                        } else {\n                            // Intersection chain is delayed crossing\n                            P_start.data.type = \"DX\";\n                            P.data.type = \"DX\";\n                            if (DEBUG) {\n                                console.log(\n                                    \"Chain: delayed crossing\",\n                                    P_start.coords.usrCoords,\n                                    \"...\",\n                                    P.coords.usrCoords\n                                );\n                            }\n                        }\n                    }\n                }\n                cnt++;\n            }\n            if (P._end) {\n                wait_for_exit = true;\n            }\n            if (wait_for_exit && !intersection_chain) {\n                break;\n            }\n            if (cnt > 1000) {\n                console.log(\n                    \"Warning: _handleIntersectionChains: intersection chain reached maximum numbers of iterations\"\n                );\n                break;\n            }\n            P = P._next;\n        }\n    },\n\n    /**\n     * Handle the case that all vertices of one path are contained\n     * in the other path. In this case we search for a midpoint of an edge\n     * which is not contained in the other path and add it to the path.\n     * It will be used as starting point for the entry/exit algorithm.\n     *\n     * @private\n     * @param {Array} S Subject path\n     * @param {Array} C Clip path\n     * @param {JXG.board} board JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     */\n    _handleFullyDegenerateCase: function (S, C, board) {\n        var P,\n            Q,\n            l,\n            M,\n            crds,\n            q1,\n            q2,\n            node,\n            i,\n            j,\n            leP,\n            leQ,\n            is_on_Q,\n            tmp,\n            is_fully_degenerated,\n            arr = [S, C];\n\n        for (l = 0; l < 2; l++) {\n            P = arr[l];\n            leP = P.length;\n            for (i = 0, is_fully_degenerated = true; i < leP; i++) {\n                if (!P[i].intersection) {\n                    is_fully_degenerated = false;\n                    break;\n                }\n            }\n\n            if (is_fully_degenerated) {\n                // All nodes of P are also on the other path.\n                Q = arr[(l + 1) % 2];\n                leQ = Q.length;\n\n                // We search for a midpoint of one edge of P which is not the other path and\n                // we add that midpoint to P.\n                for (i = 0; i < leP; i++) {\n                    q1 = P[i].coords.usrCoords;\n                    q2 = P[i]._next.coords.usrCoords;\n\n                    // M is the midpoint\n                    M = [(q1[0] + q2[0]) * 0.5, (q1[1] + q2[1]) * 0.5, (q1[2] + q2[2]) * 0.5];\n\n                    // Test if M is on path Q. If this is not the case,\n                    // we take M as additional point of P.\n                    for (j = 0, is_on_Q = false; j < leQ; j++) {\n                        if (\n                            Math.abs(\n                                Geometry.det3p(\n                                    Q[j].coords.usrCoords,\n                                    Q[(j + 1) % leQ].coords.usrCoords,\n                                    M\n                                )\n                            ) < Mat.eps\n                        ) {\n                            is_on_Q = true;\n                            break;\n                        }\n                    }\n                    if (!is_on_Q) {\n                        // The midpoint is added to the doubly-linked list.\n                        crds = new Coords(Const.COORDS_BY_USER, M, board);\n                        node = {\n                            pos: i,\n                            intersection: false,\n                            coords: crds,\n                            elementClass: Const.OBJECT_CLASS_POINT\n                        };\n\n                        tmp = P[i]._next;\n                        P[i]._next = node;\n                        node._prev = P[i];\n                        node._next = tmp;\n                        tmp._prev = node;\n\n                        if (P[i]._end) {\n                            P[i]._end = false;\n                            node._end = true;\n                        }\n\n                        break;\n                    }\n                }\n            }\n        }\n    },\n\n    _getStatus: function (P, path) {\n        var status;\n        while (P.intersection) {\n            if (P._end) {\n                break;\n            }\n            P = P._next;\n        }\n        if (Geometry.windingNumber(P.coords.usrCoords, path) === 0) {\n            // Outside\n            status = \"entry\";\n            // console.log(P.coords.usrCoords, ' is outside')\n        } else {\n            // Inside\n            status = \"exit\";\n            // console.log(P.coords.usrCoords, ' is inside')\n        }\n\n        return [P, status];\n    },\n\n    /**\n     * Mark the intersection vertices of path1 as entry points or as exit points\n     * in respect to path2.\n     * <p>\n     * This is the simple algorithm as in\n     * Greiner, Günther; Kai Hormann (1998). \"Efficient clipping of arbitrary polygons\".\n     * ACM Transactions on Graphics. 17 (2): 71–83\n     * <p>\n     * The algorithm handles also \"delayed crossings\" from\n     * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),\n     * \"Clipping simple polygons with degenerate intersections\", Computers & Graphics:X, 2.\n     * and - as an additional improvement -\n     * handles self intersections of delayed crossings (A.W. 2021).\n     *\n     * @private\n     * @param  {Array} path1 First path\n     * @param  {Array} path2 Second path\n     */\n    markEntryExit: function (path1, path2, starters) {\n        var status, P, cnt, res,\n            i, len, start,\n            endless = true,\n            chain_start = null,\n            intersection_chain = 0,\n            DEBUG = false;\n\n        len = starters.length;\n        for (i = 0; i < len; i++) {\n            start = starters[i];\n            if (DEBUG) {\n                console.log(\n                    \"\\n;;;;;;;;;; Labelling phase\",\n                    Type.exists(path1[start].data) ? path1[start].data.pathname : \" \",\n                    path1[start].coords.usrCoords\n                );\n            }\n            this._classifyDegenerateIntersections(path1[start]);\n            this._handleIntersectionChains(path1[start]);\n            if (DEBUG) {\n                console.log(\"\\n---- back to markEntryExit\");\n            }\n\n            // Decide if the first point of the component is inside or outside\n            // of the other path.\n            res = this._getStatus(path1[start], path2);\n            P = res[0];\n            status = res[1];\n            if (DEBUG) {\n                console.log(\"Start node:\", P.coords.usrCoords, status);\n            }\n\n            P._starter = true;\n\n            // Greiner-Hormann entry/exit algorithm\n            // with additional handling of delayed crossing / bouncing\n            cnt = 0;\n            chain_start = null;\n            intersection_chain = 0;\n\n            while (endless) {\n                if (P.intersection === true) {\n                    if (P.data.type === \"X\" && intersection_chain === 1) {\n                        // While we are in an intersection chain, i.e. a delayed crossing,\n                        // we stumble on a crossing intersection.\n                        // Probably, the other path is self intersecting.\n                        // We end the intersection chain here and\n                        // mark this event by setting intersection_chain = 2.\n                        chain_start.entry_exit = status;\n                        if (status === \"exit\") {\n                            chain_start.data.type = \"X\";\n                        }\n                        intersection_chain = 2;\n                    }\n\n                    if (P.data.type === \"X\" || P.data.type === \"DB\") {\n                        P.entry_exit = status;\n                        status = status === \"entry\" ? \"exit\" : \"entry\";\n                        if (DEBUG) {\n                            console.log(\"mark:\", P.coords.usrCoords, P.data.type, P.entry_exit);\n                        }\n                    }\n\n                    if (P.data.type === \"DX\") {\n                        if (intersection_chain === 0) {\n                            // Start of intersection chain.\n                            // No active intersection chain yet,\n                            // i.e. we did not pass a the first node of a delayed crossing.\n                            chain_start = P;\n                            intersection_chain = 1;\n                            if (DEBUG) {\n                                console.log(\n                                    \"Start intersection chain:\",\n                                    P.coords.usrCoords,\n                                    P.data.type,\n                                    status\n                                );\n                            }\n                        } else if (intersection_chain === 1) {\n                            // Active intersection chain (intersection_chain===1)!\n                            // End of delayed crossing chain reached\n                            P.entry_exit = status;\n                            chain_start.entry_exit = status;\n                            if (status === \"exit\") {\n                                chain_start.data.type = \"X\";\n                            } else {\n                                P.data.type = \"X\";\n                            }\n                            status = status === \"entry\" ? \"exit\" : \"entry\";\n\n                            if (DEBUG) {\n                                console.log(\n                                    \"mark':\",\n                                    chain_start.coords.usrCoords,\n                                    chain_start.data.type,\n                                    chain_start.entry_exit\n                                );\n                                console.log(\n                                    \"mark:\",\n                                    P.coords.usrCoords,\n                                    P.data.type,\n                                    P.entry_exit\n                                );\n                            }\n                            chain_start = null;\n                            intersection_chain = 0;\n                        } else if (intersection_chain === 2) {\n                            // The delayed crossing had been interrupted by a crossing intersection.\n                            // Now we treat the end of the delayed crossing as regular crossing.\n                            P.entry_exit = status;\n                            P.data.type = \"X\";\n                            status = status === \"entry\" ? \"exit\" : \"entry\";\n                            chain_start = null;\n                            intersection_chain = 0;\n                        }\n                    }\n                }\n\n                P = P._next;\n                if (Type.exists(P._starter) || cnt > 10000) {\n                    break;\n                }\n\n                cnt++;\n            }\n        }\n    },\n\n    /**\n     *\n     * @private\n     * @param {Array} P\n     * @param {Boolean} isBackward\n     * @returns {Boolean} True, if the node is an intersection and is of type 'X'\n     */\n    _stayOnPath: function (P, status) {\n        var stay = true;\n\n        if (P.intersection && P.data.type !== \"B\") {\n            stay = status === P.entry_exit;\n        }\n        return stay;\n    },\n\n    /**\n     * Add a point to the clipping path and returns if the algorithms\n     * arrived at an intersection point which has already been visited.\n     * In this case, true is returned.\n     *\n     * @param {Array} path Resulting path\n     * @param {JXG.Math.Clip.Vertex} vertex Point to be added\n     * @param {Boolean} DEBUG debug output to console.log\n     * @returns {Boolean} true: point has been visited before, false otherwise\n     * @private\n     */\n    _addVertex: function (path, vertex, DEBUG) {\n        if (!isNaN(vertex.coords.usrCoords[1]) && !isNaN(vertex.coords.usrCoords[2])) {\n            path.push(vertex);\n        }\n        if (vertex.intersection && vertex.data.done) {\n            if (DEBUG) {\n                console.log(\n                    \"Add last intersection point\",\n                    vertex.coords.usrCoords,\n                    \"on\",\n                    vertex.data.pathname,\n                    vertex.entry_exit,\n                    vertex.data.type\n                );\n            }\n            return true;\n        }\n        if (vertex.intersection) {\n            vertex.data.done = true;\n\n            if (DEBUG) {\n                console.log(\n                    \"Add intersection point\",\n                    vertex.coords.usrCoords,\n                    \"on\",\n                    vertex.data.pathname,\n                    vertex.entry_exit,\n                    vertex.data.type\n                );\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Tracing phase of the Greiner-Hormann algorithm, see\n     * Greiner, Günther; Kai Hormann (1998).\n     * \"Efficient clipping of arbitrary polygons\". ACM Transactions on Graphics. 17 (2): 71–83\n     *\n     * Boolean operations on polygons are distinguished: 'intersection', 'union', 'difference'.\n     *\n     * @private\n     * @param  {Array} S           Subject path\n     * @param  {Array} S_intersect Array containing the intersection vertices of the subject path\n     * @param  {String} clip_type  contains the Boolean operation: 'intersection', 'union', or 'difference'\n     * @return {Array}             Array consisting of two arrays containing the x-coordinates and the y-coordintaes of\n     *      the resulting path.\n     */\n    tracing: function (S, S_intersect, clip_type) {\n        var P,\n            current,\n            start,\n            cnt = 0,\n            status,\n            maxCnt = 10000,\n            S_idx = 0,\n            path = [],\n            done = false,\n            DEBUG = false;\n\n        if (DEBUG) {\n            console.log(\"\\n------ Start Phase 3\");\n        }\n\n        // reverse = (clip_type === 'difference' || clip_type === 'union') ? true : false;\n        while (S_idx < S_intersect.length && cnt < maxCnt) {\n            // Take the first intersection node of the subject path\n            // which is not yet included as start point.\n            current = S_intersect[S_idx];\n            if (\n                current.data.done ||\n                current.data.type !== \"X\" /*|| !this._isCrossing(current, reverse)*/\n            ) {\n                S_idx++;\n                continue;\n            }\n\n            if (DEBUG) {\n                console.log(\n                    \"\\nStart\",\n                    current.data.pathname,\n                    current.coords.usrCoords,\n                    current.data.type,\n                    current.entry_exit,\n                    S_idx\n                );\n            }\n            if (path.length > 0) {\n                // Add a new path\n                path.push([NaN, NaN]);\n            }\n\n            // Start now the tracing with that node of the subject path\n            start = current.data.idx;\n            P = S;\n\n            done = this._addVertex(path, current, DEBUG);\n            status = current.entry_exit;\n            do {\n                if (done) {\n                    break;\n                }\n                //\n                // Decide if we follow the current path forward or backward.\n                // for example, in case the clipping is of type \"intersection\"\n                // and the current intersection node is of type entry, we go forward.\n                //\n                if (\n                    (clip_type === \"intersection\" && current.entry_exit === \"entry\") ||\n                    (clip_type === \"union\" && current.entry_exit === \"exit\") ||\n                    (clip_type === \"difference\" &&\n                        (P === S) === (current.entry_exit === \"exit\"))\n                ) {\n                    if (DEBUG) {\n                        console.log(\"Go forward on\", current.data.pathname, current.entry_exit);\n                    }\n\n                    //\n                    // Take the next nodes and add them to the path\n                    // as long as they are not intersection nodes of type 'X'.\n                    //\n                    do {\n                        current = current._next;\n                        done = this._addVertex(path, current, DEBUG);\n                        if (done) {\n                            break;\n                        }\n                    } while (this._stayOnPath(current, status));\n                    cnt++;\n                } else {\n                    if (DEBUG) {\n                        console.log(\"Go backward on\", current.data.pathname);\n                    }\n                    //\n                    // Here, we go backward:\n                    // Take the previous nodes and add them to the path\n                    // as long as they are not intersection nodes of type 'X'.\n                    //\n                    do {\n                        current = current._prev;\n                        done = this._addVertex(path, current, DEBUG);\n                        if (done) {\n                            break;\n                        }\n                    } while (this._stayOnPath(current, status));\n                    cnt++;\n                }\n\n                if (done) {\n                    break;\n                }\n\n                if (!current.neighbour) {\n                    console.log(\n                        \"Tracing: emergency break - no neighbour!!!!!!!!!!!!!!!!!\",\n                        cnt\n                    );\n                    return [[0], [0]];\n                }\n                //\n                // We stopped the forward or backward loop, because we've\n                // arrived at a crossing intersection node, i.e. we have to\n                // switch to the other path now.\n                if (DEBUG) {\n                    console.log(\n                        \"Switch from\",\n                        current.coords.usrCoords,\n                        current.data.pathname,\n                        \"to\",\n                        current.neighbour.coords.usrCoords,\n                        \"on\",\n                        current.neighbour.data.pathname\n                    );\n                }\n                current = current.neighbour;\n                if (current.data.done) {\n                    break;\n                }\n                current.data.done = true;\n                status = current.entry_exit;\n\n                // if (current.data.done) {\n                //     // We arrived at an intersection node which is already\n                //     // added to the clipping path.\n                //     // We add it again to close the clipping path and jump out of the\n                //     // loop.\n                //     path.push(current);\n                //     if (DEBUG) {\n                //         console.log(\"Push last\", current.coords.usrCoords);\n                //     }\n                //     break;\n                // }\n                P = current.data.path;\n\n                // Polygon closed:\n                // if (DEBUG) {\n                //     console.log(\"End of loop:\", \"start=\", start, \"idx=\", current.data.idx);\n                // }\n                // } while (!(current.data.pathname === 'S' && current.data.idx === start) && cnt < maxCnt);\n            } while (current.data.idx !== start && cnt < maxCnt);\n\n            if (cnt >= maxCnt) {\n                console.log(\"Tracing: stopping an infinite loop!\", cnt);\n            }\n\n            S_idx++;\n        }\n        return this._getCoordsArrays(path, false);\n    },\n\n    /**\n     * Handle path clipping if one of the two paths is empty.\n     * @private\n     * @param  {Array} S        First path, array of JXG.Coords\n     * @param  {Array} C        Second path, array of JXG.Coords\n     * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.\n     * @return {Boolean}        true, if one of the input paths is empty, false otherwise.\n     */\n    isEmptyCase: function (S, C, clip_type) {\n        if (clip_type === \"intersection\" && (S.length === 0 || C.length === 0)) {\n            return true;\n        }\n        if (clip_type === \"union\" && S.length === 0 && C.length === 0) {\n            return true;\n        }\n        if (clip_type === \"difference\" && S.length === 0) {\n            return true;\n        }\n\n        return false;\n    },\n\n    _getCoordsArrays: function (path, doClose) {\n        var pathX = [],\n            pathY = [],\n            i,\n            le = path.length;\n\n        for (i = 0; i < le; i++) {\n            if (path[i].coords) {\n                pathX.push(path[i].coords.usrCoords[1]);\n                pathY.push(path[i].coords.usrCoords[2]);\n            } else {\n                pathX.push(path[i][0]);\n                pathY.push(path[i][1]);\n            }\n        }\n        if (doClose && le > 0) {\n            if (path[0].coords) {\n                pathX.push(path[0].coords.usrCoords[1]);\n                pathY.push(path[0].coords.usrCoords[2]);\n            } else {\n                pathX.push(path[0][0]);\n                pathY.push(path[0][1]);\n            }\n        }\n\n        return [pathX, pathY];\n    },\n\n    /**\n     * Handle cases when there are no intersection points of the two paths. This is the case if the\n     * paths are disjoint or one is contained in the other.\n     * @private\n     * @param  {Array} S        First path, array of JXG.Coords\n     * @param  {Array} C        Second path, array of JXG.Coords\n     * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     */\n    handleEmptyIntersection: function (S, C, clip_type) {\n        var P,\n            Q,\n            doClose = false,\n            path = [];\n\n        // Handle trivial cases\n        if (S.length === 0) {\n            if (clip_type === \"union\") {\n                // S cup C = C\n                path = C;\n            } else {\n                // S cap C = S \\ C = {}\n                path = [];\n            }\n            return this._getCoordsArrays(path, true);\n        }\n        if (C.length === 0) {\n            if (clip_type === \"intersection\") {\n                // S cap C = {}\n                path = [];\n            } else {\n                // S cup C = S \\ C = S\n                path = S;\n            }\n            return this._getCoordsArrays(path, true);\n        }\n\n        // From now on, both paths have non-zero length.\n        // The two paths have no crossing intersections,\n        // but there might be bouncing intersections.\n\n        // First, we find -- if possible -- on each path a point which is not an intersection point.\n        if (S.length > 0) {\n            P = S[0];\n            while (P.intersection) {\n                P = P._next;\n                if (P._end) {\n                    break;\n                }\n            }\n        }\n        if (C.length > 0) {\n            Q = C[0];\n            while (Q.intersection) {\n                Q = Q._next;\n                if (Q._end) {\n                    break;\n                }\n            }\n        }\n\n        // Test if one curve is contained by the other\n        if (Geometry.windingNumber(P.coords.usrCoords, C) === 0) {\n            // P is outside of C:\n            // Either S is disjoint from C or C is inside of S\n            if (Geometry.windingNumber(Q.coords.usrCoords, S) !== 0) {\n                // C is inside of S, i.e. C subset of S\n\n                if (clip_type === \"union\") {\n                    path = path.concat(S);\n                    path.push(S[0]);\n                } else if (clip_type === \"difference\") {\n                    path = path.concat(S);\n                    path.push(S[0]);\n                    if (Geometry.signedPolygon(S) * Geometry.signedPolygon(C) > 0) {\n                        // Pathes have same orientation, we have to revert one.\n                        path.reverse();\n                    }\n                    path.push([NaN, NaN]);\n                }\n                if (clip_type === \"difference\" || clip_type === \"intersection\") {\n                    path = path.concat(C);\n                    path.push(C[0]);\n                    doClose = false;\n                }\n            } else {\n                // The curves are disjoint\n                if (clip_type === \"difference\") {\n                    path = path.concat(S);\n                    doClose = true;\n                } else if (clip_type === \"union\") {\n                    path = path.concat(S);\n                    path.push(S[0]);\n                    path.push([NaN, NaN]);\n                    path = path.concat(C);\n                    path.push(C[0]);\n                }\n            }\n        } else {\n            // S inside of C, i.e. S subset of C\n            if (clip_type === \"intersection\") {\n                path = path.concat(S);\n                doClose = true;\n            } else if (clip_type === \"union\") {\n                path = path.concat(C);\n                path.push(C[0]);\n            }\n\n            // 'difference': path is empty\n        }\n\n        return this._getCoordsArrays(path, doClose);\n    },\n\n    /**\n     * Count intersection points of type 'X'.\n     * @param {JXG.Mat.Clip.Vertex} intersections\n     * @returns Number\n     * @private\n     */\n    _countCrossingIntersections: function (intersections) {\n        var i,\n            le = intersections.length,\n            sum = 0;\n\n        for (i = 0; i < le; i++) {\n            if (intersections[i].data.type === \"X\") {\n                sum++;\n            }\n        }\n        return sum;\n    },\n\n    /**\n     * Create path from all sorts of input elements and convert it\n     * to a suitable input path for greinerHormann().\n     *\n     * @private\n     * @param {Object} obj Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n     * array of coordinate pairs.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @returns {Array} Array of JXG.Coords elements containing a path.\n     * @see JXG.Math.Clip#greinerHormann\n     */\n    _getPath: function (obj, board) {\n        var i,\n            len,\n            r,\n            rad,\n            angle,\n            alpha,\n            steps,\n            S = [];\n\n        // Collect all points into path array S\n        if (\n            obj.elementClass === Const.OBJECT_CLASS_CURVE &&\n            (obj.type === Const.OBJECT_TYPE_ARC || obj.type === Const.OBJECT_TYPE_SECTOR)\n        ) {\n            angle = Geometry.rad(obj.radiuspoint, obj.center, obj.anglepoint);\n            steps = Math.floor((angle * 180) / Math.PI);\n            r = obj.Radius();\n            rad = angle / steps;\n            alpha = Math.atan2(\n                obj.radiuspoint.coords.usrCoords[2] - obj.center.coords.usrCoords[2],\n                obj.radiuspoint.coords.usrCoords[1] - obj.center.coords.usrCoords[1]\n            );\n\n            if (obj.type === Const.OBJECT_TYPE_SECTOR) {\n                this._addToList(S, obj.center.coords, 0);\n            }\n            for (i = 0; i <= steps; i++) {\n                this._addToList(\n                    S,\n                    new Coords(\n                        Const.COORDS_BY_USER,\n                        [\n                            obj.center.coords.usrCoords[0],\n                            obj.center.coords.usrCoords[1] + Math.cos(i * rad + alpha) * r,\n                            obj.center.coords.usrCoords[2] + Math.sin(i * rad + alpha) * r\n                        ],\n                        board\n                    ),\n                    i + 1\n                );\n            }\n            if (obj.type === Const.OBJECT_TYPE_SECTOR) {\n                this._addToList(S, obj.center.coords, steps + 2);\n            }\n        } else if (obj.elementClass === Const.OBJECT_CLASS_CURVE && Type.exists(obj.points)) {\n            len = obj.numberPoints;\n            for (i = 0; i < len; i++) {\n                this._addToList(S, obj.points[i], i);\n            }\n        } else if (obj.type === Const.OBJECT_TYPE_POLYGON) {\n            for (i = 0; i < obj.vertices.length; i++) {\n                this._addToList(S, obj.vertices[i].coords, i);\n            }\n        } else if (obj.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n            steps = 359;\n            r = obj.Radius();\n            rad = (2 * Math.PI) / steps;\n            for (i = 0; i <= steps; i++) {\n                this._addToList(\n                    S,\n                    new Coords(\n                        Const.COORDS_BY_USER,\n                        [\n                            obj.center.coords.usrCoords[0],\n                            obj.center.coords.usrCoords[1] + Math.cos(i * rad) * r,\n                            obj.center.coords.usrCoords[2] + Math.sin(i * rad) * r\n                        ],\n                        board\n                    ),\n                    i\n                );\n            }\n        } else if (Type.isArray(obj)) {\n            len = obj.length;\n            for (i = 0; i < len; i++) {\n                if (Type.exists(obj[i].coords)) {\n                    // Point type\n                    this._addToList(S, obj[i].coords, i);\n                } else if (Type.isArray(obj[i])) {\n                    // Coordinate pair\n                    this._addToList(S, new Coords(Const.COORDS_BY_USER, obj[i], board), i);\n                } else if (Type.exists(obj[i].usrCoords)) {\n                    // JXG.Coordinates\n                    this._addToList(S, obj[i], i);\n                }\n            }\n        }\n\n        return S;\n    },\n\n    /**\n     * Determine the intersection, union or difference of two closed paths.\n     * <p>\n     * This is an implementation of the Greiner-Hormann algorithm, see\n     * Günther Greiner and Kai Hormann (1998).\n     * \"Efficient clipping of arbitrary polygons\". ACM Transactions on Graphics. 17 (2): 71–83.\n     * and\n     * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),\n     * \"Clipping simple polygons with degenerate intersections\", Computers & Graphics:X, 2.\n     * <p>\n     * It is assumed that the pathes are closed, whereby it does not matter if the last point indeed\n     * equals the first point. In contrast to the original Greiner-Hormann algorithm,\n     * this algorithm can cope with many degenerate cases. A degenerate case is a vertext of one path\n     * which is contained in the other path.\n     * <p>\n     *\n     * <p>Problematic are:\n     * <ul>\n     *   <li>degenerate cases where one path additionally has self-intersections\n     *   <li>differences with one path having self-intersections.\n     * </ul>\n     *\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path, usually called 'subject'.\n     * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n     * array of coordinate pairs.\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path, usually called 'clip'.\n     * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n     * array of coordinate pairs.\n     * @param  {String} clip_type Determines the type of boolean operation on the two paths.\n     *  Possible values are 'intersection', 'union', or 'difference'.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     *\n     * @see JXG.Math.Clip#intersection\n     * @see JXG.Math.Clip#union\n     * @see JXG.Math.Clip#difference\n     *\n     * @example\n     *     var curve1 = board.create('curve', [\n     *             [-3, 3, 0, -3],\n     *             [3, 3, 0, 3]\n     *         ],\n     *         {strokeColor: 'black'});\n     *\n     *     var curve2 = board.create('curve', [\n     *             [-4, 4, 0, -4],\n     *             [2, 2, 4, 2]\n     *         ],\n     *         {strokeColor: 'blue'});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);\n     *\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *\n     *         var curve1 = board.create('curve', [\n     *                 [-3, 3, 0, -3],\n     *                 [3, 3, 0, 3]\n     *             ],\n     *             {strokeColor: 'black'});\n     *\n     *         var curve2 = board.create('curve', [\n     *                 [-4, 4, 0, -4],\n     *                 [2, 2, 4, 2]\n     *             ],\n     *             {strokeColor: 'blue'});\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);\n     *\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     * @example\n     *     var curve1 = board.create('curve', [\n     *             [-3, 3, 0, -3],\n     *             [3, 3, 0, 3]\n     *         ],\n     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n     *             {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXG6075c918-4d57-4b72-b600-6597a6a4f44e\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG6075c918-4d57-4b72-b600-6597a6a4f44e',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *         var curve1 = board.create('curve', [\n     *                 [-3, 3, 0, -3],\n     *                 [3, 3, 0, 3]\n     *             ],\n     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n     *                 {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     * @example\n     *     var curve1 = board.create('curve', [\n     *             [-4, 4, 0, -4],\n     *             [4, 4, -2, 4]\n     *         ],\n     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *     var curve2 = board.create('circle', [[0, 0], [0, -2]],\n     *             {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,\n     *             center: {visible: true, size: 5}, point2: {size: 5}});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);\n     *\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXG46b3316b-5ab9-4928-9473-ccb476ca4185\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG46b3316b-5ab9-4928-9473-ccb476ca4185',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *         var curve1 = board.create('curve', [\n     *                 [-4, 4, 0, -4],\n     *                 [4, 4, -2, 4]\n     *             ],\n     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *         var curve2 = board.create('circle', [[0, 0], [0, -2]],\n     *                 {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,\n     *                 center: {visible: true, size: 5}, point2: {size: 5}});\n     *\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);\n     *\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     * @example\n     * var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});\n     * clip_path.updateDataArray = function() {\n     *     var bbox = this.board.getBoundingBox(),\n     *         canvas, triangle;\n     *\n     *     canvas = [[bbox[0], bbox[1]], // ul\n     *          [bbox[0], bbox[3]], // ll\n     *          [bbox[2], bbox[3]], // lr\n     *          [bbox[2], bbox[1]], // ur\n     *          [bbox[0], bbox[1]]] // ul\n     *     triangle = [[-1,1], [1,1], [0,-1], [-1,1]];\n     *\n     *     var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);\n     *     this.dataX = a[0];\n     *     this.dataY = a[1];\n     * };\n     *\n     * </pre><div id=\"JXGe94da07a-2a01-4498-ad62-f71a327f8e25\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXGe94da07a-2a01-4498-ad62-f71a327f8e25',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});\n     *     clip_path.updateDataArray = function() {\n     *         var bbox = this.board.getBoundingBox(),\n     *             canvas, triangle;\n     *\n     *         canvas = [[bbox[0], bbox[1]], // ul\n     *              [bbox[0], bbox[3]], // ll\n     *              [bbox[2], bbox[3]], // lr\n     *              [bbox[2], bbox[1]], // ur\n     *              [bbox[0], bbox[1]]] // ul\n     *         triangle = [[-1,1], [1,1], [0,-1], [-1,1]];\n     *\n     *         var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    greinerHormann: function (subject, clip, clip_type, board) {\n        //},\n        // subject_first_point_type, clip_first_point_type) {\n\n        var len,\n            S = [],\n            C = [],\n            S_intersect = [],\n            // C_intersect = [],\n            S_starters,\n            C_starters,\n            res = [],\n            DEBUG = false;\n\n        if (DEBUG) {\n            console.log(\"\\n------------ GREINER-HORMANN --------------\");\n        }\n        // Collect all subject points into subject array S\n        S = this._getPath(subject, board);\n        len = S.length;\n        if (\n            len > 0 &&\n            Geometry.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < Mat.eps\n        ) {\n            S.pop();\n        }\n\n        // Collect all points into clip array C\n        C = this._getPath(clip, board);\n        len = C.length;\n        if (\n            len > 0 &&\n            Geometry.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) <\n                Mat.eps * Mat.eps\n        ) {\n            C.pop();\n        }\n\n        // Handle cases where at least one of the paths is empty\n        if (this.isEmptyCase(S, C, clip_type)) {\n            return [[], []];\n        }\n\n        // Add pointers for doubly linked lists\n        S_starters = this.makeDoublyLinkedList(S);\n        C_starters = this.makeDoublyLinkedList(C);\n\n        if (DEBUG) {\n            this._print_array(S);\n            console.log(\"Components:\", S_starters);\n            this._print_array(C);\n            console.log(\"Components:\", C_starters);\n        }\n\n        res = this.findIntersections(S, C, board);\n        S_intersect = res[0];\n\n        this._handleFullyDegenerateCase(S, C, board);\n\n        // Phase 2: mark intersection points as entry or exit points\n        this.markEntryExit(S, C, S_starters);\n\n        // if (S[0].coords.distance(Const.COORDS_BY_USER, C[0].coords) === 0) {\n        //     // Randomly disturb the first point of the second path\n        //     // if both paths start at the same point.\n        //     C[0].usrCoords[1] *= 1 + Math.random() * 0.0001 - 0.00005;\n        //     C[0].usrCoords[2] *= 1 + Math.random() * 0.0001 - 0.00005;\n        // }\n        this.markEntryExit(C, S, C_starters);\n\n        // Handle cases without intersections\n        if (this._countCrossingIntersections(S_intersect) === 0) {\n            return this.handleEmptyIntersection(S, C, clip_type);\n        }\n\n        // Phase 3: tracing\n        return this.tracing(S, S_intersect, clip_type);\n    },\n\n    /**\n     * Union of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.\n     * Computed by the Greiner-Hormann algorithm.\n     *\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     *\n     * @see JXG.Math.Clip#greinerHormann\n     * @see JXG.Math.Clip#intersection\n     * @see JXG.Math.Clip#difference\n     *\n     * @example\n     *     var curve1 = board.create('curve', [\n     *             [-3, 3, 0, -3],\n     *             [3, 3, 0, 3]\n     *         ],\n     *         {strokeColor: 'black'});\n     *\n     *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n     *             {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.union(curve1, curve2, this.board);\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXG7c5204aa-3824-4464-819c-80df7bf1d917\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG7c5204aa-3824-4464-819c-80df7bf1d917',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *         var curve1 = board.create('curve', [\n     *                 [-3, 3, 0, -3],\n     *                 [3, 3, 0, 3]\n     *             ],\n     *             {strokeColor: 'black'});\n     *\n     *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n     *                 {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.union(curve1, curve2, this.board);\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    union: function (path1, path2, board) {\n        return this.greinerHormann(path1, path2, \"union\", board);\n    },\n\n    /**\n     * Intersection of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.\n     * Computed by the Greiner-Hormann algorithm.\n     *\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     *\n     * @see JXG.Math.Clip#greinerHormann\n     * @see JXG.Math.Clip#union\n     * @see JXG.Math.Clip#difference\n     *\n     * @example\n     * var p = [];\n     * p.push(board.create('point', [0, -5]));\n     * p.push(board.create('point', [-5, 0]));\n     * p.push(board.create('point', [-3, 3]));\n     *\n     * var curve1 = board.create('ellipse', p,\n     *                 {strokeColor: 'black'});\n     *\n     * var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },\n     *                                     [0, 0],\n     *                                     0, 2 * Math.PI],\n     *                       {curveType:'polar', strokeColor: 'blue', strokewidth:1});\n     *\n     * var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     * clip_path.updateDataArray = function() {\n     *     var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);\n     *\n     *     this.dataX = a[0];\n     *     this.dataY = a[1];\n     * };\n     *\n     * board.update();\n     *\n     * </pre><div id=\"JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var p = [];\n     *     p.push(board.create('point', [0, -5]));\n     *     p.push(board.create('point', [-5, 0]));\n     *     p.push(board.create('point', [-3, 3]));\n     *\n     *     var curve1 = board.create('ellipse', p,\n     *                     {strokeColor: 'black'});\n     *\n     *     var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },\n     *                                         [0, 0],\n     *                                         0, 2 * Math.PI],\n     *                           {curveType:'polar', strokeColor: 'blue', strokewidth:1});\n     *\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);\n     *\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     *\n     */\n    intersection: function (path1, path2, board) {\n        return this.greinerHormann(path1, path2, \"intersection\", board);\n    },\n\n    /**\n     * Difference of two closed paths, i.e. path1 minus path2.\n     * The paths could be JSXGraph elements circle, curve, or polygon.\n     * Computed by the Greiner-Hormann algorithm.\n     *\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     *\n     * @see JXG.Math.Clip#greinerHormann\n     * @see JXG.Math.Clip#intersection\n     * @see JXG.Math.Clip#union\n     *\n     * @example\n     *     var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],\n     *             {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *     var curve2 = board.create('curve', [\n     *             [-1, 1, 0, -1],\n     *             [1, 1, 3, 1]\n     *         ],\n     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.difference(curve1, curve2, this.board);\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *         var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],\n     *                 {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *         var curve2 = board.create('curve', [\n     *                 [-1, 1, 0, -1],\n     *                 [1, 1, 3, 1]\n     *             ],\n     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.difference(curve1, curve2, this.board);\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    difference: function (path1, path2, board) {\n        return this.greinerHormann(path1, path2, \"difference\", board);\n    }\n}; //);\n\nJXG.extend(Mat.Clip, /** @lends JXG.Math.Clip */ {});\n\nexport default Mat.Clip;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the namespace Math.Poly is defined, which holds algorithms to create and\n * manipulate polynomials.\n */\n\nimport JXG from \"../jxg\";\nimport Mat from \"./math\";\nimport Type from \"../utils/type\";\n\n/**\n * The JXG.Math.Poly namespace holds algorithms to create and manipulate polynomials.\n * @name JXG.Math.Poly\n * @exports Mat.Poly as JXG.Math.Poly\n * @namespace\n */\nMat.Poly = {};\n\n/**\n * Define a polynomial ring over R.\n * @class\n * @name JXG.Math.Poly.Ring\n * @param {Array} variables List of indeterminates.\n */\nMat.Poly.Ring = function (variables) {\n    /**\n     * A list of variables in this polynomial ring.\n     * @type Array\n     */\n    this.vars = variables;\n};\n\nJXG.extend(\n    Mat.Poly.Ring.prototype,\n    /** @lends JXG.Math.Poly.Ring.prototype */ {\n        // nothing yet.\n    }\n);\n\n/**\n * Define a monomial over the polynomial ring <tt>ring</tt>.\n * @class\n * @name JXG.Math.Poly.Monomial\n * @param {JXG.Math.Poly.Ring} ring\n * @param {Number} coefficient\n * @param {Array} exponents An array of exponents, corresponding to ring\n */\nMat.Poly.Monomial = function (ring, coefficient, exponents) {\n    var i;\n\n    if (!Type.exists(ring)) {\n        throw new Error(\"JSXGraph error: In JXG.Math.Poly.monomial missing parameter 'ring'.\");\n    }\n\n    if (!Type.isArray(exponents)) {\n        exponents = [];\n    }\n\n    exponents = exponents.slice(0, ring.vars.length);\n\n    for (i = exponents.length; i < ring.vars.length; i++) {\n        exponents.push(0);\n    }\n\n    /**\n     * A polynomial ring.\n     * @type JXG.Math.Poly.Ring\n     */\n    this.ring = ring;\n\n    /**\n     * The monomial's coefficient\n     * @type Number\n     */\n    this.coefficient = coefficient || 0;\n\n    /**\n     * Exponent vector, the order depends on the order of the variables\n     * in the ring definition.\n     * @type Array\n     */\n    this.exponents = Type.deepCopy(exponents);\n};\n\nJXG.extend(\n    Mat.Poly.Monomial.prototype,\n    /** @lends JXG.Math.Poly.Monomial.prototype */ {\n        /**\n         * Creates a deep copy of the monomial.\n         *\n         * @returns {JXG.Math.Poly.Monomial}\n         *\n         * @memberof JXG.Math.Poly.Monomial\n         */\n        copy: function () {\n            return new Mat.Poly.Monomial(this.ring, this.coefficient, this.exponents);\n        },\n\n        /**\n         * Print the monomial.\n         * @returns {String} String representation of the monomial\n\n         * @memberof JXG.Math.Poly.Monomial\n         */\n        print: function () {\n            var s = [],\n                i;\n\n            for (i = 0; i < this.ring.vars.length; i++) {\n                s.push(this.ring.vars[i] + \"^\" + this.exponents[i]);\n            }\n\n            return this.coefficient + \"*\" + s.join(\"*\");\n        }\n    }\n);\n\n/**\n * A polynomial is a sum of monomials.\n * @class\n * @name JXG.Math.Poly.Polynomial\n * @param {JXG.Math.Poly.Ring} ring A polynomial ring.\n * @param {String} str TODO String representation of the polynomial, will be parsed.\n */\nMat.Poly.Polynomial = function (ring, str) {\n    var parse = function () {},\n        mons;\n\n    if (!Type.exists(ring)) {\n        throw new Error(\n            \"JSXGraph error: In JXG.Math.Poly.polynomial missing parameter 'ring'.\"\n        );\n    }\n\n    if (Type.exists(str) && Type.isString(str)) {\n        mons = parse(str);\n    } else {\n        mons = [];\n    }\n\n    /**\n     * A polynomial ring.\n     * @type JXG.Math.Poly.Ring\n     */\n    this.ring = ring;\n\n    /**\n     * List of monomials.\n     * @type Array\n     */\n    this.monomials = mons;\n};\n\nJXG.extend(\n    Mat.Poly.Polynomial.prototype,\n    /** @lends JXG.Math.Poly.Polynomial.prototype */ {\n        /**\n         * Find a monomial with the given signature, i.e. exponent vector.\n         * @param {Array} sig An array of numbers\n         * @returns {Number} The index of the first monomial with the given signature, or -1\n         * if no monomial could be found.\n         * @memberof JXG.Math.Poly.Polynomial\n         */\n        findSignature: function (sig) {\n            var i;\n\n            for (i = 0; i < this.monomials.length; i++) {\n                if (Type.cmpArrays(this.monomials[i].exponents, sig)) {\n                    return i;\n                }\n            }\n\n            return -1;\n        },\n\n        /**\n         * Adds a monomial to the polynomial. Checks the existing monomials for the added\n         * monomial's signature and just adds the coefficient if one is found.\n         * @param {JXG.Math.Poly.Monomial} m\n         * @param {Number} factor Either <tt>1</tt> or <tt>-1</tt>.\n         * @memberof JXG.Math.Poly.Polynomial\n         */\n        addSubMonomial: function (m, factor) {\n            var i;\n\n            i = this.findSignature(m.exponents);\n            if (i > -1) {\n                this.monomials[i].coefficient += factor * m.coefficient;\n            } else {\n                m.coefficient *= factor;\n                this.monomials.push(m);\n            }\n        },\n\n        /**\n         * Adds another polynomial or monomial to this one and merges them by checking for the\n         * signature of each new monomial in the existing monomials.\n         * @param {JXG.Math.Poly.Polynomial|JXG.Math.Poly.Monomial} mp\n         * @memberof JXG.Math.Poly.Polynomial\n         */\n        add: function (mp) {\n            var i;\n\n            if (Type.exists(mp) && mp.ring === this.ring) {\n                if (Type.isArray(mp.exponents)) {\n                    // mp is a monomial\n                    this.addSubMonomial(mp, 1);\n                } else {\n                    // mp is a polynomial\n                    for (i = 0; i < mp.monomials.length; i++) {\n                        this.addSubMonomial(mp.monomials[i], 1);\n                    }\n                }\n            } else {\n                throw new Error(\n                    \"JSXGraph error: In JXG.Math.Poly.polynomial.add either summand is undefined or rings don't match.\"\n                );\n            }\n        },\n\n        /**\n         * Subtracts another polynomial or monomial from this one and merges them by checking for the\n         * signature of each new monomial in the existing monomials.\n         * @param {JXG.Math.Poly.Polynomial|JXG.Math.Poly.Monomial} mp\n         * @memberof JXG.Math.Poly.Polynomial\n         */\n        sub: function (mp) {\n            var i;\n\n            if (Type.exists(mp) && mp.ring === this.ring) {\n                if (Type.isArray(mp.exponents)) {\n                    // mp is a monomial\n                    this.addSubMonomial(mp, -1);\n                } else {\n                    // mp is a polynomial\n                    for (i = 0; i < mp.monomials.length; i++) {\n                        this.addSubMonomial(mp.monomials[i], -1);\n                    }\n                }\n            } else {\n                throw new Error(\n                    \"JSXGraph error: In JXG.Math.Poly.polynomial.sub either summand is undefined or rings don't match.\"\n                );\n            }\n        },\n\n        /**\n         * Creates a deep copy of the polynomial.\n         * @returns {JXG.Math.Poly.Polynomial}\n         * @memberof JXG.Math.Poly.Polynomial\n         */\n        copy: function () {\n            var i, p;\n\n            p = new Mat.Poly.Polynomial(this.ring);\n\n            for (i = 0; i < this.monomials.length; i++) {\n                p.monomials.push(this.monomials[i].copy());\n            }\n            return p;\n        },\n\n        /**\n         * Prints the polynomial.\n         * @returns {String} A string representation of the polynomial.\n         * @memberof JXG.Math.Poly.Polynomial\n         */\n        print: function () {\n            var s = [],\n                i;\n\n            for (i = 0; i < this.monomials.length; i++) {\n                s.push(\"(\" + this.monomials[i].print() + \")\");\n            }\n\n            return s.join(\"+\");\n        }\n    }\n);\n\nexport default Mat.Poly;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview A class for complex arithmetics JXG.Complex is defined in this\n * file. Also a namespace JXG.C is included to provide instance-independent\n * arithmetic functions.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n\n/**\n * Creates a new complex number.\n * @class This class is for calculating with complex numbers.\n * @constructor\n * @param {Number} [x=0] Real part.\n * @param {Number} [y=0] Imaginary part.\n */\nJXG.Complex = function (x, y) {\n    /**\n     * This property is only to signalize that this object is of type JXG.Complex. Only\n     * used internally to distinguish between normal JavaScript numbers and JXG.Complex numbers.\n     * @type Boolean\n     * @default true\n     * @private\n     */\n    this.isComplex = true;\n\n    /* is the first argument a complex number? if it is,\n     * extract real and imaginary part. */\n    if (x && x.isComplex) {\n        y = x.imaginary;\n        x = x.real;\n    }\n\n    /**\n     * Real part of the complex number.\n     * @type Number\n     * @default 0\n     */\n    this.real = x || 0;\n\n    /**\n     * Imaginary part of the complex number.\n     * @type Number\n     * @default 0\n     */\n    this.imaginary = y || 0;\n\n    /**\n     * Absolute value in the polar form of the complex number. Currently unused.\n     * @type Number\n     */\n    this.absval = 0;\n\n    /**\n     * Angle value in the polar form of the complex number. Currently unused.\n     * @type Number\n     */\n    this.angle = 0;\n};\n\nJXG.extend(\n    JXG.Complex.prototype,\n    /** @lends JXG.Complex.prototype */ {\n        /**\n         * Converts a complex number into a string.\n         * @returns {String} Formatted string containing the complex number in human readable form (algebraic form).\n         */\n        toString: function () {\n            return this.real + \" + \" + this.imaginary + \"i\";\n        },\n\n        /**\n         * Add another complex number to this complex number.\n         * @param {JXG.Complex,Number} c A JavaScript number or a JXG.Complex object to be added to the current object.\n         * @returns {JXG.Complex} Reference to this complex number\n         */\n        add: function (c) {\n            if (Type.isNumber(c)) {\n                this.real += c;\n            } else {\n                this.real += c.real;\n                this.imaginary += c.imaginary;\n            }\n\n            return this;\n        },\n\n        /**\n         * Subtract another complex number from this complex number.\n         * @param {JXG.Complex,Number} c A JavaScript number or a JXG.Complex object to subtract from the current object.\n         * @returns {JXG.Complex} Reference to this complex number\n         */\n        sub: function (c) {\n            if (Type.isNumber(c)) {\n                this.real -= c;\n            } else {\n                this.real -= c.real;\n                this.imaginary -= c.imaginary;\n            }\n\n            return this;\n        },\n\n        /**\n         * Multiply another complex number to this complex number.\n         * @param {JXG.Complex,Number} c A JavaScript number or a JXG.Complex object to\n         * multiply with the current object.\n         * @returns {JXG.Complex} Reference to this complex number\n         */\n        mult: function (c) {\n            var re, im;\n\n            if (Type.isNumber(c)) {\n                this.real *= c;\n                this.imaginary *= c;\n            } else {\n                re = this.real;\n                im = this.imaginary;\n\n                //  (a+ib)(x+iy) = ax-by + i(xb+ay)\n                this.real = re * c.real - im * c.imaginary;\n                this.imaginary = re * c.imaginary + im * c.real;\n            }\n\n            return this;\n        },\n\n        /**\n         * Divide this complex number by the given complex number.\n         * @param {JXG.Complex,Number} c A JavaScript number or a JXG.Complex object to\n         * divide the current object by.\n         * @returns {JXG.Complex} Reference to this complex number\n         */\n        div: function (c) {\n            var denom, im, re;\n\n            if (Type.isNumber(c)) {\n                if (Math.abs(c) < Math.eps) {\n                    this.real = Infinity;\n                    this.imaginary = Infinity;\n\n                    return this;\n                }\n\n                this.real /= c;\n                this.imaginary /= c;\n            } else {\n                //  (a+ib)(x+iy) = ax-by + i(xb+ay)\n                if (Math.abs(c.real) < Math.eps && Math.abs(c.imaginary) < Math.eps) {\n                    this.real = Infinity;\n                    this.imaginary = Infinity;\n\n                    return this;\n                }\n\n                denom = c.real * c.real + c.imaginary * c.imaginary;\n\n                re = this.real;\n                im = this.imaginary;\n                this.real = (re * c.real + im * c.imaginary) / denom;\n                this.imaginary = (im * c.real - re * c.imaginary) / denom;\n            }\n\n            return this;\n        },\n\n        /**\n         * Conjugate a complex number in place.\n         * @returns {JXG.Complex} Reference to this complex number\n         */\n        conj: function () {\n            this.imaginary *= -1;\n\n            return this;\n        }\n    }\n);\n\n/**\n * @description\n * JXG.C is the complex number (name)space. It provides functions to calculate with\n * complex numbers (defined in {@link JXG.Complex}). With this namespace you don't have to modify\n * your existing complex numbers, e.g. to add two complex numbers:\n * <pre class=\"code\">   var z1 = new JXG.Complex(1, 0);\n *    var z2 = new JXG.Complex(0, 1);\n *    z = JXG.C.add(z1, z1);</pre>\n * z1 and z2 here remain unmodified. With the object oriented approach above this\n * section the code would look like:\n * <pre class=\"code\">   var z1 = new JXG.Complex(1, 0);\n *    var z2 = new JXG.Complex(0, 1);\n *    var z = new JXG.Complex(z1);\n *    z.add(z2);</pre>\n * @namespace Namespace for the complex number arithmetic functions.\n */\nJXG.C = {};\n\n/**\n * Add two (complex) numbers z1 and z2 and return the result as a (complex) number.\n * @param {JXG.Complex,Number} z1 Summand\n * @param {JXG.Complex,Number} z2 Summand\n * @returns {JXG.Complex} A complex number equal to the sum of the given parameters.\n */\nJXG.C.add = function (z1, z2) {\n    var z = new JXG.Complex(z1);\n    z.add(z2);\n    return z;\n};\n\n/**\n * Subtract two (complex) numbers z1 and z2 and return the result as a (complex) number.\n * @param {JXG.Complex,Number} z1 Minuend\n * @param {JXG.Complex,Number} z2 Subtrahend\n * @returns {JXG.Complex} A complex number equal to the difference of the given parameters.\n */\nJXG.C.sub = function (z1, z2) {\n    var z = new JXG.Complex(z1);\n    z.sub(z2);\n    return z;\n};\n\n/**\n * Multiply two (complex) numbers z1 and z2 and return the result as a (complex) number.\n * @param {JXG.Complex,Number} z1 Factor\n * @param {JXG.Complex,Number} z2 Factor\n * @returns {JXG.Complex} A complex number equal to the product of the given parameters.\n */\nJXG.C.mult = function (z1, z2) {\n    var z = new JXG.Complex(z1);\n    z.mult(z2);\n    return z;\n};\n\n/**\n * Divide two (complex) numbers z1 and z2 and return the result as a (complex) number.\n * @param {JXG.Complex,Number} z1 Dividend\n * @param {JXG.Complex,Number} z2 Divisor\n * @returns {JXG.Complex} A complex number equal to the quotient of the given parameters.\n */\nJXG.C.div = function (z1, z2) {\n    var z = new JXG.Complex(z1);\n    z.div(z2);\n    return z;\n};\n\n/**\n * Conjugate a complex number and return the result.\n * @param {JXG.Complex,Number} z1 Complex number\n * @returns {JXG.Complex} A complex number equal to the conjugate of the given parameter.\n */\nJXG.C.conj = function (z1) {\n    var z = new JXG.Complex(z1);\n    z.conj();\n    return z;\n};\n\n/**\n * Absolute value of a complex number.\n * @param {JXG.Complex,Number} z1 Complex number\n * @returns {Number} real number equal to the absolute value of the given parameter.\n */\nJXG.C.abs = function (z1) {\n    var z = new JXG.Complex(z1);\n\n    z.conj();\n    z.mult(z1);\n\n    return Math.sqrt(z.real);\n};\n\nJXG.Complex.C = JXG.C;\n\nexport default JXG.Complex;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true, window: true */\n\n/*\n    nomen:    Allow underscores to indicate private class members. Might be replaced by local variables.\n    plusplus: Only allowed in for-loops\n    newcap:   AsciiMathMl exposes non-constructor functions beginning with upper case letters\n*/\n/*jslint nomen: true, plusplus: true, newcap: true, unparam: true*/\n/*eslint no-unused-vars: \"off\"*/\n\n/**\n * @fileoverview JSXGraph can use various technologies to render the contents of a construction, e.g.\n * SVG, VML, and HTML5 Canvas. To accomplish this, The rendering and the logic and control mechanisms\n * are completely separated from each other. Every rendering technology has it's own class, called\n * Renderer, e.g. SVGRenderer for SVG, the same for VML and Canvas. The common base for all available\n * renderers is the class AbstractRenderer defined in this file.\n */\n\nimport JXG from \"../jxg\";\nimport Options from \"../options\";\nimport Coords from \"../base/coords\";\nimport Const from \"../base/constants\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Type from \"../utils/type\";\nimport Env from \"../utils/env\";\n\n/**\n * <p>This class defines the interface to the graphics part of JSXGraph. This class is an abstract class, it\n * actually does not render anything. This is up to the {@link JXG.SVGRenderer}, {@link JXG.VMLRenderer},\n * and {@link JXG.CanvasRenderer} classes. We strongly discourage you from using the methods in these classes\n * directly. Only the methods which are defined in this class and are not marked as private are guaranteed\n * to exist in any renderer instance you can access via {@link JXG.Board#renderer}. But not all methods may\n * work as expected.</p>\n * <p>The methods of this renderer can be divided into different categories:\n * <dl>\n *     <dt>Draw basic elements</dt>\n *     <dd>In this category we find methods to draw basic elements like {@link JXG.Point}, {@link JXG.Line},\n *     and {@link JXG.Curve} as well as assisting methods tightly bound to these basic painters. You do not\n *     need to implement these methods in a descendant renderer but instead implement the primitive drawing\n *     methods described below. This approach is encouraged when you're using a XML based rendering engine\n *     like VML and SVG. If you want to use a bitmap based rendering technique you are supposed to override\n *     these methods instead of the primitive drawing methods.</dd>\n *     <dt>Draw primitives</dt>\n *     <dd>This category summarizes methods to handle primitive nodes. As creation and management of these nodes\n *     is different among different the rendering techniques most of these methods are purely virtual and need\n *     proper implementation if you choose to not overwrite the basic element drawing methods.</dd>\n *     <dt>Attribute manipulation</dt>\n *     <dd>In XML based renders you have to manipulate XML nodes and their attributes to change the graphics.\n *     For that purpose attribute manipulation methods are defined to set the color, opacity, and other things.\n *     Please note that some of these methods are required in bitmap based renderers, too, because some elements\n *     like {@link JXG.Text} can be HTML nodes floating over the construction.</dd>\n *     <dt>Renderer control</dt>\n *     <dd>Methods to clear the drawing board or to stop and to resume the rendering engine.</dd>\n * </dl></p>\n * @class JXG.AbstractRenderer\n * @constructor\n * @see JXG.SVGRenderer\n * @see JXG.VMLRenderer\n * @see JXG.CanvasRenderer\n */\nJXG.AbstractRenderer = function () {\n    // WHY THIS IS A CLASS INSTEAD OF A SINGLETON OBJECT:\n    //\n    // The renderers need to keep track of some stuff which is not always the same on different boards,\n    // like enhancedRendering, reference to the container object, and resolution in VML. Sure, those\n    // things could be stored in board. But they are rendering related and JXG.Board is already very\n    // very big.\n    //\n    // And we can't save the rendering related data in {SVG,VML,Canvas}Renderer and make only the\n    // JXG.AbstractRenderer a singleton because of that:\n    //\n    // Given an object o with property a set to true\n    //     var o = {a: true};\n    // and a class c doing nothing\n    //     c = function() {};\n    // Set c's prototype to o\n    //     c.prototype = o;\n    // and create an instance of c we get i.a to be true\n    //     i = new c();\n    //     i.a;\n    //     > true\n    // But we can overwrite this property via\n    //     c.prototype.a = false;\n    //     i.a;\n    //     > false\n\n    /**\n     * The vertical offset for {@link Text} elements. Every {@link Text} element will\n     * be placed this amount of pixels below the user given coordinates.\n     * @type Number\n     * @default 0\n     */\n    this.vOffsetText = 0;\n\n    /**\n     * If this property is set to <tt>true</tt> the visual properties of the elements are updated\n     * on every update. Visual properties means: All the stuff stored in the\n     * {@link JXG.GeometryElement#visProp} property won't be set if enhancedRendering is <tt>false</tt>\n     * @type Boolean\n     * @default true\n     */\n    this.enhancedRendering = true;\n\n    /**\n     * The HTML element that stores the JSXGraph board in it.\n     * @type Node\n     */\n    this.container = null;\n\n    /**\n     * This is used to easily determine which renderer we are using\n     * @example if (board.renderer.type === 'vml') {\n     *     // do something\n     * }\n     * @type String\n     */\n    this.type = \"\";\n\n    /**\n     * True if the browsers' SVG engine supports foreignObject.\n     * Not supported browsers are IE 9 - 11.\n     * All other browsers return ture, since it is tested with\n     * document.implementation.hasFeature() which is deprecated.\n     *\n     * @type Boolean\n     * @private\n     */\n    this.supportsForeignObject = false;\n};\n\nJXG.extend(\n    JXG.AbstractRenderer.prototype,\n    /** @lends JXG.AbstractRenderer.prototype */ {\n        /* ******************************** *\n         *    private methods               *\n         *    should not be called from     *\n         *    outside AbstractRenderer      *\n         * ******************************** */\n\n        /**\n         * Update visual properties, but only if {@link JXG.AbstractRenderer#enhancedRendering} or <tt>enhanced</tt> is set to true.\n         * @param {JXG.GeometryElement} el The element to update\n         * @param {Object} [not={}] Select properties you don't want to be updated: <tt>{fill: true, dash: true}</tt> updates\n         * everything except for fill and dash. Possible values are <tt>stroke, fill, dash, shadow, gradient</tt>.\n         * @param {Boolean} [enhanced=false] If true, {@link JXG.AbstractRenderer#enhancedRendering} is assumed to be true.\n         * @private\n         */\n        _updateVisual: function (el, not, enhanced) {\n            if (enhanced || this.enhancedRendering) {\n                not = not || {};\n\n                this.setObjectTransition(el);\n                if (!Type.evaluate(el.visProp.draft)) {\n                    if (!not.stroke) {\n                        if (el.highlighted) {\n                            this.setObjectStrokeColor(\n                                el,\n                                el.visProp.highlightstrokecolor,\n                                el.visProp.highlightstrokeopacity\n                            );\n                            this.setObjectStrokeWidth(el, el.visProp.highlightstrokewidth);\n                        } else {\n                            this.setObjectStrokeColor(\n                                el,\n                                el.visProp.strokecolor,\n                                el.visProp.strokeopacity\n                            );\n                            this.setObjectStrokeWidth(el, el.visProp.strokewidth);\n                        }\n                    }\n\n                    if (!not.fill) {\n                        if (el.highlighted) {\n                            this.setObjectFillColor(\n                                el,\n                                el.visProp.highlightfillcolor,\n                                el.visProp.highlightfillopacity\n                            );\n                        } else {\n                            this.setObjectFillColor(\n                                el,\n                                el.visProp.fillcolor,\n                                el.visProp.fillopacity\n                            );\n                        }\n                    }\n\n                    if (!not.dash) {\n                        this.setDashStyle(el, el.visProp);\n                    }\n\n                    if (!not.shadow) {\n                        this.setShadow(el);\n                    }\n\n                    if (!not.gradient) {\n                        this.setShadow(el);\n                    }\n\n                    if (!not.tabindex) {\n                        this.setTabindex(el);\n                    }\n                } else {\n                    this.setDraft(el);\n                }\n            }\n        },\n\n        /**\n         * Get information if element is highlighted.\n         * @param {JXG.GeometryElement} el The element which is tested for being highlighted.\n         * @returns {String} 'highlight' if highlighted, otherwise the ampty string '' is returned.\n         * @private\n         */\n        _getHighlighted: function (el) {\n            var isTrace = false,\n                hl;\n\n            if (!Type.exists(el.board) || !Type.exists(el.board.highlightedObjects)) {\n                // This case handles trace elements.\n                // To make them work, we simply neglect highlighting.\n                isTrace = true;\n            }\n\n            if (!isTrace && Type.exists(el.board.highlightedObjects[el.id])) {\n                hl = \"highlight\";\n            } else {\n                hl = \"\";\n            }\n            return hl;\n        },\n\n        /* ******************************** *\n         *    Point drawing and updating    *\n         * ******************************** */\n\n        /**\n         * Draws a point on the {@link JXG.Board}.\n         * @param {JXG.Point} el Reference to a {@link JXG.Point} object that has to be drawn.\n         * @see Point\n         * @see JXG.Point\n         * @see JXG.AbstractRenderer#updatePoint\n         * @see JXG.AbstractRenderer#changePointStyle\n         */\n        drawPoint: function (el) {\n            var prim,\n                // sometimes el is not a real point and lacks the methods of a JXG.Point instance,\n                // in these cases to not use el directly.\n                face = Options.normalizePointFace(Type.evaluate(el.visProp.face));\n\n            // determine how the point looks like\n            if (face === \"o\") {\n                prim = \"ellipse\";\n            } else if (face === \"[]\") {\n                prim = \"rect\";\n            } else {\n                // cross/x, diamond/<>, triangleup/a/^, triangledown/v, triangleleft/<,\n                // triangleright/>, plus/+,\n                prim = \"path\";\n            }\n\n            el.rendNode = this.appendChildPrim(\n                this.createPrim(prim, el.id),\n                Type.evaluate(el.visProp.layer)\n            );\n            this.appendNodesToElement(el, prim);\n\n            // adjust visual propertys\n            this._updateVisual(el, { dash: true, shadow: true }, true);\n\n            // By now we only created the xml nodes and set some styles, in updatePoint\n            // the attributes are filled with data.\n            this.updatePoint(el);\n        },\n\n        /**\n         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Point}.\n         * @param {JXG.Point} el Reference to a {@link JXG.Point} object, that has to be updated.\n         * @see Point\n         * @see JXG.Point\n         * @see JXG.AbstractRenderer#drawPoint\n         * @see JXG.AbstractRenderer#changePointStyle\n         */\n        updatePoint: function (el) {\n            var size = Type.evaluate(el.visProp.size),\n                // sometimes el is not a real point and lacks the methods of a JXG.Point instance,\n                // in these cases to not use el directly.\n                face = Options.normalizePointFace(Type.evaluate(el.visProp.face)),\n                unit = Type.evaluate(el.visProp.sizeunit),\n                zoom = Type.evaluate(el.visProp.zoom),\n                s1;\n\n            if (!isNaN(el.coords.scrCoords[2] + el.coords.scrCoords[1])) {\n                if (unit === \"user\") {\n                    size *= Math.sqrt(el.board.unitX * el.board.unitY);\n                }\n                size *= !el.board || !zoom ? 1.0 : Math.sqrt(el.board.zoomX * el.board.zoomY);\n                s1 = size === 0 ? 0 : size + 1;\n\n                if (face === \"o\") {\n                    // circle\n                    this.updateEllipsePrim(\n                        el.rendNode,\n                        el.coords.scrCoords[1],\n                        el.coords.scrCoords[2],\n                        s1,\n                        s1\n                    );\n                } else if (face === \"[]\") {\n                    // rectangle\n                    this.updateRectPrim(\n                        el.rendNode,\n                        el.coords.scrCoords[1] - size,\n                        el.coords.scrCoords[2] - size,\n                        size * 2,\n                        size * 2\n                    );\n                } else {\n                    // x, +, <>, ^, v, <, >\n                    this.updatePathPrim(\n                        el.rendNode,\n                        this.updatePathStringPoint(el, size, face),\n                        el.board\n                    );\n                }\n                this._updateVisual(el, { dash: false, shadow: false });\n                this.setShadow(el);\n            }\n        },\n\n        /**\n         * Changes the style of a {@link JXG.Point}. This is required because the point styles differ in what\n         * elements have to be drawn, e.g. if the point is marked by a \"x\" or a \"+\" two lines are drawn, if\n         * it's marked by spot a circle is drawn. This method removes the old renderer element(s) and creates\n         * the new one(s).\n         * @param {JXG.Point} el Reference to a {@link JXG.Point} object, that's style is changed.\n         * @see Point\n         * @see JXG.Point\n         * @see JXG.AbstractRenderer#updatePoint\n         * @see JXG.AbstractRenderer#drawPoint\n         */\n        changePointStyle: function (el) {\n            var node = this.getElementById(el.id);\n\n            // remove the existing point rendering node\n            if (Type.exists(node)) {\n                this.remove(node);\n            }\n\n            // and make a new one\n            this.drawPoint(el);\n            Type.clearVisPropOld(el);\n\n            if (!el.visPropCalc.visible) {\n                this.display(el, false);\n            }\n\n            if (Type.evaluate(el.visProp.draft)) {\n                this.setDraft(el);\n            }\n        },\n\n        /* ******************************** *\n         *           Lines                  *\n         * ******************************** */\n\n        /**\n         * Draws a line on the {@link JXG.Board}.\n         * @param {JXG.Line} el Reference to a line object, that has to be drawn.\n         * @see Line\n         * @see JXG.Line\n         * @see JXG.AbstractRenderer#updateLine\n         */\n        drawLine: function (el) {\n            el.rendNode = this.appendChildPrim(\n                this.createPrim(\"line\", el.id),\n                Type.evaluate(el.visProp.layer)\n            );\n            this.appendNodesToElement(el, \"lines\");\n            this.updateLine(el);\n        },\n\n        /**\n         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Line}.\n         * @param {JXG.Line} el Reference to the {@link JXG.Line} object that has to be updated.\n         * @see Line\n         * @see JXG.Line\n         * @see JXG.AbstractRenderer#drawLine\n         */\n        updateLine: function (el) {\n            this._updateVisual(el);\n            this.updatePathWithArrowHeads(el); // Calls the renderer primitive\n            this.setLineCap(el);\n        },\n\n        /* **************************\n         *    Curves\n         * **************************/\n\n        /**\n         * Draws a {@link JXG.Curve} on the {@link JXG.Board}.\n         * @param {JXG.Curve} el Reference to a graph object, that has to be plotted.\n         * @see Curve\n         * @see JXG.Curve\n         * @see JXG.AbstractRenderer#updateCurve\n         */\n        drawCurve: function (el) {\n            el.rendNode = this.appendChildPrim(\n                this.createPrim(\"path\", el.id),\n                Type.evaluate(el.visProp.layer)\n            );\n            this.appendNodesToElement(el, \"path\");\n            this.updateCurve(el);\n        },\n\n        /**\n         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Curve}.\n         * @param {JXG.Curve} el Reference to a {@link JXG.Curve} object, that has to be updated.\n         * @see Curve\n         * @see JXG.Curve\n         * @see JXG.AbstractRenderer#drawCurve\n         */\n        updateCurve: function (el) {\n            this._updateVisual(el);\n            this.updatePathWithArrowHeads(el); // Calls the renderer primitive\n            this.setLineCap(el);\n        },\n\n        /* **************************\n         *    Arrow heads and related stuff\n         * **************************/\n\n        /**\n         * Handles arrow heads of a line or curve element and calls the renderer primitive.\n         *\n         * @param {JXG.GeometryElement} el Reference to a line or curve object that has to be drawn.\n         * @param {Boolean} doHighlight\n         *\n         * @private\n         * @see Line\n         * @see JXG.Line\n         * @see Curve\n         * @see JXG.Curve\n         * @see JXG.AbstractRenderer#updateLine\n         * @see JXG.AbstractRenderer#updateCurve\n         * @see JXG.AbstractRenderer#makeArrows\n         * @see JXG.AbstractRenderer#getArrowHeadData\n         */\n        updatePathWithArrowHeads: function (el, doHighlight) {\n            var ev = el.visProp,\n                hl = doHighlight ? \"highlight\" : \"\",\n                w,\n                arrowData;\n\n            if (doHighlight && ev.highlightstrokewidth) {\n                w = Math.max(\n                    Type.evaluate(ev.highlightstrokewidth),\n                    Type.evaluate(ev.strokewidth)\n                );\n            } else {\n                w = Type.evaluate(ev.strokewidth);\n            }\n\n            // Get information if there are arrow heads and how large they are.\n            arrowData = this.getArrowHeadData(el, w, hl);\n\n            // Create the SVG nodes if neccessary\n            this.makeArrows(el, arrowData);\n\n            // Draw the paths with arrow heads\n            if (el.elementClass === Const.OBJECT_CLASS_LINE) {\n                this.updateLineWithEndings(el, arrowData);\n            } else if (el.elementClass === Const.OBJECT_CLASS_CURVE) {\n                this.updatePath(el);\n            }\n\n            this.setArrowSize(el, arrowData);\n        },\n\n        /**\n         * This method determines some data about the line endings of this element.\n         * If there are arrow heads, the offset is determined so that no parts of the line stroke\n         * lap over the arrow head.\n         * <p>\n         * The returned object also contains the types of the arrow heads.\n         *\n         * @param {JXG.GeometryElement} el JSXGraph line or curve element\n         * @param {Number} strokewidth strokewidth of the element\n         * @param {String} hl Ither 'highlight' or empty string\n         * @returns {Object} object containing the data\n         *\n         * @private\n         */\n        getArrowHeadData: function (el, strokewidth, hl) {\n            var minlen = Mat.eps,\n                typeFirst,\n                typeLast,\n                offFirst = 0,\n                offLast = 0,\n                sizeFirst = 0,\n                sizeLast = 0,\n                ev_fa = Type.evaluate(el.visProp.firstarrow),\n                ev_la = Type.evaluate(el.visProp.lastarrow),\n                off,\n                size;\n\n            /*\n               Handle arrow heads.\n\n               The default arrow head is an isosceles triangle with base length 10 units and height 10 units.\n               These 10 units are scaled to strokeWidth * arrowSize pixels pixels.\n            */\n            if (ev_fa || ev_la) {\n                if (Type.exists(ev_fa.type)) {\n                    typeFirst = Type.evaluate(ev_fa.type);\n                } else {\n                    if (el.elementClass === Const.OBJECT_CLASS_LINE) {\n                        typeFirst = 1;\n                    } else {\n                        typeFirst = 7;\n                    }\n                }\n                if (Type.exists(ev_la.type)) {\n                    typeLast = Type.evaluate(ev_la.type);\n                } else {\n                    if (el.elementClass === Const.OBJECT_CLASS_LINE) {\n                        typeLast = 1;\n                    } else {\n                        typeLast = 7;\n                    }\n                }\n\n                if (ev_fa) {\n                    size = 6;\n                    if (Type.exists(ev_fa.size)) {\n                        size = Type.evaluate(ev_fa.size);\n                    }\n                    if (hl !== \"\" && Type.exists(ev_fa[hl + \"size\"])) {\n                        size = Type.evaluate(ev_fa[hl + \"size\"]);\n                    }\n\n                    off = strokewidth * size;\n                    if (typeFirst === 2) {\n                        off *= 0.5;\n                        minlen += strokewidth * size;\n                    } else if (typeFirst === 3) {\n                        off = (strokewidth * size) / 3;\n                        minlen += strokewidth;\n                    } else if (typeFirst === 4 || typeFirst === 5 || typeFirst === 6) {\n                        off = (strokewidth * size) / 1.5;\n                        minlen += strokewidth * size;\n                    } else if (typeFirst === 7) {\n                        off = 0;\n                        size = 10;\n                        minlen += strokewidth;\n                    } else {\n                        minlen += strokewidth * size;\n                    }\n                    offFirst += off;\n                    sizeFirst = size;\n                }\n\n                if (ev_la) {\n                    size = 6;\n                    if (Type.exists(ev_la.size)) {\n                        size = Type.evaluate(ev_la.size);\n                    }\n                    if (hl !== \"\" && Type.exists(ev_la[hl + \"size\"])) {\n                        size = Type.evaluate(ev_la[hl + \"size\"]);\n                    }\n                    off = strokewidth * size;\n                    if (typeLast === 2) {\n                        off *= 0.5;\n                        minlen += strokewidth * size;\n                    } else if (typeLast === 3) {\n                        off = (strokewidth * size) / 3;\n                        minlen += strokewidth;\n                    } else if (typeLast === 4 || typeLast === 5 || typeLast === 6) {\n                        off = (strokewidth * size) / 1.5;\n                        minlen += strokewidth * size;\n                    } else if (typeLast === 7) {\n                        off = 0;\n                        size = 10;\n                        minlen += strokewidth;\n                    } else {\n                        minlen += strokewidth * size;\n                    }\n                    offLast += off;\n                    sizeLast = size;\n                }\n            }\n            el.visPropCalc.typeFirst = typeFirst;\n            el.visPropCalc.typeLast = typeLast;\n\n            return {\n                evFirst: ev_fa,\n                evLast: ev_la,\n                typeFirst: typeFirst,\n                typeLast: typeLast,\n                offFirst: offFirst,\n                offLast: offLast,\n                sizeFirst: sizeFirst,\n                sizeLast: sizeLast,\n                showFirst: 1, // Show arrow head. 0 if the distance is too small\n                showLast: 1, // Show arrow head. 0 if the distance is too small\n                minLen: minlen,\n                strokeWidth: strokewidth\n            };\n        },\n\n        /**\n         * Corrects the line length if there are arrow heads, such that\n         * the arrow ends exactly at the intended position.\n         * Calls the renderer method to draw the line.\n         *\n         * @param {JXG.Line} el Reference to a line object, that has to be drawn\n         * @param {Object} arrowData Data concerning possible arrow heads\n         *\n         * @returns {JXG.AbstractRenderer} Reference to the renderer\n         *\n         * @private\n         * @see Line\n         * @see JXG.Line\n         * @see JXG.AbstractRenderer#updateLine\n         * @see JXG.AbstractRenderer#getPositionArrowHead\n         *\n         */\n        updateLineWithEndings: function (el, arrowData) {\n            var c1,\n                c2,\n                // useTotalLength = true,\n                margin = null;\n\n            c1 = new Coords(Const.COORDS_BY_USER, el.point1.coords.usrCoords, el.board);\n            c2 = new Coords(Const.COORDS_BY_USER, el.point2.coords.usrCoords, el.board);\n            margin = Type.evaluate(el.visProp.margin);\n            Geometry.calcStraight(el, c1, c2, margin);\n\n            this.handleTouchpoints(el, c1, c2, arrowData);\n            this.getPositionArrowHead(el, c1, c2, arrowData);\n\n            this.updateLinePrim(\n                el.rendNode,\n                c1.scrCoords[1],\n                c1.scrCoords[2],\n                c2.scrCoords[1],\n                c2.scrCoords[2],\n                el.board\n            );\n\n            return this;\n        },\n\n        /**\n         *\n         * Calls the renderer method to draw a curve.\n         *\n         * @param {JXG.GeometryElement} el Reference to a line object, that has to be drawn.\n         * @returns {JXG.AbstractRenderer} Reference to the renderer\n         *\n         * @private\n         * @see Curve\n         * @see JXG.Curve\n         * @see JXG.AbstractRenderer#updateCurve\n         *\n         */\n        updatePath: function (el) {\n            if (Type.evaluate(el.visProp.handdrawing)) {\n                this.updatePathPrim(el.rendNode, this.updatePathStringBezierPrim(el), el.board);\n            } else {\n                this.updatePathPrim(el.rendNode, this.updatePathStringPrim(el), el.board);\n            }\n\n            return this;\n        },\n\n        /**\n         * Shorten the length of a line element such that the arrow head touches\n         * the start or end point and such that the arrow head ends exactly\n         * at the start / end position of the line.\n         *\n         * @param  {JXG.Line} el Reference to the line object that gets arrow heads.\n         * @param  {JXG.Coords} c1  Coords of the first point of the line (after {@link JXG.Math.Geometry#calcStraight}).\n         * @param  {JXG.Coords} c2  Coords of the second point of the line (after {@link JXG.Math.Geometry#calcStraight}).\n         * @param  {Object}  a\n         * @return {object} Object containing how much the line has to be shortened.\n         * Data structure: {c1, c2, d1x, d1y, d2x, d2y, sFirst, sLast}. sFirst and sLast is the length by which\n         * firstArrow and lastArrow have to shifted such that there is no gap between arrow head and line.\n         * Additionally, if one of these values is zero, the arrow is not displayed. This is the case, if the\n         * line length is very short.\n         */\n        getPositionArrowHead: function (el, c1, c2, a) {\n            var d, d1x, d1y, d2x, d2y;\n\n            /*\n               Handle arrow heads.\n\n               The default arrow head (type==1) is an isosceles triangle with base length 10 units and height 10 units.\n               These 10 units are scaled to strokeWidth * arrowSize pixels pixels.\n            */\n            if (a.evFirst || a.evLast) {\n                // Correct the position of the arrow heads\n                d1x = d1y = d2x = d2y = 0.0;\n                d = c1.distance(Const.COORDS_BY_SCREEN, c2);\n\n                if (a.evFirst && el.board.renderer.type !== \"vml\") {\n                    if (d >= a.minLen) {\n                        d1x = ((c2.scrCoords[1] - c1.scrCoords[1]) * a.offFirst) / d;\n                        d1y = ((c2.scrCoords[2] - c1.scrCoords[2]) * a.offFirst) / d;\n                    } else {\n                        a.showFirst = 0;\n                    }\n                }\n\n                if (a.evLast && el.board.renderer.type !== \"vml\") {\n                    if (d >= a.minLen) {\n                        d2x = ((c2.scrCoords[1] - c1.scrCoords[1]) * a.offLast) / d;\n                        d2y = ((c2.scrCoords[2] - c1.scrCoords[2]) * a.offLast) / d;\n                    } else {\n                        a.showLast = 0;\n                    }\n                }\n                c1.setCoordinates(\n                    Const.COORDS_BY_SCREEN,\n                    [c1.scrCoords[1] + d1x, c1.scrCoords[2] + d1y],\n                    false,\n                    true\n                );\n                c2.setCoordinates(\n                    Const.COORDS_BY_SCREEN,\n                    [c2.scrCoords[1] - d2x, c2.scrCoords[2] - d2y],\n                    false,\n                    true\n                );\n            }\n\n            return this;\n        },\n\n        /**\n         * Handle touchlastpoint / touchfirstpoint\n         *\n         * @param {JXG.GeometryElement} el\n         * @param {JXG.Coords} c1 Coordinates of the start of the line. The coordinates are changed in place.\n         * @param {JXG.Coords} c2 Coordinates of the end of the line. The coordinates are changed in place.\n         * @param {Object} a\n         */\n        handleTouchpoints: function (el, c1, c2, a) {\n            var s1, s2, d, d1x, d1y, d2x, d2y;\n\n            if (a.evFirst || a.evLast) {\n                d = d1x = d1y = d2x = d2y = 0.0;\n\n                s1 =\n                    Type.evaluate(el.point1.visProp.size) +\n                    Type.evaluate(el.point1.visProp.strokewidth);\n                s2 =\n                    Type.evaluate(el.point2.visProp.size) +\n                    Type.evaluate(el.point2.visProp.strokewidth);\n\n                // Handle touchlastpoint /touchfirstpoint\n                if (a.evFirst && Type.evaluate(el.visProp.touchfirstpoint)) {\n                    d = c1.distance(Const.COORDS_BY_SCREEN, c2);\n                    //if (d > s) {\n                    d1x = ((c2.scrCoords[1] - c1.scrCoords[1]) * s1) / d;\n                    d1y = ((c2.scrCoords[2] - c1.scrCoords[2]) * s1) / d;\n                    //}\n                }\n                if (a.evLast && Type.evaluate(el.visProp.touchlastpoint)) {\n                    d = c1.distance(Const.COORDS_BY_SCREEN, c2);\n                    //if (d > s) {\n                    d2x = ((c2.scrCoords[1] - c1.scrCoords[1]) * s2) / d;\n                    d2y = ((c2.scrCoords[2] - c1.scrCoords[2]) * s2) / d;\n                    //}\n                }\n                c1.setCoordinates(\n                    Const.COORDS_BY_SCREEN,\n                    [c1.scrCoords[1] + d1x, c1.scrCoords[2] + d1y],\n                    false,\n                    true\n                );\n                c2.setCoordinates(\n                    Const.COORDS_BY_SCREEN,\n                    [c2.scrCoords[1] - d2x, c2.scrCoords[2] - d2y],\n                    false,\n                    true\n                );\n            }\n\n            return this;\n        },\n\n        /**\n         * Set the arrow head size.\n         *\n         * @param {JXG.GeometryElement} el Reference to a line or curve object that has to be drawn.\n         * @param {Object} arrowData Data concerning possible arrow heads\n         * @returns {JXG.AbstractRenderer} Reference to the renderer\n         *\n         * @private\n         * @see Line\n         * @see JXG.Line\n         * @see Curve\n         * @see JXG.Curve\n         * @see JXG.AbstractRenderer#updatePathWithArrowHeads\n         * @see JXG.AbstractRenderer#getArrowHeadData\n         */\n        setArrowSize: function (el, a) {\n            if (a.evFirst) {\n                this._setArrowWidth(\n                    el.rendNodeTriangleStart,\n                    a.showFirst * a.strokeWidth,\n                    el.rendNode,\n                    a.sizeFirst\n                );\n            }\n            if (a.evLast) {\n                this._setArrowWidth(\n                    el.rendNodeTriangleEnd,\n                    a.showLast * a.strokeWidth,\n                    el.rendNode,\n                    a.sizeLast\n                );\n            }\n            return this;\n        },\n\n        /**\n         * Update the line endings (linecap) of a straight line from its attribute\n         * 'linecap'.\n         * Possible values for the attribute 'linecap' are: 'butt', 'round', 'square'.\n         * The default value is 'butt'. Not available for VML renderer.\n         *\n         * @param {JXG.Line} element A arbitrary line.\n         * @see Line\n         * @see JXG.Line\n         * @see JXG.AbstractRenderer#updateLine\n         */\n        setLineCap: function (el) {\n            /* stub */\n        },\n\n        /* **************************\n         *    Ticks related stuff\n         * **************************/\n\n        /**\n         * Creates a rendering node for ticks added to a line.\n         * @param {JXG.Line} el A arbitrary line.\n         * @see Line\n         * @see Ticks\n         * @see JXG.Line\n         * @see JXG.Ticks\n         * @see JXG.AbstractRenderer#updateTicks\n         */\n        drawTicks: function (el) {\n            el.rendNode = this.appendChildPrim(\n                this.createPrim(\"path\", el.id),\n                Type.evaluate(el.visProp.layer)\n            );\n            this.appendNodesToElement(el, \"path\");\n        },\n\n        /**\n         * Update {@link Ticks} on a {@link JXG.Line}. This method is only a stub and has to be implemented\n         * in any descendant renderer class.\n         * @param {JXG.Ticks} element Reference of a ticks object that has to be updated.\n         * @see Line\n         * @see Ticks\n         * @see JXG.Line\n         * @see JXG.Ticks\n         * @see JXG.AbstractRenderer#drawTicks\n         */\n        updateTicks: function (element) {\n            /* stub */\n        },\n\n        /* **************************\n         *    Circle related stuff\n         * **************************/\n\n        /**\n         * Draws a {@link JXG.Circle}\n         * @param {JXG.Circle} el Reference to a {@link JXG.Circle} object that has to be drawn.\n         * @see Circle\n         * @see JXG.Circle\n         * @see JXG.AbstractRenderer#updateEllipse\n         */\n        drawEllipse: function (el) {\n            el.rendNode = this.appendChildPrim(\n                this.createPrim(\"ellipse\", el.id),\n                Type.evaluate(el.visProp.layer)\n            );\n            this.appendNodesToElement(el, \"ellipse\");\n            this.updateEllipse(el);\n        },\n\n        /**\n         * Updates visual appearance of a given {@link JXG.Circle} on the {@link JXG.Board}.\n         * @param {JXG.Circle} el Reference to a {@link JXG.Circle} object, that has to be updated.\n         * @see Circle\n         * @see JXG.Circle\n         * @see JXG.AbstractRenderer#drawEllipse\n         */\n        updateEllipse: function (el) {\n            this._updateVisual(el);\n\n            var radius = el.Radius();\n\n            if (\n                radius > 0.0 &&\n                Math.abs(el.center.coords.usrCoords[0]) > Mat.eps &&\n                !isNaN(\n                    radius + el.center.coords.scrCoords[1] + el.center.coords.scrCoords[2]\n                ) &&\n                radius * el.board.unitX < 2000000\n            ) {\n                this.updateEllipsePrim(\n                    el.rendNode,\n                    el.center.coords.scrCoords[1],\n                    el.center.coords.scrCoords[2],\n                    radius * el.board.unitX,\n                    radius * el.board.unitY\n                );\n            }\n        },\n\n        /* **************************\n         *   Polygon related stuff\n         * **************************/\n\n        /**\n         * Draws a {@link JXG.Polygon} on the {@link JXG.Board}.\n         * @param {JXG.Polygon} el Reference to a Polygon object, that is to be drawn.\n         * @see Polygon\n         * @see JXG.Polygon\n         * @see JXG.AbstractRenderer#updatePolygon\n         */\n        drawPolygon: function (el) {\n            el.rendNode = this.appendChildPrim(\n                this.createPrim(\"polygon\", el.id),\n                Type.evaluate(el.visProp.layer)\n            );\n            this.appendNodesToElement(el, \"polygon\");\n            this.updatePolygon(el);\n        },\n\n        /**\n         * Updates properties of a {@link JXG.Polygon}'s rendering node.\n         * @param {JXG.Polygon} el Reference to a {@link JXG.Polygon} object, that has to be updated.\n         * @see Polygon\n         * @see JXG.Polygon\n         * @see JXG.AbstractRenderer#drawPolygon\n         */\n        updatePolygon: function (el) {\n            // Here originally strokecolor wasn't updated but strokewidth was.\n            // But if there's no strokecolor i don't see why we should update strokewidth.\n            this._updateVisual(el, { stroke: true, dash: true });\n            this.updatePolygonPrim(el.rendNode, el);\n        },\n\n        /* **************************\n         *    Text related stuff\n         * **************************/\n\n        /**\n         * Shows a small copyright notice in the top left corner of the board.\n         * @param {String} str The copyright notice itself\n         * @param {Number} fontsize Size of the font the copyright notice is written in\n         */\n        displayCopyright: function (str, fontsize) {\n            /* stub */\n        },\n\n        /**\n         * An internal text is a {@link JXG.Text} element which is drawn using only\n         * the given renderer but no HTML. This method is only a stub, the drawing\n         * is done in the special renderers.\n         * @param {JXG.Text} element Reference to a {@link JXG.Text} object\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#updateInternalText\n         * @see JXG.AbstractRenderer#drawText\n         * @see JXG.AbstractRenderer#updateText\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        drawInternalText: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Updates visual properties of an already existing {@link JXG.Text} element.\n         * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be updated.\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#drawInternalText\n         * @see JXG.AbstractRenderer#drawText\n         * @see JXG.AbstractRenderer#updateText\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        updateInternalText: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Displays a {@link JXG.Text} on the {@link JXG.Board} by putting a HTML div over it.\n         * @param {JXG.Text} el Reference to an {@link JXG.Text} object, that has to be displayed\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#drawInternalText\n         * @see JXG.AbstractRenderer#updateText\n         * @see JXG.AbstractRenderer#updateInternalText\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        drawText: function (el) {\n            var node, z, level, ev_visible;\n\n            if (\n                Type.evaluate(el.visProp.display) === \"html\" &&\n                Env.isBrowser &&\n                this.type !== \"no\"\n            ) {\n                node = this.container.ownerDocument.createElement(\"div\");\n                //node = this.container.ownerDocument.createElementNS('http://www.w3.org/1999/xhtml', 'div'); //\n                node.style.position = \"absolute\";\n                node.className = Type.evaluate(el.visProp.cssclass);\n\n                level = Type.evaluate(el.visProp.layer);\n                if (!Type.exists(level)) {\n                    // trace nodes have level not set\n                    level = 0;\n                }\n\n                if (this.container.style.zIndex === \"\") {\n                    z = 0;\n                } else {\n                    z = parseInt(this.container.style.zIndex, 10);\n                }\n\n                node.style.zIndex = z + level;\n                this.container.appendChild(node);\n\n                node.setAttribute(\"id\", this.container.id + \"_\" + el.id);\n            } else {\n                node = this.drawInternalText(el);\n            }\n\n            el.rendNode = node;\n            el.htmlStr = \"\";\n\n            // Set el.visPropCalc.visible\n            if (el.visProp.islabel && Type.exists(el.visProp.anchor)) {\n                ev_visible = Type.evaluate(el.visProp.anchor.visProp.visible);\n                el.prepareUpdate().updateVisibility(ev_visible);\n            } else {\n                el.prepareUpdate().updateVisibility();\n            }\n            this.updateText(el);\n        },\n\n        /**\n         * Updates visual properties of an already existing {@link JXG.Text} element.\n         * @param {JXG.Text} el Reference to an {@link JXG.Text} object, that has to be updated.\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#drawText\n         * @see JXG.AbstractRenderer#drawInternalText\n         * @see JXG.AbstractRenderer#updateInternalText\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        updateText: function (el) {\n            var content = el.plaintext,\n                v,\n                c,\n                parentNode,\n                scale,\n                vshift,\n                id,\n                wrap_id,\n                ax,\n                ay;\n\n            if (el.visPropCalc.visible) {\n                this.updateTextStyle(el, false);\n\n                if (Type.evaluate(el.visProp.display) === \"html\" && this.type !== \"no\") {\n                    // Set the position\n                    if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {\n                        // Horizontal\n                        c = el.coords.scrCoords[1];\n                        // webkit seems to fail for extremely large values for c.\n                        c = Math.abs(c) < 1000000 ? c : 1000000;\n                        ax = el.getAnchorX();\n\n                        if (ax === \"right\") {\n                            // v = Math.floor(el.board.canvasWidth - c);\n                            v = el.board.canvasWidth - c;\n                        } else if (ax === \"middle\") {\n                            // v = Math.floor(c - 0.5 * el.size[0]);\n                            v = c - 0.5 * el.size[0];\n                        } else {\n                            // 'left'\n                            // v = Math.floor(c);\n                            v = c;\n                        }\n\n                        // This may be useful for foreignObj.\n                        //if (window.devicePixelRatio !== undefined) {\n                        //v *= window.devicePixelRatio;\n                        //}\n\n                        if (el.visPropOld.left !== ax + v) {\n                            if (ax === \"right\") {\n                                el.rendNode.style.right = v + \"px\";\n                                el.rendNode.style.left = \"auto\";\n                            } else {\n                                el.rendNode.style.left = v + \"px\";\n                                el.rendNode.style.right = \"auto\";\n                            }\n                            el.visPropOld.left = ax + v;\n                        }\n\n                        // Vertical\n                        c = el.coords.scrCoords[2] + this.vOffsetText;\n                        c = Math.abs(c) < 1000000 ? c : 1000000;\n                        ay = el.getAnchorY();\n\n                        if (ay === \"bottom\") {\n                            // v = Math.floor(el.board.canvasHeight - c);\n                            v = el.board.canvasHeight - c;\n                        } else if (ay === \"middle\") {\n                            // v = Math.floor(c - 0.5 * el.size[1]);\n                            v = c - 0.5 * el.size[1];\n                        } else {\n                            // top\n                            // v = Math.floor(c);\n                            v = c;\n                        }\n\n                        // This may be useful for foreignObj.\n                        //if (window.devicePixelRatio !== undefined) {\n                        //v *= window.devicePixelRatio;\n                        //}\n\n                        if (el.visPropOld.top !== ay + v) {\n                            if (ay === \"bottom\") {\n                                el.rendNode.style.top = \"auto\";\n                                el.rendNode.style.bottom = v + \"px\";\n                            } else {\n                                el.rendNode.style.bottom = \"auto\";\n                                el.rendNode.style.top = v + \"px\";\n                            }\n                            el.visPropOld.top = ay + v;\n                        }\n                    }\n\n                    // Set the content\n                    if (el.htmlStr !== content) {\n                        try {\n                            if (el.type === Type.OBJECT_TYPE_BUTTON) {\n                                el.rendNodeButton.innerHTML = content;\n                            } else if (\n                                el.type === Type.OBJECT_TYPE_CHECKBOX ||\n                                el.type === Type.OBJECT_TYPE_INPUT\n                            ) {\n                                el.rendNodeLabel.innerHTML = content;\n                            } else {\n                                el.rendNode.innerHTML = content;\n                            }\n                        } catch (e) {\n                            // Setting innerHTML sometimes fails in IE8.\n                            // A workaround is to take the node off the DOM, assign innerHTML,\n                            // then append back.\n                            // Works for text elements as they are absolutely positioned.\n                            parentNode = el.rendNode.parentNode;\n                            el.rendNode.parentNode.removeChild(el.rendNode);\n                            el.rendNode.innerHTML = content;\n                            parentNode.appendChild(el.rendNode);\n                        }\n                        el.htmlStr = content;\n\n                        if (Type.evaluate(el.visProp.usemathjax)) {\n                            // Typesetting directly might not work because mathjax was not loaded completely\n                            // see http://www.mathjax.org/docs/1.1/typeset.html\n                            try {\n                                if (MathJax.typeset) {\n                                    // Version 3\n                                    MathJax.typeset([el.rendNode]);\n                                } else {\n                                    // Version 2\n                                    MathJax.Hub.Queue([\"Typeset\", MathJax.Hub, el.rendNode]);\n                                }\n\n                                // Restore the transformation necessary for fullscreen mode\n                                // MathJax removes it when handling dynamic content\n                                id = el.board.container;\n                                wrap_id = \"fullscreenwrap_\" + id;\n                                if (document.getElementById(wrap_id)) {\n                                    scale = el.board.containerObj._cssFullscreenStore.scale;\n                                    vshift = el.board.containerObj._cssFullscreenStore.vshift;\n                                    Env.scaleJSXGraphDiv(\n                                        \"#\" + wrap_id,\n                                        \"#\" + id,\n                                        scale,\n                                        vshift\n                                    );\n                                }\n                            } catch (e) {\n                                JXG.debug(\"MathJax (not yet) loaded\");\n                            }\n                        } else if (Type.evaluate(el.visProp.usekatex)) {\n                            try {\n                                /* eslint-disable no-undef */\n                                katex.render(content, el.rendNode, {\n                                    throwOnError: false\n                                });\n                                /* eslint-enable no-undef */\n                            } catch (e) {\n                                JXG.debug(\"KaTeX (not yet) loaded\");\n                            }\n                        } else if (Type.evaluate(el.visProp.useasciimathml)) {\n                            // This is not a constructor.\n                            // See http://www1.chapman.edu/~jipsen/mathml/asciimath.html for more information\n                            // about AsciiMathML and the project's source code.\n                            try {\n                                AMprocessNode(el.rendNode, false);\n                            } catch (e) {\n                                JXG.debug(\"AsciiMathML (not yet) loaded\");\n                            }\n                        }\n                    }\n                    this.transformImage(el, el.transformations);\n                } else {\n                    this.updateInternalText(el);\n                }\n            }\n        },\n\n        /**\n         * Converts string containing CSS properties into\n         * array with key-value pair objects.\n         *\n         * @example\n         * \"color:blue; background-color:yellow\" is converted to\n         * [{'color': 'blue'}, {'backgroundColor': 'yellow'}]\n         *\n         * @param  {String} cssString String containing CSS properties\n         * @return {Array}           Array of CSS key-value pairs\n         */\n        _css2js: function (cssString) {\n            var pairs = [],\n                i,\n                len,\n                key,\n                val,\n                s,\n                list = Type.trim(cssString).replace(/;$/, \"\").split(\";\");\n\n            len = list.length;\n            for (i = 0; i < len; ++i) {\n                if (Type.trim(list[i]) !== \"\") {\n                    s = list[i].split(\":\");\n                    key = Type.trim(\n                        s[0].replace(/-([a-z])/gi, function (match, char) {\n                            return char.toUpperCase();\n                        })\n                    );\n                    val = Type.trim(s[1]);\n                    pairs.push({ key: key, val: val });\n                }\n            }\n            return pairs;\n        },\n\n        /**\n         * Updates font-size, color and opacity propertiey and CSS style properties of a {@link JXG.Text} node.\n         * This function is also called by highlight() and nohighlight().\n         * @param {JXG.Text} el Reference to the {@link JXG.Text} object, that has to be updated.\n         * @param {Boolean} doHighlight\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#drawText\n         * @see JXG.AbstractRenderer#drawInternalText\n         * @see JXG.AbstractRenderer#updateText\n         * @see JXG.AbstractRenderer#updateInternalText\n         * @see JXG.AbstractRenderer#updateInternalTextStyle\n         */\n        updateTextStyle: function (el, doHighlight) {\n            var fs,\n                so,\n                sc,\n                css,\n                node,\n                ev = el.visProp,\n                display = Env.isBrowser ? ev.display : \"internal\",\n                nodeList = [\"rendNode\", \"rendNodeTag\", \"rendNodeLabel\"],\n                lenN = nodeList.length,\n                fontUnit = Type.evaluate(ev.fontunit),\n                cssList,\n                prop,\n                style,\n                cssString,\n                styleList = [\"cssdefaultstyle\", \"cssstyle\"],\n                lenS = styleList.length;\n\n            if (doHighlight) {\n                sc = ev.highlightstrokecolor;\n                so = ev.highlightstrokeopacity;\n                css = ev.highlightcssclass;\n            } else {\n                sc = ev.strokecolor;\n                so = ev.strokeopacity;\n                css = ev.cssclass;\n            }\n\n            // This part is executed for all text elements except internal texts in canvas.\n            // HTML-texts or internal texts in SVG or VML.\n            //            HTML    internal\n            //  SVG        +         +\n            //  VML        +         +\n            //  canvas     +         -\n            //  no         -         -\n            if (this.type !== \"no\" && (display === \"html\" || this.type !== \"canvas\")) {\n                for (style = 0; style < lenS; style++) {\n                    // First set cssString to\n                    // ev.cssdefaultstyle of ev.highlightcssdefaultstyle,\n                    // then to\n                    // ev.cssstyle of ev.highlightcssstyle\n                    cssString = Type.evaluate(\n                        ev[(doHighlight ? \"highlight\" : \"\") + styleList[style]]\n                    );\n                    if (cssString !== \"\" && el.visPropOld[styleList[style]] !== cssString) {\n                        cssList = this._css2js(cssString);\n                        for (node = 0; node < lenN; node++) {\n                            if (Type.exists(el[nodeList[node]])) {\n                                for (prop in cssList) {\n                                    if (cssList.hasOwnProperty(prop)) {\n                                        el[nodeList[node]].style[cssList[prop].key] =\n                                            cssList[prop].val;\n                                    }\n                                }\n                            }\n                        }\n                        el.visPropOld[styleList[style]] = cssString;\n                    }\n                }\n\n                fs = Type.evaluate(ev.fontsize);\n                if (el.visPropOld.fontsize !== fs) {\n                    el.needsSizeUpdate = true;\n                    try {\n                        for (node = 0; node < lenN; node++) {\n                            if (Type.exists(el[nodeList[node]])) {\n                                el[nodeList[node]].style.fontSize = fs + fontUnit;\n                            }\n                        }\n                    } catch (e) {\n                        // IE needs special treatment.\n                        for (node = 0; node < lenN; node++) {\n                            if (Type.exists(el[nodeList[node]])) {\n                                el[nodeList[node]].style.fontSize = fs;\n                            }\n                        }\n                    }\n                    el.visPropOld.fontsize = fs;\n                }\n            }\n\n            this.setObjectTransition(el);\n            if (display === \"html\" && this.type !== \"no\") {\n                // Set new CSS class\n                if (el.visPropOld.cssclass !== css) {\n                    el.rendNode.className = css;\n                    el.visPropOld.cssclass = css;\n                    el.needsSizeUpdate = true;\n                }\n                this.setObjectStrokeColor(el, sc, so);\n            } else {\n                this.updateInternalTextStyle(el, sc, so);\n            }\n\n            return this;\n        },\n\n        /**\n         * Set color and opacity of internal texts.\n         * This method is used for Canvas and VML.\n         * SVG needs its own version.\n         * @private\n         * @see JXG.AbstractRenderer#updateTextStyle\n         * @see JXG.SVGRenderer#updateInternalTextStyle\n         */\n        updateInternalTextStyle: function (el, strokeColor, strokeOpacity) {\n            this.setObjectStrokeColor(el, strokeColor, strokeOpacity);\n        },\n\n        /* **************************\n         *    Image related stuff\n         * **************************/\n\n        /**\n         * Draws an {@link JXG.Image} on a board; This is just a template that has to be implemented by special\n         * renderers.\n         * @param {JXG.Image} element Reference to the image object that is to be drawn\n         * @see Image\n         * @see JXG.Image\n         * @see JXG.AbstractRenderer#updateImage\n         */\n        drawImage: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Updates the properties of an {@link JXG.Image} element.\n         * @param {JXG.Image} el Reference to an {@link JXG.Image} object, that has to be updated.\n         * @see Image\n         * @see JXG.Image\n         * @see JXG.AbstractRenderer#drawImage\n         */\n        updateImage: function (el) {\n            this.updateRectPrim(\n                el.rendNode,\n                el.coords.scrCoords[1],\n                el.coords.scrCoords[2] - el.size[1],\n                el.size[0],\n                el.size[1]\n            );\n\n            this.updateImageURL(el);\n            this.transformImage(el, el.transformations);\n            this._updateVisual(el, { stroke: true, dash: true }, true);\n        },\n\n        /**\n         * Multiplication of transformations without updating. That means, at that point it is expected that the\n         * matrices contain numbers only. First, the origin in user coords is translated to <tt>(0,0)</tt> in screen\n         * coords. Then, the stretch factors are divided out. After the transformations in user coords, the stretch\n         * factors are multiplied in again, and the origin in user coords is translated back to its position. This\n         * method does not have to be implemented in a new renderer.\n         * @param {JXG.GeometryElement} el A JSXGraph element. We only need its board property.\n         * @param {Array} transformations An array of JXG.Transformations.\n         * @returns {Array} A matrix represented by a two dimensional array of numbers.\n         * @see JXG.AbstractRenderer#transformImage\n         */\n        joinTransforms: function (el, transformations) {\n            var i,\n                ox = el.board.origin.scrCoords[1],\n                oy = el.board.origin.scrCoords[2],\n                ux = el.board.unitX,\n                uy = el.board.unitY,\n                // Translate to 0,0 in screen coords\n                /*\n                m = [[1, 0, 0], [0, 1, 0], [0, 0, 1]],\n                mpre1 =  [[1,   0, 0],\n                    [-ox, 1, 0],\n                    [-oy, 0, 1]],\n                // Scale\n                mpre2 =  [[1, 0,     0],\n                    [0, 1 / ux,  0],\n                    [0, 0, -1 / uy]],\n                // Scale back\n                mpost2 = [[1, 0,   0],\n                    [0, ux,  0],\n                    [0, 0, -uy]],\n                // Translate back\n                mpost1 = [[1,  0, 0],\n                    [ox, 1, 0],\n                    [oy, 0, 1]],\n                */\n                len = transformations.length,\n                // Translate to 0,0 in screen coords and then scale\n                m = [\n                    [1, 0, 0],\n                    [-ox / ux, 1 / ux, 0],\n                    [oy / uy, 0, -1 / uy]\n                ];\n\n            for (i = 0; i < len; i++) {\n                //m = Mat.matMatMult(mpre1, m);\n                //m = Mat.matMatMult(mpre2, m);\n                m = Mat.matMatMult(transformations[i].matrix, m);\n                //m = Mat.matMatMult(mpost2, m);\n                //m = Mat.matMatMult(mpost1, m);\n            }\n            // Scale back and then translate back\n            m = Mat.matMatMult(\n                [\n                    [1, 0, 0],\n                    [ox, ux, 0],\n                    [oy, 0, -uy]\n                ],\n                m\n            );\n            return m;\n        },\n\n        /**\n         * Applies transformations on images and text elements. This method is just a stub and has to be implemented in\n         * all descendant classes where text and image transformations are to be supported.\n         * @param {JXG.Image|JXG.Text} element A {@link JXG.Image} or {@link JXG.Text} object.\n         * @param {Array} transformations An array of {@link JXG.Transformation} objects. This is usually the\n         * transformations property of the given element <tt>el</tt>.\n         */\n        transformImage: function (element, transformations) {\n            /* stub */\n        },\n\n        /**\n         * If the URL of the image is provided by a function the URL has to be updated during updateImage()\n         * @param {JXG.Image} element Reference to an image object.\n         * @see JXG.AbstractRenderer#updateImage\n         */\n        updateImageURL: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Updates CSS style properties of a {@link JXG.Image} node.\n         * In SVGRenderer opacity is the only available style element.\n         * This function is called by highlight() and nohighlight().\n         * This function works for VML.\n         * It does not work for Canvas.\n         * SVGRenderer overwrites this method.\n         * @param {JXG.Text} el Reference to the {@link JXG.Image} object, that has to be updated.\n         * @param {Boolean} doHighlight\n         * @see Image\n         * @see JXG.Image\n         * @see JXG.AbstractRenderer#highlight\n         * @see JXG.AbstractRenderer#noHighlight\n         */\n        updateImageStyle: function (el, doHighlight) {\n            el.rendNode.className = Type.evaluate(\n                doHighlight ? el.visProp.highlightcssclass : el.visProp.cssclass\n            );\n        },\n\n        drawForeignObject: function (el) {\n            /* stub */\n        },\n\n        updateForeignObject: function (el) {\n            /* stub */\n        },\n\n        /* **************************\n         * Render primitive objects\n         * **************************/\n\n        /**\n         * Appends a node to a specific layer level. This is just an abstract method and has to be implemented\n         * in all renderers that want to use the <tt>createPrim</tt> model to draw.\n         * @param {Node} node A DOM tree node.\n         * @param {Number} level The layer the node is attached to. This is the index of the layer in\n         * {@link JXG.SVGRenderer#layer} or the <tt>z-index</tt> style property of the node in VMLRenderer.\n         */\n        appendChildPrim: function (node, level) {\n            /* stub */\n        },\n\n        /**\n         * Stores the rendering nodes. This is an abstract method which has to be implemented in all renderers that use\n         * the <tt>createPrim</tt> method.\n         * @param {JXG.GeometryElement} element A JSXGraph element.\n         * @param {String} type The XML node name. Only used in VMLRenderer.\n         */\n        appendNodesToElement: function (element, type) {\n            /* stub */\n        },\n\n        /**\n         * Creates a node of a given type with a given id.\n         * @param {String} type The type of the node to create.\n         * @param {String} id Set the id attribute to this.\n         * @returns {Node} Reference to the created node.\n         */\n        createPrim: function (type, id) {\n            /* stub */\n            return null;\n        },\n\n        /**\n         * Removes an element node. Just a stub.\n         * @param {Node} node The node to remove.\n         */\n        remove: function (node) {\n            /* stub */\n        },\n\n        /**\n         * Can be used to create the nodes to display arrows. This is an abstract method which has to be implemented\n         * in any descendant renderer.\n         * @param {JXG.GeometryElement} element The element the arrows are to be attached to.\n         * @param {Object} arrowData Data concerning possible arrow heads\n         *\n         */\n        makeArrows: function (element, arrowData) {\n            /* stub */\n        },\n\n        /**\n         * Updates width of an arrow DOM node. Used in\n         * @param {Node} node The arrow node.\n         * @param {Number} width\n         * @param {Node} parentNode Used in IE only\n         */\n        _setArrowWidth: function (node, width, parentNode) {\n            /* stub */\n        },\n\n        /**\n         * Updates an ellipse node primitive. This is an abstract method which has to be implemented in all renderers\n         * that use the <tt>createPrim</tt> method.\n         * @param {Node} node Reference to the node.\n         * @param {Number} x Centre X coordinate\n         * @param {Number} y Centre Y coordinate\n         * @param {Number} rx The x-axis radius.\n         * @param {Number} ry The y-axis radius.\n         */\n        updateEllipsePrim: function (node, x, y, rx, ry) {\n            /* stub */\n        },\n\n        /**\n         * Refreshes a line node. This is an abstract method which has to be implemented in all renderers that use\n         * the <tt>createPrim</tt> method.\n         * @param {Node} node The node to be refreshed.\n         * @param {Number} p1x The first point's x coordinate.\n         * @param {Number} p1y The first point's y coordinate.\n         * @param {Number} p2x The second point's x coordinate.\n         * @param {Number} p2y The second point's y coordinate.\n         * @param {JXG.Board} board\n         */\n        updateLinePrim: function (node, p1x, p1y, p2x, p2y, board) {\n            /* stub */\n        },\n\n        /**\n         * Updates a path element. This is an abstract method which has to be implemented in all renderers that use\n         * the <tt>createPrim</tt> method.\n         * @param {Node} node The path node.\n         * @param {String} pathString A string formatted like e.g. <em>'M 1,2 L 3,1 L5,5'</em>. The format of the string\n         * depends on the rendering engine.\n         * @param {JXG.Board} board Reference to the element's board.\n         */\n        updatePathPrim: function (node, pathString, board) {\n            /* stub */\n        },\n\n        /**\n         * Builds a path data string to draw a point with a face other than <em>rect</em> and <em>circle</em>. Since\n         * the format of such a string usually depends on the renderer this method\n         * is only an abstract method. Therefore, it has to be implemented in the descendant renderer itself unless\n         * the renderer does not use the createPrim interface but the draw* interfaces to paint.\n         * @param {JXG.Point} element The point element\n         * @param {Number} size A positive number describing the size. Usually the half of the width and height of\n         * the drawn point.\n         * @param {String} type A string describing the point's face. This method only accepts the shortcut version of\n         * each possible face: <tt>x, +, <>, ^, v, >, < </tt>\n         */\n        updatePathStringPoint: function (element, size, type) {\n            /* stub */\n        },\n\n        /**\n         * Builds a path data string from a {@link JXG.Curve} element. Since the path data strings heavily depend on the\n         * underlying rendering technique this method is just a stub. Although such a path string is of no use for the\n         * CanvasRenderer, this method is used there to draw a path directly.\n         * @param element\n         */\n        updatePathStringPrim: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Builds a path data string from a {@link JXG.Curve} element such that the curve looks like hand drawn. Since\n         * the path data strings heavily depend on the underlying rendering technique this method is just a stub.\n         * Although such a path string is of no use for the CanvasRenderer, this method is used there to draw a path\n         * directly.\n         * @param element\n         */\n        updatePathStringBezierPrim: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Update a polygon primitive.\n         * @param {Node} node\n         * @param {JXG.Polygon} element A JSXGraph element of type {@link JXG.Polygon}\n         */\n        updatePolygonPrim: function (node, element) {\n            /* stub */\n        },\n\n        /**\n         * Update a rectangle primitive. This is used only for points with face of type 'rect'.\n         * @param {Node} node The node yearning to be updated.\n         * @param {Number} x x coordinate of the top left vertex.\n         * @param {Number} y y coordinate of the top left vertex.\n         * @param {Number} w Width of the rectangle.\n         * @param {Number} h The rectangle's height.\n         */\n        updateRectPrim: function (node, x, y, w, h) {\n            /* stub */\n        },\n\n        /* **************************\n         *  Set Attributes\n         * **************************/\n\n        /**\n         * Sets a node's attribute.\n         * @param {Node} node The node that is to be updated.\n         * @param {String} key Name of the attribute.\n         * @param {String} val New value for the attribute.\n         */\n        setPropertyPrim: function (node, key, val) {\n            /* stub */\n        },\n\n        setTabindex: function (element) {\n            var val;\n            if (element.board.attr.keyboard.enabled && Type.exists(element.rendNode)) {\n                val = Type.evaluate(element.visProp.tabindex);\n                if (!element.visPropCalc.visible || Type.evaluate(element.visProp.fixed)) {\n                    val = null;\n                }\n                if (val !== element.visPropOld.tabindex) {\n                    element.rendNode.setAttribute(\"tabindex\", val);\n                    element.visPropOld.tabindex = val;\n                }\n            }\n        },\n\n        /**\n         * Shows or hides an element on the canvas; Only a stub, requires implementation in the derived renderer.\n         * @param {JXG.GeometryElement} element Reference to the object that has to appear.\n         * @param {Boolean} value true to show the element, false to hide the element.\n         */\n        display: function (element, value) {\n            if (element) {\n                element.visPropOld.visible = value;\n            }\n        },\n\n        /**\n         * Shows a hidden element on the canvas; Only a stub, requires implementation in the derived renderer.\n         *\n         * Please use JXG.AbstractRenderer#display instead\n         * @param {JXG.GeometryElement} element Reference to the object that has to appear.\n         * @see JXG.AbstractRenderer#hide\n         * @deprecated\n         */\n        show: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Hides an element on the canvas; Only a stub, requires implementation in the derived renderer.\n         *\n         * Please use JXG.AbstractRenderer#display instead\n         * @param {JXG.GeometryElement} element Reference to the geometry element that has to disappear.\n         * @see JXG.AbstractRenderer#show\n         * @deprecated\n         */\n        hide: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Sets the buffering as recommended by SVGWG. Until now only Opera supports this and will be ignored by other\n         * browsers. Although this feature is only supported by SVG we have this method in {@link JXG.AbstractRenderer}\n         * because it is called from outside the renderer.\n         * @param {Node} node The SVG DOM Node which buffering type to update.\n         * @param {String} type Either 'auto', 'dynamic', or 'static'. For an explanation see\n         *   {@link http://www.w3.org/TR/SVGTiny12/painting.html#BufferedRenderingProperty}.\n         */\n        setBuffering: function (node, type) {\n            /* stub */\n        },\n\n        /**\n         * Sets an element's dash style.\n         * @param {JXG.GeometryElement} element An JSXGraph element.\n         */\n        setDashStyle: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Puts an object into draft mode, i.e. it's visual appearance will be changed. For GEONE<sub>x</sub>T backwards\n         * compatibility.\n         * @param {JXG.GeometryElement} el Reference of the object that is in draft mode.\n         */\n        setDraft: function (el) {\n            if (!Type.evaluate(el.visProp.draft)) {\n                return;\n            }\n            var draftColor = el.board.options.elements.draft.color,\n                draftOpacity = el.board.options.elements.draft.opacity;\n\n            this.setObjectTransition(el);\n            if (el.type === Const.OBJECT_TYPE_POLYGON) {\n                this.setObjectFillColor(el, draftColor, draftOpacity);\n            } else {\n                if (el.elementClass === Const.OBJECT_CLASS_POINT) {\n                    this.setObjectFillColor(el, draftColor, draftOpacity);\n                } else {\n                    this.setObjectFillColor(el, \"none\", 0);\n                }\n                this.setObjectStrokeColor(el, draftColor, draftOpacity);\n                this.setObjectStrokeWidth(el, el.board.options.elements.draft.strokeWidth);\n            }\n        },\n\n        /**\n         * Puts an object from draft mode back into normal mode.\n         * @param {JXG.GeometryElement} el Reference of the object that no longer is in draft mode.\n         */\n        removeDraft: function (el) {\n            this.setObjectTransition(el);\n            if (el.type === Const.OBJECT_TYPE_POLYGON) {\n                this.setObjectFillColor(el, el.visProp.fillcolor, el.visProp.fillopacity);\n            } else {\n                if (el.type === Const.OBJECT_CLASS_POINT) {\n                    this.setObjectFillColor(el, el.visProp.fillcolor, el.visProp.fillopacity);\n                }\n                this.setObjectStrokeColor(el, el.visProp.strokecolor, el.visProp.strokeopacity);\n                this.setObjectStrokeWidth(el, el.visProp.strokewidth);\n            }\n        },\n\n        /**\n         * Sets up nodes for rendering a gradient fill.\n         * @param element\n         */\n        setGradient: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Updates the gradient fill.\n         * @param {JXG.GeometryElement} element An JSXGraph element with an area that can be filled.\n         */\n        updateGradient: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Sets the transition duration (in milliseconds) for fill color and stroke\n         * color and opacity.\n         * @param {JXG.GeometryElement} element Reference of the object that wants a\n         *         new transition duration.\n         * @param {Number} duration (Optional) duration in milliseconds. If not given,\n         *        element.visProp.transitionDuration is taken. This is the default.\n         */\n        setObjectTransition: function (element, duration) {\n            /* stub */\n        },\n\n        /**\n         * Sets an objects fill color.\n         * @param {JXG.GeometryElement} element Reference of the object that wants a new fill color.\n         * @param {String} color Color in a HTML/CSS compatible format. If you don't want any fill color at all, choose\n         * 'none'.\n         * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.\n         */\n        setObjectFillColor: function (element, color, opacity) {\n            /* stub */\n        },\n\n        /**\n         * Changes an objects stroke color to the given color.\n         * @param {JXG.GeometryElement} element Reference of the {@link JXG.GeometryElement} that gets a new stroke\n         * color.\n         * @param {String} color Color value in a HTML compatible format, e.g. <strong>#00ff00</strong> or\n         * <strong>green</strong> for green.\n         * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.\n         */\n        setObjectStrokeColor: function (element, color, opacity) {\n            /* stub */\n        },\n\n        /**\n         * Sets an element's stroke width.\n         * @param {JXG.GeometryElement} element Reference to the geometry element.\n         * @param {Number} width The new stroke width to be assigned to the element.\n         */\n        setObjectStrokeWidth: function (element, width) {\n            /* stub */\n        },\n\n        /**\n         * Sets the shadow properties to a geometry element. This method is only a stub, it is implemented in the actual\n         * renderers.\n         * @param {JXG.GeometryElement} element Reference to a geometry object, that should get a shadow\n         */\n        setShadow: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Highlights an object, i.e. changes the current colors of the object to its highlighting colors\n         * and highlighting stroke width.\n         * @param {JXG.GeometryElement} el Reference of the object that will be highlighted.\n         * @returns {JXG.AbstractRenderer} Reference to the renderer\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        highlight: function (el) {\n            var i,\n                ev = el.visProp,\n                sw;\n\n            this.setObjectTransition(el);\n            if (!ev.draft) {\n                if (el.type === Const.OBJECT_TYPE_POLYGON) {\n                    this.setObjectFillColor(el, ev.highlightfillcolor, ev.highlightfillopacity);\n                    for (i = 0; i < el.borders.length; i++) {\n                        this.setObjectStrokeColor(\n                            el.borders[i],\n                            el.borders[i].visProp.highlightstrokecolor,\n                            el.borders[i].visProp.highlightstrokeopacity\n                        );\n                    }\n                } else {\n                    if (el.elementClass === Const.OBJECT_CLASS_TEXT) {\n                        this.updateTextStyle(el, true);\n                    } else if (el.type === Const.OBJECT_TYPE_IMAGE) {\n                        this.updateImageStyle(el, true);\n                        this.setObjectFillColor(\n                            el,\n                            ev.highlightfillcolor,\n                            ev.highlightfillopacity\n                        );\n                    } else {\n                        this.setObjectStrokeColor(\n                            el,\n                            ev.highlightstrokecolor,\n                            ev.highlightstrokeopacity\n                        );\n                        this.setObjectFillColor(\n                            el,\n                            ev.highlightfillcolor,\n                            ev.highlightfillopacity\n                        );\n                    }\n                }\n                if (ev.highlightstrokewidth) {\n                    sw = Math.max(\n                        Type.evaluate(ev.highlightstrokewidth),\n                        Type.evaluate(ev.strokewidth)\n                    );\n                    this.setObjectStrokeWidth(el, sw);\n                    if (\n                        el.elementClass === Const.OBJECT_CLASS_LINE ||\n                        el.elementClass === Const.OBJECT_CLASS_CURVE\n                    ) {\n                        this.updatePathWithArrowHeads(el, true);\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Uses the normal colors of an object, i.e. the opposite of {@link JXG.AbstractRenderer#highlight}.\n         * @param {JXG.GeometryElement} el Reference of the object that will get its normal colors.\n         * @returns {JXG.AbstractRenderer} Reference to the renderer\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        noHighlight: function (el) {\n            var i,\n                ev = el.visProp,\n                sw;\n\n            this.setObjectTransition(el);\n            if (!Type.evaluate(el.visProp.draft)) {\n                if (el.type === Const.OBJECT_TYPE_POLYGON) {\n                    this.setObjectFillColor(el, ev.fillcolor, ev.fillopacity);\n                    for (i = 0; i < el.borders.length; i++) {\n                        this.setObjectStrokeColor(\n                            el.borders[i],\n                            el.borders[i].visProp.strokecolor,\n                            el.borders[i].visProp.strokeopacity\n                        );\n                    }\n                } else {\n                    if (el.elementClass === Const.OBJECT_CLASS_TEXT) {\n                        this.updateTextStyle(el, false);\n                    } else if (el.type === Const.OBJECT_TYPE_IMAGE) {\n                        this.updateImageStyle(el, false);\n                        this.setObjectFillColor(el, ev.fillcolor, ev.fillopacity);\n                    } else {\n                        this.setObjectStrokeColor(el, ev.strokecolor, ev.strokeopacity);\n                        this.setObjectFillColor(el, ev.fillcolor, ev.fillopacity);\n                    }\n                }\n\n                sw = Type.evaluate(ev.strokewidth);\n                this.setObjectStrokeWidth(el, sw);\n                if (\n                    el.elementClass === Const.OBJECT_CLASS_LINE ||\n                    el.elementClass === Const.OBJECT_CLASS_CURVE\n                ) {\n                    this.updatePathWithArrowHeads(el, false);\n                }\n            }\n\n            return this;\n        },\n\n        /* **************************\n         * renderer control\n         * **************************/\n\n        /**\n         * Stop redraw. This method is called before every update, so a non-vector-graphics based renderer can use this\n         * method to delete the contents of the drawing panel. This is an abstract method every descendant renderer\n         * should implement, if appropriate.\n         * @see JXG.AbstractRenderer#unsuspendRedraw\n         */\n        suspendRedraw: function () {\n            /* stub */\n        },\n\n        /**\n         * Restart redraw. This method is called after updating all the rendering node attributes.\n         * @see JXG.AbstractRenderer#suspendRedraw\n         */\n        unsuspendRedraw: function () {\n            /* stub */\n        },\n\n        /**\n         * The tiny zoom bar shown on the bottom of a board (if showNavigation on board creation is true).\n         * It is a div element and gets the CSS class \"JXG_navigation\" and the id {board id}_navigationbar.\n         *\n         * The buttons get the CSS class \"JXG_navigation_button\" and the id {board_id}_name where name is\n         * one of [top, down, left, right, out, 100, in, fullscreen, screenshot, reload, cleartraces].\n         *\n         * The symbols are hard-coded.\n         *\n         * @param {JXG.Board} board Reference to a JSXGraph board.\n         * @param {Object} attr Attributes of the navigation bar\n         *\n         */\n        drawZoomBar: function (board, attr) {\n            var doc,\n                node,\n                cancelbubble = function (e) {\n                    if (!e) {\n                        e = window.event;\n                    }\n\n                    if (e.stopPropagation) {\n                        // Non IE<=8\n                        e.stopPropagation();\n                    } else {\n                        e.cancelBubble = true;\n                    }\n                },\n                createButton = function (label, handler, id) {\n                    var button;\n\n                    id = id || \"\";\n\n                    button = doc.createElement(\"span\");\n                    button.innerHTML = label; // button.appendChild(doc.createTextNode(label));\n\n                    // Style settings are superseded by adding the CSS class below\n                    button.style.paddingLeft = \"7px\";\n                    button.style.paddingRight = \"7px\";\n\n                    if (button.classList !== undefined) {\n                        // classList not available in IE 9\n                        button.classList.add(\"JXG_navigation_button\");\n                    }\n                    // button.setAttribute('tabindex', 0);\n\n                    button.setAttribute(\"id\", id);\n                    node.appendChild(button);\n\n                    // Highlighting is now done with CSS\n                    // Env.addEvent(button, 'mouseover', function () {\n                    //     this.style.backgroundColor = attr.highlightfillcolor;\n                    // }, button);\n                    // Env.addEvent(button, 'mouseover', function () {\n                    //     this.style.backgroundColor = attr.highlightfillcolor;\n                    // }, button);\n                    // Env.addEvent(button, 'mouseout', function () {\n                    //     this.style.backgroundColor = attr.fillcolor;\n                    // }, button);\n\n                    Env.addEvent(\n                        button,\n                        \"click\",\n                        function (e) {\n                            Type.bind(handler, board)();\n                            return false;\n                        },\n                        board\n                    );\n                    // prevent the click from bubbling down to the board\n                    Env.addEvent(button, \"mouseup\", cancelbubble, board);\n                    Env.addEvent(button, \"mousedown\", cancelbubble, board);\n                    Env.addEvent(button, \"touchend\", cancelbubble, board);\n                    Env.addEvent(button, \"touchstart\", cancelbubble, board);\n                };\n\n            if (Env.isBrowser && this.type !== \"no\") {\n                doc = board.containerObj.ownerDocument;\n                node = doc.createElement(\"div\");\n\n                node.setAttribute(\"id\", board.container + \"_navigationbar\");\n\n                // Style settings are superseded by adding the CSS class below\n                node.style.color = attr.strokecolor;\n                node.style.backgroundColor = attr.fillcolor;\n                node.style.padding = attr.padding;\n                node.style.position = attr.position;\n                node.style.fontSize = attr.fontsize;\n                node.style.cursor = attr.cursor;\n                node.style.zIndex = attr.zindex;\n                board.containerObj.appendChild(node);\n                node.style.right = attr.right;\n                node.style.bottom = attr.bottom;\n\n                if (node.classList !== undefined) {\n                    // classList not available in IE 9\n                    node.classList.add(\"JXG_navigation\");\n                }\n                // For XHTML we need unicode instead of HTML entities\n\n                if (board.attr.showfullscreen) {\n                    createButton(\n                        board.attr.fullscreen.symbol,\n                        function () {\n                            board.toFullscreen(board.attr.fullscreen.id);\n                        },\n                        board.container + \"_navigation_fullscreen\"\n                    );\n                }\n\n                if (board.attr.showscreenshot) {\n                    createButton(\n                        board.attr.screenshot.symbol,\n                        function () {\n                            window.setTimeout(function () {\n                                board.renderer.screenshot(board, \"\", false);\n                            }, 330);\n                        },\n                        board.container + \"_navigation_screenshot\"\n                    );\n                }\n\n                if (board.attr.showreload) {\n                    // full reload circle: \\u27F2\n                    // the board.reload() method does not exist during the creation\n                    // of this button. That's why this anonymous function wrapper is required.\n                    createButton(\n                        \"\\u21BB\",\n                        function () {\n                            board.reload();\n                        },\n                        board.container + \"_navigation_reload\"\n                    );\n                }\n\n                if (board.attr.showcleartraces) {\n                    // clear traces symbol (otimes): \\u27F2\n                    createButton(\n                        \"\\u2297\",\n                        function () {\n                            board.clearTraces();\n                        },\n                        board.container + \"_navigation_cleartraces\"\n                    );\n                }\n\n                if (board.attr.shownavigation) {\n                    if (board.attr.showzoom) {\n                        createButton(\n                            \"\\u2013\",\n                            board.zoomOut,\n                            board.container + \"_navigation_out\"\n                        );\n                        createButton(\"o\", board.zoom100, board.container + \"_navigation_100\");\n                        createButton(\"+\", board.zoomIn, board.container + \"_navigation_in\");\n                    }\n                    createButton(\n                        \"\\u2190\",\n                        board.clickLeftArrow,\n                        board.container + \"_navigation_left\"\n                    );\n                    createButton(\n                        \"\\u2193\",\n                        board.clickUpArrow,\n                        board.container + \"_navigation_down\"\n                    ); // Down arrow\n                    createButton(\n                        \"\\u2191\",\n                        board.clickDownArrow,\n                        board.container + \"_navigation_up\"\n                    ); // Up arrow\n                    createButton(\n                        \"\\u2192\",\n                        board.clickRightArrow,\n                        board.container + \"_navigation_right\"\n                    );\n                }\n            }\n        },\n\n        /**\n         * Wrapper for getElementById for maybe other renderers which elements are not directly accessible by DOM\n         * methods like document.getElementById().\n         * @param {String} id Unique identifier for element.\n         * @returns {Object} Reference to a JavaScript object. In case of SVG/VMLRenderer it's a reference to a SVG/VML node.\n         */\n        getElementById: function (id) {\n            if (Type.exists(this.container)) {\n                // Use querySelector over getElementById for compatibility with both 'regular' document\n                // and ShadowDOM fragments.\n                return this.container.querySelector('#' + this.container.id + '_' + id);\n            }\n            return \"\";\n        },\n\n        /**\n         * Remove an element and provide a function that inserts it into its original position. This method\n         * is taken from this article {@link https://developers.google.com/speed/articles/javascript-dom}.\n         * @author KeeKim Heng, Google Web Developer\n         * @param {Element} el The element to be temporarily removed\n         * @returns {Function} A function that inserts the element into its original position\n         */\n        removeToInsertLater: function (el) {\n            var parentNode = el.parentNode,\n                nextSibling = el.nextSibling;\n\n            if (parentNode === null) {\n                return;\n            }\n            parentNode.removeChild(el);\n\n            return function () {\n                if (nextSibling) {\n                    parentNode.insertBefore(el, nextSibling);\n                } else {\n                    parentNode.appendChild(el);\n                }\n            };\n        },\n\n        /**\n         * Resizes the rendering element\n         * @param {Number} w New width\n         * @param {Number} h New height\n         */\n        resize: function (w, h) {\n            /* stub */\n        },\n\n        /**\n         * Create crosshair elements (Fadenkreuz) for presentations.\n         * @param {Number} n Number of crosshairs.\n         */\n        createTouchpoints: function (n) {},\n\n        /**\n         * Show a specific crosshair.\n         * @param {Number} i Number of the crosshair to show\n         */\n        showTouchpoint: function (i) {},\n\n        /**\n         * Hide a specific crosshair.\n         * @param {Number} i Number of the crosshair to show\n         */\n        hideTouchpoint: function (i) {},\n\n        /**\n         * Move a specific crosshair.\n         * @param {Number} i Number of the crosshair to show\n         * @param {Array} pos New positon in screen coordinates\n         */\n        updateTouchpoint: function (i, pos) {},\n\n        /**\n         * Convert SVG construction to base64 encoded SVG data URL.\n         * Only available on SVGRenderer.\n         *\n         * @see JXG.SVGRenderer#dumpToDataURI\n         */\n        dumpToDataURI: function (_ignoreTexts) {},\n\n        /**\n         * Convert SVG construction to canvas.\n         * Only available on SVGRenderer.\n         *\n         * @see JXG.SVGRenderer#dumpToCanvas\n         */\n        dumpToCanvas: function (canvasId, w, h, _ignoreTexts) {},\n\n        /**\n         * Display SVG image in html img-tag which enables\n         * easy download for the user.\n         *\n         * See JXG.SVGRenderer#screenshot\n         */\n        screenshot: function (board) {},\n\n        /**\n         * Move element into new layer. This is trivial for canvas, but needs more effort in SVG.\n         * Does not work dynamically, i.e. if level is a function.\n         *\n         * @param {JXG.GeometryElement} el Element which is put into different layer\n         * @param {Number} value Layer number\n         * @private\n         */\n        setLayer: function (el, level) {}\n    }\n);\n\nexport default JXG.AbstractRenderer;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG:true, define: true, ActiveXObject:true, jxgBinFileReader:true, DOMParser:true, XMLHttpRequest:true, document:true, navigator:true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Env from \"../utils/env\";\nimport Type from \"../utils/type\";\nimport Encoding from \"../utils/encoding\";\nimport Base64 from \"../utils/base64\";\n\n/**\n * The FileReader object bundles the file input capabilities of JSXGraph.\n */\nJXG.FileReader = {\n    /**\n     *\n     * @param {String} url\n     * @param {JXG.Board} board\n     * @param {String} format\n     * @param {Boolean} async\n     * @param {Function} callback\n     *\n     * @private\n     */\n    handleRemoteFile: function (url, board, format, async, encoding, callback) {\n        var request = false;\n\n        try {\n            request = new XMLHttpRequest();\n            if (format.toLowerCase() === \"raw\") {\n                request.overrideMimeType(\"text/plain; charset=\" + encoding);\n            } else {\n                request.overrideMimeType(\"text/xml; charset=\" + encoding);\n            }\n        } catch (e) {\n            try {\n                request = new ActiveXObject(\"Msxml2.XMLHTTP\");\n            } catch (ex) {\n                try {\n                    request = new ActiveXObject(\"Microsoft.XMLHTTP\");\n                } catch (exc) {\n                    request = false;\n                }\n            }\n        }\n        if (!request) {\n            JXG.debug(\"AJAX not activated!\");\n            return;\n        }\n\n        request.open(\"GET\", url, async);\n        if (format.toLowerCase() === \"raw\") {\n            this.cbp = function () {\n                var req = request;\n                if (req.readyState === 4) {\n                    board(req.responseText);\n                }\n            };\n        } else {\n            this.cbp = function () {\n                var req = request,\n                    text = \"\";\n\n                if (req.readyState === 4) {\n                    // Hack for ancient IEs:\n                    // We use the Visual Basic stuff from below.\n                    if (\n                        Type.exists(req.responseStream) &&\n                        // PK: zip, geogebra\n                        // 31: gzip, cinderella\n                        (req.responseText.slice(0, 2) === \"PK\" ||\n                            Encoding.asciiCharCodeAt(req.responseText.slice(0, 1), 0) === 31)\n                    ) {\n                        // After this, text contains the binary? zip-compressed string\n                        text = Base64.decode(jxgBinFileReader(req));\n                    } else {\n                        // This is for all browsers except ancient IEs.\n                        text = req.responseText;\n                        // console.log(text);\n                    }\n                    this.parseString(text, board, format, callback);\n                }\n            };\n        }\n\n        this.cb = Type.bind(this.cbp, this);\n        // Old style\n        request.onreadystatechange = this.cb;\n\n        try {\n            request.send(null);\n        } catch (ex2) {\n            throw new Error(\n                \"JSXGraph: A problem occurred while trying to read remote file '\" + url + \"'.\"\n            );\n        }\n    },\n\n    /**\n     *\n     * @param {Blob} url The Blob or File from which to read\n     * @param {JXG.Board} board\n     * @param {String} format\n     * @param {Boolean} async\n     * @param {Function} callback\n     *\n     * @private\n     */\n    handleLocalFile: function (url, board, format, async, encoding, callback) {\n        if (!Type.exists(async)) {\n            async = true;\n        }\n\n        if (format.toLowerCase() === \"raw\") {\n            this.cbp = function (e) {\n                board(e.target.result);\n            };\n        } else {\n            this.cbp = function (e) {\n                var text = e.target.result;\n                //console.log(text);\n                this.parseString(text, board, format, callback);\n            };\n        }\n\n        this.cb = Type.bind(this.cbp, this);\n\n        var reader = new FileReader();\n        reader.onload = this.cb;\n        if (format.toLowerCase() === \"raw\") {\n            reader.readAsText(url);\n        } else {\n            reader.readAsText(url, encoding);\n        }\n    },\n\n    /**\n     * Opens a file using the given URL and passes the contents to {@link JXG.FileReader#parseString}\n     * @param {String} url\n     * @param {JXG.Board|function} board Either a board or in case <tt>format</tt> equals 'raw' this has to be a callback function.\n     * @param {String} format The expected file format. Possible values are <dl>\n     * <dt>raw</dt><dd>Raw text file. In this case <tt>board</tt> has to be a callback function.</dd>\n     * <dt>geonext</dt><dd>Geonext File <a href=\"http://www.geonext.de\">http://www.geonext.de</a></dd>\n     * <dt>intergeo</dt><dd>Intergeo file format <a href=\"http://www.i2geo.net\">http://www.i2geo.net</a></dd>\n     * <dt>tracenpoche</dt><dd>Tracenpoche construction <a href=\"http://www.tracenpoche.net\">http://www.tracenpoche.net</a></dd>\n     * <dt>graph</dt><dd>Graph file</dd>\n     * <dt>digraph</dt><dd>DiGraph file</dd>\n     * <dt>geogebra</dt><dd>Geogebra File <a href=\"http://www.geogebra.org\">http://www.geogebra.org</a></dd>\n     * <dl><dt>cdy or cinderella</dt><dd>Cinderella (<a href=\"http://www.cinderella.de/\">http://www.cinderella.de</a></dd>\n     * </dl>\n     * @param {Boolean} async Call ajax asynchonously.\n     * @param {function} callback A function that is run when the board is ready.\n     */\n    parseFileContent: function (url, board, format, async, encoding, callback) {\n        if (Type.isString(url) || FileReader === undefined) {\n            this.handleRemoteFile(url, board, format, async, encoding, callback);\n        } else {\n            this.handleLocalFile(url, board, format, async, encoding, callback);\n        }\n    },\n\n    /**\n     * Parses a given string according to the file format given in format.\n     * @param {String} str Contents of the file.\n     * @param {JXG.Board} board The board the construction in the file should be loaded in.\n     * @param {String} format Possible values are <dl>\n     * <dt>raw</dt><dd>Raw text file. In this case <tt>board</tt> has to be a callback function.</dd>\n     * <dt>geonext</dt><dd>Geonext File <a href=\"http://www.geonext.de\">http://www.geonext.de</a></dd>\n     * <dt>intergeo</dt><dd>Intergeo file format <a href=\"http://www.i2geo.net\">http://www.i2geo.net</a></dd>\n     * <dt>tracenpoche</dt><dd>Tracenpoche construction <a href=\"http://www.tracenpoche.net\">http://www.tracenpoche.net</a></dd>\n     * <dt>graph</dt><dd>Graph file</dd>\n     * <dt>digraph</dt><dd>DiGraph file</dd>\n     * <dt>geogebra</dt><dd>Geogebra File <a href=\"http://www.geogebra.org\">http://www.geogebra.org</a></dd>\n     * <dl><dt>cdy or cinderella</dt><dd>Cinderella (<a href=\"http://www.cinderella.de/\">http://www.cinderella.de</a></dd>\n     * </dl>\n     * @param {function} callback\n     */\n    parseString: function (str, board, format, callback) {\n        var Reader, read;\n\n        format = format.toLowerCase();\n        Reader = JXG.readers[format];\n\n        if (Type.exists(Reader)) {\n            read = new Reader(board, str);\n            read.read();\n        } else if (format === \"jessiecode\") {\n        } else {\n            throw new Error(\"JSXGraph: There is no reader available for '\" + format + \"'.\");\n        }\n\n        if (Type.isFunction(callback)) {\n            callback(board);\n        }\n    }\n};\n\n// The following code is vbscript. This is a workaround to enable binary data downloads via AJAX in\n// Microsoft Internet Explorer.\n\n/*jslint evil:true, es5:true, white:true*/\n/*jshint multistr:true*/\nif (\n    !Env.isMetroApp() &&\n    Env.isBrowser &&\n    typeof navigator === \"object\" &&\n    /msie/i.test(navigator.userAgent) &&\n    !/opera/i.test(navigator.userAgent) &&\n    document &&\n    document.write\n) {\n    document.write(\n        '<script type=\"text/vbscript\">\\n\\\nFunction Base64Encode(inData)\\n\\\n  Const Base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\\n\\\n  Dim cOut, sOut, I\\n\\\n  For I = 1 To LenB(inData) Step 3\\n\\\n    Dim nGroup, pOut, sGroup\\n\\\n    nGroup = &H10000 * AscB(MidB(inData, I, 1)) + _\\n\\\n      &H100 * MyASC(MidB(inData, I + 1, 1)) + MyASC(MidB(inData, I + 2, 1))\\n\\\n    nGroup = Oct(nGroup)\\n\\\n    nGroup = String(8 - Len(nGroup), \"0\") & nGroup\\n\\\n    pOut = Mid(Base64, CLng(\"&o\" & Mid(nGroup, 1, 2)) + 1, 1) + _\\n\\\n      Mid(Base64, CLng(\"&o\" & Mid(nGroup, 3, 2)) + 1, 1) + _\\n\\\n      Mid(Base64, CLng(\"&o\" & Mid(nGroup, 5, 2)) + 1, 1) + _\\n\\\n      Mid(Base64, CLng(\"&o\" & Mid(nGroup, 7, 2)) + 1, 1)\\n\\\n    sOut = sOut + pOut\\n\\\n  Next\\n\\\n  Select Case LenB(inData) Mod 3\\n\\\n    Case 1: \\'8 bit final\\n\\\n      sOut = Left(sOut, Len(sOut) - 2) + \"==\"\\n\\\n    Case 2: \\'16 bit final\\n\\\n      sOut = Left(sOut, Len(sOut) - 1) + \"=\"\\n\\\n  End Select\\n\\\n  Base64Encode = sOut\\n\\\nEnd Function\\n\\\n\\n\\\nFunction MyASC(OneChar)\\n\\\n  If OneChar = \"\" Then MyASC = 0 Else MyASC = AscB(OneChar)\\n\\\nEnd Function\\n\\\n\\n\\\nFunction jxgBinFileReader(xhr)\\n\\\n    Dim byteString\\n\\\n    Dim b64String\\n\\\n    Dim i\\n\\\n    byteString = xhr.responseBody\\n\\\n    ReDim byteArray(LenB(byteString))\\n\\\n    For i = 1 To LenB(byteString)\\n\\\n        byteArray(i-1) = AscB(MidB(byteString, i, 1))\\n\\\n    Next\\n\\\n    b64String = Base64Encode(byteString)\\n\\\n    jxgBinFileReader = b64String\\n\\\nEnd Function\\n\\\n</script>\\n'\n    );\n}\n\nexport default JXG.FileReader;\n","/*\n Copyright 2008-2022\n Matthias Ehmann,\n Michael Gerhaeuser,\n Carsten Miller,\n Bianca Valentin,\n Alfred Wassermann,\n Peter Wilfahrt\n\n This file is part of JSXGraph.\n\n JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n You can redistribute it and/or modify it under the terms of the\n\n * GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version\n OR\n * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n JSXGraph is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License and\n the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n\n/**\n * A composition is a simple container that manages none or more {@link JXG.GeometryElement}s.\n * @param {Object} elements A list of elements with a descriptive name for the element as the key and a reference\n * to the element as the value of every list entry. The name is used to access the element later on.\n * @example\n * var p1 = board.create('point', [1, 2]),\n *     p2 = board.create('point', [2, 3]),\n *     c = new JXG.Composition({\n *         start: p1,\n *         end: p2\n *     });\n *\n * // moves p1 to [3, 3]\n * c.start.moveTo([3, 3]);\n * @class JXG.Composition\n */\nJXG.Composition = function (elements) {\n    var e,\n        that = this,\n        genericMethods = [\n            /**\n             * Invokes setAttribute for every stored element with a setAttribute method and hands over the given arguments.\n             * See {@link JXG.GeometryElement#setAttribute} for further description, valid parameters and return values.\n             * @name setAttribute\n             * @memberOf JXG.Composition.prototype\n             * @function\n             */\n            \"setAttribute\",\n\n            /**\n             * Invokes setParents for every stored element with a setParents method and hands over the given arguments.\n             * See {@link JXG.GeometryElement#setParents} for further description, valid parameters and return values.\n             * @name setParents\n             * @memberOf JXG.Composition.prototype\n             * @function\n             */\n            \"setParents\",\n\n            /**\n             * Invokes prepareUpdate for every stored element with a prepareUpdate method and hands over the given arguments.\n             * See {@link JXG.GeometryElement#prepareUpdate} for further description, valid parameters and return values.\n             * @name prepareUpdate\n             * @memberOf JXG.Composition.prototype\n             * @function\n             */\n            \"prepareUpdate\",\n\n            /**\n             * Invokes updateRenderer for every stored element with a updateRenderer method and hands over the given arguments.\n             * See {@link JXG.GeometryElement#updateRenderer} for further description, valid parameters and return values.\n             * @name updateRenderer\n             * @memberOf JXG.Composition.prototype\n             * @function\n             */\n            \"updateRenderer\",\n\n            /**\n             * Invokes update for every stored element with a update method and hands over the given arguments.\n             * See {@link JXG.GeometryElement#update} for further description, valid parameters and return values.\n             * @name update\n             * @memberOf JXG.Composition.prototype\n             * @function\n             */\n            \"update\",\n\n            /**\n             * Invokes fullUpdate for every stored element with a fullUpdate method and hands over the given arguments.\n             * See {@link JXG.GeometryElement#fullUpdate} for further description, valid parameters and return values.\n             * @name fullUpdate\n             * @memberOf JXG.Composition.prototype\n             * @function\n             */\n            \"fullUpdate\",\n\n            /**\n             * Invokes highlight for every stored element with a highlight method and hands over the given arguments.\n             * See {@link JXG.GeometryElement#highlight} for further description, valid parameters and return values.\n             * @name highlight\n             * @memberOf JXG.Composition.prototype\n             * @function\n             */\n            \"highlight\",\n\n            /**\n             * Invokes noHighlight for every stored element with a noHighlight method and hands over the given arguments.\n             * See {@link JXG.GeometryElement#noHighlight} for further description, valid parameters and return values.\n             * @name noHighlight\n             * @memberOf JXG.Composition.prototype\n             * @function\n             */\n            \"noHighlight\"\n        ],\n        generateMethod = function (what) {\n            return function () {\n                var i;\n\n                for (i in that.elements) {\n                    if (that.elements.hasOwnProperty(i)) {\n                        if (Type.exists(that.elements[i][what])) {\n                            that.elements[i][what].apply(that.elements[i], arguments);\n                        }\n                    }\n                }\n                return that;\n            };\n        };\n\n    for (e = 0; e < genericMethods.length; e++) {\n        this[genericMethods[e]] = generateMethod(genericMethods[e]);\n    }\n\n    this.elements = {};\n    this.objects = this.elements;\n\n    this.elementsByName = {};\n    this.objectsList = [];\n\n    // unused, required for select()\n    this.groups = {};\n\n    this.methodMap = {\n        setAttribute: \"setAttribute\",\n        setProperty: \"setAttribute\",\n        setParents: \"setParents\",\n        add: \"add\",\n        remove: \"remove\",\n        select: \"select\"\n    };\n\n    for (e in elements) {\n        if (elements.hasOwnProperty(e)) {\n            this.add(e, elements[e]);\n        }\n    }\n\n    this.dump = true;\n    this.subs = {};\n};\n\nJXG.extend(\n    JXG.Composition.prototype,\n    /** @lends JXG.Composition.prototype */ {\n        /**\n         * Adds an element to the composition container.\n         * @param {String} what Descriptive name for the element, e.g. <em>startpoint</em> or <em>area</em>. This is used to\n         * access the element later on. There are some reserved names: <em>elements, add, remove, update, prepareUpdate,\n         * updateRenderer, highlight, noHighlight</em>, and all names that would form invalid object property names in\n         * JavaScript.\n         * @param {JXG.GeometryElement|JXG.Composition} element A reference to the element that is to be added. This can be\n         * another composition, too.\n         * @returns {Boolean} True, if the element was added successfully. Reasons why adding the element failed include\n         * using a reserved name and providing an invalid element.\n         */\n        add: function (what, element) {\n            if (!Type.exists(this[what]) && Type.exists(element)) {\n                if (Type.exists(element.id)) {\n                    this.elements[element.id] = element;\n                } else {\n                    this.elements[what] = element;\n                }\n\n                if (Type.exists(element.name)) {\n                    this.elementsByName[element.name] = element;\n                }\n\n                element.on(\"attribute:name\", this.nameListener, this);\n\n                this.objectsList.push(element);\n                this[what] = element;\n                this.methodMap[what] = element;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        /**\n         * Remove an element from the composition container.\n         * @param {String} what The name used to access the element.\n         * @returns {Boolean} True, if the element has been removed successfully.\n         */\n        remove: function (what) {\n            var found = false,\n                e;\n\n            for (e in this.elements) {\n                if (this.elements.hasOwnProperty(e)) {\n                    if (this.elements[e].id === this[what].id) {\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (found) {\n                delete this.elements[this[what].id];\n                delete this[what];\n            }\n\n            return found;\n        },\n\n        nameListener: function (oval, nval, el) {\n            delete this.elementsByName[oval];\n            this.elementsByName[nval] = el;\n        },\n\n        select: function (filter) {\n            // for now, hijack JXG.Board's select() method\n            if (Type.exists(JXG.Board)) {\n                return JXG.Board.prototype.select.call(this, filter);\n            }\n\n            return new JXG.Composition();\n        },\n\n        getParents: function () {\n            return this.parents;\n        },\n\n        getType: function () {\n            return this.elType;\n        },\n\n        getAttributes: function () {\n            var attr = {},\n                e;\n\n            for (e in this.subs) {\n                if (this.subs.hasOwnProperty(e)) {\n                    attr[e] = this.subs[e].visProp;\n                }\n            }\n\n            return this.attr;\n        }\n    }\n);\n\nexport default JXG.Composition;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, window: true, document: true, init: true, translateASCIIMath: true, google: true*/\n\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The JXG.Board class is defined in this file. JXG.Board controls all properties and methods\n * used to manage a geonext board like managing geometric elements, managing mouse and touch events, etc.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport Coords from \"./coords\";\nimport Options from \"../options\";\nimport Numerics from \"../math/numerics\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Complex from \"../math/complex\";\nimport Statistics from \"../math/statistics\";\nimport JessieCode from \"../parser/jessiecode\";\nimport Color from \"../utils/color\";\nimport Type from \"../utils/type\";\nimport EventEmitter from \"../utils/event\";\nimport Env from \"../utils/env\";\nimport Composition from \"./composition\";\n\n/**\n * Constructs a new Board object.\n * @class JXG.Board controls all properties and methods used to manage a geonext board like managing geometric\n * elements, managing mouse and touch events, etc. You probably don't want to use this constructor directly.\n * Please use {@link JXG.JSXGraph.initBoard} to initialize a board.\n * @constructor\n * @param {String} container The id or reference of the HTML DOM element the board is drawn in. This is usually a HTML div.\n * @param {JXG.AbstractRenderer} renderer The reference of a renderer.\n * @param {String} id Unique identifier for the board, may be an empty string or null or even undefined.\n * @param {JXG.Coords} origin The coordinates where the origin is placed, in user coordinates.\n * @param {Number} zoomX Zoom factor in x-axis direction\n * @param {Number} zoomY Zoom factor in y-axis direction\n * @param {Number} unitX Units in x-axis direction\n * @param {Number} unitY Units in y-axis direction\n * @param {Number} canvasWidth  The width of canvas\n * @param {Number} canvasHeight The height of canvas\n * @param {Object} attributes The attributes object given to {@link JXG.JSXGraph.initBoard}\n * @borrows JXG.EventEmitter#on as this.on\n * @borrows JXG.EventEmitter#off as this.off\n * @borrows JXG.EventEmitter#triggerEventHandlers as this.triggerEventHandlers\n * @borrows JXG.EventEmitter#eventHandlers as this.eventHandlers\n */\nJXG.Board = function (\n    container,\n    renderer,\n    id,\n    origin,\n    zoomX,\n    zoomY,\n    unitX,\n    unitY,\n    canvasWidth,\n    canvasHeight,\n    attributes\n) {\n    /**\n     * Board is in no special mode, objects are highlighted on mouse over and objects may be\n     * clicked to start drag&drop.\n     * @type Number\n     * @constant\n     */\n    this.BOARD_MODE_NONE = 0x0000;\n\n    /**\n     * Board is in drag mode, objects aren't highlighted on mouse over and the object referenced in\n     * {@link JXG.Board#mouse} is updated on mouse movement.\n     * @type Number\n     * @constant\n     * @see JXG.Board#drag_obj\n     */\n    this.BOARD_MODE_DRAG = 0x0001;\n\n    /**\n     * In this mode a mouse move changes the origin's screen coordinates.\n     * @type Number\n     * @constant\n     */\n    this.BOARD_MODE_MOVE_ORIGIN = 0x0002;\n\n    /**\n     * Update is made with high quality, e.g. graphs are evaluated at much more points.\n     * @type Number\n     * @constant\n     * @see JXG.Board#updateQuality\n     */\n    this.BOARD_MODE_ZOOM = 0x0011;\n\n    /**\n     * Update is made with low quality, e.g. graphs are evaluated at a lesser amount of points.\n     * @type Number\n     * @constant\n     * @see JXG.Board#updateQuality\n     */\n    this.BOARD_QUALITY_LOW = 0x1;\n\n    /**\n     * Update is made with high quality, e.g. graphs are evaluated at much more points.\n     * @type Number\n     * @constant\n     * @see JXG.Board#updateQuality\n     */\n    this.BOARD_QUALITY_HIGH = 0x2;\n\n        /**\n         * Pointer to the document element containing the board.\n         * @type Object\n         */\n        // Former version:\n        // this.document = attributes.document || document;\n        if (Type.exists(attributes.document) && attributes.document !== false) {\n            this.document = attributes.document;\n        } else if (Env.isBrowser) {\n            this.document = document;\n        }\n\n        /**\n         * The html-id of the html element containing the board.\n         * @type String\n         */\n        this.container = container;\n\n        /**\n         * Pointer to the html element containing the board.\n         * @type Object\n         */\n        this.containerObj = (Env.isBrowser ? this.document.getElementById(this.container) : null);\n\n        if (Env.isBrowser && renderer.type !== 'no' && this.containerObj === null) {\n            throw new Error(\"\\nJSXGraph: HTML container element '\" + container + \"' not found.\");\n        }\n\n        /**\n         * A reference to this boards renderer.\n         * @type JXG.AbstractRenderer\n         * @name JXG.Board#renderer\n         * @private\n         * @ignore\n         */\n        this.renderer = renderer;\n\n        /**\n         * Grids keeps track of all grids attached to this board.\n         * @type Array\n         * @private\n         */\n        this.grids = [];\n\n        /**\n         * Some standard options\n         * @type JXG.Options\n         */\n        this.options = Type.deepCopy(Options);\n        this.attr = attributes;\n\n        /**\n         * Dimension of the board.\n         * @default 2\n         * @type Number\n         */\n        this.dimension = 2;\n\n        this.jc = new JessieCode();\n        this.jc.use(this);\n\n        /**\n         * Coordinates of the boards origin. This a object with the two properties\n         * usrCoords and scrCoords. usrCoords always equals [1, 0, 0] and scrCoords\n         * stores the boards origin in homogeneous screen coordinates.\n         * @type Object\n         * @private\n         */\n        this.origin = {};\n        this.origin.usrCoords = [1, 0, 0];\n        this.origin.scrCoords = [1, origin[0], origin[1]];\n\n        /**\n         * Zoom factor in X direction. It only stores the zoom factor to be able\n         * to get back to 100% in zoom100().\n         * @name JXG.Board.zoomX\n         * @type Number\n         * @private\n         * @ignore\n         */\n        this.zoomX = zoomX;\n\n        /**\n         * Zoom factor in Y direction. It only stores the zoom factor to be able\n         * to get back to 100% in zoom100().\n         * @name JXG.Board.zoomY\n         * @type Number\n         * @private\n         * @ignore\n         */\n        this.zoomY = zoomY;\n\n        /**\n         * The number of pixels which represent one unit in user-coordinates in x direction.\n         * @type Number\n         * @private\n         */\n        this.unitX = unitX * this.zoomX;\n\n        /**\n         * The number of pixels which represent one unit in user-coordinates in y direction.\n         * @type Number\n         * @private\n         */\n        this.unitY = unitY * this.zoomY;\n\n        /**\n         * Keep aspect ratio if bounding box is set and the width/height ratio differs from the\n         * width/height ratio of the canvas.\n         * @type Boolean\n         * @private\n         */\n        this.keepaspectratio = false;\n\n        /**\n         * Canvas width.\n         * @type Number\n         * @private\n         */\n        this.canvasWidth = canvasWidth;\n\n        /**\n         * Canvas Height\n         * @type Number\n         * @private\n         */\n        this.canvasHeight = canvasHeight;\n\n        // If the given id is not valid, generate an unique id\n        if (Type.exists(id) && id !== '' && Env.isBrowser && !Type.exists(this.document.getElementById(id))) {\n            this.id = id;\n        } else {\n            this.id = this.generateId();\n        }\n\n        EventEmitter.eventify(this);\n\n        this.hooks = [];\n\n        /**\n         * An array containing all other boards that are updated after this board has been updated.\n         * @type Array\n         * @see JXG.Board#addChild\n         * @see JXG.Board#removeChild\n         */\n        this.dependentBoards = [];\n\n        /**\n         * During the update process this is set to false to prevent an endless loop.\n         * @default false\n         * @type Boolean\n         */\n        this.inUpdate = false;\n\n        /**\n         * An associative array containing all geometric objects belonging to the board. Key is the id of the object and value is a reference to the object.\n         * @type Object\n         */\n        this.objects = {};\n\n        /**\n         * An array containing all geometric objects on the board in the order of construction.\n         * @type Array\n         */\n        this.objectsList = [];\n\n        /**\n         * An associative array containing all groups belonging to the board. Key is the id of the group and value is a reference to the object.\n         * @type Object\n         */\n        this.groups = {};\n\n        /**\n         * Stores all the objects that are currently running an animation.\n         * @type Object\n         */\n        this.animationObjects = {};\n\n        /**\n         * An associative array containing all highlighted elements belonging to the board.\n         * @type Object\n         */\n        this.highlightedObjects = {};\n\n        /**\n         * Number of objects ever created on this board. This includes every object, even invisible and deleted ones.\n         * @type Number\n         */\n        this.numObjects = 0;\n\n        /**\n         * An associative array / dictionary to store the objects of the board by name. The name of the object is the key and value is a reference to the object.\n         * @type Object\n         */\n        this.elementsByName = {};\n\n        /**\n         * The board mode the board is currently in. Possible values are\n         * <ul>\n         * <li>JXG.Board.BOARD_MODE_NONE</li>\n         * <li>JXG.Board.BOARD_MODE_DRAG</li>\n         * <li>JXG.Board.BOARD_MODE_MOVE_ORIGIN</li>\n         * </ul>\n         * @type Number\n         */\n        this.mode = this.BOARD_MODE_NONE;\n\n        /**\n         * The update quality of the board. In most cases this is set to {@link JXG.Board#BOARD_QUALITY_HIGH}.\n         * If {@link JXG.Board#mode} equals {@link JXG.Board#BOARD_MODE_DRAG} this is set to\n         * {@link JXG.Board#BOARD_QUALITY_LOW} to speed up the update process by e.g. reducing the number of\n         * evaluation points when plotting functions. Possible values are\n         * <ul>\n         * <li>BOARD_QUALITY_LOW</li>\n         * <li>BOARD_QUALITY_HIGH</li>\n         * </ul>\n         * @type Number\n         * @see JXG.Board#mode\n         */\n        this.updateQuality = this.BOARD_QUALITY_HIGH;\n\n        /**\n         * If true updates are skipped.\n         * @type Boolean\n         */\n        this.isSuspendedRedraw = false;\n\n        this.calculateSnapSizes();\n\n        /**\n         * The distance from the mouse to the dragged object in x direction when the user clicked the mouse button.\n         * @type Number\n         * @see JXG.Board#drag_dy\n         * @see JXG.Board#drag_obj\n         */\n        this.drag_dx = 0;\n\n        /**\n         * The distance from the mouse to the dragged object in y direction when the user clicked the mouse button.\n         * @type Number\n         * @see JXG.Board#drag_dx\n         * @see JXG.Board#drag_obj\n         */\n        this.drag_dy = 0;\n\n        /**\n         * The last position where a drag event has been fired.\n         * @type Array\n         * @see JXG.Board#moveObject\n         */\n        this.drag_position = [0, 0];\n\n        /**\n         * References to the object that is dragged with the mouse on the board.\n         * @type JXG.GeometryElement\n         * @see JXG.Board#touches\n         */\n        this.mouse = {};\n\n        /**\n         * Keeps track on touched elements, like {@link JXG.Board#mouse} does for mouse events.\n         * @type Array\n         * @see JXG.Board#mouse\n         */\n        this.touches = [];\n\n        /**\n         * A string containing the XML text of the construction.\n         * This is set in {@link JXG.FileReader.parseString}.\n         * Only useful if a construction is read from a GEONExT-, Intergeo-, Geogebra-, or Cinderella-File.\n         * @type String\n         */\n        this.xmlString = '';\n\n        /**\n         * Cached result of getCoordsTopLeftCorner for touch/mouseMove-Events to save some DOM operations.\n         * @type Array\n         */\n        this.cPos = [];\n\n        /**\n         * Contains the last time (epoch, msec) since the last touchMove event which was not thrown away or since\n         * touchStart because Android's Webkit browser fires too much of them.\n         * @type Number\n         */\n        this.touchMoveLast = 0;\n\n        /**\n         * Contains the pointerId of the last touchMove event which was not thrown away or since\n         * touchStart because Android's Webkit browser fires too much of them.\n         * @type Number\n         */\n         this.touchMoveLastId = Infinity;\n\n        /**\n         * Contains the last time (epoch, msec) since the last getCoordsTopLeftCorner call which was not thrown away.\n         * @type Number\n         */\n        this.positionAccessLast = 0;\n\n        /**\n         * Collects all elements that triggered a mouse down event.\n         * @type Array\n         */\n        this.downObjects = [];\n\n        if (this.attr.showcopyright) {\n            this.renderer.displayCopyright(Const.licenseText, parseInt(this.options.text.fontSize, 10));\n        }\n\n        /**\n         * Full updates are needed after zoom and axis translates. This saves some time during an update.\n         * @default false\n         * @type Boolean\n         */\n        this.needsFullUpdate = false;\n\n        /**\n         * If reducedUpdate is set to true then only the dragged element and few (e.g. 2) following\n         * elements are updated during mouse move. On mouse up the whole construction is\n         * updated. This enables us to be fast even on very slow devices.\n         * @type BooleanupdateQuality: 2\n         * @default false\n         */\n        this.reducedUpdate = false;\n\n        /**\n         * The current color blindness deficiency is stored in this property. If color blindness is not emulated\n         * at the moment, it's value is 'none'.\n         */\n        this.currentCBDef = 'none';\n\n        /**\n         * If GEONExT constructions are displayed, then this property should be set to true.\n         * At the moment there should be no difference. But this may change.\n         * This is set in {@link JXG.GeonextReader.readGeonext}.\n         * @type Boolean\n         * @default false\n         * @see JXG.GeonextReader.readGeonext\n         */\n        this.geonextCompatibilityMode = false;\n\n        if (this.options.text.useASCIIMathML && translateASCIIMath) {\n            init();\n        } else {\n            this.options.text.useASCIIMathML = false;\n        }\n\n        /**\n         * A flag which tells if the board registers mouse events.\n         * @type Boolean\n         * @default false\n         */\n        this.hasMouseHandlers = false;\n\n        /**\n         * A flag which tells if the board registers touch events.\n         * @type Boolean\n         * @default false\n         */\n        this.hasTouchHandlers = false;\n\n        /**\n         * A flag which stores if the board registered pointer events.\n         * @type Boolean\n         * @default false\n         */\n        this.hasPointerHandlers = false;\n\n        /**\n         * A flag which tells if the board the JXG.Board#mouseUpListener is currently registered.\n         * @type Boolean\n         * @default false\n         */\n        this.hasMouseUp = false;\n\n        /**\n         * A flag which tells if the board the JXG.Board#touchEndListener is currently registered.\n         * @type Boolean\n         * @default false\n         */\n        this.hasTouchEnd = false;\n\n        /**\n         * A flag which tells us if the board has a pointerUp event registered at the moment.\n         * @type Boolean\n         * @default false\n         */\n        this.hasPointerUp = false;\n\n        /**\n         * Offset for large coords elements like images\n         * @type Array\n         * @private\n         * @default [0, 0]\n         */\n        this._drag_offset = [0, 0];\n\n        /**\n         * Stores the input device used in the last down or move event.\n         * @type String\n         * @private\n         * @default 'mouse'\n         */\n        this._inputDevice = 'mouse';\n\n        /**\n         * Keeps a list of pointer devices which are currently touching the screen.\n         * @type Array\n         * @private\n         */\n        this._board_touches = [];\n\n        /**\n         * A flag which tells us if the board is in the selecting mode\n         * @type Boolean\n         * @default false\n         */\n        this.selectingMode = false;\n\n        /**\n         * A flag which tells us if the user is selecting\n         * @type Boolean\n         * @default false\n         */\n        this.isSelecting = false;\n\n        /**\n         * A flag which tells us if the user is scrolling the viewport\n         * @type Boolean\n         * @private\n         * @default false\n         * @see JXG.Board#scrollListener\n         */\n        this._isScrolling = false;\n\n        /**\n         * A flag which tells us if a resize is in process\n         * @type Boolean\n         * @private\n         * @default false\n         * @see JXG.Board#resizeListener\n         */\n        this._isResizing = false;\n\n        /**\n         * A bounding box for the selection\n         * @type Array\n         * @default [ [0,0], [0,0] ]\n         */\n        this.selectingBox = [[0, 0], [0, 0]];\n\n        /**\n         * Array to log user activity. \n         * Entries are objects of the form \"{type, id, start, end}\" notifying\n         * the start time as well as the last time of a single event of type \"type\"\n         * on a JSXGraph element of id \"id\". \n         * <p> \"start\" and \"end\" contain the amount of milliseconds elapsed between 1 January 1970 00:00:00 UTC\n         * and the time the event happened.\n         * <p>\n         * For the time being (i.e. v1.5.0) the only supported type is 'drag'.\n         * @type Array\n         */\n        this.userLog = [];\n\n        this.mathLib = Math;        // Math or JXG.Math.IntervalArithmetic\n        this.mathLibJXG = JXG.Math; // JXG.Math or JXG.Math.IntervalArithmetic\n\n        if (this.attr.registerevents) {\n            this.addEventHandlers();\n        }\n\n        this.methodMap = {\n            update: 'update',\n            fullUpdate: 'fullUpdate',\n            on: 'on',\n            off: 'off',\n            trigger: 'trigger',\n            setView: 'setBoundingBox',\n            setBoundingBox: 'setBoundingBox',\n            migratePoint: 'migratePoint',\n            colorblind: 'emulateColorblindness',\n            suspendUpdate: 'suspendUpdate',\n            unsuspendUpdate: 'unsuspendUpdate',\n            clearTraces: 'clearTraces',\n            left: 'clickLeftArrow',\n            right: 'clickRightArrow',\n            up: 'clickUpArrow',\n            down: 'clickDownArrow',\n            zoomIn: 'zoomIn',\n            zoomOut: 'zoomOut',\n            zoom100: 'zoom100',\n            zoomElements: 'zoomElements',\n            remove: 'removeObject',\n            removeObject: 'removeObject'\n        };\n    };\n\nJXG.extend(\n    JXG.Board.prototype,\n    /** @lends JXG.Board.prototype */ {\n        /**\n         * Generates an unique name for the given object. The result depends on the objects type, if the\n         * object is a {@link JXG.Point}, capital characters are used, if it is of type {@link JXG.Line}\n         * only lower case characters are used. If object is of type {@link JXG.Polygon}, a bunch of lower\n         * case characters prefixed with P_ are used. If object is of type {@link JXG.Circle} the name is\n         * generated using lower case characters. prefixed with k_ is used. In any other case, lower case\n         * chars prefixed with s_ is used.\n         * @param {Object} object Reference of an JXG.GeometryElement that is to be named.\n         * @returns {String} Unique name for the object.\n         */\n        generateName: function (object) {\n            var possibleNames,\n                i,\n                maxNameLength = this.attr.maxnamelength,\n                pre = \"\",\n                post = \"\",\n                indices = [],\n                name = \"\";\n\n            if (object.type === Const.OBJECT_TYPE_TICKS) {\n                return \"\";\n            }\n\n            if (Type.isPoint(object) || Type.isPoint3D(object)) {\n                // points have capital letters\n                possibleNames = [\n                    \"\",\n                    \"A\",\n                    \"B\",\n                    \"C\",\n                    \"D\",\n                    \"E\",\n                    \"F\",\n                    \"G\",\n                    \"H\",\n                    \"I\",\n                    \"J\",\n                    \"K\",\n                    \"L\",\n                    \"M\",\n                    \"N\",\n                    \"O\",\n                    \"P\",\n                    \"Q\",\n                    \"R\",\n                    \"S\",\n                    \"T\",\n                    \"U\",\n                    \"V\",\n                    \"W\",\n                    \"X\",\n                    \"Y\",\n                    \"Z\"\n                ];\n            } else if (object.type === Const.OBJECT_TYPE_ANGLE) {\n                possibleNames = [\n                    \"\",\n                    \"&alpha;\",\n                    \"&beta;\",\n                    \"&gamma;\",\n                    \"&delta;\",\n                    \"&epsilon;\",\n                    \"&zeta;\",\n                    \"&eta;\",\n                    \"&theta;\",\n                    \"&iota;\",\n                    \"&kappa;\",\n                    \"&lambda;\",\n                    \"&mu;\",\n                    \"&nu;\",\n                    \"&xi;\",\n                    \"&omicron;\",\n                    \"&pi;\",\n                    \"&rho;\",\n                    \"&sigma;\",\n                    \"&tau;\",\n                    \"&upsilon;\",\n                    \"&phi;\",\n                    \"&chi;\",\n                    \"&psi;\",\n                    \"&omega;\"\n                ];\n            } else {\n                // all other elements get lowercase labels\n                possibleNames = [\n                    \"\",\n                    \"a\",\n                    \"b\",\n                    \"c\",\n                    \"d\",\n                    \"e\",\n                    \"f\",\n                    \"g\",\n                    \"h\",\n                    \"i\",\n                    \"j\",\n                    \"k\",\n                    \"l\",\n                    \"m\",\n                    \"n\",\n                    \"o\",\n                    \"p\",\n                    \"q\",\n                    \"r\",\n                    \"s\",\n                    \"t\",\n                    \"u\",\n                    \"v\",\n                    \"w\",\n                    \"x\",\n                    \"y\",\n                    \"z\"\n                ];\n            }\n\n            if (\n                !Type.isPoint(object) &&\n                object.elementClass !== Const.OBJECT_CLASS_LINE &&\n                object.type !== Const.OBJECT_TYPE_ANGLE\n            ) {\n                if (object.type === Const.OBJECT_TYPE_POLYGON) {\n                    pre = \"P_{\";\n                } else if (object.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                    pre = \"k_{\";\n                } else if (object.elementClass === Const.OBJECT_CLASS_TEXT) {\n                    pre = \"t_{\";\n                } else {\n                    pre = \"s_{\";\n                }\n                post = \"}\";\n            }\n\n            for (i = 0; i < maxNameLength; i++) {\n                indices[i] = 0;\n            }\n\n            while (indices[maxNameLength - 1] < possibleNames.length) {\n                for (indices[0] = 1; indices[0] < possibleNames.length; indices[0]++) {\n                    name = pre;\n\n                    for (i = maxNameLength; i > 0; i--) {\n                        name += possibleNames[indices[i - 1]];\n                    }\n\n                    if (!Type.exists(this.elementsByName[name + post])) {\n                        return name + post;\n                    }\n                }\n                indices[0] = possibleNames.length;\n\n                for (i = 1; i < maxNameLength; i++) {\n                    if (indices[i - 1] === possibleNames.length) {\n                        indices[i - 1] = 1;\n                        indices[i] += 1;\n                    }\n                }\n            }\n\n            return \"\";\n        },\n\n        /**\n         * Generates unique id for a board. The result is randomly generated and prefixed with 'jxgBoard'.\n         * @returns {String} Unique id for a board.\n         */\n        generateId: function () {\n            var r = 1;\n\n            // as long as we don't have a unique id generate a new one\n            while (Type.exists(JXG.boards[\"jxgBoard\" + r])) {\n                r = Math.round(Math.random() * 65535);\n            }\n\n            return \"jxgBoard\" + r;\n        },\n\n        /**\n         * Composes an id for an element. If the ID is empty ('' or null) a new ID is generated, depending on the\n         * object type. As a side effect {@link JXG.Board#numObjects}\n         * is updated.\n         * @param {Object} obj Reference of an geometry object that needs an id.\n         * @param {Number} type Type of the object.\n         * @returns {String} Unique id for an element.\n         */\n        setId: function (obj, type) {\n            var randomNumber,\n                num = this.numObjects,\n                elId = obj.id;\n\n            this.numObjects += 1;\n\n            // If no id is provided or id is empty string, a new one is chosen\n            if (elId === \"\" || !Type.exists(elId)) {\n                elId = this.id + type + num;\n                while (Type.exists(this.objects[elId])) {\n                    randomNumber = Math.round(Math.random() * 65535);\n                    elId = this.id + type + num + \"-\" + randomNumber;\n                }\n            }\n\n            obj.id = elId;\n            this.objects[elId] = obj;\n            obj._pos = this.objectsList.length;\n            this.objectsList[this.objectsList.length] = obj;\n\n            return elId;\n        },\n\n        /**\n         * After construction of the object the visibility is set\n         * and the label is constructed if necessary.\n         * @param {Object} obj The object to add.\n         */\n        finalizeAdding: function (obj) {\n            if (Type.evaluate(obj.visProp.visible) === false) {\n                this.renderer.display(obj, false);\n            }\n        },\n\n        finalizeLabel: function (obj) {\n            if (\n                obj.hasLabel &&\n                !Type.evaluate(obj.label.visProp.islabel) &&\n                Type.evaluate(obj.label.visProp.visible) === false\n            ) {\n                this.renderer.display(obj.label, false);\n            }\n        },\n\n        /**********************************************************\n         *\n         * Event Handler helpers\n         *\n         **********************************************************/\n\n        /**\n         * Returns false if the event has been triggered faster than the maximum frame rate.\n         *\n         * @param {Event} evt Event object given by the browser (unused)\n         * @returns {Boolean} If the event has been triggered faster than the maximum frame rate, false is returned.\n         * @private\n         * @see JXG.Board#pointerMoveListener\n         * @see JXG.Board#touchMoveListener\n         * @see JXG.Board#mouseMoveListener\n         */\n        checkFrameRate: function (evt) {\n            var handleEvt = false,\n                time = new Date().getTime();\n\n            if (Type.exists(evt.pointerId) && this.touchMoveLastId !== evt.pointerId) {\n                handleEvt = true;\n                this.touchMoveLastId = evt.pointerId;\n            }\n            if (!handleEvt && (time - this.touchMoveLast) * this.attr.maxframerate >= 1000) {\n                handleEvt = true;\n            }\n            if (handleEvt) {\n                this.touchMoveLast = time;\n            }\n            return handleEvt;\n        },\n\n        /**\n         * Calculates mouse coordinates relative to the boards container.\n         * @returns {Array} Array of coordinates relative the boards container top left corner.\n         */\n        getCoordsTopLeftCorner: function () {\n            var cPos,\n                doc,\n                crect,\n                // In ownerDoc we need the \"real\" document object.\n                // The first version is used in the case of shadowDom,\n                // the second case in the \"normal\" case.\n                ownerDoc = this.document.ownerDocument || this.document,\n                docElement = ownerDoc.documentElement || this.document.body.parentNode,\n                docBody = ownerDoc.body,\n                container = this.containerObj,\n                // viewport, content,\n                zoom,\n                o;\n\n            /**\n             * During drags and origin moves the container element is usually not changed.\n             * Check the position of the upper left corner at most every 1000 msecs\n             */\n            if (\n                this.cPos.length > 0 &&\n                (this.mode === this.BOARD_MODE_DRAG ||\n                    this.mode === this.BOARD_MODE_MOVE_ORIGIN ||\n                    new Date().getTime() - this.positionAccessLast < 1000)\n            ) {\n                return this.cPos;\n            }\n            this.positionAccessLast = new Date().getTime();\n\n            // Check if getBoundingClientRect exists. If so, use this as this covers *everything*\n            // even CSS3D transformations etc.\n            // Supported by all browsers but IE 6, 7.\n\n            if (container.getBoundingClientRect) {\n                crect = container.getBoundingClientRect();\n\n                zoom = 1.0;\n                // Recursively search for zoom style entries.\n                // This is necessary for reveal.js on webkit.\n                // It fails if the user does zooming\n                o = container;\n                while (o && Type.exists(o.parentNode)) {\n                    if (\n                        Type.exists(o.style) &&\n                        Type.exists(o.style.zoom) &&\n                        o.style.zoom !== \"\"\n                    ) {\n                        zoom *= parseFloat(o.style.zoom);\n                    }\n                    o = o.parentNode;\n                }\n                cPos = [crect.left * zoom, crect.top * zoom];\n\n                // add border width\n                cPos[0] += Env.getProp(container, \"border-left-width\");\n                cPos[1] += Env.getProp(container, \"border-top-width\");\n\n                // vml seems to ignore paddings\n                if (this.renderer.type !== \"vml\") {\n                    // add padding\n                    cPos[0] += Env.getProp(container, \"padding-left\");\n                    cPos[1] += Env.getProp(container, \"padding-top\");\n                }\n\n                this.cPos = cPos.slice();\n                return this.cPos;\n            }\n\n            //\n            //  OLD CODE\n            //  IE 6-7 only:\n            //\n            cPos = Env.getOffset(container);\n            doc = this.document.documentElement.ownerDocument;\n\n            if (!this.containerObj.currentStyle && doc.defaultView) {\n                // Non IE\n                // this is for hacks like this one used in wordpress for the admin bar:\n                // html { margin-top: 28px }\n                // seems like it doesn't work in IE\n\n                cPos[0] += Env.getProp(docElement, \"margin-left\");\n                cPos[1] += Env.getProp(docElement, \"margin-top\");\n\n                cPos[0] += Env.getProp(docElement, \"border-left-width\");\n                cPos[1] += Env.getProp(docElement, \"border-top-width\");\n\n                cPos[0] += Env.getProp(docElement, \"padding-left\");\n                cPos[1] += Env.getProp(docElement, \"padding-top\");\n            }\n\n            if (docBody) {\n                cPos[0] += Env.getProp(docBody, \"left\");\n                cPos[1] += Env.getProp(docBody, \"top\");\n            }\n\n            // Google Translate offers widgets for web authors. These widgets apparently tamper with the clientX\n            // and clientY coordinates of the mouse events. The minified sources seem to be the only publicly\n            // available version so we're doing it the hacky way: Add a fixed offset.\n            // see https://groups.google.com/d/msg/google-translate-general/H2zj0TNjjpY/jw6irtPlCw8J\n            if (typeof google === \"object\" && google.translate) {\n                cPos[0] += 10;\n                cPos[1] += 25;\n            }\n\n            // add border width\n            cPos[0] += Env.getProp(container, \"border-left-width\");\n            cPos[1] += Env.getProp(container, \"border-top-width\");\n\n            // vml seems to ignore paddings\n            if (this.renderer.type !== \"vml\") {\n                // add padding\n                cPos[0] += Env.getProp(container, \"padding-left\");\n                cPos[1] += Env.getProp(container, \"padding-top\");\n            }\n\n            cPos[0] += this.attr.offsetx;\n            cPos[1] += this.attr.offsety;\n\n            this.cPos = cPos.slice();\n            return this.cPos;\n        },\n\n        /**\n         * Get the position of the mouse in screen coordinates, relative to the upper left corner\n         * of the host tag.\n         * @param {Event} e Event object given by the browser.\n         * @param {Number} [i] Only use in case of touch events. This determines which finger to use and should not be set\n         * for mouseevents.\n         * @returns {Array} Contains the mouse coordinates in screen coordinates, ready for {@link JXG.Coords}\n         */\n        getMousePosition: function (e, i) {\n            var cPos = this.getCoordsTopLeftCorner(),\n                absPos,\n                v;\n\n            // Position of cursor using clientX/Y\n            absPos = Env.getPosition(e, i, this.document);\n\n            /**\n             * In case there has been no down event before.\n             */\n            if (!Type.exists(this.cssTransMat)) {\n                this.updateCSSTransforms();\n            }\n            // Position relative to the top left corner\n            v = [1, absPos[0] - cPos[0], absPos[1] - cPos[1]];\n            v = Mat.matVecMult(this.cssTransMat, v);\n            v[1] /= v[0];\n            v[2] /= v[0];\n            return [v[1], v[2]];\n\n            // Method without CSS transformation\n            /*\n             return [absPos[0] - cPos[0], absPos[1] - cPos[1]];\n             */\n        },\n\n        /**\n         * Initiate moving the origin. This is used in mouseDown and touchStart listeners.\n         * @param {Number} x Current mouse/touch coordinates\n         * @param {Number} y Current mouse/touch coordinates\n         */\n        initMoveOrigin: function (x, y) {\n            this.drag_dx = x - this.origin.scrCoords[1];\n            this.drag_dy = y - this.origin.scrCoords[2];\n\n            this.mode = this.BOARD_MODE_MOVE_ORIGIN;\n            this.updateQuality = this.BOARD_QUALITY_LOW;\n        },\n\n        /**\n         * Collects all elements below the current mouse pointer and fulfilling the following constraints:\n         * <ul><li>isDraggable</li><li>visible</li><li>not fixed</li><li>not frozen</li></ul>\n         * @param {Number} x Current mouse/touch coordinates\n         * @param {Number} y current mouse/touch coordinates\n         * @param {Object} evt An event object\n         * @param {String} type What type of event? 'touch', 'mouse' or 'pen'.\n         * @returns {Array} A list of geometric elements.\n         */\n        initMoveObject: function (x, y, evt, type) {\n            var pEl,\n                el,\n                collect = [],\n                offset = [],\n                haspoint,\n                len = this.objectsList.length,\n                dragEl = { visProp: { layer: -10000 } };\n\n            //for (el in this.objects) {\n            for (el = 0; el < len; el++) {\n                pEl = this.objectsList[el];\n                haspoint = pEl.hasPoint && pEl.hasPoint(x, y);\n\n                if (pEl.visPropCalc.visible && haspoint) {\n                    pEl.triggerEventHandlers([type + \"down\", \"down\"], [evt]);\n                    this.downObjects.push(pEl);\n                }\n\n                if (\n                    haspoint &&\n                    pEl.isDraggable &&\n                    pEl.visPropCalc.visible &&\n                    ((this.geonextCompatibilityMode &&\n                        (Type.isPoint(pEl) || pEl.elementClass === Const.OBJECT_CLASS_TEXT)) ||\n                        !this.geonextCompatibilityMode) &&\n                    !Type.evaluate(pEl.visProp.fixed)\n                    /*(!pEl.visProp.frozen) &&*/\n                ) {\n                    // Elements in the highest layer get priority.\n                    if (\n                        pEl.visProp.layer > dragEl.visProp.layer ||\n                        (pEl.visProp.layer === dragEl.visProp.layer &&\n                            pEl.lastDragTime.getTime() >= dragEl.lastDragTime.getTime())\n                    ) {\n                        // If an element and its label have the focus\n                        // simultaneously, the element is taken.\n                        // This only works if we assume that every browser runs\n                        // through this.objects in the right order, i.e. an element A\n                        // added before element B turns up here before B does.\n                        if (\n                            !this.attr.ignorelabels ||\n                            !Type.exists(dragEl.label) ||\n                            pEl !== dragEl.label\n                        ) {\n                            dragEl = pEl;\n                            collect.push(dragEl);\n\n                            // Save offset for large coords elements.\n                            if (Type.exists(dragEl.coords)) {\n                                offset.push(\n                                    Statistics.subtract(dragEl.coords.scrCoords.slice(1), [\n                                        x,\n                                        y\n                                    ])\n                                );\n                            } else {\n                                offset.push([0, 0]);\n                            }\n\n                            // we can't drop out of this loop because of the event handling system\n                            //if (this.attr.takefirst) {\n                            //    return collect;\n                            //}\n                        }\n                    }\n                }\n            }\n\n            if (this.attr.drag.enabled && collect.length > 0) {\n                this.mode = this.BOARD_MODE_DRAG;\n            }\n\n            // A one-element array is returned.\n            if (this.attr.takefirst) {\n                collect.length = 1;\n                this._drag_offset = offset[0];\n            } else {\n                collect = collect.slice(-1);\n                this._drag_offset = offset[offset.length - 1];\n            }\n\n            if (!this._drag_offset) {\n                this._drag_offset = [0, 0];\n            }\n\n            // Move drag element to the top of the layer\n            if (\n                this.renderer.type === \"svg\" &&\n                Type.exists(collect[0]) &&\n                Type.evaluate(collect[0].visProp.dragtotopoflayer) &&\n                collect.length === 1 &&\n                Type.exists(collect[0].rendNode)\n            ) {\n                collect[0].rendNode.parentNode.appendChild(collect[0].rendNode);\n            }\n\n            // Init rotation angle and scale factor for two finger movements\n            this.previousRotation = 0.0;\n            this.previousScale = 1.0;\n\n            if (collect.length >= 1) {\n                collect[0].highlight(true);\n                this.triggerEventHandlers([\"mousehit\", \"hit\"], [evt, collect[0]]);\n            }\n\n            return collect;\n        },\n\n        /**\n         * Moves an object.\n         * @param {Number} x Coordinate\n         * @param {Number} y Coordinate\n         * @param {Object} o The touch object that is dragged: {JXG.Board#mouse} or {JXG.Board#touches}.\n         * @param {Object} evt The event object.\n         * @param {String} type Mouse or touch event?\n         */\n        moveObject: function (x, y, o, evt, type) {\n            var newPos = new Coords(\n                    Const.COORDS_BY_SCREEN,\n                    this.getScrCoordsOfMouse(x, y),\n                    this\n                ),\n                drag,\n                dragScrCoords,\n                newDragScrCoords;\n\n            if (!(o && o.obj)) {\n                return;\n            }\n            drag = o.obj;\n\n            // Save updates for very small movements of coordsElements, see below\n            if (drag.coords) {\n                dragScrCoords = drag.coords.scrCoords.slice();\n            }\n\n            this.addLogEntry('drag', drag);\n\n            /*\n             * Save the position.\n             */\n            this.drag_position = [newPos.scrCoords[1], newPos.scrCoords[2]];\n            this.drag_position = Statistics.add(this.drag_position, this._drag_offset);\n            //\n            // We have to distinguish between CoordsElements and other elements like lines.\n            // The latter need the difference between two move events.\n            if (Type.exists(drag.coords)) {\n                drag.setPositionDirectly(Const.COORDS_BY_SCREEN, this.drag_position);\n            } else {\n                this.displayInfobox(false);\n                // Hide infobox in case the user has touched an intersection point\n                // and drags the underlying line now.\n\n                if (!isNaN(o.targets[0].Xprev + o.targets[0].Yprev)) {\n                    drag.setPositionDirectly(\n                        Const.COORDS_BY_SCREEN,\n                        [newPos.scrCoords[1], newPos.scrCoords[2]],\n                        [o.targets[0].Xprev, o.targets[0].Yprev]\n                    );\n                }\n                // Remember the actual position for the next move event. Then we are able to\n                // compute the difference vector.\n                o.targets[0].Xprev = newPos.scrCoords[1];\n                o.targets[0].Yprev = newPos.scrCoords[2];\n            }\n            // This may be necessary for some gliders and labels\n            if (Type.exists(drag.coords)) {\n                drag.prepareUpdate().update(false).updateRenderer();\n                this.updateInfobox(drag);\n                drag.prepareUpdate().update(true).updateRenderer();\n            }\n\n            if (drag.coords) {\n                newDragScrCoords = drag.coords.scrCoords;\n            }\n            // No updates for very small movements of coordsElements\n            if (\n                !drag.coords ||\n                dragScrCoords[1] !== newDragScrCoords[1] ||\n                dragScrCoords[2] !== newDragScrCoords[2]\n            ) {\n                drag.triggerEventHandlers([type + \"drag\", \"drag\"], [evt]);\n\n                this.update();\n            }\n            drag.highlight(true);\n            this.triggerEventHandlers([\"mousehit\", \"hit\"], [evt, drag]);\n\n            drag.lastDragTime = new Date();\n        },\n\n        /**\n         * Moves elements in multitouch mode.\n         * @param {Array} p1 x,y coordinates of first touch\n         * @param {Array} p2 x,y coordinates of second touch\n         * @param {Object} o The touch object that is dragged: {JXG.Board#touches}.\n         * @param {Object} evt The event object that lead to this movement.\n         */\n        twoFingerMove: function (o, id, evt) {\n            var drag;\n\n            if (Type.exists(o) && Type.exists(o.obj)) {\n                drag = o.obj;\n            } else {\n                return;\n            }\n\n            if (\n                drag.elementClass === Const.OBJECT_CLASS_LINE ||\n                drag.type === Const.OBJECT_TYPE_POLYGON\n            ) {\n                this.twoFingerTouchObject(o.targets, drag, id);\n            } else if (drag.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                this.twoFingerTouchCircle(o.targets, drag, id);\n            }\n\n            if (evt) {\n                drag.triggerEventHandlers([\"touchdrag\", \"drag\"], [evt]);\n            }\n        },\n\n        /**\n         * Moves, rotates and scales a line or polygon with two fingers.\n         * @param {Array} tar Array conatining touch event objects: {JXG.Board#touches.targets}.\n         * @param {object} drag The object that is dragged:\n         * @param {Number} id pointerId of the event. In case of old touch event this is emulated.\n         */\n        twoFingerTouchObject: function (tar, drag, id) {\n            var np,\n                op,\n                nd,\n                od,\n                d,\n                alpha = 0,\n                S,\n                t1,\n                t3,\n                t4,\n                t5,\n                ar,\n                i,\n                len,\n                fixEl,\n                moveEl,\n                fix;\n\n            if (\n                Type.exists(tar[0]) &&\n                Type.exists(tar[1]) &&\n                !isNaN(tar[0].Xprev + tar[0].Yprev + tar[1].Xprev + tar[1].Yprev)\n            ) {\n                if (id === tar[0].num) {\n                    fixEl = tar[1];\n                    moveEl = tar[0];\n                } else {\n                    fixEl = tar[0];\n                    moveEl = tar[1];\n                }\n\n                fix = new Coords(Const.COORDS_BY_SCREEN, [fixEl.Xprev, fixEl.Yprev], this)\n                    .usrCoords;\n                // Previous finger position\n                op = new Coords(Const.COORDS_BY_SCREEN, [moveEl.Xprev, moveEl.Yprev], this)\n                    .usrCoords;\n                // New finger position\n                np = new Coords(Const.COORDS_BY_SCREEN, [moveEl.X, moveEl.Y], this).usrCoords;\n\n                // Old and new directions\n                od = Mat.crossProduct(fix, op);\n                nd = Mat.crossProduct(fix, np);\n\n                // Intersection between the two directions\n                S = Mat.crossProduct(od, nd);\n\n                // If parallel translate, otherwise rotate\n                if (Math.abs(S[0]) < Mat.eps) {\n                    return;\n                }\n\n                if (Type.evaluate(drag.visProp.rotatable)) {\n                    alpha = Geometry.rad(op.slice(1), fix.slice(1), np.slice(1));\n                }\n\n                t1 = this.create(\"transform\", [alpha, [fix[1], fix[2]]], {\n                    type: \"rotate\"\n                });\n                t1.update();\n\n                if (Type.evaluate(drag.visProp.scalable)) {\n                    // Scale\n                    d = Geometry.distance(np, fix) / Geometry.distance(op, fix);\n\n                    t3 = this.create(\"transform\", [-fix[1], -fix[2]], {\n                        type: \"translate\"\n                    });\n                    t4 = this.create(\"transform\", [d, d], { type: \"scale\" });\n                    t5 = this.create(\"transform\", [fix[1], fix[2]], {\n                        type: \"translate\"\n                    });\n                    t1.melt(t3).melt(t4).melt(t5);\n                }\n\n                if (drag.elementClass === Const.OBJECT_CLASS_LINE) {\n                    ar = [];\n                    if (drag.point1.draggable()) {\n                        ar.push(drag.point1);\n                    }\n                    if (drag.point2.draggable()) {\n                        ar.push(drag.point2);\n                    }\n                    t1.applyOnce(ar);\n                } else if (drag.type === Const.OBJECT_TYPE_POLYGON) {\n                    ar = [];\n                    len = drag.vertices.length - 1;\n                    for (i = 0; i < len; ++i) {\n                        if (drag.vertices[i].draggable()) {\n                            ar.push(drag.vertices[i]);\n                        }\n                    }\n                    t1.applyOnce(ar);\n                }\n\n                this.update();\n                drag.highlight(true);\n            }\n        },\n\n        /*\n         * Moves, rotates and scales a circle with two fingers.\n         * @param {Array} tar Array conatining touch event objects: {JXG.Board#touches.targets}.\n         * @param {object} drag The object that is dragged:\n         * @param {Number} id pointerId of the event. In case of old touch event this is emulated.\n         */\n        twoFingerTouchCircle: function (tar, drag, id) {\n            var fixEl, moveEl, np, op, fix, d, alpha, t1, t2, t3, t4;\n\n            if (drag.method === \"pointCircle\" || drag.method === \"pointLine\") {\n                return;\n            }\n\n            if (\n                Type.exists(tar[0]) &&\n                Type.exists(tar[1]) &&\n                !isNaN(tar[0].Xprev + tar[0].Yprev + tar[1].Xprev + tar[1].Yprev)\n            ) {\n                if (id === tar[0].num) {\n                    fixEl = tar[1];\n                    moveEl = tar[0];\n                } else {\n                    fixEl = tar[0];\n                    moveEl = tar[1];\n                }\n\n                fix = new Coords(Const.COORDS_BY_SCREEN, [fixEl.Xprev, fixEl.Yprev], this)\n                    .usrCoords;\n                // Previous finger position\n                op = new Coords(Const.COORDS_BY_SCREEN, [moveEl.Xprev, moveEl.Yprev], this)\n                    .usrCoords;\n                // New finger position\n                np = new Coords(Const.COORDS_BY_SCREEN, [moveEl.X, moveEl.Y], this).usrCoords;\n\n                alpha = Geometry.rad(op.slice(1), fix.slice(1), np.slice(1));\n\n                // Rotate and scale by the movement of the second finger\n                t1 = this.create(\"transform\", [-fix[1], -fix[2]], {\n                    type: \"translate\"\n                });\n                t2 = this.create(\"transform\", [alpha], { type: \"rotate\" });\n                t1.melt(t2);\n                if (Type.evaluate(drag.visProp.scalable)) {\n                    d = Geometry.distance(fix, np) / Geometry.distance(fix, op);\n                    t3 = this.create(\"transform\", [d, d], { type: \"scale\" });\n                    t1.melt(t3);\n                }\n                t4 = this.create(\"transform\", [fix[1], fix[2]], {\n                    type: \"translate\"\n                });\n                t1.melt(t4);\n\n                if (drag.center.draggable()) {\n                    t1.applyOnce([drag.center]);\n                }\n\n                if (drag.method === \"twoPoints\") {\n                    if (drag.point2.draggable()) {\n                        t1.applyOnce([drag.point2]);\n                    }\n                } else if (drag.method === \"pointRadius\") {\n                    if (Type.isNumber(drag.updateRadius.origin)) {\n                        drag.setRadius(drag.radius * d);\n                    }\n                }\n\n                this.update(drag.center);\n                drag.highlight(true);\n            }\n        },\n\n        highlightElements: function (x, y, evt, target) {\n            var el,\n                pEl,\n                pId,\n                overObjects = {},\n                len = this.objectsList.length;\n\n            // Elements  below the mouse pointer which are not highlighted yet will be highlighted.\n            for (el = 0; el < len; el++) {\n                pEl = this.objectsList[el];\n                pId = pEl.id;\n                if (\n                    Type.exists(pEl.hasPoint) &&\n                    pEl.visPropCalc.visible &&\n                    pEl.hasPoint(x, y)\n                ) {\n                    // this is required in any case because otherwise the box won't be shown until the point is dragged\n                    this.updateInfobox(pEl);\n\n                    if (!Type.exists(this.highlightedObjects[pId])) {\n                        // highlight only if not highlighted\n                        overObjects[pId] = pEl;\n                        pEl.highlight();\n                        // triggers board event.\n                        this.triggerEventHandlers([\"mousehit\", \"hit\"], [evt, pEl, target]);\n                    }\n\n                    if (pEl.mouseover) {\n                        pEl.triggerEventHandlers([\"mousemove\", \"move\"], [evt]);\n                    } else {\n                        pEl.triggerEventHandlers([\"mouseover\", \"over\"], [evt]);\n                        pEl.mouseover = true;\n                    }\n                }\n            }\n\n            for (el = 0; el < len; el++) {\n                pEl = this.objectsList[el];\n                pId = pEl.id;\n                if (pEl.mouseover) {\n                    if (!overObjects[pId]) {\n                        pEl.triggerEventHandlers([\"mouseout\", \"out\"], [evt]);\n                        pEl.mouseover = false;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Helper function which returns a reasonable starting point for the object being dragged.\n         * Formerly known as initXYstart().\n         * @private\n         * @param {JXG.GeometryElement} obj The object to be dragged\n         * @param {Array} targets Array of targets. It is changed by this function.\n         */\n        saveStartPos: function (obj, targets) {\n            var xy = [],\n                i,\n                len;\n\n            if (obj.type === Const.OBJECT_TYPE_TICKS) {\n                xy.push([1, NaN, NaN]);\n            } else if (obj.elementClass === Const.OBJECT_CLASS_LINE) {\n                xy.push(obj.point1.coords.usrCoords);\n                xy.push(obj.point2.coords.usrCoords);\n            } else if (obj.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                xy.push(obj.center.coords.usrCoords);\n                if (obj.method === \"twoPoints\") {\n                    xy.push(obj.point2.coords.usrCoords);\n                }\n            } else if (obj.type === Const.OBJECT_TYPE_POLYGON) {\n                len = obj.vertices.length - 1;\n                for (i = 0; i < len; i++) {\n                    xy.push(obj.vertices[i].coords.usrCoords);\n                }\n            } else if (obj.type === Const.OBJECT_TYPE_SECTOR) {\n                xy.push(obj.point1.coords.usrCoords);\n                xy.push(obj.point2.coords.usrCoords);\n                xy.push(obj.point3.coords.usrCoords);\n            } else if (Type.isPoint(obj) || obj.type === Const.OBJECT_TYPE_GLIDER) {\n                xy.push(obj.coords.usrCoords);\n            } else if (obj.elementClass === Const.OBJECT_CLASS_CURVE) {\n                // if (Type.exists(obj.parents)) {\n                //     len = obj.parents.length;\n                //     if (len > 0) {\n                //         for (i = 0; i < len; i++) {\n                //             xy.push(this.select(obj.parents[i]).coords.usrCoords);\n                //         }\n                //     } else\n                // }\n                if (obj.points.length > 0) {\n                    xy.push(obj.points[0].usrCoords);\n                }\n            } else {\n                try {\n                    xy.push(obj.coords.usrCoords);\n                } catch (e) {\n                    JXG.debug(\n                        \"JSXGraph+ saveStartPos: obj.coords.usrCoords not available: \" + e\n                    );\n                }\n            }\n\n            len = xy.length;\n            for (i = 0; i < len; i++) {\n                targets.Zstart.push(xy[i][0]);\n                targets.Xstart.push(xy[i][1]);\n                targets.Ystart.push(xy[i][2]);\n            }\n        },\n\n        mouseOriginMoveStart: function (evt) {\n            var r, pos;\n\n            r = this._isRequiredKeyPressed(evt, \"pan\");\n            if (r) {\n                pos = this.getMousePosition(evt);\n                this.initMoveOrigin(pos[0], pos[1]);\n            }\n\n            return r;\n        },\n\n        mouseOriginMove: function (evt) {\n            var r = this.mode === this.BOARD_MODE_MOVE_ORIGIN,\n                pos;\n\n            if (r) {\n                pos = this.getMousePosition(evt);\n                this.moveOrigin(pos[0], pos[1], true);\n            }\n\n            return r;\n        },\n\n        /**\n         * Start moving the origin with one finger.\n         * @private\n         * @param  {Object} evt Event from touchStartListener\n         * @return {Boolean}   returns if the origin is moved.\n         */\n        touchStartMoveOriginOneFinger: function (evt) {\n            var touches = evt[JXG.touchProperty],\n                conditions,\n                pos;\n\n            conditions =\n                this.attr.pan.enabled && !this.attr.pan.needtwofingers && touches.length === 1;\n\n            if (conditions) {\n                pos = this.getMousePosition(evt, 0);\n                this.initMoveOrigin(pos[0], pos[1]);\n            }\n\n            return conditions;\n        },\n\n        /**\n         * Move the origin with one finger\n         * @private\n         * @param  {Object} evt Event from touchMoveListener\n         * @return {Boolean}     returns if the origin is moved.\n         */\n        touchOriginMove: function (evt) {\n            var r = this.mode === this.BOARD_MODE_MOVE_ORIGIN,\n                pos;\n\n            if (r) {\n                pos = this.getMousePosition(evt, 0);\n                this.moveOrigin(pos[0], pos[1], true);\n            }\n\n            return r;\n        },\n\n        /**\n         * Stop moving the origin with one finger\n         * @return {null} null\n         * @private\n         */\n        originMoveEnd: function () {\n            this.updateQuality = this.BOARD_QUALITY_HIGH;\n            this.mode = this.BOARD_MODE_NONE;\n        },\n\n        /**********************************************************\n         *\n         * Event Handler\n         *\n         **********************************************************/\n\n        /**\n         *  Add all possible event handlers to the board object\n         */\n        addEventHandlers: function () {\n            if (Env.supportsPointerEvents()) {\n                this.addPointerEventHandlers();\n            } else {\n                this.addMouseEventHandlers();\n                this.addTouchEventHandlers();\n            }\n\n            // This one produces errors on IE\n            //Env.addEvent(this.containerObj, 'contextmenu', function (e) { e.preventDefault(); return false;}, this);\n            // This one works on IE, Firefox and Chromium with default configurations. On some Safari\n            // or Opera versions the user must explicitly allow the deactivation of the context menu.\n            if (this.containerObj !== null) {\n                this.containerObj.oncontextmenu = function (e) {\n                    if (Type.exists(e)) {\n                        e.preventDefault();\n                    }\n                    return false;\n                };\n            }\n\n            this.addFullscreenEventHandlers();\n            this.addKeyboardEventHandlers();\n\n            if (Env.isBrowser) {\n                try {\n                    // resizeObserver: triggered if size of the JSXGraph div changes.\n                    this.startResizeObserver();\n                } catch (err) {\n                    // resize event: triggered if size of window changes\n                    Env.addEvent(window, \"resize\", this.resizeListener, this);\n                    // intersectionObserver: triggered if JSXGraph becomes visible.\n                    this.startIntersectionObserver();\n                }\n                // Scroll event: needs to be captured since on mobile devices\n                // sometimes a header bar is displayed / hidden, which triggers a\n                // resize event.\n                Env.addEvent(window, \"scroll\", this.scrollListener, this);\n            }\n        },\n\n        /**\n         * Remove all event handlers from the board object\n         */\n        removeEventHandlers: function () {\n            this.removeMouseEventHandlers();\n            this.removeTouchEventHandlers();\n            this.removePointerEventHandlers();\n\n            this.removeFullscreenEventHandlers();\n            this.removeKeyboardEventHandlers();\n            if (Env.isBrowser) {\n                if (Type.exists(this.resizeObserver)) {\n                    this.stopResizeObserver();\n                } else {\n                    Env.removeEvent(window, \"resize\", this.resizeListener, this);\n                    this.stopIntersectionObserver();\n                }\n                Env.removeEvent(window, \"scroll\", this.scrollListener, this);\n            }\n        },\n\n        /**\n         * Registers the MSPointer* event handlers.\n         */\n        addPointerEventHandlers: function () {\n            if (!this.hasPointerHandlers && Env.isBrowser) {\n                var moveTarget = this.attr.movetarget || this.containerObj;\n\n                if (window.navigator.msPointerEnabled) {\n                    // IE10-\n                    Env.addEvent(\n                        this.containerObj,\n                        \"MSPointerDown\",\n                        this.pointerDownListener,\n                        this\n                    );\n                    Env.addEvent(moveTarget, \"MSPointerMove\", this.pointerMoveListener, this);\n                } else {\n                    Env.addEvent(\n                        this.containerObj,\n                        \"pointerdown\",\n                        this.pointerDownListener,\n                        this\n                    );\n                    Env.addEvent(moveTarget, \"pointermove\", this.pointerMoveListener, this);\n                }\n                Env.addEvent(this.containerObj, \"mousewheel\", this.mouseWheelListener, this);\n                Env.addEvent(\n                    this.containerObj,\n                    \"DOMMouseScroll\",\n                    this.mouseWheelListener,\n                    this\n                );\n\n                if (this.containerObj !== null) {\n                    // This is needed for capturing touch events.\n                    // It is in jsxgraph.css, for ms-touch-action...\n                    this.containerObj.style.touchAction = 'none';\n                }\n\n                this.hasPointerHandlers = true;\n            }\n        },\n\n        /**\n         * Registers mouse move, down and wheel event handlers.\n         */\n        addMouseEventHandlers: function () {\n            if (!this.hasMouseHandlers && Env.isBrowser) {\n                var moveTarget = this.attr.movetarget || this.containerObj;\n\n                Env.addEvent(this.containerObj, \"mousedown\", this.mouseDownListener, this);\n                Env.addEvent(moveTarget, \"mousemove\", this.mouseMoveListener, this);\n\n                Env.addEvent(this.containerObj, \"mousewheel\", this.mouseWheelListener, this);\n                Env.addEvent(\n                    this.containerObj,\n                    \"DOMMouseScroll\",\n                    this.mouseWheelListener,\n                    this\n                );\n\n                this.hasMouseHandlers = true;\n            }\n        },\n\n        /**\n         * Register touch start and move and gesture start and change event handlers.\n         * @param {Boolean} appleGestures If set to false the gesturestart and gesturechange event handlers\n         * will not be registered.\n         *\n         * Since iOS 13, touch events were abandoned in favour of pointer events\n         */\n        addTouchEventHandlers: function (appleGestures) {\n            if (!this.hasTouchHandlers && Env.isBrowser) {\n                var moveTarget = this.attr.movetarget || this.containerObj;\n\n                Env.addEvent(this.containerObj, \"touchstart\", this.touchStartListener, this);\n                Env.addEvent(moveTarget, \"touchmove\", this.touchMoveListener, this);\n\n                /*\n                if (!Type.exists(appleGestures) || appleGestures) {\n                    // Gesture listener are called in touchStart and touchMove.\n                    //Env.addEvent(this.containerObj, 'gesturestart', this.gestureStartListener, this);\n                    //Env.addEvent(this.containerObj, 'gesturechange', this.gestureChangeListener, this);\n                }\n                */\n\n                this.hasTouchHandlers = true;\n            }\n        },\n\n        /**\n         * Add fullscreen events which update the CSS transformation matrix to correct\n         * the mouse/touch/pointer positions in case of CSS transformations.\n         */\n        addFullscreenEventHandlers: function () {\n            var i,\n                // standard/Edge, firefox, chrome/safari, IE11\n                events = [\n                    \"fullscreenchange\",\n                    \"mozfullscreenchange\",\n                    \"webkitfullscreenchange\",\n                    \"msfullscreenchange\"\n                ],\n                le = events.length;\n\n            if (!this.hasFullsceenEventHandlers && Env.isBrowser) {\n                for (i = 0; i < le; i++) {\n                    Env.addEvent(this.document, events[i], this.fullscreenListener, this);\n                }\n                this.hasFullsceenEventHandlers = true;\n            }\n        },\n\n        addKeyboardEventHandlers: function () {\n            if (this.attr.keyboard.enabled && !this.hasKeyboardHandlers && Env.isBrowser) {\n                Env.addEvent(this.containerObj, \"keydown\", this.keyDownListener, this);\n                Env.addEvent(this.containerObj, \"focusin\", this.keyFocusInListener, this);\n                Env.addEvent(this.containerObj, \"focusout\", this.keyFocusOutListener, this);\n                this.hasKeyboardHandlers = true;\n            }\n        },\n\n        /**\n         * Remove all registered touch event handlers.\n         */\n        removeKeyboardEventHandlers: function () {\n            if (this.hasKeyboardHandlers && Env.isBrowser) {\n                Env.removeEvent(this.containerObj, \"keydown\", this.keyDownListener, this);\n                Env.removeEvent(this.containerObj, \"focusin\", this.keyFocusInListener, this);\n                Env.removeEvent(this.containerObj, \"focusout\", this.keyFocusOutListener, this);\n                this.hasKeyboardHandlers = false;\n            }\n        },\n\n        /**\n         * Remove all registered event handlers regarding fullscreen mode.\n         */\n        removeFullscreenEventHandlers: function () {\n            var i,\n                // standard/Edge, firefox, chrome/safari, IE11\n                events = [\n                    \"fullscreenchange\",\n                    \"mozfullscreenchange\",\n                    \"webkitfullscreenchange\",\n                    \"msfullscreenchange\"\n                ],\n                le = events.length;\n\n            if (this.hasFullsceenEventHandlers && Env.isBrowser) {\n                for (i = 0; i < le; i++) {\n                    Env.removeEvent(this.document, events[i], this.fullscreenListener, this);\n                }\n                this.hasFullsceenEventHandlers = false;\n            }\n        },\n\n        /**\n         * Remove MSPointer* Event handlers.\n         */\n        removePointerEventHandlers: function () {\n            if (this.hasPointerHandlers && Env.isBrowser) {\n                var moveTarget = this.attr.movetarget || this.containerObj;\n\n                if (window.navigator.msPointerEnabled) {\n                    // IE10-\n                    Env.removeEvent(\n                        this.containerObj,\n                        \"MSPointerDown\",\n                        this.pointerDownListener,\n                        this\n                    );\n                    Env.removeEvent(\n                        moveTarget,\n                        \"MSPointerMove\",\n                        this.pointerMoveListener,\n                        this\n                    );\n                } else {\n                    Env.removeEvent(\n                        this.containerObj,\n                        \"pointerdown\",\n                        this.pointerDownListener,\n                        this\n                    );\n                    Env.removeEvent(moveTarget, \"pointermove\", this.pointerMoveListener, this);\n                }\n\n                Env.removeEvent(this.containerObj, \"mousewheel\", this.mouseWheelListener, this);\n                Env.removeEvent(\n                    this.containerObj,\n                    \"DOMMouseScroll\",\n                    this.mouseWheelListener,\n                    this\n                );\n\n                if (this.hasPointerUp) {\n                    if (window.navigator.msPointerEnabled) {\n                        // IE10-\n                        Env.removeEvent(\n                            this.document,\n                            \"MSPointerUp\",\n                            this.pointerUpListener,\n                            this\n                        );\n                    } else {\n                        Env.removeEvent(\n                            this.document,\n                            \"pointerup\",\n                            this.pointerUpListener,\n                            this\n                        );\n                        Env.removeEvent(\n                            this.document,\n                            \"pointercancel\",\n                            this.pointerUpListener,\n                            this\n                        );\n                    }\n                    this.hasPointerUp = false;\n                }\n\n                this.hasPointerHandlers = false;\n            }\n        },\n\n        /**\n         * De-register mouse event handlers.\n         */\n        removeMouseEventHandlers: function () {\n            if (this.hasMouseHandlers && Env.isBrowser) {\n                var moveTarget = this.attr.movetarget || this.containerObj;\n\n                Env.removeEvent(this.containerObj, \"mousedown\", this.mouseDownListener, this);\n                Env.removeEvent(moveTarget, \"mousemove\", this.mouseMoveListener, this);\n\n                if (this.hasMouseUp) {\n                    Env.removeEvent(this.document, \"mouseup\", this.mouseUpListener, this);\n                    this.hasMouseUp = false;\n                }\n\n                Env.removeEvent(this.containerObj, \"mousewheel\", this.mouseWheelListener, this);\n                Env.removeEvent(\n                    this.containerObj,\n                    \"DOMMouseScroll\",\n                    this.mouseWheelListener,\n                    this\n                );\n\n                this.hasMouseHandlers = false;\n            }\n        },\n\n        /**\n         * Remove all registered touch event handlers.\n         */\n        removeTouchEventHandlers: function () {\n            if (this.hasTouchHandlers && Env.isBrowser) {\n                var moveTarget = this.attr.movetarget || this.containerObj;\n\n                Env.removeEvent(this.containerObj, \"touchstart\", this.touchStartListener, this);\n                Env.removeEvent(moveTarget, \"touchmove\", this.touchMoveListener, this);\n\n                if (this.hasTouchEnd) {\n                    Env.removeEvent(this.document, \"touchend\", this.touchEndListener, this);\n                    this.hasTouchEnd = false;\n                }\n\n                this.hasTouchHandlers = false;\n            }\n        },\n\n        /**\n         * Handler for click on left arrow in the navigation bar\n         * @returns {JXG.Board} Reference to the board\n         */\n        clickLeftArrow: function () {\n            this.moveOrigin(\n                this.origin.scrCoords[1] + this.canvasWidth * 0.1,\n                this.origin.scrCoords[2]\n            );\n            return this;\n        },\n\n        /**\n         * Handler for click on right arrow in the navigation bar\n         * @returns {JXG.Board} Reference to the board\n         */\n        clickRightArrow: function () {\n            this.moveOrigin(\n                this.origin.scrCoords[1] - this.canvasWidth * 0.1,\n                this.origin.scrCoords[2]\n            );\n            return this;\n        },\n\n        /**\n         * Handler for click on up arrow in the navigation bar\n         * @returns {JXG.Board} Reference to the board\n         */\n        clickUpArrow: function () {\n            this.moveOrigin(\n                this.origin.scrCoords[1],\n                this.origin.scrCoords[2] - this.canvasHeight * 0.1\n            );\n            return this;\n        },\n\n        /**\n         * Handler for click on down arrow in the navigation bar\n         * @returns {JXG.Board} Reference to the board\n         */\n        clickDownArrow: function () {\n            this.moveOrigin(\n                this.origin.scrCoords[1],\n                this.origin.scrCoords[2] + this.canvasHeight * 0.1\n            );\n            return this;\n        },\n\n        /**\n         * Triggered on iOS/Safari while the user inputs a gesture (e.g. pinch) and is used to zoom into the board.\n         * Works on iOS/Safari and Android.\n         * @param {Event} evt Browser event object\n         * @returns {Boolean}\n         */\n        gestureChangeListener: function (evt) {\n            var c,\n                dir1 = [],\n                dir2 = [],\n                angle,\n                mi = 10,\n                isPinch = false,\n                // Save zoomFactors\n                zx = this.attr.zoom.factorx,\n                zy = this.attr.zoom.factory,\n                factor,\n                dist,\n                dx,\n                dy,\n                theta,\n                cx,\n                cy,\n                bound;\n\n            if (this.mode !== this.BOARD_MODE_ZOOM) {\n                return true;\n            }\n            evt.preventDefault();\n\n            dist = Geometry.distance(\n                [evt.touches[0].clientX, evt.touches[0].clientY],\n                [evt.touches[1].clientX, evt.touches[1].clientY],\n                2\n            );\n\n            // Android pinch to zoom\n            // evt.scale was available in iOS touch events (pre iOS 13)\n            // evt.scale is undefined in Android\n            if (evt.scale === undefined) {\n                evt.scale = dist / this.prevDist;\n            }\n\n            if (!Type.exists(this.prevCoords)) {\n                return false;\n            }\n            // Compute the angle of the two finger directions\n            dir1 = [\n                evt.touches[0].clientX - this.prevCoords[0][0],\n                evt.touches[0].clientY - this.prevCoords[0][1]\n            ];\n            dir2 = [\n                evt.touches[1].clientX - this.prevCoords[1][0],\n                evt.touches[1].clientY - this.prevCoords[1][1]\n            ];\n\n            if (\n                dir1[0] * dir1[0] + dir1[1] * dir1[1] < mi * mi &&\n                dir2[0] * dir2[0] + dir2[1] * dir2[1] < mi * mi\n            ) {\n                return false;\n            }\n\n            angle = Geometry.rad(dir1, [0, 0], dir2);\n            if (\n                this.isPreviousGesture !== \"pan\" &&\n                Math.abs(angle) > Math.PI * 0.2 &&\n                Math.abs(angle) < Math.PI * 1.8\n            ) {\n                isPinch = true;\n            }\n\n            if (this.isPreviousGesture !== \"pan\" && !isPinch) {\n                if (Math.abs(evt.scale) < 0.77 || Math.abs(evt.scale) > 1.3) {\n                    isPinch = true;\n                }\n            }\n\n            factor = evt.scale / this.prevScale;\n            this.prevScale = evt.scale;\n            this.prevCoords = [\n                [evt.touches[0].clientX, evt.touches[0].clientY],\n                [evt.touches[1].clientX, evt.touches[1].clientY]\n            ];\n\n            c = new Coords(Const.COORDS_BY_SCREEN, this.getMousePosition(evt, 0), this);\n\n            if (this.attr.pan.enabled && this.attr.pan.needtwofingers && !isPinch) {\n                // Pan detected\n\n                this.isPreviousGesture = \"pan\";\n\n                this.moveOrigin(c.scrCoords[1], c.scrCoords[2], true);\n            } else if (this.attr.zoom.enabled && Math.abs(factor - 1.0) < 0.5) {\n                // Pinch detected\n\n                if (this.attr.zoom.pinchhorizontal || this.attr.zoom.pinchvertical) {\n                    dx = Math.abs(evt.touches[0].clientX - evt.touches[1].clientX);\n                    dy = Math.abs(evt.touches[0].clientY - evt.touches[1].clientY);\n                    theta = Math.abs(Math.atan2(dy, dx));\n                    bound = (Math.PI * this.attr.zoom.pinchsensitivity) / 90.0;\n                }\n\n                if (this.attr.zoom.pinchhorizontal && theta < bound) {\n                    this.attr.zoom.factorx = factor;\n                    this.attr.zoom.factory = 1.0;\n                    cx = 0;\n                    cy = 0;\n                } else if (\n                    this.attr.zoom.pinchvertical &&\n                    Math.abs(theta - Math.PI * 0.5) < bound\n                ) {\n                    this.attr.zoom.factorx = 1.0;\n                    this.attr.zoom.factory = factor;\n                    cx = 0;\n                    cy = 0;\n                } else {\n                    this.attr.zoom.factorx = factor;\n                    this.attr.zoom.factory = factor;\n                    cx = c.usrCoords[1];\n                    cy = c.usrCoords[2];\n                }\n\n                this.zoomIn(cx, cy);\n\n                // Restore zoomFactors\n                this.attr.zoom.factorx = zx;\n                this.attr.zoom.factory = zy;\n            }\n\n            return false;\n        },\n\n        /**\n         * Called by iOS/Safari as soon as the user starts a gesture. Works natively on iOS/Safari,\n         * on Android we emulate it.\n         * @param {Event} evt\n         * @returns {Boolean}\n         */\n        gestureStartListener: function (evt) {\n            var pos;\n\n            evt.preventDefault();\n            this.prevScale = 1.0;\n            // Android pinch to zoom\n            this.prevDist = Geometry.distance(\n                [evt.touches[0].clientX, evt.touches[0].clientY],\n                [evt.touches[1].clientX, evt.touches[1].clientY],\n                2\n            );\n            this.prevCoords = [\n                [evt.touches[0].clientX, evt.touches[0].clientY],\n                [evt.touches[1].clientX, evt.touches[1].clientY]\n            ];\n            this.isPreviousGesture = \"none\";\n\n            // If pinch-to-zoom is interpreted as panning\n            // we have to prepare move origin\n            pos = this.getMousePosition(evt, 0);\n            this.initMoveOrigin(pos[0], pos[1]);\n\n            this.mode = this.BOARD_MODE_ZOOM;\n            return false;\n        },\n\n        /**\n         * Test if the required key combination is pressed for wheel zoom, move origin and\n         * selection\n         * @private\n         * @param  {Object}  evt    Mouse or pen event\n         * @param  {String}  action String containing the action: 'zoom', 'pan', 'selection'.\n         * Corresponds to the attribute subobject.\n         * @return {Boolean}        true or false.\n         */\n        _isRequiredKeyPressed: function (evt, action) {\n            var obj = this.attr[action];\n            if (!obj.enabled) {\n                return false;\n            }\n\n            if (\n                ((obj.needshift && evt.shiftKey) || (!obj.needshift && !evt.shiftKey)) &&\n                ((obj.needctrl && evt.ctrlKey) || (!obj.needctrl && !evt.ctrlKey))\n            ) {\n                return true;\n            }\n\n            return false;\n        },\n\n        /*\n         * Pointer events\n         */\n\n        /**\n         *\n         * Check if pointer event is already registered in {@link JXG.Board#_board_touches}.\n         *\n         * @param  {Object} evt Event object\n         * @return {Boolean} true if down event has already been sent.\n         * @private\n         */\n        _isPointerRegistered: function (evt) {\n            var i,\n                len = this._board_touches.length;\n\n            for (i = 0; i < len; i++) {\n                if (this._board_touches[i].pointerId === evt.pointerId) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        /**\n         *\n         * Store the position of a pointer event.\n         * If not yet done, registers a pointer event in {@link JXG.Board#_board_touches}.\n         * Allows to follow the path of that finger on the screen.\n         * Only two simultaneous touches are supported.\n         *\n         * @param {Object} evt Event object\n         * @returns {JXG.Board} Reference to the board\n         * @private\n         */\n        _pointerStorePosition: function (evt) {\n            var i, found;\n\n            for (i = 0, found = false; i < this._board_touches.length; i++) {\n                if (this._board_touches[i].pointerId === evt.pointerId) {\n                    this._board_touches[i].clientX = evt.clientX;\n                    this._board_touches[i].clientY = evt.clientY;\n                    found = true;\n                    break;\n                }\n            }\n\n            // Restrict the number of simultaneous touches to 2\n            if (!found && this._board_touches.length < 2) {\n                this._board_touches.push({\n                    pointerId: evt.pointerId,\n                    clientX: evt.clientX,\n                    clientY: evt.clientY\n                });\n            }\n\n            return this;\n        },\n\n        /**\n         * Deregisters a pointer event in {@link JXG.Board#_board_touches}.\n         * It happens if a finger has been lifted from the screen.\n         *\n         * @param {Object} evt Event object\n         * @returns {JXG.Board} Reference to the board\n         * @private\n         */\n        _pointerRemoveTouches: function (evt) {\n            var i;\n            for (i = 0; i < this._board_touches.length; i++) {\n                if (this._board_touches[i].pointerId === evt.pointerId) {\n                    this._board_touches.splice(i, 1);\n                    break;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Remove all registered fingers from {@link JXG.Board#_board_touches}.\n         * This might be necessary if too many fingers have been registered.\n         * @returns {JXG.Board} Reference to the board\n         * @private\n         */\n        _pointerClearTouches: function () {\n            if (this._board_touches.length > 0) {\n                this.dehighlightAll();\n            }\n            this.updateQuality = this.BOARD_QUALITY_HIGH;\n            this.mode = this.BOARD_MODE_NONE;\n            this._board_touches = [];\n            this.touches = [];\n        },\n\n        /**\n         * Determine which input device is used for this action.\n         * Possible devices are 'touch', 'pen' and 'mouse'.\n         * This affects the precision and certain events.\n         * In case of no browser, 'mouse' is used.\n         *\n         * @see JXG.Board#pointerDownListener\n         * @see JXG.Board#pointerMoveListener\n         * @see JXG.Board#initMoveObject\n         * @see JXG.Board#moveObject\n         *\n         * @param {Event} evt The browsers event object.\n         * @returns {String} 'mouse', 'pen', or 'touch'\n         * @private\n         */\n        _getPointerInputDevice: function (evt) {\n            if (Env.isBrowser) {\n                if (\n                    evt.pointerType === \"touch\" || // New\n                    (window.navigator.msMaxTouchPoints && // Old\n                        window.navigator.msMaxTouchPoints > 1)\n                ) {\n                    return \"touch\";\n                }\n                if (evt.pointerType === \"mouse\") {\n                    return \"mouse\";\n                }\n                if (evt.pointerType === \"pen\") {\n                    return \"pen\";\n                }\n            }\n            return \"mouse\";\n        },\n\n        /**\n         * This method is called by the browser when a pointing device is pressed on the screen.\n         * @param {Event} evt The browsers event object.\n         * @param {Object} object If the object to be dragged is already known, it can be submitted via this parameter\n         * @returns {Boolean} ...\n         */\n        pointerDownListener: function (evt, object) {\n            var i,\n                j,\n                k,\n                pos,\n                elements,\n                sel,\n                target_obj,\n                type = 'mouse', // Used in case of no browser\n                found, target, ta;\n\n            // Fix for Firefox browser: When using a second finger, the\n            // touch event for the first finger is sent again.\n            if (!object && this._isPointerRegistered(evt)) {\n                return false;\n            }\n\n            if (!object && evt.isPrimary) {\n                // First finger down. To be on the safe side this._board_touches is cleared.\n                this._pointerClearTouches();\n            }\n\n            if (!this.hasPointerUp) {\n                if (window.navigator.msPointerEnabled) {\n                    // IE10-\n                    Env.addEvent(this.document, \"MSPointerUp\", this.pointerUpListener, this);\n                } else {\n                    // 'pointercancel' is fired e.g. if the finger leaves the browser and drags down the system menu on Android\n                    Env.addEvent(this.document, \"pointerup\", this.pointerUpListener, this);\n                    Env.addEvent(this.document, \"pointercancel\", this.pointerUpListener, this);\n                }\n                this.hasPointerUp = true;\n            }\n\n            if (this.hasMouseHandlers) {\n                this.removeMouseEventHandlers();\n            }\n\n            if (this.hasTouchHandlers) {\n                this.removeTouchEventHandlers();\n            }\n\n            // Prevent accidental selection of text\n            if (this.document.selection && Type.isFunction(this.document.selection.empty)) {\n                this.document.selection.empty();\n            } else if (window.getSelection) {\n                sel = window.getSelection();\n                if (sel.removeAllRanges) {\n                    try {\n                        sel.removeAllRanges();\n                    } catch (e) {}\n                }\n            }\n\n            // Mouse, touch or pen device\n            this._inputDevice = this._getPointerInputDevice(evt);\n            type = this._inputDevice;\n            this.options.precision.hasPoint = this.options.precision[type];\n\n            // Handling of multi touch with pointer events should be easier than the touch events.\n            // Every pointer device has its own pointerId, e.g. the mouse\n            // always has id 1 or 0, fingers and pens get unique ids every time a pointerDown event is fired and they will\n            // keep this id until a pointerUp event is fired. What we have to do here is:\n            //  1. collect all elements under the current pointer\n            //  2. run through the touches control structure\n            //    a. look for the object collected in step 1.\n            //    b. if an object is found, check the number of pointers. If appropriate, add the pointer.\n            pos = this.getMousePosition(evt);\n\n            // selection\n            this._testForSelection(evt);\n            if (this.selectingMode) {\n                this._startSelecting(pos);\n                this.triggerEventHandlers(\n                    [\"touchstartselecting\", \"pointerstartselecting\", \"startselecting\"],\n                    [evt]\n                );\n                return; // don't continue as a normal click\n            }\n\n            if (this.attr.drag.enabled && object) {\n                elements = [object];\n                this.mode = this.BOARD_MODE_DRAG;\n            } else {\n                elements = this.initMoveObject(pos[0], pos[1], evt, type);\n            }\n\n            target_obj = {\n                num: evt.pointerId,\n                X: pos[0],\n                Y: pos[1],\n                Xprev: NaN,\n                Yprev: NaN,\n                Xstart: [],\n                Ystart: [],\n                Zstart: []\n            };\n\n            // If no draggable object can be found, get out here immediately\n            if (elements.length > 0) {\n                // check touches structure\n                target = elements[elements.length - 1];\n                found = false;\n\n                // Reminder: this.touches is the list of elements which\n                // currently \"possess\" a pointer (mouse, pen, finger)\n                for (i = 0; i < this.touches.length; i++) {\n                    // An element receives a further touch, i.e.\n                    // the target is already in our touches array, add the pointer to the existing touch\n                    if (this.touches[i].obj === target) {\n                        j = i;\n                        k = this.touches[i].targets.push(target_obj) - 1;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    // An new element hae been touched.\n                    k = 0;\n                    j =\n                        this.touches.push({\n                            obj: target,\n                            targets: [target_obj]\n                        }) - 1;\n                }\n\n                this.dehighlightAll();\n                target.highlight(true);\n\n                this.saveStartPos(target, this.touches[j].targets[k]);\n\n                // Prevent accidental text selection\n                // this could get us new trouble: input fields, links and drop down boxes placed as text\n                // on the board don't work anymore.\n                if (evt && evt.preventDefault) {\n                    evt.preventDefault();\n                } else if (window.event) {\n                    window.event.returnValue = false;\n                }\n            }\n\n            if (this.touches.length > 0) {\n                evt.preventDefault();\n                evt.stopPropagation();\n            }\n\n            if (!Env.isBrowser) {\n                return false;\n            }\n            if (this._getPointerInputDevice(evt) !== \"touch\") {\n                if (this.mode === this.BOARD_MODE_NONE) {\n                    this.mouseOriginMoveStart(evt);\n                }\n            } else {\n                this._pointerStorePosition(evt);\n                evt.touches = this._board_touches;\n\n                // Touch events on empty areas of the board are handled here, see also touchStartListener\n                // 1. case: one finger. If allowed, this triggers pan with one finger\n                if (\n                    evt.touches.length === 1 &&\n                    this.mode === this.BOARD_MODE_NONE &&\n                    this.touchStartMoveOriginOneFinger(evt)\n                ) {\n                    // Empty by purpose\n                } else if (\n                    evt.touches.length === 2 &&\n                    (this.mode === this.BOARD_MODE_NONE ||\n                        this.mode === this.BOARD_MODE_MOVE_ORIGIN)\n                ) {\n                    // 2. case: two fingers: pinch to zoom or pan with two fingers needed.\n                    // This happens when the second finger hits the device. First, the\n                    // \"one finger pan mode\" has to be cancelled.\n                    if (this.mode === this.BOARD_MODE_MOVE_ORIGIN) {\n                        this.originMoveEnd();\n                    }\n\n                    this.gestureStartListener(evt);\n                }\n            }\n\n            // Allow browser scrolling\n            // For this: pan by one finger has to be disabled\n            ta = 'none';             // JSXGraph catches all user touch events\n            if (this.mode === this.BOARD_MODE_NONE &&\n                Type.evaluate(this.attr.browserpan) &&\n                !(Type.evaluate(this.attr.pan.enabled) && !Type.evaluate(this.attr.pan.needtwofingers))\n               ) {\n                ta = 'pan-x pan-y';  // JSXGraph allows browser scrolling\n            }\n            this.containerObj.style.touchAction = ta;\n\n            this.triggerEventHandlers(['touchstart', 'down', 'pointerdown', 'MSPointerDown'], [evt]);\n\n            return true;\n        },\n\n        // /**\n        //  * Called if pointer leaves an HTML tag. It is called by the inner-most tag.\n        //  * That means, if a JSXGraph text, i.e. an HTML div, is placed close\n        //  * to the border of the board, this pointerout event will be ignored.\n        //  * @param  {Event} evt\n        //  * @return {Boolean}\n        //  */\n        // pointerOutListener: function (evt) {\n        //     if (evt.target === this.containerObj ||\n        //         (this.renderer.type === 'svg' && evt.target === this.renderer.foreignObjLayer)) {\n        //         this.pointerUpListener(evt);\n        //     }\n        //     return this.mode === this.BOARD_MODE_NONE;\n        // },\n\n        /**\n         * Called periodically by the browser while the user moves a pointing device across the screen.\n         * @param {Event} evt\n         * @returns {Boolean}\n         */\n        pointerMoveListener: function (evt) {\n            var i,\n                j,\n                pos,\n                touchTargets,\n                type = \"mouse\"; // in case of no browser\n\n            if (\n                this._getPointerInputDevice(evt) === \"touch\" &&\n                !this._isPointerRegistered(evt)\n            ) {\n                // Test, if there was a previous down event of this _getPointerId\n                // (in case it is a touch event).\n                // Otherwise this move event is ignored. This is necessary e.g. for sketchometry.\n                return this.BOARD_MODE_NONE;\n            }\n\n            if (!this.checkFrameRate(evt)) {\n                return false;\n            }\n\n            if (this.mode !== this.BOARD_MODE_DRAG) {\n                this.dehighlightAll();\n                this.displayInfobox(false);\n            }\n\n            if (this.mode !== this.BOARD_MODE_NONE) {\n                evt.preventDefault();\n                evt.stopPropagation();\n            }\n\n            this.updateQuality = this.BOARD_QUALITY_LOW;\n            // Mouse, touch or pen device\n            this._inputDevice = this._getPointerInputDevice(evt);\n            type = this._inputDevice;\n            this.options.precision.hasPoint = this.options.precision[type];\n\n            // selection\n            if (this.selectingMode) {\n                pos = this.getMousePosition(evt);\n                this._moveSelecting(pos);\n                this.triggerEventHandlers(\n                    [\"touchmoveselecting\", \"moveselecting\", \"pointermoveselecting\"],\n                    [evt, this.mode]\n                );\n            } else if (!this.mouseOriginMove(evt)) {\n                if (this.mode === this.BOARD_MODE_DRAG) {\n                    // Run through all jsxgraph elements which are touched by at least one finger.\n                    for (i = 0; i < this.touches.length; i++) {\n                        touchTargets = this.touches[i].targets;\n                        // Run through all touch events which have been started on this jsxgraph element.\n                        for (j = 0; j < touchTargets.length; j++) {\n                            if (touchTargets[j].num === evt.pointerId) {\n                                pos = this.getMousePosition(evt);\n                                touchTargets[j].X = pos[0];\n                                touchTargets[j].Y = pos[1];\n\n                                if (touchTargets.length === 1) {\n                                    // Touch by one finger: this is possible for all elements that can be dragged\n                                    this.moveObject(pos[0], pos[1], this.touches[i], evt, type);\n                                } else if (touchTargets.length === 2) {\n                                    // Touch by two fingers: e.g. moving lines\n                                    this.twoFingerMove(this.touches[i], evt.pointerId, evt);\n\n                                    touchTargets[j].Xprev = pos[0];\n                                    touchTargets[j].Yprev = pos[1];\n                                }\n\n                                // There is only one pointer in the evt object, so there's no point in looking further\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    if (this._getPointerInputDevice(evt) === \"touch\") {\n                        this._pointerStorePosition(evt);\n\n                        if (this._board_touches.length === 2) {\n                            evt.touches = this._board_touches;\n                            this.gestureChangeListener(evt);\n                        }\n                    }\n\n                    // Move event without dragging an element\n                    pos = this.getMousePosition(evt);\n                    this.highlightElements(pos[0], pos[1], evt, -1);\n                }\n            }\n\n            // Hiding the infobox is commented out, since it prevents showing the infobox\n            // on IE 11+ on 'over'\n            //if (this.mode !== this.BOARD_MODE_DRAG) {\n            //this.displayInfobox(false);\n            //}\n            this.triggerEventHandlers(['pointermove', 'MSPointerMove', 'move'], [evt, this.mode]);\n            this.updateQuality = this.BOARD_QUALITY_HIGH;\n\n            return this.mode === this.BOARD_MODE_NONE;\n        },\n\n        /**\n         * Triggered as soon as the user stops touching the device with at least one finger.\n         * @param {Event} evt\n         * @returns {Boolean}\n         */\n        pointerUpListener: function (evt) {\n            var i,\n                j,\n                found,\n                touchTargets,\n                updateNeeded = false;\n\n            this.triggerEventHandlers([\"touchend\", \"up\", \"pointerup\", \"MSPointerUp\"], [evt]);\n            this.displayInfobox(false);\n\n            if (evt) {\n                for (i = 0; i < this.touches.length; i++) {\n                    touchTargets = this.touches[i].targets;\n                    for (j = 0; j < touchTargets.length; j++) {\n                        if (touchTargets[j].num === evt.pointerId) {\n                            touchTargets.splice(j, 1);\n                            if (touchTargets.length === 0) {\n                                this.touches.splice(i, 1);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n\n            this.originMoveEnd();\n            this.update();\n\n            // selection\n            if (this.selectingMode) {\n                this._stopSelecting(evt);\n                this.triggerEventHandlers(\n                    [\"touchstopselecting\", \"pointerstopselecting\", \"stopselecting\"],\n                    [evt]\n                );\n                this.stopSelectionMode();\n            } else {\n                for (i = this.downObjects.length - 1; i > -1; i--) {\n                    found = false;\n                    for (j = 0; j < this.touches.length; j++) {\n                        if (this.touches[j].obj.id === this.downObjects[i].id) {\n                            found = true;\n                        }\n                    }\n                    if (!found) {\n                        this.downObjects[i].triggerEventHandlers(\n                            [\"touchend\", \"up\", \"pointerup\", \"MSPointerUp\"],\n                            [evt]\n                        );\n                        if (!Type.exists(this.downObjects[i].coords)) {\n                            // snapTo methods have to be called e.g. for line elements here.\n                            // For coordsElements there might be a conflict with\n                            // attractors, see commit from 2022.04.08, 11:12:18.\n                            this.downObjects[i].snapToGrid();\n                            this.downObjects[i].snapToPoints();\n                            updateNeeded = true;\n                        }\n                        this.downObjects.splice(i, 1);\n                    }\n                }\n            }\n\n            if (this.hasPointerUp) {\n                if (window.navigator.msPointerEnabled) {\n                    // IE10-\n                    Env.removeEvent(this.document, \"MSPointerUp\", this.pointerUpListener, this);\n                } else {\n                    Env.removeEvent(this.document, \"pointerup\", this.pointerUpListener, this);\n                    Env.removeEvent(\n                        this.document,\n                        \"pointercancel\",\n                        this.pointerUpListener,\n                        this\n                    );\n                }\n                this.hasPointerUp = false;\n            }\n\n            // this.dehighlightAll();\n            // this.updateQuality = this.BOARD_QUALITY_HIGH;\n            // this.mode = this.BOARD_MODE_NONE;\n\n            // this.originMoveEnd();\n            if (updateNeeded) {\n                this.update();\n            }\n\n            // After one finger leaves the screen the gesture is stopped.\n            this._pointerClearTouches();\n\n            return true;\n        },\n\n        /**\n         * Touch-Events\n         */\n\n        /**\n         * This method is called by the browser when a finger touches the surface of the touch-device.\n         * @param {Event} evt The browsers event object.\n         * @returns {Boolean} ...\n         */\n        touchStartListener: function (evt) {\n            var i,\n                pos,\n                elements,\n                j,\n                k,\n                eps = this.options.precision.touch,\n                obj,\n                found,\n                targets,\n                evtTouches = evt[JXG.touchProperty],\n                target,\n                touchTargets;\n\n            if (!this.hasTouchEnd) {\n                Env.addEvent(this.document, \"touchend\", this.touchEndListener, this);\n                this.hasTouchEnd = true;\n            }\n\n            // Do not remove mouseHandlers, since Chrome on win tablets sends mouseevents if used with pen.\n            //if (this.hasMouseHandlers) { this.removeMouseEventHandlers(); }\n\n            // prevent accidental selection of text\n            if (this.document.selection && Type.isFunction(this.document.selection.empty)) {\n                this.document.selection.empty();\n            } else if (window.getSelection) {\n                window.getSelection().removeAllRanges();\n            }\n\n            // multitouch\n            this._inputDevice = \"touch\";\n            this.options.precision.hasPoint = this.options.precision.touch;\n\n            // This is the most critical part. first we should run through the existing touches and collect all targettouches that don't belong to our\n            // previous touches. once this is done we run through the existing touches again and watch out for free touches that can be attached to our existing\n            // touches, e.g. we translate (parallel translation) a line with one finger, now a second finger is over this line. this should change the operation to\n            // a rotational translation. or one finger moves a circle, a second finger can be attached to the circle: this now changes the operation from translation to\n            // stretching. as a last step we're going through the rest of the targettouches and initiate new move operations:\n            //  * points have higher priority over other elements.\n            //  * if we find a targettouch over an element that could be transformed with more than one finger, we search the rest of the targettouches, if they are over\n            //    this element and add them.\n            // ADDENDUM 11/10/11:\n            //  (1) run through the touches control object,\n            //  (2) try to find the targetTouches for every touch. on touchstart only new touches are added, hence we can find a targettouch\n            //      for every target in our touches objects\n            //  (3) if one of the targettouches was bound to a touches targets array, mark it\n            //  (4) run through the targettouches. if the targettouch is marked, continue. otherwise check for elements below the targettouch:\n            //      (a) if no element could be found: mark the target touches and continue\n            //      --- in the following cases, \"init\" means:\n            //           (i) check if the element is already used in another touches element, if so, mark the targettouch and continue\n            //          (ii) if not, init a new touches element, add the targettouch to the touches property and mark it\n            //      (b) if the element is a point, init\n            //      (c) if the element is a line, init and try to find a second targettouch on that line. if a second one is found, add and mark it\n            //      (d) if the element is a circle, init and try to find TWO other targettouches on that circle. if only one is found, mark it and continue. otherwise\n            //          add both to the touches array and mark them.\n            for (i = 0; i < evtTouches.length; i++) {\n                evtTouches[i].jxg_isused = false;\n            }\n\n            for (i = 0; i < this.touches.length; i++) {\n                touchTargets = this.touches[i].targets;\n                for (j = 0; j < touchTargets.length; j++) {\n                    touchTargets[j].num = -1;\n                    eps = this.options.precision.touch;\n\n                    do {\n                        for (k = 0; k < evtTouches.length; k++) {\n                            // find the new targettouches\n                            if (\n                                Math.abs(\n                                    Math.pow(evtTouches[k].screenX - touchTargets[j].X, 2) +\n                                        Math.pow(evtTouches[k].screenY - touchTargets[j].Y, 2)\n                                ) <\n                                eps * eps\n                            ) {\n                                touchTargets[j].num = k;\n                                touchTargets[j].X = evtTouches[k].screenX;\n                                touchTargets[j].Y = evtTouches[k].screenY;\n                                evtTouches[k].jxg_isused = true;\n                                break;\n                            }\n                        }\n\n                        eps *= 2;\n                    } while (\n                        touchTargets[j].num === -1 &&\n                        eps < this.options.precision.touchMax\n                    );\n\n                    if (touchTargets[j].num === -1) {\n                        JXG.debug(\n                            \"i couldn't find a targettouches for target no \" +\n                                j +\n                                \" on \" +\n                                this.touches[i].obj.name +\n                                \" (\" +\n                                this.touches[i].obj.id +\n                                \"). Removed the target.\"\n                        );\n                        JXG.debug(\n                            \"eps = \" + eps + \", touchMax = \" + Options.precision.touchMax\n                        );\n                        touchTargets.splice(i, 1);\n                    }\n                }\n            }\n\n            // we just re-mapped the targettouches to our existing touches list.\n            // now we have to initialize some touches from additional targettouches\n            for (i = 0; i < evtTouches.length; i++) {\n                if (!evtTouches[i].jxg_isused) {\n                    pos = this.getMousePosition(evt, i);\n                    // selection\n                    // this._testForSelection(evt); // we do not have shift or ctrl keys yet.\n                    if (this.selectingMode) {\n                        this._startSelecting(pos);\n                        this.triggerEventHandlers(\n                            [\"touchstartselecting\", \"startselecting\"],\n                            [evt]\n                        );\n                        evt.preventDefault();\n                        evt.stopPropagation();\n                        this.options.precision.hasPoint = this.options.precision.mouse;\n                        return this.touches.length > 0; // don't continue as a normal click\n                    }\n\n                    elements = this.initMoveObject(pos[0], pos[1], evt, \"touch\");\n                    if (elements.length !== 0) {\n                        obj = elements[elements.length - 1];\n                        target = {\n                            num: i,\n                            X: evtTouches[i].screenX,\n                            Y: evtTouches[i].screenY,\n                            Xprev: NaN,\n                            Yprev: NaN,\n                            Xstart: [],\n                            Ystart: [],\n                            Zstart: []\n                        };\n\n                        if (\n                            Type.isPoint(obj) ||\n                            obj.elementClass === Const.OBJECT_CLASS_TEXT ||\n                            obj.type === Const.OBJECT_TYPE_TICKS ||\n                            obj.type === Const.OBJECT_TYPE_IMAGE\n                        ) {\n                            // It's a point, so it's single touch, so we just push it to our touches\n                            targets = [target];\n\n                            // For the UNDO/REDO of object moves\n                            this.saveStartPos(obj, targets[0]);\n\n                            this.touches.push({ obj: obj, targets: targets });\n                            obj.highlight(true);\n                        } else if (\n                            obj.elementClass === Const.OBJECT_CLASS_LINE ||\n                            obj.elementClass === Const.OBJECT_CLASS_CIRCLE ||\n                            obj.elementClass === Const.OBJECT_CLASS_CURVE ||\n                            obj.type === Const.OBJECT_TYPE_POLYGON\n                        ) {\n                            found = false;\n\n                            // first check if this geometric object is already captured in this.touches\n                            for (j = 0; j < this.touches.length; j++) {\n                                if (obj.id === this.touches[j].obj.id) {\n                                    found = true;\n                                    // only add it, if we don't have two targets in there already\n                                    if (this.touches[j].targets.length === 1) {\n                                        // For the UNDO/REDO of object moves\n                                        this.saveStartPos(obj, target);\n                                        this.touches[j].targets.push(target);\n                                    }\n\n                                    evtTouches[i].jxg_isused = true;\n                                }\n                            }\n\n                            // we couldn't find it in touches, so we just init a new touches\n                            // IF there is a second touch targetting this line, we will find it later on, and then add it to\n                            // the touches control object.\n                            if (!found) {\n                                targets = [target];\n\n                                // For the UNDO/REDO of object moves\n                                this.saveStartPos(obj, targets[0]);\n                                this.touches.push({ obj: obj, targets: targets });\n                                obj.highlight(true);\n                            }\n                        }\n                    }\n\n                    evtTouches[i].jxg_isused = true;\n                }\n            }\n\n            if (this.touches.length > 0) {\n                evt.preventDefault();\n                evt.stopPropagation();\n            }\n\n            // Touch events on empty areas of the board are handled here:\n            // 1. case: one finger. If allowed, this triggers pan with one finger\n            if (\n                evtTouches.length === 1 &&\n                this.mode === this.BOARD_MODE_NONE &&\n                this.touchStartMoveOriginOneFinger(evt)\n            ) {\n            } else if (\n                evtTouches.length === 2 &&\n                (this.mode === this.BOARD_MODE_NONE ||\n                    this.mode === this.BOARD_MODE_MOVE_ORIGIN)\n            ) {\n                // 2. case: two fingers: pinch to zoom or pan with two fingers needed.\n                // This happens when the second finger hits the device. First, the\n                // \"one finger pan mode\" has to be cancelled.\n                if (this.mode === this.BOARD_MODE_MOVE_ORIGIN) {\n                    this.originMoveEnd();\n                }\n                this.gestureStartListener(evt);\n            }\n\n            this.options.precision.hasPoint = this.options.precision.mouse;\n            this.triggerEventHandlers([\"touchstart\", \"down\"], [evt]);\n\n            return false;\n            //return this.touches.length > 0;\n        },\n\n        /**\n         * Called periodically by the browser while the user moves his fingers across the device.\n         * @param {Event} evt\n         * @returns {Boolean}\n         */\n        touchMoveListener: function (evt) {\n            var i,\n                pos1,\n                pos2,\n                touchTargets,\n                evtTouches = evt[JXG.touchProperty];\n\n            if (!this.checkFrameRate(evt)) {\n                return false;\n            }\n\n            if (this.mode !== this.BOARD_MODE_NONE) {\n                evt.preventDefault();\n                evt.stopPropagation();\n            }\n\n            if (this.mode !== this.BOARD_MODE_DRAG) {\n                this.dehighlightAll();\n                this.displayInfobox(false);\n            }\n\n            this._inputDevice = \"touch\";\n            this.options.precision.hasPoint = this.options.precision.touch;\n            this.updateQuality = this.BOARD_QUALITY_LOW;\n\n            // selection\n            if (this.selectingMode) {\n                for (i = 0; i < evtTouches.length; i++) {\n                    if (!evtTouches[i].jxg_isused) {\n                        pos1 = this.getMousePosition(evt, i);\n                        this._moveSelecting(pos1);\n                        this.triggerEventHandlers(\n                            [\"touchmoves\", \"moveselecting\"],\n                            [evt, this.mode]\n                        );\n                        break;\n                    }\n                }\n            } else {\n                if (!this.touchOriginMove(evt)) {\n                    if (this.mode === this.BOARD_MODE_DRAG) {\n                        // Runs over through all elements which are touched\n                        // by at least one finger.\n                        for (i = 0; i < this.touches.length; i++) {\n                            touchTargets = this.touches[i].targets;\n                            if (touchTargets.length === 1) {\n                                // Touch by one finger:  this is possible for all elements that can be dragged\n                                if (evtTouches[touchTargets[0].num]) {\n                                    pos1 = this.getMousePosition(evt, touchTargets[0].num);\n                                    if (\n                                        pos1[0] < 0 ||\n                                        pos1[0] > this.canvasWidth ||\n                                        pos1[1] < 0 ||\n                                        pos1[1] > this.canvasHeight\n                                    ) {\n                                        return;\n                                    }\n                                    touchTargets[0].X = pos1[0];\n                                    touchTargets[0].Y = pos1[1];\n                                    this.moveObject(\n                                        pos1[0],\n                                        pos1[1],\n                                        this.touches[i],\n                                        evt,\n                                        \"touch\"\n                                    );\n                                }\n                            } else if (\n                                touchTargets.length === 2 &&\n                                touchTargets[0].num > -1 &&\n                                touchTargets[1].num > -1\n                            ) {\n                                // Touch by two fingers: moving lines, ...\n                                if (\n                                    evtTouches[touchTargets[0].num] &&\n                                    evtTouches[touchTargets[1].num]\n                                ) {\n                                    // Get coordinates of the two touches\n                                    pos1 = this.getMousePosition(evt, touchTargets[0].num);\n                                    pos2 = this.getMousePosition(evt, touchTargets[1].num);\n                                    if (\n                                        pos1[0] < 0 ||\n                                        pos1[0] > this.canvasWidth ||\n                                        pos1[1] < 0 ||\n                                        pos1[1] > this.canvasHeight ||\n                                        pos2[0] < 0 ||\n                                        pos2[0] > this.canvasWidth ||\n                                        pos2[1] < 0 ||\n                                        pos2[1] > this.canvasHeight\n                                    ) {\n                                        return;\n                                    }\n\n                                    touchTargets[0].X = pos1[0];\n                                    touchTargets[0].Y = pos1[1];\n                                    touchTargets[1].X = pos2[0];\n                                    touchTargets[1].Y = pos2[1];\n\n                                    this.twoFingerMove(\n                                        this.touches[i],\n                                        touchTargets[0].num,\n                                        evt\n                                    );\n                                    this.twoFingerMove(this.touches[i], touchTargets[1].num);\n\n                                    touchTargets[0].Xprev = pos1[0];\n                                    touchTargets[0].Yprev = pos1[1];\n                                    touchTargets[1].Xprev = pos2[0];\n                                    touchTargets[1].Yprev = pos2[1];\n                                }\n                            }\n                        }\n                    } else {\n                        if (evtTouches.length === 2) {\n                            this.gestureChangeListener(evt);\n                        }\n                        // Move event without dragging an element\n                        pos1 = this.getMousePosition(evt, 0);\n                        this.highlightElements(pos1[0], pos1[1], evt, -1);\n                    }\n                }\n            }\n\n            if (this.mode !== this.BOARD_MODE_DRAG) {\n                this.displayInfobox(false);\n            }\n\n            this.triggerEventHandlers([\"touchmove\", \"move\"], [evt, this.mode]);\n            this.options.precision.hasPoint = this.options.precision.mouse;\n            this.updateQuality = this.BOARD_QUALITY_HIGH;\n\n            return this.mode === this.BOARD_MODE_NONE;\n        },\n\n        /**\n         * Triggered as soon as the user stops touching the device with at least one finger.\n         * @param {Event} evt\n         * @returns {Boolean}\n         */\n        touchEndListener: function (evt) {\n            var i,\n                j,\n                k,\n                eps = this.options.precision.touch,\n                tmpTouches = [],\n                found,\n                foundNumber,\n                evtTouches = evt && evt[JXG.touchProperty],\n                touchTargets,\n                updateNeeded = false;\n\n            this.triggerEventHandlers([\"touchend\", \"up\"], [evt]);\n            this.displayInfobox(false);\n\n            // selection\n            if (this.selectingMode) {\n                this._stopSelecting(evt);\n                this.triggerEventHandlers([\"touchstopselecting\", \"stopselecting\"], [evt]);\n                this.stopSelectionMode();\n            } else if (evtTouches && evtTouches.length > 0) {\n                for (i = 0; i < this.touches.length; i++) {\n                    tmpTouches[i] = this.touches[i];\n                }\n                this.touches.length = 0;\n\n                // try to convert the operation, e.g. if a lines is rotated and translated with two fingers and one finger is lifted,\n                // convert the operation to a simple one-finger-translation.\n                // ADDENDUM 11/10/11:\n                // see addendum to touchStartListener from 11/10/11\n                // (1) run through the tmptouches\n                // (2) check the touches.obj, if it is a\n                //     (a) point, try to find the targettouch, if found keep it and mark the targettouch, else drop the touch.\n                //     (b) line with\n                //          (i) one target: try to find it, if found keep it mark the targettouch, else drop the touch.\n                //         (ii) two targets: if none can be found, drop the touch. if one can be found, remove the other target. mark all found targettouches\n                //     (c) circle with [proceed like in line]\n\n                // init the targettouches marker\n                for (i = 0; i < evtTouches.length; i++) {\n                    evtTouches[i].jxg_isused = false;\n                }\n\n                for (i = 0; i < tmpTouches.length; i++) {\n                    // could all targets of the current this.touches.obj be assigned to targettouches?\n                    found = false;\n                    foundNumber = 0;\n                    touchTargets = tmpTouches[i].targets;\n\n                    for (j = 0; j < touchTargets.length; j++) {\n                        touchTargets[j].found = false;\n                        for (k = 0; k < evtTouches.length; k++) {\n                            if (\n                                Math.abs(\n                                    Math.pow(evtTouches[k].screenX - touchTargets[j].X, 2) +\n                                        Math.pow(evtTouches[k].screenY - touchTargets[j].Y, 2)\n                                ) <\n                                eps * eps\n                            ) {\n                                touchTargets[j].found = true;\n                                touchTargets[j].num = k;\n                                touchTargets[j].X = evtTouches[k].screenX;\n                                touchTargets[j].Y = evtTouches[k].screenY;\n                                foundNumber += 1;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (Type.isPoint(tmpTouches[i].obj)) {\n                        found = touchTargets[0] && touchTargets[0].found;\n                    } else if (tmpTouches[i].obj.elementClass === Const.OBJECT_CLASS_LINE) {\n                        found =\n                            (touchTargets[0] && touchTargets[0].found) ||\n                            (touchTargets[1] && touchTargets[1].found);\n                    } else if (tmpTouches[i].obj.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                        found = foundNumber === 1 || foundNumber === 3;\n                    }\n\n                    // if we found this object to be still dragged by the user, add it back to this.touches\n                    if (found) {\n                        this.touches.push({\n                            obj: tmpTouches[i].obj,\n                            targets: []\n                        });\n\n                        for (j = 0; j < touchTargets.length; j++) {\n                            if (touchTargets[j].found) {\n                                this.touches[this.touches.length - 1].targets.push({\n                                    num: touchTargets[j].num,\n                                    X: touchTargets[j].screenX,\n                                    Y: touchTargets[j].screenY,\n                                    Xprev: NaN,\n                                    Yprev: NaN,\n                                    Xstart: touchTargets[j].Xstart,\n                                    Ystart: touchTargets[j].Ystart,\n                                    Zstart: touchTargets[j].Zstart\n                                });\n                            }\n                        }\n                    } else {\n                        tmpTouches[i].obj.noHighlight();\n                    }\n                }\n            } else {\n                this.touches.length = 0;\n            }\n\n            for (i = this.downObjects.length - 1; i > -1; i--) {\n                found = false;\n                for (j = 0; j < this.touches.length; j++) {\n                    if (this.touches[j].obj.id === this.downObjects[i].id) {\n                        found = true;\n                    }\n                }\n                if (!found) {\n                    this.downObjects[i].triggerEventHandlers([\"touchup\", \"up\"], [evt]);\n                    if (!Type.exists(this.downObjects[i].coords)) {\n                        // snapTo methods have to be called e.g. for line elements here.\n                        // For coordsElements there might be a conflict with\n                        // attractors, see commit from 2022.04.08, 11:12:18.\n                        this.downObjects[i].snapToGrid();\n                        this.downObjects[i].snapToPoints();\n                        updateNeeded = true;\n                    }\n                    this.downObjects.splice(i, 1);\n                }\n            }\n\n            if (!evtTouches || evtTouches.length === 0) {\n                if (this.hasTouchEnd) {\n                    Env.removeEvent(this.document, \"touchend\", this.touchEndListener, this);\n                    this.hasTouchEnd = false;\n                }\n\n                this.dehighlightAll();\n                this.updateQuality = this.BOARD_QUALITY_HIGH;\n\n                this.originMoveEnd();\n                if (updateNeeded) {\n                    this.update();\n                }\n            }\n\n            return true;\n        },\n\n        /**\n         * This method is called by the browser when the mouse button is clicked.\n         * @param {Event} evt The browsers event object.\n         * @returns {Boolean} True if no element is found under the current mouse pointer, false otherwise.\n         */\n        mouseDownListener: function (evt) {\n            var pos, elements, result;\n\n            // prevent accidental selection of text\n            if (this.document.selection && Type.isFunction(this.document.selection.empty)) {\n                this.document.selection.empty();\n            } else if (window.getSelection) {\n                window.getSelection().removeAllRanges();\n            }\n\n            if (!this.hasMouseUp) {\n                Env.addEvent(this.document, \"mouseup\", this.mouseUpListener, this);\n                this.hasMouseUp = true;\n            } else {\n                // In case this.hasMouseUp==true, it may be that there was a\n                // mousedown event before which was not followed by an mouseup event.\n                // This seems to happen with interactive whiteboard pens sometimes.\n                return;\n            }\n\n            this._inputDevice = \"mouse\";\n            this.options.precision.hasPoint = this.options.precision.mouse;\n            pos = this.getMousePosition(evt);\n\n            // selection\n            this._testForSelection(evt);\n            if (this.selectingMode) {\n                this._startSelecting(pos);\n                this.triggerEventHandlers([\"mousestartselecting\", \"startselecting\"], [evt]);\n                return; // don't continue as a normal click\n            }\n\n            elements = this.initMoveObject(pos[0], pos[1], evt, \"mouse\");\n\n            // if no draggable object can be found, get out here immediately\n            if (elements.length === 0) {\n                this.mode = this.BOARD_MODE_NONE;\n                result = true;\n            } else {\n                /** @ignore */\n                this.mouse = {\n                    obj: null,\n                    targets: [\n                        {\n                            X: pos[0],\n                            Y: pos[1],\n                            Xprev: NaN,\n                            Yprev: NaN\n                        }\n                    ]\n                };\n                this.mouse.obj = elements[elements.length - 1];\n\n                this.dehighlightAll();\n                this.mouse.obj.highlight(true);\n\n                this.mouse.targets[0].Xstart = [];\n                this.mouse.targets[0].Ystart = [];\n                this.mouse.targets[0].Zstart = [];\n\n                this.saveStartPos(this.mouse.obj, this.mouse.targets[0]);\n\n                // prevent accidental text selection\n                // this could get us new trouble: input fields, links and drop down boxes placed as text\n                // on the board don't work anymore.\n                if (evt && evt.preventDefault) {\n                    evt.preventDefault();\n                } else if (window.event) {\n                    window.event.returnValue = false;\n                }\n            }\n\n            if (this.mode === this.BOARD_MODE_NONE) {\n                result = this.mouseOriginMoveStart(evt);\n            }\n\n            this.triggerEventHandlers([\"mousedown\", \"down\"], [evt]);\n\n            return result;\n        },\n\n        /**\n         * This method is called by the browser when the mouse is moved.\n         * @param {Event} evt The browsers event object.\n         */\n        mouseMoveListener: function (evt) {\n            var pos;\n\n            if (!this.checkFrameRate(evt)) {\n                return false;\n            }\n\n            pos = this.getMousePosition(evt);\n\n            this.updateQuality = this.BOARD_QUALITY_LOW;\n\n            if (this.mode !== this.BOARD_MODE_DRAG) {\n                this.dehighlightAll();\n                this.displayInfobox(false);\n            }\n\n            // we have to check for four cases:\n            //   * user moves origin\n            //   * user drags an object\n            //   * user just moves the mouse, here highlight all elements at\n            //     the current mouse position\n            //   * the user is selecting\n\n            // selection\n            if (this.selectingMode) {\n                this._moveSelecting(pos);\n                this.triggerEventHandlers(\n                    [\"mousemoveselecting\", \"moveselecting\"],\n                    [evt, this.mode]\n                );\n            } else if (!this.mouseOriginMove(evt)) {\n                if (this.mode === this.BOARD_MODE_DRAG) {\n                    this.moveObject(pos[0], pos[1], this.mouse, evt, \"mouse\");\n                } else {\n                    // BOARD_MODE_NONE\n                    // Move event without dragging an element\n                    this.highlightElements(pos[0], pos[1], evt, -1);\n                }\n                this.triggerEventHandlers([\"mousemove\", \"move\"], [evt, this.mode]);\n            }\n            this.updateQuality = this.BOARD_QUALITY_HIGH;\n        },\n\n        /**\n         * This method is called by the browser when the mouse button is released.\n         * @param {Event} evt\n         */\n        mouseUpListener: function (evt) {\n            var i;\n\n            if (this.selectingMode === false) {\n                this.triggerEventHandlers([\"mouseup\", \"up\"], [evt]);\n            }\n\n            // redraw with high precision\n            this.updateQuality = this.BOARD_QUALITY_HIGH;\n\n            if (this.mouse && this.mouse.obj) {\n                if (!Type.exists(this.mouse.obj.coords)) {\n                    // snapTo methods have to be called e.g. for line elements here.\n                    // For coordsElements there might be a conflict with\n                    // attractors, see commit from 2022.04.08, 11:12:18.\n                    // The parameter is needed for lines with snapToGrid enabled\n                    this.mouse.obj.snapToGrid(this.mouse.targets[0]);\n                    this.mouse.obj.snapToPoints();\n                }\n            }\n\n            this.originMoveEnd();\n            this.dehighlightAll();\n            this.update();\n\n            // selection\n            if (this.selectingMode) {\n                this._stopSelecting(evt);\n                this.triggerEventHandlers([\"mousestopselecting\", \"stopselecting\"], [evt]);\n                this.stopSelectionMode();\n            } else {\n                for (i = 0; i < this.downObjects.length; i++) {\n                    this.downObjects[i].triggerEventHandlers([\"mouseup\", \"up\"], [evt]);\n                }\n            }\n\n            this.downObjects.length = 0;\n\n            if (this.hasMouseUp) {\n                Env.removeEvent(this.document, \"mouseup\", this.mouseUpListener, this);\n                this.hasMouseUp = false;\n            }\n\n            // release dragged mouse object\n            /** @ignore */\n            this.mouse = null;\n        },\n\n        /**\n         * Handler for mouse wheel events. Used to zoom in and out of the board.\n         * @param {Event} evt\n         * @returns {Boolean}\n         */\n        mouseWheelListener: function (evt) {\n            if (!this.attr.zoom.wheel || !this._isRequiredKeyPressed(evt, \"zoom\")) {\n                return true;\n            }\n\n            evt = evt || window.event;\n            var wd = evt.detail ? -evt.detail : evt.wheelDelta / 40,\n                pos = new Coords(Const.COORDS_BY_SCREEN, this.getMousePosition(evt), this);\n\n            if (wd > 0) {\n                this.zoomIn(pos.usrCoords[1], pos.usrCoords[2]);\n            } else {\n                this.zoomOut(pos.usrCoords[1], pos.usrCoords[2]);\n            }\n\n            this.triggerEventHandlers([\"mousewheel\"], [evt]);\n\n            evt.preventDefault();\n            return false;\n        },\n\n        /**\n         * Allow moving of JSXGraph elements with arrow keys.\n         * The selection of the element is done with the tab key. For this,\n         * the attribute \"tabindex\" of the element has to be set to some number (default=0).\n         * tabindex corresponds to the HTML attribute of the same name.\n         * <p>\n         * Panning of the construction is done with arrow keys\n         * if the pan key (shift or ctrl - depending on the board attributes) is pressed.\n         * <p>\n         * Zooming is triggered with the keys +, o, -, if\n         * the pan key (shift or ctrl - depending on the board attributes) is pressed.\n         * <p>\n         * Keyboard control (move, pan, and zoom) is disabled if an HTML element of type input or textarea has received focus.\n         *\n         * @param  {Event} evt The browser's event object\n         *\n         * @see JXG.Board#keyboard\n         * @see JXG.Board#keyFocusInListener\n         * @see JXG.Board#keyFocusOutListener\n         *\n         */\n        keyDownListener: function (evt) {\n            var id_node = evt.target.id,\n                id,\n                el,\n                res,\n                doc,\n                sX = 0,\n                sY = 0,\n                // dx, dy are provided in screen units and\n                // are converted to user coordinates\n                dx = Type.evaluate(this.attr.keyboard.dx) / this.unitX,\n                dy = Type.evaluate(this.attr.keyboard.dy) / this.unitY,\n                doZoom = false,\n                done = true,\n                dir,\n                actPos;\n\n            if (!this.attr.keyboard.enabled || id_node === \"\") {\n                return false;\n            }\n\n            // An element of type input or textarea has foxus, get out of here.\n            doc = this.containerObj.shadowRoot || document;\n            if (doc.activeElement) {\n                el = doc.activeElement;\n                if (el.tagName === \"INPUT\" || el.tagName === \"textarea\") {\n                    return false;\n                }\n            }\n\n            // Get the JSXGraph id from the id of the SVG node.\n            id = id_node.replace(this.containerObj.id + \"_\", \"\");\n            el = this.select(id);\n\n            if (Type.exists(el.coords)) {\n                actPos = el.coords.usrCoords.slice(1);\n            }\n\n            if (\n                (Type.evaluate(this.attr.keyboard.panshift) && evt.shiftKey) ||\n                (Type.evaluate(this.attr.keyboard.panctrl) && evt.ctrlKey)\n            ) {\n                // Pan key has been pressed\n\n                if (Type.evaluate(this.attr.zoom.enabled) === true) {\n                    doZoom = true;\n                }\n\n                // Arrow keys\n                if (evt.keyCode === 38) {\n                    // up\n                    this.clickUpArrow();\n                } else if (evt.keyCode === 40) {\n                    // down\n                    this.clickDownArrow();\n                } else if (evt.keyCode === 37) {\n                    // left\n                    this.clickLeftArrow();\n                } else if (evt.keyCode === 39) {\n                    // right\n                    this.clickRightArrow();\n\n                    // Zoom keys\n                } else if (doZoom && evt.keyCode === 171) {\n                    // +\n                    this.zoomIn();\n                } else if (doZoom && evt.keyCode === 173) {\n                    // -\n                    this.zoomOut();\n                } else if (doZoom && evt.keyCode === 79) {\n                    // o\n                    this.zoom100();\n                } else {\n                    done = false;\n                }\n            } else {\n                // Adapt dx, dy to snapToGrid and attractToGrid\n                // snapToGrid has priority.\n                if (Type.exists(el.visProp)) {\n                    if (\n                        Type.exists(el.visProp.snaptogrid) &&\n                        el.visProp.snaptogrid &&\n                        Type.evaluate(el.visProp.snapsizex) &&\n                        Type.evaluate(el.visProp.snapsizey)\n                    ) {\n                        // Adapt dx, dy such that snapToGrid is possible\n                        res = el.getSnapSizes();\n                        sX = res[0];\n                        sY = res[1];\n                        dx = Math.max(sX, dx);\n                        dy = Math.max(sY, dy);\n                    } else if (\n                        Type.exists(el.visProp.attracttogrid) &&\n                        el.visProp.attracttogrid &&\n                        Type.evaluate(el.visProp.attractordistance) &&\n                        Type.evaluate(el.visProp.attractorunit)\n                    ) {\n                        // Adapt dx, dy such that attractToGrid is possible\n                        sX = 1.1 * Type.evaluate(el.visProp.attractordistance);\n                        sY = sX;\n\n                        if (Type.evaluate(el.visProp.attractorunit) === \"screen\") {\n                            sX /= this.unitX;\n                            sY /= this.unitX;\n                        }\n                        dx = Math.max(sX, dx);\n                        dy = Math.max(sY, dy);\n                    }\n                }\n\n                if (evt.keyCode === 38) {\n                    // up\n                    dir = [0, dy];\n                } else if (evt.keyCode === 40) {\n                    // down\n                    dir = [0, -dy];\n                } else if (evt.keyCode === 37) {\n                    // left\n                    dir = [-dx, 0];\n                } else if (evt.keyCode === 39) {\n                    // right\n                    dir = [dx, 0];\n                } else {\n                    done = false;\n                }\n\n                if (dir && el.isDraggable &&\n                        el.visPropCalc.visible &&\n                        ((this.geonextCompatibilityMode &&\n                            (Type.isPoint(el) ||\n                            el.elementClass === Const.OBJECT_CLASS_TEXT)\n                        ) || !this.geonextCompatibilityMode) &&\n                        !Type.evaluate(el.visProp.fixed)\n                    ) {\n\n                    this.mode = this.BOARD_MODE_DRAG;\n                    if (Type.exists(el.coords)) {\n                        dir[0] += actPos[0];\n                        dir[1] += actPos[1];\n                    }\n                    // For coordsElement setPosition has to call setPositionDirectly.\n                    // Otherwise the position is set by a translation.\n                    el.setPosition(JXG.COORDS_BY_USER, dir);\n                    if (Type.exists(el.coords)) {\n                        this.updateInfobox(el);\n                    }\n                    this.triggerEventHandlers(['keymove', 'move'], [evt, this.mode]);\n                    el.triggerEventHandlers(['keydrag', 'drag'], [evt]);\n                    this.mode = this.BOARD_MODE_NONE;\n                }\n            }\n\n            this.update();\n\n            if (done && Type.exists(evt.preventDefault)) {\n                evt.preventDefault();\n            }\n            return done;\n        },\n\n        /**\n         * Event listener for SVG elements getting focus.\n         * This is needed for highlighting when using keyboard control.\n         * Only elements having the attribute \"tabindex\" can receive focus.\n         *\n         * @see JXG.Board#keyFocusOutListener\n         * @see JXG.Board#keyDownListener\n         * @see JXG.Board#keyboard\n         *\n         * @param  {Event} evt The browser's event object\n         */\n        keyFocusInListener: function (evt) {\n            var id_node = evt.target.id,\n                id,\n                el;\n\n            if (!this.attr.keyboard.enabled || id_node === \"\") {\n                return false;\n            }\n\n            id = id_node.replace(this.containerObj.id + \"_\", \"\");\n            el = this.select(id);\n            if (Type.exists(el.highlight)) {\n                el.highlight(true);\n                el.triggerEventHandlers(['hit'], [evt]);\n            }\n            if (Type.exists(el.coords)) {\n                this.updateInfobox(el);\n            }\n        },\n\n        /**\n         * Event listener for SVG elements losing focus.\n         * This is needed for dehighlighting when using keyboard control.\n         * Only elements having the attribute \"tabindex\" can receive focus.\n         *\n         * @see JXG.Board#keyFocusInListener\n         * @see JXG.Board#keyDownListener\n         * @see JXG.Board#keyboard\n         *\n         * @param  {Event} evt The browser's event object\n         */\n        keyFocusOutListener: function (evt) {\n            if (!this.attr.keyboard.enabled) {\n                return false;\n            }\n            // var id_node = evt.target.id,\n            //     id, el;\n\n            // id = id_node.replace(this.containerObj.id + '_', '');\n            // el = this.select(id);\n            this.dehighlightAll();\n            this.displayInfobox(false);\n        },\n\n        /**\n         * Update the width and height of the JSXGraph container div element.\n         * Read actual values with getBoundingClientRect(),\n         * and call board.resizeContainer() with this values.\n         * <p>\n         * If necessary, also call setBoundingBox().\n         *\n         * @see JXG.Board#startResizeObserver\n         * @see JXG.Board#resizeListener\n         * @see JXG.Board#resizeContainer\n         * @see JXG.Board#setBoundingBox\n         *\n         */\n        updateContainerDims: function() {\n            var w, h,\n                bb, css,\n                width_adjustment, height_adjustment;\n\n            // Get size of the board's container div\n            bb = this.containerObj.getBoundingClientRect();\n            w = bb.width;\n            h = bb.height;\n\n            // Subtract the border size\n            if (window && window.getComputedStyle) {\n                css = window.getComputedStyle(this.containerObj, null);\n                width_adjustment = parseFloat(css.getPropertyValue('border-left-width')) + parseFloat(css.getPropertyValue('border-right-width'));\n                if(!isNaN(width_adjustment)) {\n                    w -= width_adjustment;\n                }\n                height_adjustment = parseFloat(css.getPropertyValue('border-top-width'))  + parseFloat(css.getPropertyValue('border-bottom-width'));\n                if(!isNaN(height_adjustment)) {\n                    h -= height_adjustment;\n                }\n            }\n\n            // If div is invisible - do nothing\n            if (w <= 0 || h <= 0 || isNaN(w) || isNaN(h)) {\n                return;\n            }\n\n            // If bounding box is not yet initialized, do it now.\n            if (isNaN(this.getBoundingBox()[0])) {\n                this.setBoundingBox(this.attr.boundingbox, this.keepaspectratio, \"keep\");\n            }\n\n            // Do nothing if the dimension did not change since being visible\n            // the last time. Note that if the div had display:none in the mean time,\n            // we did not store this._prevDim.\n            if (Type.exists(this._prevDim) && this._prevDim.w === w && this._prevDim.h === h) {\n                return;\n            }\n\n            // Set the size of the SVG or canvas element\n            this.resizeContainer(w, h, true);\n            this._prevDim = {\n                w: w,\n                h: h\n            };\n        },\n\n        /**\n         * Start observer which reacts to size changes of the JSXGraph\n         * container div element. Calls updateContainerDims().\n         * If not available, an event listener for the window-resize event is started.\n         * On mobile devices also scrolling might trigger resizes.\n         * However, resize events triggered by scrolling events should be ignored.\n         * Therefore, also a scrollListener is started.\n         * Resize can be controlled with the board attribute resize.\n         *\n         * @see JXG.Board#updateContainerDims\n         * @see JXG.Board#resizeListener\n         * @see JXG.Board#scrollListener\n         * @see JXG.Board#resize\n         *\n         */\n        startResizeObserver: function () {\n            var that = this;\n\n            if (!Env.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {\n                return;\n            }\n\n            this.resizeObserver = new ResizeObserver(function (entries) {\n                if (!that._isResizing) {\n                    that._isResizing = true;\n                    window.setTimeout(function () {\n                        try {\n                            that.updateContainerDims();\n                        } catch (err) {\n                            that.stopResizeObserver();\n                        } finally {\n                            that._isResizing = false;\n                        }\n                    }, that.attr.resize.throttle);\n                }\n            });\n            this.resizeObserver.observe(this.containerObj);\n        },\n\n        /**\n         * Stops the resize observer.\n         * @see JXG.Board#startResizeObserver\n         *\n         */\n        stopResizeObserver: function () {\n            if (!Env.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {\n                return;\n            }\n\n            if (Type.exists(this.resizeObserver)) {\n                this.resizeObserver.unobserve(this.containerObj);\n            }\n        },\n\n        /**\n         * Fallback solutions if there is no resizeObserver available in the browser.\n         * Reacts to resize events of the window (only). Otherwise similar to\n         * startResizeObserver(). To handle changes of the visibility\n         * of the JSXGraph container element, additionally an intersection observer is used.\n         * which watches changes in the visibility of the JSXGraph container element.\n         * This is necessary e.g. for register tabs or dia shows.\n         *\n         * @see JXG.Board#startResizeObserver\n         * @see JXG.Board#startIntersectionObserver\n         */\n        resizeListener: function () {\n            var that = this;\n\n            if (!Env.isBrowser || !this.attr.resize || !this.attr.resize.enabled) {\n                return;\n            }\n            if (!this._isScrolling && !this._isResizing) {\n                this._isResizing = true;\n                window.setTimeout(function () {\n                    that.updateContainerDims();\n                    that._isResizing = false;\n                }, this.attr.resize.throttle);\n            }\n        },\n\n        /**\n         * Listener to watch for scroll events. Sets board._isScrolling = true\n         * @param  {Event} evt The browser's event object\n         *\n         * @see JXG.Board#startResizeObserver\n         * @see JXG.Board#resizeListener\n         *\n         */\n        scrollListener: function (evt) {\n            var that = this;\n\n            if (!Env.isBrowser) {\n                return;\n            }\n            if (!this._isScrolling) {\n                this._isScrolling = true;\n                window.setTimeout(function () {\n                    that._isScrolling = false;\n                }, 66);\n            }\n        },\n\n        /**\n         * Watch for changes of the visibility of the JSXGraph container element.\n         *\n         * @see JXG.Board#startResizeObserver\n         * @see JXG.Board#resizeListener\n         *\n         */\n        startIntersectionObserver: function () {\n            var that = this,\n                options = {\n                    root: null,\n                    rootMargin: \"0px\",\n                    threshold: 0.8\n                };\n\n            try {\n                this.intersectionObserver = new IntersectionObserver(function (entries) {\n                    // If bounding box is not yet initialized, do it now.\n                    if (isNaN(that.getBoundingBox()[0])) {\n                        that.updateContainerDims();\n                    }\n                }, options);\n                this.intersectionObserver.observe(that.containerObj);\n            } catch (err) {\n                console.log(\"JSXGraph: IntersectionObserver not available in this browser.\");\n            }\n        },\n\n        /**\n         * Stop the intersection observer\n         *\n         * @see JXG.Board#startIntersectionObserver\n         *\n         */\n        stopIntersectionObserver: function () {\n            if (Type.exists(this.intersectionObserver)) {\n                this.intersectionObserver.unobserve(this.containerObj);\n            }\n        },\n\n        /**********************************************************\n         *\n         * End of Event Handlers\n         *\n         **********************************************************/\n\n        /**\n         * Initialize the info box object which is used to display\n         * the coordinates of points near the mouse pointer,\n         * @returns {JXG.Board} Reference to the board\n         */\n        initInfobox: function () {\n            var attr = Type.copyAttributes({}, this.options, \"infobox\");\n\n            attr.id = this.id + \"_infobox\";\n            /**\n             * Infobox close to points in which the points' coordinates are displayed.\n             * This is simply a JXG.Text element. Access through board.infobox.\n             * Uses CSS class .JXGinfobox.\n             * @type JXG.Text\n             *\n             */\n            this.infobox = this.create(\"text\", [0, 0, \"0,0\"], attr);\n\n            this.infobox.distanceX = -20;\n            this.infobox.distanceY = 25;\n            // this.infobox.needsUpdateSize = false;  // That is not true, but it speeds drawing up.\n\n            this.infobox.dump = false;\n\n            this.displayInfobox(false);\n            return this;\n        },\n\n        /**\n         * Updates and displays a little info box to show coordinates of current selected points.\n         * @param {JXG.GeometryElement} el A GeometryElement\n         * @returns {JXG.Board} Reference to the board\n         * @see JXG.Board#displayInfobox\n         * @see JXG.Board#showInfobox\n         * @see Point#showInfobox\n         *\n         */\n        updateInfobox: function (el) {\n            var x,\n                y,\n                xc,\n                yc,\n                vpinfoboxdigits,\n                vpsi = Type.evaluate(el.visProp.showinfobox);\n\n            if ((!Type.evaluate(this.attr.showinfobox) && vpsi === \"inherit\") || !vpsi) {\n                return this;\n            }\n\n            if (Type.isPoint(el)) {\n                xc = el.coords.usrCoords[1];\n                yc = el.coords.usrCoords[2];\n\n                vpinfoboxdigits = Type.evaluate(el.visProp.infoboxdigits);\n                this.infobox.setCoords(\n                    xc + this.infobox.distanceX / this.unitX,\n                    yc + this.infobox.distanceY / this.unitY\n                );\n\n                if (typeof el.infoboxText !== \"string\") {\n                    if (vpinfoboxdigits === \"auto\") {\n                        x = Type.autoDigits(xc);\n                        y = Type.autoDigits(yc);\n                    } else if (Type.isNumber(vpinfoboxdigits)) {\n                        x = Type.toFixed(xc, vpinfoboxdigits);\n                        y = Type.toFixed(yc, vpinfoboxdigits);\n                    } else {\n                        x = xc;\n                        y = yc;\n                    }\n\n                    this.highlightInfobox(x, y, el);\n                } else {\n                    this.highlightCustomInfobox(el.infoboxText, el);\n                }\n\n                this.displayInfobox(true);\n            }\n            return this;\n        },\n\n        /**\n         * Set infobox visible / invisible.\n         *\n         * It uses its property hiddenByParent to memorize its status.\n         * In this way, many DOM access can be avoided.\n         *\n         * @param  {Boolean} val true for visible, false for invisible\n         * @returns {JXG.Board} Reference to the board.\n         * @see JXG.Board#updateInfobox\n         *\n         */\n        displayInfobox: function (val) {\n            if (this.infobox.hiddenByParent === val) {\n                this.infobox.hiddenByParent = !val;\n                this.infobox.prepareUpdate().updateVisibility(val).updateRenderer();\n            }\n            return this;\n        },\n\n        // Alias for displayInfobox to be backwards compatible.\n        // The method showInfobox clashes with the board attribute showInfobox\n        showInfobox: function (val) {\n            return this.displayInfobox(val);\n        },\n\n        /**\n         * Changes the text of the info box to show the given coordinates.\n         * @param {Number} x\n         * @param {Number} y\n         * @param {JXG.GeometryElement} [el] The element the mouse is pointing at\n         * @returns {JXG.Board} Reference to the board.\n         */\n        highlightInfobox: function (x, y, el) {\n            this.highlightCustomInfobox(\"(\" + x + \", \" + y + \")\", el);\n            return this;\n        },\n\n        /**\n         * Changes the text of the info box to what is provided via text.\n         * @param {String} text\n         * @param {JXG.GeometryElement} [el]\n         * @returns {JXG.Board} Reference to the board.\n         */\n        highlightCustomInfobox: function (text, el) {\n            this.infobox.setText(text);\n            return this;\n        },\n\n        /**\n         * Remove highlighting of all elements.\n         * @returns {JXG.Board} Reference to the board.\n         */\n        dehighlightAll: function () {\n            var el,\n                pEl,\n                needsDehighlight = false;\n\n            for (el in this.highlightedObjects) {\n                if (this.highlightedObjects.hasOwnProperty(el)) {\n                    pEl = this.highlightedObjects[el];\n\n                    if (this.hasMouseHandlers || this.hasPointerHandlers) {\n                        pEl.noHighlight();\n                    }\n\n                    needsDehighlight = true;\n\n                    // In highlightedObjects should only be objects which fulfill all these conditions\n                    // And in case of complex elements, like a turtle based fractal, it should be faster to\n                    // just de-highlight the element instead of checking hasPoint...\n                    // if ((!Type.exists(pEl.hasPoint)) || !pEl.hasPoint(x, y) || !pEl.visPropCalc.visible)\n                }\n            }\n\n            this.highlightedObjects = {};\n\n            // We do not need to redraw during dehighlighting in CanvasRenderer\n            // because we are redrawing anyhow\n            //  -- We do need to redraw during dehighlighting. Otherwise objects won't be dehighlighted until\n            // another object is highlighted.\n            if (this.renderer.type === \"canvas\" && needsDehighlight) {\n                this.prepareUpdate();\n                this.renderer.suspendRedraw(this);\n                this.updateRenderer();\n                this.renderer.unsuspendRedraw();\n            }\n\n            return this;\n        },\n\n        /**\n         * Returns the input parameters in an array. This method looks pointless and it really is, but it had a purpose\n         * once.\n         * @private\n         * @param {Number} x X coordinate in screen coordinates\n         * @param {Number} y Y coordinate in screen coordinates\n         * @returns {Array} Coordinates [x, y] of the mouse in screen coordinates.\n         * @see JXG.Board#getUsrCoordsOfMouse\n         */\n        getScrCoordsOfMouse: function (x, y) {\n            return [x, y];\n        },\n\n        /**\n         * This method calculates the user coords of the current mouse coordinates.\n         * @param {Event} evt Event object containing the mouse coordinates.\n         * @returns {Array} Coordinates [x, y] of the mouse in user coordinates.\n         * @example\n         * board.on('up', function (evt) {\n         *         var a = board.getUsrCoordsOfMouse(evt),\n         *             x = a[0],\n         *             y = a[1],\n         *             somePoint = board.create('point', [x,y], {name:'SomePoint',size:4});\n         *             // Shorter version:\n         *             //somePoint = board.create('point', a, {name:'SomePoint',size:4});\n         *         });\n         *\n         * </pre><div id=\"JXG48d5066b-16ba-4920-b8ea-a4f8eff6b746\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG48d5066b-16ba-4920-b8ea-a4f8eff6b746',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     board.on('up', function (evt) {\n         *             var a = board.getUsrCoordsOfMouse(evt),\n         *                 x = a[0],\n         *                 y = a[1],\n         *                 somePoint = board.create('point', [x,y], {name:'SomePoint',size:4});\n         *                 // Shorter version:\n         *                 //somePoint = board.create('point', a, {name:'SomePoint',size:4});\n         *             });\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         * @see JXG.Board#getScrCoordsOfMouse\n         * @see JXG.Board#getAllUnderMouse\n         */\n        getUsrCoordsOfMouse: function (evt) {\n            var cPos = this.getCoordsTopLeftCorner(),\n                absPos = Env.getPosition(evt, null, this.document),\n                x = absPos[0] - cPos[0],\n                y = absPos[1] - cPos[1],\n                newCoords = new Coords(Const.COORDS_BY_SCREEN, [x, y], this);\n\n            return newCoords.usrCoords.slice(1);\n        },\n\n        /**\n         * Collects all elements under current mouse position plus current user coordinates of mouse cursor.\n         * @param {Event} evt Event object containing the mouse coordinates.\n         * @returns {Array} Array of elements at the current mouse position plus current user coordinates of mouse.\n         * @see JXG.Board#getUsrCoordsOfMouse\n         * @see JXG.Board#getAllObjectsUnderMouse\n         */\n        getAllUnderMouse: function (evt) {\n            var elList = this.getAllObjectsUnderMouse(evt);\n            elList.push(this.getUsrCoordsOfMouse(evt));\n\n            return elList;\n        },\n\n        /**\n         * Collects all elements under current mouse position.\n         * @param {Event} evt Event object containing the mouse coordinates.\n         * @returns {Array} Array of elements at the current mouse position.\n         * @see JXG.Board#getAllUnderMouse\n         */\n        getAllObjectsUnderMouse: function (evt) {\n            var cPos = this.getCoordsTopLeftCorner(),\n                absPos = Env.getPosition(evt, null, this.document),\n                dx = absPos[0] - cPos[0],\n                dy = absPos[1] - cPos[1],\n                elList = [],\n                el,\n                pEl,\n                len = this.objectsList.length;\n\n            for (el = 0; el < len; el++) {\n                pEl = this.objectsList[el];\n                if (pEl.visPropCalc.visible && pEl.hasPoint && pEl.hasPoint(dx, dy)) {\n                    elList[elList.length] = pEl;\n                }\n            }\n\n            return elList;\n        },\n\n        /**\n         * Update the coords object of all elements which possess this\n         * property. This is necessary after changing the viewport.\n         * @returns {JXG.Board} Reference to this board.\n         **/\n        updateCoords: function () {\n            var el,\n                ob,\n                len = this.objectsList.length;\n\n            for (ob = 0; ob < len; ob++) {\n                el = this.objectsList[ob];\n\n                if (Type.exists(el.coords)) {\n                    if (Type.evaluate(el.visProp.frozen)) {\n                        el.coords.screen2usr();\n                    } else {\n                        el.coords.usr2screen();\n                    }\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Moves the origin and initializes an update of all elements.\n         * @param {Number} x\n         * @param {Number} y\n         * @param {Boolean} [diff=false]\n         * @returns {JXG.Board} Reference to this board.\n         */\n        moveOrigin: function (x, y, diff) {\n            var ox, oy, ul, lr;\n            if (Type.exists(x) && Type.exists(y)) {\n                ox = this.origin.scrCoords[1];\n                oy = this.origin.scrCoords[2];\n\n                this.origin.scrCoords[1] = x;\n                this.origin.scrCoords[2] = y;\n\n                if (diff) {\n                    this.origin.scrCoords[1] -= this.drag_dx;\n                    this.origin.scrCoords[2] -= this.drag_dy;\n                }\n\n                ul = new Coords(Const.COORDS_BY_SCREEN, [0, 0], this).usrCoords;\n                lr = new Coords(\n                    Const.COORDS_BY_SCREEN,\n                    [this.canvasWidth, this.canvasHeight],\n                    this\n                ).usrCoords;\n                if (\n                    ul[1] < this.maxboundingbox[0] ||\n                    ul[2] > this.maxboundingbox[1] ||\n                    lr[1] > this.maxboundingbox[2] ||\n                    lr[2] < this.maxboundingbox[3]\n                ) {\n                    this.origin.scrCoords[1] = ox;\n                    this.origin.scrCoords[2] = oy;\n                }\n            }\n\n            this.updateCoords().clearTraces().fullUpdate();\n            this.triggerEventHandlers([\"boundingbox\"]);\n\n            return this;\n        },\n\n        /**\n         * Add conditional updates to the elements.\n         * @param {String} str String containing coniditional update in geonext syntax\n         */\n        addConditions: function (str) {\n            var term,\n                m,\n                left,\n                right,\n                name,\n                el,\n                property,\n                functions = [],\n                // plaintext = 'var el, x, y, c, rgbo;\\n',\n                i = str.indexOf(\"<data>\"),\n                j = str.indexOf(\"<\" + \"/data>\"),\n                xyFun = function (board, el, f, what) {\n                    return function () {\n                        var e, t;\n\n                        e = board.select(el.id);\n                        t = e.coords.usrCoords[what];\n\n                        if (what === 2) {\n                            e.setPositionDirectly(Const.COORDS_BY_USER, [f(), t]);\n                        } else {\n                            e.setPositionDirectly(Const.COORDS_BY_USER, [t, f()]);\n                        }\n                        e.prepareUpdate().update();\n                    };\n                },\n                visFun = function (board, el, f) {\n                    return function () {\n                        var e, v;\n\n                        e = board.select(el.id);\n                        v = f();\n\n                        e.setAttribute({ visible: v });\n                    };\n                },\n                colFun = function (board, el, f, what) {\n                    return function () {\n                        var e, v;\n\n                        e = board.select(el.id);\n                        v = f();\n\n                        if (what === \"strokewidth\") {\n                            e.visProp.strokewidth = v;\n                        } else {\n                            v = Color.rgba2rgbo(v);\n                            e.visProp[what + \"color\"] = v[0];\n                            e.visProp[what + \"opacity\"] = v[1];\n                        }\n                    };\n                },\n                posFun = function (board, el, f) {\n                    return function () {\n                        var e = board.select(el.id);\n\n                        e.position = f();\n                    };\n                },\n                styleFun = function (board, el, f) {\n                    return function () {\n                        var e = board.select(el.id);\n\n                        e.setStyle(f());\n                    };\n                };\n\n            if (i < 0) {\n                return;\n            }\n\n            while (i >= 0) {\n                term = str.slice(i + 6, j); // throw away <data>\n                m = term.indexOf(\"=\");\n                left = term.slice(0, m);\n                right = term.slice(m + 1);\n                m = left.indexOf(\".\"); // Dies erzeugt Probleme bei Variablennamen der Form \" Steuern akt.\"\n                name = left.slice(0, m); //.replace(/\\s+$/,''); // do NOT cut out name (with whitespace)\n                el = this.elementsByName[Type.unescapeHTML(name)];\n\n                property = left\n                    .slice(m + 1)\n                    .replace(/\\s+/g, \"\")\n                    .toLowerCase(); // remove whitespace in property\n                right = Type.createFunction(right, this, \"\", true);\n\n                // Debug\n                if (!Type.exists(this.elementsByName[name])) {\n                    JXG.debug(\"debug conditions: |\" + name + \"| undefined\");\n                } else {\n                    // plaintext += \"el = this.objects[\\\"\" + el.id + \"\\\"];\\n\";\n\n                    switch (property) {\n                        case \"x\":\n                            functions.push(xyFun(this, el, right, 2));\n                            break;\n                        case \"y\":\n                            functions.push(xyFun(this, el, right, 1));\n                            break;\n                        case \"visible\":\n                            functions.push(visFun(this, el, right));\n                            break;\n                        case \"position\":\n                            functions.push(posFun(this, el, right));\n                            break;\n                        case \"stroke\":\n                            functions.push(colFun(this, el, right, \"stroke\"));\n                            break;\n                        case \"style\":\n                            functions.push(styleFun(this, el, right));\n                            break;\n                        case \"strokewidth\":\n                            functions.push(colFun(this, el, right, \"strokewidth\"));\n                            break;\n                        case \"fill\":\n                            functions.push(colFun(this, el, right, \"fill\"));\n                            break;\n                        case \"label\":\n                            break;\n                        default:\n                            JXG.debug(\n                                \"property '\" +\n                                    property +\n                                    \"' in conditions not yet implemented:\" +\n                                    right\n                            );\n                            break;\n                    }\n                }\n                str = str.slice(j + 7); // cut off \"</data>\"\n                i = str.indexOf(\"<data>\");\n                j = str.indexOf(\"<\" + \"/data>\");\n            }\n\n            this.updateConditions = function () {\n                var i;\n\n                for (i = 0; i < functions.length; i++) {\n                    functions[i]();\n                }\n\n                this.prepareUpdate().updateElements();\n                return true;\n            };\n            this.updateConditions();\n        },\n\n        /**\n         * Computes the commands in the conditions-section of the gxt file.\n         * It is evaluated after an update, before the unsuspendRedraw.\n         * The function is generated in\n         * @see JXG.Board#addConditions\n         * @private\n         */\n        updateConditions: function () {\n            return false;\n        },\n\n        /**\n         * Calculates adequate snap sizes.\n         * @returns {JXG.Board} Reference to the board.\n         */\n        calculateSnapSizes: function () {\n            var p1 = new Coords(Const.COORDS_BY_USER, [0, 0], this),\n                p2 = new Coords(\n                    Const.COORDS_BY_USER,\n                    [this.options.grid.gridX, this.options.grid.gridY],\n                    this\n                ),\n                x = p1.scrCoords[1] - p2.scrCoords[1],\n                y = p1.scrCoords[2] - p2.scrCoords[2];\n\n            this.options.grid.snapSizeX = this.options.grid.gridX;\n            while (Math.abs(x) > 25) {\n                this.options.grid.snapSizeX *= 2;\n                x /= 2;\n            }\n\n            this.options.grid.snapSizeY = this.options.grid.gridY;\n            while (Math.abs(y) > 25) {\n                this.options.grid.snapSizeY *= 2;\n                y /= 2;\n            }\n\n            return this;\n        },\n\n        /**\n         * Apply update on all objects with the new zoom-factors. Clears all traces.\n         * @returns {JXG.Board} Reference to the board.\n         */\n        applyZoom: function () {\n            this.updateCoords().calculateSnapSizes().clearTraces().fullUpdate();\n\n            return this;\n        },\n\n        /**\n         * Zooms into the board by the factors board.attr.zoom.factorX and board.attr.zoom.factorY and applies the zoom.\n         * The zoom operation is centered at x, y.\n         * @param {Number} [x]\n         * @param {Number} [y]\n         * @returns {JXG.Board} Reference to the board\n         */\n        zoomIn: function (x, y) {\n            var bb = this.getBoundingBox(),\n                zX = this.attr.zoom.factorx,\n                zY = this.attr.zoom.factory,\n                dX = (bb[2] - bb[0]) * (1.0 - 1.0 / zX),\n                dY = (bb[1] - bb[3]) * (1.0 - 1.0 / zY),\n                lr = 0.5,\n                tr = 0.5,\n                mi = this.attr.zoom.eps || this.attr.zoom.min || 0.001; // this.attr.zoom.eps is deprecated\n\n            if (\n                (this.zoomX > this.attr.zoom.max && zX > 1.0) ||\n                (this.zoomY > this.attr.zoom.max && zY > 1.0) ||\n                (this.zoomX < mi && zX < 1.0) || // zoomIn is used for all zooms on touch devices\n                (this.zoomY < mi && zY < 1.0)\n            ) {\n                return this;\n            }\n\n            if (Type.isNumber(x) && Type.isNumber(y)) {\n                lr = (x - bb[0]) / (bb[2] - bb[0]);\n                tr = (bb[1] - y) / (bb[1] - bb[3]);\n            }\n\n            this.setBoundingBox(\n                [\n                    bb[0] + dX * lr,\n                    bb[1] - dY * tr,\n                    bb[2] - dX * (1 - lr),\n                    bb[3] + dY * (1 - tr)\n                ],\n                this.keepaspectratio,\n                \"update\"\n            );\n            return this.applyZoom();\n        },\n\n        /**\n         * Zooms out of the board by the factors board.attr.zoom.factorX and board.attr.zoom.factorY and applies the zoom.\n         * The zoom operation is centered at x, y.\n         *\n         * @param {Number} [x]\n         * @param {Number} [y]\n         * @returns {JXG.Board} Reference to the board\n         */\n        zoomOut: function (x, y) {\n            var bb = this.getBoundingBox(),\n                zX = this.attr.zoom.factorx,\n                zY = this.attr.zoom.factory,\n                dX = (bb[2] - bb[0]) * (1.0 - zX),\n                dY = (bb[1] - bb[3]) * (1.0 - zY),\n                lr = 0.5,\n                tr = 0.5,\n                mi = this.attr.zoom.eps || this.attr.zoom.min || 0.001; // this.attr.zoom.eps is deprecated\n\n            if (this.zoomX < mi || this.zoomY < mi) {\n                return this;\n            }\n\n            if (Type.isNumber(x) && Type.isNumber(y)) {\n                lr = (x - bb[0]) / (bb[2] - bb[0]);\n                tr = (bb[1] - y) / (bb[1] - bb[3]);\n            }\n\n            this.setBoundingBox(\n                [\n                    bb[0] + dX * lr,\n                    bb[1] - dY * tr,\n                    bb[2] - dX * (1 - lr),\n                    bb[3] + dY * (1 - tr)\n                ],\n                this.keepaspectratio,\n                \"update\"\n            );\n\n            return this.applyZoom();\n        },\n\n        /**\n         * Reset the zoom level to the original zoom level from initBoard();\n         * Additionally, if the board as been initialized with a boundingBox (which is the default),\n         * restore the viewport to the original viewport during initialization. Otherwise,\n         * (i.e. if the board as been initialized with unitX/Y and originX/Y),\n         * just set the zoom level to 100%.\n         *\n         * @returns {JXG.Board} Reference to the board\n         */\n        zoom100: function () {\n            var bb, dX, dY;\n\n            if (Type.exists(this.attr.boundingbox)) {\n                this.setBoundingBox(this.attr.boundingbox, this.keepaspectratio, \"reset\");\n            } else {\n                // Board has been set up with unitX/Y and originX/Y\n                bb = this.getBoundingBox();\n                dX = (bb[2] - bb[0]) * (1.0 - this.zoomX) * 0.5;\n                dY = (bb[1] - bb[3]) * (1.0 - this.zoomY) * 0.5;\n                this.setBoundingBox(\n                    [bb[0] + dX, bb[1] - dY, bb[2] - dX, bb[3] + dY],\n                    this.keepaspectratio,\n                    \"reset\"\n                );\n            }\n            return this.applyZoom();\n        },\n\n        /**\n         * Zooms the board so every visible point is shown. Keeps aspect ratio.\n         * @returns {JXG.Board} Reference to the board\n         */\n        zoomAllPoints: function () {\n            var el,\n                border,\n                borderX,\n                borderY,\n                pEl,\n                minX = 0,\n                maxX = 0,\n                minY = 0,\n                maxY = 0,\n                len = this.objectsList.length;\n\n            for (el = 0; el < len; el++) {\n                pEl = this.objectsList[el];\n\n                if (Type.isPoint(pEl) && pEl.visPropCalc.visible) {\n                    if (pEl.coords.usrCoords[1] < minX) {\n                        minX = pEl.coords.usrCoords[1];\n                    } else if (pEl.coords.usrCoords[1] > maxX) {\n                        maxX = pEl.coords.usrCoords[1];\n                    }\n                    if (pEl.coords.usrCoords[2] > maxY) {\n                        maxY = pEl.coords.usrCoords[2];\n                    } else if (pEl.coords.usrCoords[2] < minY) {\n                        minY = pEl.coords.usrCoords[2];\n                    }\n                }\n            }\n\n            border = 50;\n            borderX = border / this.unitX;\n            borderY = border / this.unitY;\n\n            this.setBoundingBox(\n                [minX - borderX, maxY + borderY, maxX + borderX, minY - borderY],\n                this.keepaspectratio,\n                \"update\"\n            );\n\n            return this.applyZoom();\n        },\n\n        /**\n         * Reset the bounding box and the zoom level to 100% such that a given set of elements is\n         * within the board's viewport.\n         * @param {Array} elements A set of elements given by id, reference, or name.\n         * @returns {JXG.Board} Reference to the board.\n         */\n        zoomElements: function (elements) {\n            var i,\n                e,\n                box,\n                newBBox = [Infinity, -Infinity, -Infinity, Infinity],\n                cx,\n                cy,\n                dx,\n                dy,\n                d;\n\n            if (!Type.isArray(elements) || elements.length === 0) {\n                return this;\n            }\n\n            for (i = 0; i < elements.length; i++) {\n                e = this.select(elements[i]);\n\n                box = e.bounds();\n                if (Type.isArray(box)) {\n                    if (box[0] < newBBox[0]) {\n                        newBBox[0] = box[0];\n                    }\n                    if (box[1] > newBBox[1]) {\n                        newBBox[1] = box[1];\n                    }\n                    if (box[2] > newBBox[2]) {\n                        newBBox[2] = box[2];\n                    }\n                    if (box[3] < newBBox[3]) {\n                        newBBox[3] = box[3];\n                    }\n                }\n            }\n\n            if (Type.isArray(newBBox)) {\n                cx = 0.5 * (newBBox[0] + newBBox[2]);\n                cy = 0.5 * (newBBox[1] + newBBox[3]);\n                dx = 1.5 * (newBBox[2] - newBBox[0]) * 0.5;\n                dy = 1.5 * (newBBox[1] - newBBox[3]) * 0.5;\n                d = Math.max(dx, dy);\n                this.setBoundingBox(\n                    [cx - d, cy + d, cx + d, cy - d],\n                    this.keepaspectratio,\n                    \"update\"\n                );\n            }\n\n            return this;\n        },\n\n        /**\n         * Sets the zoom level to <tt>fX</tt> resp <tt>fY</tt>.\n         * @param {Number} fX\n         * @param {Number} fY\n         * @returns {JXG.Board} Reference to the board.\n         */\n        setZoom: function (fX, fY) {\n            var oX = this.attr.zoom.factorx,\n                oY = this.attr.zoom.factory;\n\n            this.attr.zoom.factorx = fX / this.zoomX;\n            this.attr.zoom.factory = fY / this.zoomY;\n\n            this.zoomIn();\n\n            this.attr.zoom.factorx = oX;\n            this.attr.zoom.factory = oY;\n\n            return this;\n        },\n\n        /**\n         * Removes object from board and renderer.\n         * <p>\n         * <b>Performance hints:</b> It is recommended to use the object's id.\n         * If many elements are removed, it is best to call <tt>board.suspendUpdate()</tt>\n         * before looping through the elements to be removed and call\n         * <tt>board.unsuspendUpdate()</tt> after the loop. Further, it is advisable to loop\n         * in reverse order, i.e. remove the object in reverse order of their creation time.\n         *\n         * @param {JXG.GeometryElement|Array} object The object to remove or array of objects to be removed.\n         * The element(s) is/are given by name, id or a reference.\n         * @param {Boolean} saveMethod If true, the algorithm runs through all elements\n         * and tests if the element to be deleted is a child element. If yes, it will be\n         * removed from the list of child elements. If false (default), the element\n         * is removed from the lists of child elements of all its ancestors.\n         * This should be much faster.\n         * @returns {JXG.Board} Reference to the board\n         */\n        removeObject: function (object, saveMethod) {\n            var el, i;\n\n            if (Type.isArray(object)) {\n                for (i = 0; i < object.length; i++) {\n                    this.removeObject(object[i]);\n                }\n\n                return this;\n            }\n\n            object = this.select(object);\n\n            // If the object which is about to be removed unknown or a string, do nothing.\n            // it is a string if a string was given and could not be resolved to an element.\n            if (!Type.exists(object) || Type.isString(object)) {\n                return this;\n            }\n\n            try {\n                // remove all children.\n                for (el in object.childElements) {\n                    if (object.childElements.hasOwnProperty(el)) {\n                        object.childElements[el].board.removeObject(object.childElements[el]);\n                    }\n                }\n\n                // Remove all children in elements like turtle\n                for (el in object.objects) {\n                    if (object.objects.hasOwnProperty(el)) {\n                        object.objects[el].board.removeObject(object.objects[el]);\n                    }\n                }\n\n                // Remove the element from the childElement list and the descendant list of all elements.\n                if (saveMethod) {\n                    // Running through all objects has quadratic complexity if many objects are deleted.\n                    for (el in this.objects) {\n                        if (this.objects.hasOwnProperty(el)) {\n                            if (\n                                Type.exists(this.objects[el].childElements) &&\n                                Type.exists(\n                                    this.objects[el].childElements.hasOwnProperty(object.id)\n                                )\n                            ) {\n                                delete this.objects[el].childElements[object.id];\n                                delete this.objects[el].descendants[object.id];\n                            }\n                        }\n                    }\n                } else if (Type.exists(object.ancestors)) {\n                    // Running through the ancestors should be much more efficient.\n                    for (el in object.ancestors) {\n                        if (object.ancestors.hasOwnProperty(el)) {\n                            if (\n                                Type.exists(object.ancestors[el].childElements) &&\n                                Type.exists(\n                                    object.ancestors[el].childElements.hasOwnProperty(object.id)\n                                )\n                            ) {\n                                delete object.ancestors[el].childElements[object.id];\n                                delete object.ancestors[el].descendants[object.id];\n                            }\n                        }\n                    }\n                }\n\n                // remove the object itself from our control structures\n                if (object._pos > -1) {\n                    this.objectsList.splice(object._pos, 1);\n                    for (el = object._pos; el < this.objectsList.length; el++) {\n                        this.objectsList[el]._pos--;\n                    }\n                } else if (object.type !== Const.OBJECT_TYPE_TURTLE) {\n                    JXG.debug(\n                        \"Board.removeObject: object \" + object.id + \" not found in list.\"\n                    );\n                }\n\n                delete this.objects[object.id];\n                delete this.elementsByName[object.name];\n\n                if (object.visProp && Type.evaluate(object.visProp.trace)) {\n                    object.clearTrace();\n                }\n\n                // the object deletion itself is handled by the object.\n                if (Type.exists(object.remove)) {\n                    object.remove();\n                }\n            } catch (e) {\n                JXG.debug(object.id + \": Could not be removed: \" + e);\n            }\n\n            this.update();\n\n            return this;\n        },\n\n        /**\n         * Removes the ancestors of an object an the object itself from board and renderer.\n         * @param {JXG.GeometryElement} object The object to remove.\n         * @returns {JXG.Board} Reference to the board\n         */\n        removeAncestors: function (object) {\n            var anc;\n\n            for (anc in object.ancestors) {\n                if (object.ancestors.hasOwnProperty(anc)) {\n                    this.removeAncestors(object.ancestors[anc]);\n                }\n            }\n\n            this.removeObject(object);\n\n            return this;\n        },\n\n        /**\n         * Initialize some objects which are contained in every GEONExT construction by default,\n         * but are not contained in the gxt files.\n         * @returns {JXG.Board} Reference to the board\n         */\n        initGeonextBoard: function () {\n            var p1, p2, p3;\n\n            p1 = this.create(\"point\", [0, 0], {\n                id: this.id + \"g00e0\",\n                name: \"Ursprung\",\n                withLabel: false,\n                visible: false,\n                fixed: true\n            });\n\n            p2 = this.create(\"point\", [1, 0], {\n                id: this.id + \"gX0e0\",\n                name: \"Punkt_1_0\",\n                withLabel: false,\n                visible: false,\n                fixed: true\n            });\n\n            p3 = this.create(\"point\", [0, 1], {\n                id: this.id + \"gY0e0\",\n                name: \"Punkt_0_1\",\n                withLabel: false,\n                visible: false,\n                fixed: true\n            });\n\n            this.create(\"line\", [p1, p2], {\n                id: this.id + \"gXLe0\",\n                name: \"X-Achse\",\n                withLabel: false,\n                visible: false\n            });\n\n            this.create(\"line\", [p1, p3], {\n                id: this.id + \"gYLe0\",\n                name: \"Y-Achse\",\n                withLabel: false,\n                visible: false\n            });\n\n            return this;\n        },\n\n        /**\n         * Change the height and width of the board's container.\n         * After doing so, {@link JXG.JSXGraph.setBoundingBox} is called using\n         * the actual size of the bounding box and the actual value of keepaspectratio.\n         * If setBoundingbox() should not be called automatically,\n         * call resizeContainer with dontSetBoundingBox == true.\n         * @param {Number} canvasWidth New width of the container.\n         * @param {Number} canvasHeight New height of the container.\n         * @param {Boolean} [dontset=false] If true do not set the CSS width and height of the DOM element.\n         * @param {Boolean} [dontSetBoundingBox=false] If true do not call setBoundingBox(), but keep view centered around original visible center.\n         * @returns {JXG.Board} Reference to the board\n         */\n        resizeContainer: function (canvasWidth, canvasHeight, dontset, dontSetBoundingBox) {\n            var box,\n                oldWidth, oldHeight,\n                oX, oY;\n                // w, h, cx, cy;\n                // box_act,\n                // shift_x = 0,\n                // shift_y = 0;\n\n            oldWidth = this.canvasWidth;\n            oldHeight = this.canvasHeight;\n\n            if (!dontSetBoundingBox) {\n                // box_act = this.getBoundingBox();\n                box = this.getBoundingBox();    // This is the actual bounding box.\n            }\n\n            this.canvasWidth = parseFloat(canvasWidth);\n            this.canvasHeight = parseFloat(canvasHeight);\n\n            // if (!dontSetBoundingBox) {\n            //     box     = this.attr.boundingbox;    // This is the intended bounding box.\n\n            //     // The shift values compensate the follow-up correction\n            //     // in setBoundingBox in case of \"this.keepaspectratio==true\"\n            //     // Otherwise, shift_x and shift_y will be zero.\n            //     // Obsolet since setBoundingBox centers in case of \"this.keepaspectratio==true\".\n            //     // shift_x = box_act[0] - box[0] / this.zoomX;\n            //     // shift_y = box_act[1] - box[1] / this.zoomY;\n\n            //     cx = (box[2] + box[0]) * 0.5; // + shift_x;\n            //     cy = (box[3] + box[1]) * 0.5; // + shift_y;\n\n            //     w = (box[2] - box[0]) * 0.5 / this.zoomX;\n            //     h = (box[1] - box[3]) * 0.5 / this.zoomY;\n\n            //     box = [cx - w, cy + h, cx + w, cy - h];\n            // }\n\n            if (!dontset) {\n                this.containerObj.style.width = this.canvasWidth + \"px\";\n                this.containerObj.style.height = this.canvasHeight + \"px\";\n            }\n            this.renderer.resize(this.canvasWidth, this.canvasHeight);\n\n            if (!dontSetBoundingBox) {\n                this.setBoundingBox(box, this.keepaspectratio, 'keep');\n            } else {\n                oX = (this.canvasWidth - oldWidth) / 2;\n                oY = (this.canvasHeight - oldHeight) / 2;\n\n                this.moveOrigin(\n                    this.origin.scrCoords[1] + oX,\n                    this.origin.scrCoords[2] + oY\n                );\n            }\n\n            return this;\n        },\n\n        /**\n         * Lists the dependencies graph in a new HTML-window.\n         * @returns {JXG.Board} Reference to the board\n         */\n        showDependencies: function () {\n            var el, t, c, f, i;\n\n            t = \"<p>\\n\";\n            for (el in this.objects) {\n                if (this.objects.hasOwnProperty(el)) {\n                    i = 0;\n                    for (c in this.objects[el].childElements) {\n                        if (this.objects[el].childElements.hasOwnProperty(c)) {\n                            i += 1;\n                        }\n                    }\n                    if (i >= 0) {\n                        t += \"<strong>\" + this.objects[el].id + \":<\" + \"/strong> \";\n                    }\n\n                    for (c in this.objects[el].childElements) {\n                        if (this.objects[el].childElements.hasOwnProperty(c)) {\n                            t +=\n                                this.objects[el].childElements[c].id +\n                                \"(\" +\n                                this.objects[el].childElements[c].name +\n                                \")\" +\n                                \", \";\n                        }\n                    }\n                    t += \"<p>\\n\";\n                }\n            }\n            t += \"<\" + \"/p>\\n\";\n            f = window.open();\n            f.document.open();\n            f.document.write(t);\n            f.document.close();\n            return this;\n        },\n\n        /**\n         * Lists the XML code of the construction in a new HTML-window.\n         * @returns {JXG.Board} Reference to the board\n         */\n        showXML: function () {\n            var f = window.open(\"\");\n            f.document.open();\n            f.document.write(\"<pre>\" + Type.escapeHTML(this.xmlString) + \"<\" + \"/pre>\");\n            f.document.close();\n            return this;\n        },\n\n        /**\n         * Sets for all objects the needsUpdate flag to \"true\".\n         * @returns {JXG.Board} Reference to the board\n         */\n        prepareUpdate: function () {\n            var el,\n                pEl,\n                len = this.objectsList.length;\n\n            /*\n            if (this.attr.updatetype === 'hierarchical') {\n                return this;\n            }\n            */\n\n            for (el = 0; el < len; el++) {\n                pEl = this.objectsList[el];\n                pEl.needsUpdate = pEl.needsRegularUpdate || this.needsFullUpdate;\n            }\n\n            for (el in this.groups) {\n                if (this.groups.hasOwnProperty(el)) {\n                    pEl = this.groups[el];\n                    pEl.needsUpdate = pEl.needsRegularUpdate || this.needsFullUpdate;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Runs through all elements and calls their update() method.\n         * @param {JXG.GeometryElement} drag Element that caused the update.\n         * @returns {JXG.Board} Reference to the board\n         */\n        updateElements: function (drag) {\n            var el, pEl;\n            //var childId, i = 0;\n\n            drag = this.select(drag);\n\n            /*\n            if (Type.exists(drag)) {\n                for (el = 0; el < this.objectsList.length; el++) {\n                    pEl = this.objectsList[el];\n                    if (pEl.id === drag.id) {\n                        i = el;\n                        break;\n                    }\n                }\n            }\n            */\n\n            for (el = 0; el < this.objectsList.length; el++) {\n                pEl = this.objectsList[el];\n                if (this.needsFullUpdate && pEl.elementClass === Const.OBJECT_CLASS_TEXT) {\n                    pEl.updateSize();\n                }\n\n                // For updates of an element we distinguish if the dragged element is updated or\n                // other elements are updated.\n                // The difference lies in the treatment of gliders and points based on transformations.\n                pEl.update(!Type.exists(drag) || pEl.id !== drag.id).updateVisibility();\n            }\n\n            // update groups last\n            for (el in this.groups) {\n                if (this.groups.hasOwnProperty(el)) {\n                    this.groups[el].update(drag);\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Runs through all elements and calls their update() method.\n         * @returns {JXG.Board} Reference to the board\n         */\n        updateRenderer: function () {\n            var el,\n                len = this.objectsList.length;\n\n            if (!this.renderer) {\n                return;\n            }\n\n            /*\n            objs = this.objectsList.slice(0);\n            objs.sort(function (a, b) {\n                if (a.visProp.layer < b.visProp.layer) {\n                    return -1;\n                } else if (a.visProp.layer === b.visProp.layer) {\n                    return b.lastDragTime.getTime() - a.lastDragTime.getTime();\n                } else {\n                    return 1;\n                }\n            });\n            */\n\n            if (this.renderer.type === \"canvas\") {\n                this.updateRendererCanvas();\n            } else {\n                for (el = 0; el < len; el++) {\n                    this.objectsList[el].updateRenderer();\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Runs through all elements and calls their update() method.\n         * This is a special version for the CanvasRenderer.\n         * Here, we have to do our own layer handling.\n         * @returns {JXG.Board} Reference to the board\n         */\n        updateRendererCanvas: function () {\n            var el,\n                pEl,\n                i,\n                mini,\n                la,\n                olen = this.objectsList.length,\n                layers = this.options.layer,\n                len = this.options.layer.numlayers,\n                last = Number.NEGATIVE_INFINITY;\n\n            for (i = 0; i < len; i++) {\n                mini = Number.POSITIVE_INFINITY;\n\n                for (la in layers) {\n                    if (layers.hasOwnProperty(la)) {\n                        if (layers[la] > last && layers[la] < mini) {\n                            mini = layers[la];\n                        }\n                    }\n                }\n\n                last = mini;\n\n                for (el = 0; el < olen; el++) {\n                    pEl = this.objectsList[el];\n\n                    if (pEl.visProp.layer === mini) {\n                        pEl.prepareUpdate().updateRenderer();\n                    }\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Please use {@link JXG.Board.on} instead.\n         * @param {Function} hook A function to be called by the board after an update occurred.\n         * @param {String} [m='update'] When the hook is to be called. Possible values are <i>mouseup</i>, <i>mousedown</i> and <i>update</i>.\n         * @param {Object} [context=board] Determines the execution context the hook is called. This parameter is optional, default is the\n         * board object the hook is attached to.\n         * @returns {Number} Id of the hook, required to remove the hook from the board.\n         * @deprecated\n         */\n        addHook: function (hook, m, context) {\n            JXG.deprecated(\"Board.addHook()\", \"Board.on()\");\n            m = Type.def(m, \"update\");\n\n            context = Type.def(context, this);\n\n            this.hooks.push([m, hook]);\n            this.on(m, hook, context);\n\n            return this.hooks.length - 1;\n        },\n\n        /**\n         * Alias of {@link JXG.Board.on}.\n         */\n        addEvent: JXG.shortcut(JXG.Board.prototype, \"on\"),\n\n        /**\n         * Please use {@link JXG.Board.off} instead.\n         * @param {Number|function} id The number you got when you added the hook or a reference to the event handler.\n         * @returns {JXG.Board} Reference to the board\n         * @deprecated\n         */\n        removeHook: function (id) {\n            JXG.deprecated(\"Board.removeHook()\", \"Board.off()\");\n            if (this.hooks[id]) {\n                this.off(this.hooks[id][0], this.hooks[id][1]);\n                this.hooks[id] = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * Alias of {@link JXG.Board.off}.\n         */\n        removeEvent: JXG.shortcut(JXG.Board.prototype, \"off\"),\n\n        /**\n         * Runs through all hooked functions and calls them.\n         * @returns {JXG.Board} Reference to the board\n         * @deprecated\n         */\n        updateHooks: function (m) {\n            var arg = Array.prototype.slice.call(arguments, 0);\n\n            JXG.deprecated(\"Board.updateHooks()\", \"Board.triggerEventHandlers()\");\n\n            arg[0] = Type.def(arg[0], \"update\");\n            this.triggerEventHandlers([arg[0]], arguments);\n\n            return this;\n        },\n\n        /**\n         * Adds a dependent board to this board.\n         * @param {JXG.Board} board A reference to board which will be updated after an update of this board occurred.\n         * @returns {JXG.Board} Reference to the board\n         */\n        addChild: function (board) {\n            if (Type.exists(board) && Type.exists(board.containerObj)) {\n                this.dependentBoards.push(board);\n                this.update();\n            }\n            return this;\n        },\n\n        /**\n         * Deletes a board from the list of dependent boards.\n         * @param {JXG.Board} board Reference to the board which will be removed.\n         * @returns {JXG.Board} Reference to the board\n         */\n        removeChild: function (board) {\n            var i;\n\n            for (i = this.dependentBoards.length - 1; i >= 0; i--) {\n                if (this.dependentBoards[i] === board) {\n                    this.dependentBoards.splice(i, 1);\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Runs through most elements and calls their update() method and update the conditions.\n         * @param {JXG.GeometryElement} [drag] Element that caused the update.\n         * @returns {JXG.Board} Reference to the board\n         */\n        update: function (drag) {\n            var i, len, b, insert, storeActiveEl;\n\n            if (this.inUpdate || this.isSuspendedUpdate) {\n                return this;\n            }\n            this.inUpdate = true;\n\n            if (\n                this.attr.minimizereflow === \"all\" &&\n                this.containerObj &&\n                this.renderer.type !== \"vml\"\n            ) {\n                storeActiveEl = this.document.activeElement; // Store focus element\n                insert = this.renderer.removeToInsertLater(this.containerObj);\n            }\n\n            if (this.attr.minimizereflow === \"svg\" && this.renderer.type === \"svg\") {\n                storeActiveEl = this.document.activeElement;\n                insert = this.renderer.removeToInsertLater(this.renderer.svgRoot);\n            }\n\n            this.prepareUpdate().updateElements(drag).updateConditions();\n            this.renderer.suspendRedraw(this);\n            this.updateRenderer();\n            this.renderer.unsuspendRedraw();\n            this.triggerEventHandlers([\"update\"], []);\n\n            if (insert) {\n                insert();\n                storeActiveEl.focus(); // Restore focus element\n            }\n\n            // To resolve dependencies between boards\n            // for (var board in JXG.boards) {\n            len = this.dependentBoards.length;\n            for (i = 0; i < len; i++) {\n                b = this.dependentBoards[i];\n                if (Type.exists(b) && b !== this) {\n                    b.updateQuality = this.updateQuality;\n                    b.prepareUpdate().updateElements().updateConditions();\n                    b.renderer.suspendRedraw();\n                    b.updateRenderer();\n                    b.renderer.unsuspendRedraw();\n                    b.triggerEventHandlers([\"update\"], []);\n                }\n            }\n\n            this.inUpdate = false;\n            return this;\n        },\n\n        /**\n         * Runs through all elements and calls their update() method and update the conditions.\n         * This is necessary after zooming and changing the bounding box.\n         * @returns {JXG.Board} Reference to the board\n         */\n        fullUpdate: function () {\n            this.needsFullUpdate = true;\n            this.update();\n            this.needsFullUpdate = false;\n            return this;\n        },\n\n        /**\n         * Adds a grid to the board according to the settings given in board.options.\n         * @returns {JXG.Board} Reference to the board.\n         */\n        addGrid: function () {\n            this.create(\"grid\", []);\n\n            return this;\n        },\n\n        /**\n         * Removes all grids assigned to this board. Warning: This method also removes all objects depending on one or\n         * more of the grids.\n         * @returns {JXG.Board} Reference to the board object.\n         */\n        removeGrids: function () {\n            var i;\n\n            for (i = 0; i < this.grids.length; i++) {\n                this.removeObject(this.grids[i]);\n            }\n\n            this.grids.length = 0;\n            this.update(); // required for canvas renderer\n\n            return this;\n        },\n\n        /**\n         * Creates a new geometric element of type elementType.\n         * @param {String} elementType Type of the element to be constructed given as a string e.g. 'point' or 'circle'.\n         * @param {Array} parents Array of parent elements needed to construct the element e.g. coordinates for a point or two\n         * points to construct a line. This highly depends on the elementType that is constructed. See the corresponding JXG.create*\n         * methods for a list of possible parameters.\n         * @param {Object} [attributes] An object containing the attributes to be set. This also depends on the elementType.\n         * Common attributes are name, visible, strokeColor.\n         * @returns {Object} Reference to the created element. This is usually a GeometryElement, but can be an array containing\n         * two or more elements.\n         */\n        create: function (elementType, parents, attributes) {\n            var el, i;\n\n            elementType = elementType.toLowerCase();\n\n            if (!Type.exists(parents)) {\n                parents = [];\n            }\n\n            if (!Type.exists(attributes)) {\n                attributes = {};\n            }\n\n            for (i = 0; i < parents.length; i++) {\n                if (\n                    Type.isString(parents[i]) &&\n                    !(elementType === \"text\" && i === 2) &&\n                    !(elementType === \"solidofrevolution3d\" && i === 2) &&\n                    !(\n                        (elementType === \"input\" ||\n                            elementType === \"checkbox\" ||\n                            elementType === \"button\") &&\n                        (i === 2 || i === 3)\n                    ) &&\n                    !(elementType === \"curve\" && i > 0) // Allow curve plots with jessiecode\n                ) {\n                    parents[i] = this.select(parents[i]);\n                }\n            }\n\n            if (Type.isFunction(JXG.elements[elementType])) {\n                el = JXG.elements[elementType](this, parents, attributes);\n            } else {\n                throw new Error(\"JSXGraph: create: Unknown element type given: \" + elementType);\n            }\n\n            if (!Type.exists(el)) {\n                JXG.debug(\"JSXGraph: create: failure creating \" + elementType);\n                return el;\n            }\n\n            if (el.prepareUpdate && el.update && el.updateRenderer) {\n                el.fullUpdate();\n            }\n            return el;\n        },\n\n        /**\n         * Deprecated name for {@link JXG.Board.create}.\n         * @deprecated\n         */\n        createElement: function () {\n            JXG.deprecated(\"Board.createElement()\", \"Board.create()\");\n            return this.create.apply(this, arguments);\n        },\n\n        /**\n         * Delete the elements drawn as part of a trace of an element.\n         * @returns {JXG.Board} Reference to the board\n         */\n        clearTraces: function () {\n            var el;\n\n            for (el = 0; el < this.objectsList.length; el++) {\n                this.objectsList[el].clearTrace();\n            }\n\n            this.numTraces = 0;\n            return this;\n        },\n\n        /**\n         * Stop updates of the board.\n         * @returns {JXG.Board} Reference to the board\n         */\n        suspendUpdate: function () {\n            if (!this.inUpdate) {\n                this.isSuspendedUpdate = true;\n            }\n            return this;\n        },\n\n        /**\n         * Enable updates of the board.\n         * @returns {JXG.Board} Reference to the board\n         */\n        unsuspendUpdate: function () {\n            if (this.isSuspendedUpdate) {\n                this.isSuspendedUpdate = false;\n                this.fullUpdate();\n            }\n            return this;\n        },\n\n        /**\n         * Set the bounding box of the board.\n         * @param {Array} bbox New bounding box [x1,y1,x2,y2]\n         * @param {Boolean} [keepaspectratio=false] If set to true, the aspect ratio will be 1:1, but\n         * the resulting viewport may be larger.\n         * @param {String} [setZoom='reset'] Reset, keep or update the zoom level of the board. 'reset'\n         * sets {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY} to the start values (or 1.0).\n         * 'update' adapts these values accoring to the new bounding box and 'keep' does nothing.\n         * @returns {JXG.Board} Reference to the board\n         */\n        setBoundingBox: function (bbox, keepaspectratio, setZoom) {\n            var h,\n                w,\n                ux,\n                uy,\n                offX = 0,\n                offY = 0,\n                zoom_ratio = 1,\n                ratio, dx, dy, prev_w, prev_h,\n                dim = Env.getDimensions(this.container, this.document);\n\n            if (!Type.isArray(bbox)) {\n                return this;\n            }\n\n            if (\n                bbox[0] < this.maxboundingbox[0] ||\n                bbox[1] > this.maxboundingbox[1] ||\n                bbox[2] > this.maxboundingbox[2] ||\n                bbox[3] < this.maxboundingbox[3]\n            ) {\n                return this;\n            }\n\n            if (!Type.exists(setZoom)) {\n                setZoom = \"reset\";\n            }\n\n            ux = this.unitX;\n            uy = this.unitY;\n            this.canvasWidth = parseFloat(dim.width);   // parseInt(dim.width, 10);\n            this.canvasHeight = parseFloat(dim.height); // parseInt(dim.height, 10);\n            w = this.canvasWidth;\n            h = this.canvasHeight;\n            if (keepaspectratio) {\n                ratio = ux / uy;            // Keep this ratio if aspectratio==true\n                if (setZoom === 'keep') {\n                    zoom_ratio = this.zoomX / this.zoomY;\n                }\n                dx = bbox[2] - bbox[0];\n                dy = bbox[1] - bbox[3];\n                prev_w = ux * dx;\n                prev_h = uy * dy;\n                if (w >= h) {\n                    if (prev_w >= prev_h) {\n                        this.unitY = h / dy;\n                        this.unitX = this.unitY * ratio;\n                    } else {\n                        // Switch dominating interval\n                        this.unitY = h / Math.abs(dx) * Mat.sign(dy) / zoom_ratio;\n                        this.unitX = this.unitY * ratio;\n                    }\n                } else {\n                    if (prev_h > prev_w) {\n                        this.unitX = w / dx;\n                        this.unitY = this.unitX / ratio;\n                    } else {\n                        // Switch dominating interval\n                        this.unitX = w / Math.abs(dy) * Mat.sign(dx) * zoom_ratio;\n                        this.unitY = this.unitX / ratio;\n                    }\n                }\n                // Add the additional units in equal portions left and right\n                offX = (w / this.unitX - dx) * 0.5;\n                // Add the additional units in equal portions above and below\n                offY = (h / this.unitY - dy) * 0.5;\n                this.keepaspectratio = true;\n            } else {\n                this.unitX = w / (bbox[2] - bbox[0]);\n                this.unitY = h / (bbox[1] - bbox[3]);\n                this.keepaspectratio = false;\n            }\n\n            this.moveOrigin(-this.unitX * (bbox[0] - offX), this.unitY * (bbox[1] + offY));\n\n            if (setZoom === \"update\") {\n                this.zoomX *= this.unitX / ux;\n                this.zoomY *= this.unitY / uy;\n            } else if (setZoom === \"reset\") {\n                this.zoomX = Type.exists(this.attr.zoomx) ? this.attr.zoomx : 1.0;\n                this.zoomY = Type.exists(this.attr.zoomy) ? this.attr.zoomy : 1.0;\n            }\n\n            return this;\n        },\n\n        /**\n         * Get the bounding box of the board.\n         * @returns {Array} bounding box [x1,y1,x2,y2] upper left corner, lower right corner\n         */\n        getBoundingBox: function () {\n            var ul = new Coords(Const.COORDS_BY_SCREEN, [0, 0], this).usrCoords,\n                lr = new Coords(\n                    Const.COORDS_BY_SCREEN,\n                    [this.canvasWidth, this.canvasHeight],\n                    this\n                ).usrCoords;\n\n            return [ul[1], ul[2], lr[1], lr[2]];\n        },\n\n        /**\n         * Adds an animation. Animations are controlled by the boards, so the boards need to be aware of the\n         * animated elements. This function tells the board about new elements to animate.\n         * @param {JXG.GeometryElement} element The element which is to be animated.\n         * @returns {JXG.Board} Reference to the board\n         */\n        addAnimation: function (element) {\n            var that = this;\n\n            this.animationObjects[element.id] = element;\n\n            if (!this.animationIntervalCode) {\n                this.animationIntervalCode = window.setInterval(function () {\n                    that.animate();\n                }, element.board.attr.animationdelay);\n            }\n\n            return this;\n        },\n\n        /**\n         * Cancels all running animations.\n         * @returns {JXG.Board} Reference to the board\n         */\n        stopAllAnimation: function () {\n            var el;\n\n            for (el in this.animationObjects) {\n                if (\n                    this.animationObjects.hasOwnProperty(el) &&\n                    Type.exists(this.animationObjects[el])\n                ) {\n                    this.animationObjects[el] = null;\n                    delete this.animationObjects[el];\n                }\n            }\n\n            window.clearInterval(this.animationIntervalCode);\n            delete this.animationIntervalCode;\n\n            return this;\n        },\n\n        /**\n         * General purpose animation function. This currently only supports moving points from one place to another. This\n         * is faster than managing the animation per point, especially if there is more than one animated point at the same time.\n         * @returns {JXG.Board} Reference to the board\n         */\n        animate: function () {\n            var props,\n                el,\n                o,\n                newCoords,\n                r,\n                p,\n                c,\n                cbtmp,\n                count = 0,\n                obj = null;\n\n            for (el in this.animationObjects) {\n                if (\n                    this.animationObjects.hasOwnProperty(el) &&\n                    Type.exists(this.animationObjects[el])\n                ) {\n                    count += 1;\n                    o = this.animationObjects[el];\n\n                    if (o.animationPath) {\n                        if (Type.isFunction(o.animationPath)) {\n                            newCoords = o.animationPath(\n                                new Date().getTime() - o.animationStart\n                            );\n                        } else {\n                            newCoords = o.animationPath.pop();\n                        }\n\n                        if (\n                            !Type.exists(newCoords) ||\n                            (!Type.isArray(newCoords) && isNaN(newCoords))\n                        ) {\n                            delete o.animationPath;\n                        } else {\n                            o.setPositionDirectly(Const.COORDS_BY_USER, newCoords);\n                            o.fullUpdate();\n                            obj = o;\n                        }\n                    }\n                    if (o.animationData) {\n                        c = 0;\n\n                        for (r in o.animationData) {\n                            if (o.animationData.hasOwnProperty(r)) {\n                                p = o.animationData[r].pop();\n\n                                if (!Type.exists(p)) {\n                                    delete o.animationData[p];\n                                } else {\n                                    c += 1;\n                                    props = {};\n                                    props[r] = p;\n                                    o.setAttribute(props);\n                                }\n                            }\n                        }\n\n                        if (c === 0) {\n                            delete o.animationData;\n                        }\n                    }\n\n                    if (!Type.exists(o.animationData) && !Type.exists(o.animationPath)) {\n                        this.animationObjects[el] = null;\n                        delete this.animationObjects[el];\n\n                        if (Type.exists(o.animationCallback)) {\n                            cbtmp = o.animationCallback;\n                            o.animationCallback = null;\n                            cbtmp();\n                        }\n                    }\n                }\n            }\n\n            if (count === 0) {\n                window.clearInterval(this.animationIntervalCode);\n                delete this.animationIntervalCode;\n            } else {\n                this.update(obj);\n            }\n\n            return this;\n        },\n\n        /**\n         * Migrate the dependency properties of the point src\n         * to the point dest and  delete the point src.\n         * For example, a circle around the point src\n         * receives the new center dest. The old center src\n         * will be deleted.\n         * @param {JXG.Point} src Original point which will be deleted\n         * @param {JXG.Point} dest New point with the dependencies of src.\n         * @param {Boolean} copyName Flag which decides if the name of the src element is copied to the\n         *  dest element.\n         * @returns {JXG.Board} Reference to the board\n         */\n        migratePoint: function (src, dest, copyName) {\n            var child,\n                childId,\n                prop,\n                found,\n                i,\n                srcLabelId,\n                srcHasLabel = false;\n\n            src = this.select(src);\n            dest = this.select(dest);\n\n            if (Type.exists(src.label)) {\n                srcLabelId = src.label.id;\n                srcHasLabel = true;\n                this.removeObject(src.label);\n            }\n\n            for (childId in src.childElements) {\n                if (src.childElements.hasOwnProperty(childId)) {\n                    child = src.childElements[childId];\n                    found = false;\n\n                    for (prop in child) {\n                        if (child.hasOwnProperty(prop)) {\n                            if (child[prop] === src) {\n                                child[prop] = dest;\n                                found = true;\n                            }\n                        }\n                    }\n\n                    if (found) {\n                        delete src.childElements[childId];\n                    }\n\n                    for (i = 0; i < child.parents.length; i++) {\n                        if (child.parents[i] === src.id) {\n                            child.parents[i] = dest.id;\n                        }\n                    }\n\n                    dest.addChild(child);\n                }\n            }\n\n            // The destination object should receive the name\n            // and the label of the originating (src) object\n            if (copyName) {\n                if (srcHasLabel) {\n                    delete dest.childElements[srcLabelId];\n                    delete dest.descendants[srcLabelId];\n                }\n\n                if (dest.label) {\n                    this.removeObject(dest.label);\n                }\n\n                delete this.elementsByName[dest.name];\n                dest.name = src.name;\n                if (srcHasLabel) {\n                    dest.createLabel();\n                }\n            }\n\n            this.removeObject(src);\n\n            if (Type.exists(dest.name) && dest.name !== \"\") {\n                this.elementsByName[dest.name] = dest;\n            }\n\n            this.fullUpdate();\n\n            return this;\n        },\n\n        /**\n         * Initializes color blindness simulation.\n         * @param {String} deficiency Describes the color blindness deficiency which is simulated. Accepted values are 'protanopia', 'deuteranopia', and 'tritanopia'.\n         * @returns {JXG.Board} Reference to the board\n         */\n        emulateColorblindness: function (deficiency) {\n            var e, o;\n\n            if (!Type.exists(deficiency)) {\n                deficiency = \"none\";\n            }\n\n            if (this.currentCBDef === deficiency) {\n                return this;\n            }\n\n            for (e in this.objects) {\n                if (this.objects.hasOwnProperty(e)) {\n                    o = this.objects[e];\n\n                    if (deficiency !== \"none\") {\n                        if (this.currentCBDef === \"none\") {\n                            // this could be accomplished by JXG.extend, too. But do not use\n                            // JXG.deepCopy as this could result in an infinite loop because in\n                            // visProp there could be geometry elements which contain the board which\n                            // contains all objects which contain board etc.\n                            o.visPropOriginal = {\n                                strokecolor: o.visProp.strokecolor,\n                                fillcolor: o.visProp.fillcolor,\n                                highlightstrokecolor: o.visProp.highlightstrokecolor,\n                                highlightfillcolor: o.visProp.highlightfillcolor\n                            };\n                        }\n                        o.setAttribute({\n                            strokecolor: Color.rgb2cb(\n                                Type.evaluate(o.visPropOriginal.strokecolor),\n                                deficiency\n                            ),\n                            fillcolor: Color.rgb2cb(\n                                Type.evaluate(o.visPropOriginal.fillcolor),\n                                deficiency\n                            ),\n                            highlightstrokecolor: Color.rgb2cb(\n                                Type.evaluate(o.visPropOriginal.highlightstrokecolor),\n                                deficiency\n                            ),\n                            highlightfillcolor: Color.rgb2cb(\n                                Type.evaluate(o.visPropOriginal.highlightfillcolor),\n                                deficiency\n                            )\n                        });\n                    } else if (Type.exists(o.visPropOriginal)) {\n                        JXG.extend(o.visProp, o.visPropOriginal);\n                    }\n                }\n            }\n            this.currentCBDef = deficiency;\n            this.update();\n\n            return this;\n        },\n\n        /**\n         * Select a single or multiple elements at once.\n         * @param {String|Object|function} str The name, id or a reference to a JSXGraph element on this board. An object will\n         * be used as a filter to return multiple elements at once filtered by the properties of the object.\n         * @param {Boolean} onlyByIdOrName If true (default:false) elements are only filtered by their id, name or groupId.\n         * The advanced filters consisting of objects or functions are ignored.\n         * @returns {JXG.GeometryElement|JXG.Composition}\n         * @example\n         * // select the element with name A\n         * board.select('A');\n         *\n         * // select all elements with strokecolor set to 'red' (but not '#ff0000')\n         * board.select({\n         *   strokeColor: 'red'\n         * });\n         *\n         * // select all points on or below the x axis and make them black.\n         * board.select({\n         *   elementClass: JXG.OBJECT_CLASS_POINT,\n         *   Y: function (v) {\n         *     return v <= 0;\n         *   }\n         * }).setAttribute({color: 'black'});\n         *\n         * // select all elements\n         * board.select(function (el) {\n         *   return true;\n         * });\n         */\n        select: function (str, onlyByIdOrName) {\n            var flist,\n                olist,\n                i,\n                l,\n                s = str;\n\n            if (s === null) {\n                return s;\n            }\n\n            // It's a string, most likely an id or a name.\n            if (Type.isString(s) && s !== \"\") {\n                // Search by ID\n                if (Type.exists(this.objects[s])) {\n                    s = this.objects[s];\n                    // Search by name\n                } else if (Type.exists(this.elementsByName[s])) {\n                    s = this.elementsByName[s];\n                    // Search by group ID\n                } else if (Type.exists(this.groups[s])) {\n                    s = this.groups[s];\n                }\n\n                // It's a function or an object, but not an element\n            } else if (\n                !onlyByIdOrName &&\n                (Type.isFunction(s) || (Type.isObject(s) && !Type.isFunction(s.setAttribute)))\n            ) {\n                flist = Type.filterElements(this.objectsList, s);\n\n                olist = {};\n                l = flist.length;\n                for (i = 0; i < l; i++) {\n                    olist[flist[i].id] = flist[i];\n                }\n                s = new Composition(olist);\n\n                // It's an element which has been deleted (and still hangs around, e.g. in an attractor list\n            } else if (\n                Type.isObject(s) &&\n                Type.exists(s.id) &&\n                !Type.exists(this.objects[s.id])\n            ) {\n                s = null;\n            }\n\n            return s;\n        },\n\n        /**\n         * Checks if the given point is inside the boundingbox.\n         * @param {Number|JXG.Coords} x User coordinate or {@link JXG.Coords} object.\n         * @param {Number} [y] User coordinate. May be omitted in case <tt>x</tt> is a {@link JXG.Coords} object.\n         * @returns {Boolean}\n         */\n        hasPoint: function (x, y) {\n            var px = x,\n                py = y,\n                bbox = this.getBoundingBox();\n\n            if (Type.exists(x) && Type.isArray(x.usrCoords)) {\n                px = x.usrCoords[1];\n                py = x.usrCoords[2];\n            }\n\n            return !!(\n                Type.isNumber(px) &&\n                Type.isNumber(py) &&\n                bbox[0] < px &&\n                px < bbox[2] &&\n                bbox[1] > py &&\n                py > bbox[3]\n            );\n        },\n\n        /**\n         * Update CSS transformations of type scaling. It is used to correct the mouse position\n         * in {@link JXG.Board.getMousePosition}.\n         * The inverse transformation matrix is updated on each mouseDown and touchStart event.\n         *\n         * It is up to the user to call this method after an update of the CSS transformation\n         * in the DOM.\n         */\n        updateCSSTransforms: function () {\n            var obj = this.containerObj,\n                o = obj,\n                o2 = obj;\n\n            this.cssTransMat = Env.getCSSTransformMatrix(o);\n\n            // Newer variant of walking up the tree.\n            // We walk up all parent nodes and collect possible CSS transforms.\n            // Works also for ShadowDOM\n            if (Type.exists(o.getRootNode)) {\n                o = o.parentNode === o.getRootNode() ? o.parentNode.host : o.parentNode;\n                while (o) {\n                    this.cssTransMat = Mat.matMatMult(Env.getCSSTransformMatrix(o), this.cssTransMat);\n                    o = o.parentNode === o.getRootNode() ? o.parentNode.host : o.parentNode;\n                }\n                this.cssTransMat = Mat.inverse(this.cssTransMat);\n            } else {\n                /*\n                 * This is necessary for IE11\n                 */\n                o = o.offsetParent;\n                while (o) {\n                    this.cssTransMat = Mat.matMatMult(Env.getCSSTransformMatrix(o), this.cssTransMat);\n\n                    o2 = o2.parentNode;\n                    while (o2 !== o) {\n                        this.cssTransMat = Mat.matMatMult(Env.getCSSTransformMatrix(o), this.cssTransMat);\n                        o2 = o2.parentNode;\n                    }\n                    o = o.offsetParent;\n                }\n                this.cssTransMat = Mat.inverse(this.cssTransMat);\n            }\n            return this;\n        },\n\n        /**\n         * Start selection mode. This function can either be triggered from outside or by\n         * a down event together with correct key pressing. The default keys are\n         * shift+ctrl. But this can be changed in the options.\n         *\n         * Starting from out side can be realized for example with a button like this:\n         * <pre>\n         * \t&lt;button onclick=\"board.startSelectionMode()\"&gt;Start&lt;/button&gt;\n         * </pre>\n         * @example\n         * //\n         * // Set a new bounding box from the selection rectangle\n         * //\n         * var board = JXG.JSXGraph.initBoard('jxgbox', {\n         *         boundingBox:[-3,2,3,-2],\n         *         keepAspectRatio: false,\n         *         axis:true,\n         *         selection: {\n         *             enabled: true,\n         *             needShift: false,\n         *             needCtrl: true,\n         *             withLines: false,\n         *             vertices: {\n         *                 visible: false\n         *             },\n         *             fillColor: '#ffff00',\n         *         }\n         *      });\n         *\n         * var f = function f(x) { return Math.cos(x); },\n         *     curve = board.create('functiongraph', [f]);\n         *\n         * board.on('stopselecting', function(){\n         *     var box = board.stopSelectionMode(),\n         *\n         *         // bbox has the coordinates of the selection rectangle.\n         *         // Attention: box[i].usrCoords have the form [1, x, y], i.e.\n         *         // are homogeneous coordinates.\n         *         bbox = box[0].usrCoords.slice(1).concat(box[1].usrCoords.slice(1));\n         *\n         *         // Set a new bounding box\n         *         board.setBoundingBox(bbox, false);\n         *  });\n         *\n         *\n         * </pre><div class=\"jxgbox\" id=\"JXG11eff3a6-8c50-11e5-b01d-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *     //\n         *     // Set a new bounding box from the selection rectangle\n         *     //\n         *     var board = JXG.JSXGraph.initBoard('JXG11eff3a6-8c50-11e5-b01d-901b0e1b8723', {\n         *             boundingBox:[-3,2,3,-2],\n         *             keepAspectRatio: false,\n         *             axis:true,\n         *             selection: {\n         *                 enabled: true,\n         *                 needShift: false,\n         *                 needCtrl: true,\n         *                 withLines: false,\n         *                 vertices: {\n         *                     visible: false\n         *                 },\n         *                 fillColor: '#ffff00',\n         *             }\n         *        });\n         *\n         *     var f = function f(x) { return Math.cos(x); },\n         *         curve = board.create('functiongraph', [f]);\n         *\n         *     board.on('stopselecting', function(){\n         *         var box = board.stopSelectionMode(),\n         *\n         *             // bbox has the coordinates of the selection rectangle.\n         *             // Attention: box[i].usrCoords have the form [1, x, y], i.e.\n         *             // are homogeneous coordinates.\n         *             bbox = box[0].usrCoords.slice(1).concat(box[1].usrCoords.slice(1));\n         *\n         *             // Set a new bounding box\n         *             board.setBoundingBox(bbox, false);\n         *      });\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        startSelectionMode: function () {\n            this.selectingMode = true;\n            this.selectionPolygon.setAttribute({ visible: true });\n            this.selectingBox = [\n                [0, 0],\n                [0, 0]\n            ];\n            this._setSelectionPolygonFromBox();\n            this.selectionPolygon.fullUpdate();\n        },\n\n        /**\n         * Finalize the selection: disable selection mode and return the coordinates\n         * of the selection rectangle.\n         * @returns {Array} Coordinates of the selection rectangle. The array\n         * contains two {@link JXG.Coords} objects. One the upper left corner and\n         * the second for the lower right corner.\n         */\n        stopSelectionMode: function () {\n            this.selectingMode = false;\n            this.selectionPolygon.setAttribute({ visible: false });\n            return [\n                this.selectionPolygon.vertices[0].coords,\n                this.selectionPolygon.vertices[2].coords\n            ];\n        },\n\n        /**\n         * Start the selection of a region.\n         * @private\n         * @param  {Array} pos Screen coordiates of the upper left corner of the\n         * selection rectangle.\n         */\n        _startSelecting: function (pos) {\n            this.isSelecting = true;\n            this.selectingBox = [\n                [pos[0], pos[1]],\n                [pos[0], pos[1]]\n            ];\n            this._setSelectionPolygonFromBox();\n        },\n\n        /**\n         * Update the selection rectangle during a move event.\n         * @private\n         * @param  {Array} pos Screen coordiates of the move event\n         */\n        _moveSelecting: function (pos) {\n            if (this.isSelecting) {\n                this.selectingBox[1] = [pos[0], pos[1]];\n                this._setSelectionPolygonFromBox();\n                this.selectionPolygon.fullUpdate();\n            }\n        },\n\n        /**\n         * Update the selection rectangle during an up event. Stop selection.\n         * @private\n         * @param  {Object} evt Event object\n         */\n        _stopSelecting: function (evt) {\n            var pos = this.getMousePosition(evt);\n\n            this.isSelecting = false;\n            this.selectingBox[1] = [pos[0], pos[1]];\n            this._setSelectionPolygonFromBox();\n        },\n\n        /**\n         * Update the Selection rectangle.\n         * @private\n         */\n        _setSelectionPolygonFromBox: function () {\n            var A = this.selectingBox[0],\n                B = this.selectingBox[1];\n\n            this.selectionPolygon.vertices[0].setPositionDirectly(JXG.COORDS_BY_SCREEN, [\n                A[0],\n                A[1]\n            ]);\n            this.selectionPolygon.vertices[1].setPositionDirectly(JXG.COORDS_BY_SCREEN, [\n                A[0],\n                B[1]\n            ]);\n            this.selectionPolygon.vertices[2].setPositionDirectly(JXG.COORDS_BY_SCREEN, [\n                B[0],\n                B[1]\n            ]);\n            this.selectionPolygon.vertices[3].setPositionDirectly(JXG.COORDS_BY_SCREEN, [\n                B[0],\n                A[1]\n            ]);\n        },\n\n        /**\n         * Test if a down event should start a selection. Test if the\n         * required keys are pressed. If yes, {@link JXG.Board.startSelectionMode} is called.\n         * @param  {Object} evt Event object\n         */\n        _testForSelection: function (evt) {\n            if (this._isRequiredKeyPressed(evt, \"selection\")) {\n                if (!Type.exists(this.selectionPolygon)) {\n                    this._createSelectionPolygon(this.attr);\n                }\n                this.startSelectionMode();\n            }\n        },\n\n        /**\n         * Create the internal selection polygon, which will be available as board.selectionPolygon.\n         * @private\n         * @param  {Object} attr board attributes, e.g. the subobject board.attr.\n         * @returns {Object} pointer to the board to enable chaining.\n         */\n        _createSelectionPolygon: function (attr) {\n            var selectionattr;\n\n            if (!Type.exists(this.selectionPolygon)) {\n                selectionattr = Type.copyAttributes(attr, Options, \"board\", \"selection\");\n                if (selectionattr.enabled === true) {\n                    this.selectionPolygon = this.create(\n                        \"polygon\",\n                        [\n                            [0, 0],\n                            [0, 0],\n                            [0, 0],\n                            [0, 0]\n                        ],\n                        selectionattr\n                    );\n                }\n            }\n\n            return this;\n        },\n\n        /* **************************\n         *     EVENT DEFINITION\n         * for documentation purposes\n         * ************************** */\n\n        //region Event handler documentation\n\n        /**\n         * @event\n         * @description Whenever the user starts to touch or click the board.\n         * @name JXG.Board#down\n         * @param {Event} e The browser's event object.\n         */\n        __evt__down: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user starts to click on the board.\n         * @name JXG.Board#mousedown\n         * @param {Event} e The browser's event object.\n         */\n        __evt__mousedown: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user taps the pen on the board.\n         * @name JXG.Board#pendown\n         * @param {Event} e The browser's event object.\n         */\n        __evt__pendown: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user starts to click on the board with a\n         * device sending pointer events.\n         * @name JXG.Board#pointerdown\n         * @param {Event} e The browser's event object.\n         */\n        __evt__pointerdown: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user starts to touch the board.\n         * @name JXG.Board#touchstart\n         * @param {Event} e The browser's event object.\n         */\n        __evt__touchstart: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user stops to touch or click the board.\n         * @name JXG.Board#up\n         * @param {Event} e The browser's event object.\n         */\n        __evt__up: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user releases the mousebutton over the board.\n         * @name JXG.Board#mouseup\n         * @param {Event} e The browser's event object.\n         */\n        __evt__mouseup: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user releases the mousebutton over the board with a\n         * device sending pointer events.\n         * @name JXG.Board#pointerup\n         * @param {Event} e The browser's event object.\n         */\n        __evt__pointerup: function (e) {},\n\n        /**\n         * @event\n         * @description Whenever the user stops touching the board.\n         * @name JXG.Board#touchend\n         * @param {Event} e The browser's event object.\n         */\n        __evt__touchend: function (e) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is moving the finger or mouse pointer over the board.\n         * @name JXG.Board#move\n         * @param {Event} e The browser's event object.\n         * @param {Number} mode The mode the board currently is in\n         * @see JXG.Board#mode\n         */\n        __evt__move: function (e, mode) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is moving the mouse over the board.\n         * @name JXG.Board#mousemove\n         * @param {Event} e The browser's event object.\n         * @param {Number} mode The mode the board currently is in\n         * @see JXG.Board#mode\n         */\n        __evt__mousemove: function (e, mode) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is moving the pen over the board.\n         * @name JXG.Board#penmove\n         * @param {Event} e The browser's event object.\n         * @param {Number} mode The mode the board currently is in\n         * @see JXG.Board#mode\n         */\n        __evt__penmove: function (e, mode) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is moving the mouse over the board with a\n         * device sending pointer events.\n         * @name JXG.Board#pointermove\n         * @param {Event} e The browser's event object.\n         * @param {Number} mode The mode the board currently is in\n         * @see JXG.Board#mode\n         */\n        __evt__pointermove: function (e, mode) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is moving the finger over the board.\n         * @name JXG.Board#touchmove\n         * @param {Event} e The browser's event object.\n         * @param {Number} mode The mode the board currently is in\n         * @see JXG.Board#mode\n         */\n        __evt__touchmove: function (e, mode) {},\n\n        /**\n         * @event\n         * @description This event is fired whenever the user is moving an element over the board by\n         * pressing arrow keys on a keyboard.\n         * @name JXG.Board#keymove\n         * @param {Event} e The browser's event object.\n         * @param {Number} mode The mode the board currently is in\n         * @see JXG.Board#mode\n         */\n        __evt__keymove: function (e, mode) { },\n\n        /**\n         * @event\n         * @description Whenever an element is highlighted this event is fired.\n         * @name JXG.Board#hit\n         * @param {Event} e The browser's event object.\n         * @param {JXG.GeometryElement} el The hit element.\n         * @param target\n         *\n         * @example\n         * var c = board.create('circle', [[1, 1], 2]);\n         * board.on('hit', function(evt, el) {\n         *     console.log(\"Hit element\", el);\n         * });\n         *\n         * </pre><div id=\"JXG19eb31ac-88e6-11e8-bcb5-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG19eb31ac-88e6-11e8-bcb5-901b0e1b8723',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     var c = board.create('circle', [[1, 1], 2]);\n         *     board.on('hit', function(evt, el) {\n         *         console.log(\"Hit element\", el);\n         *     });\n         *\n         *     })();\n         *\n         * </script><pre>\n         */\n        __evt__hit: function (e, el, target) {},\n\n        /**\n         * @event\n         * @description Whenever an element is highlighted this event is fired.\n         * @name JXG.Board#mousehit\n         * @see JXG.Board#hit\n         * @param {Event} e The browser's event object.\n         * @param {JXG.GeometryElement} el The hit element.\n         * @param target\n         */\n        __evt__mousehit: function (e, el, target) {},\n\n        /**\n         * @event\n         * @description This board is updated.\n         * @name JXG.Board#update\n         */\n        __evt__update: function () {},\n\n        /**\n         * @event\n         * @description The bounding box of the board has changed.\n         * @name JXG.Board#boundingbox\n         */\n        __evt__boundingbox: function () {},\n\n        /**\n         * @event\n         * @description Select a region is started during a down event or by calling\n         * {@link JXG.Board.startSelectionMode}\n         * @name JXG.Board#startselecting\n         */\n        __evt__startselecting: function () {},\n\n        /**\n         * @event\n         * @description Select a region is started during a down event\n         * from a device sending mouse events or by calling\n         * {@link JXG.Board.startSelectionMode}.\n         * @name JXG.Board#mousestartselecting\n         */\n        __evt__mousestartselecting: function () {},\n\n        /**\n         * @event\n         * @description Select a region is started during a down event\n         * from a device sending pointer events or by calling\n         * {@link JXG.Board.startSelectionMode}.\n         * @name JXG.Board#pointerstartselecting\n         */\n        __evt__pointerstartselecting: function () {},\n\n        /**\n         * @event\n         * @description Select a region is started during a down event\n         * from a device sending touch events or by calling\n         * {@link JXG.Board.startSelectionMode}.\n         * @name JXG.Board#touchstartselecting\n         */\n        __evt__touchstartselecting: function () {},\n\n        /**\n         * @event\n         * @description Selection of a region is stopped during an up event.\n         * @name JXG.Board#stopselecting\n         */\n        __evt__stopselecting: function () {},\n\n        /**\n         * @event\n         * @description Selection of a region is stopped during an up event\n         * from a device sending mouse events.\n         * @name JXG.Board#mousestopselecting\n         */\n        __evt__mousestopselecting: function () {},\n\n        /**\n         * @event\n         * @description Selection of a region is stopped during an up event\n         * from a device sending pointer events.\n         * @name JXG.Board#pointerstopselecting\n         */\n        __evt__pointerstopselecting: function () {},\n\n        /**\n         * @event\n         * @description Selection of a region is stopped during an up event\n         * from a device sending touch events.\n         * @name JXG.Board#touchstopselecting\n         */\n        __evt__touchstopselecting: function () {},\n\n        /**\n         * @event\n         * @description A move event while selecting of a region is active.\n         * @name JXG.Board#moveselecting\n         */\n        __evt__moveselecting: function () {},\n\n        /**\n         * @event\n         * @description A move event while selecting of a region is active\n         * from a device sending mouse events.\n         * @name JXG.Board#mousemoveselecting\n         */\n        __evt__mousemoveselecting: function () {},\n\n        /**\n         * @event\n         * @description Select a region is started during a down event\n         * from a device sending mouse events.\n         * @name JXG.Board#pointermoveselecting\n         */\n        __evt__pointermoveselecting: function () {},\n\n        /**\n         * @event\n         * @description Select a region is started during a down event\n         * from a device sending touch events.\n         * @name JXG.Board#touchmoveselecting\n         */\n        __evt__touchmoveselecting: function () {},\n\n        /**\n         * @ignore\n         */\n        __evt: function () {},\n\n        //endregion\n\n        /**\n         * Expand the JSXGraph construction to fullscreen.\n         * In order to preserve the proportions of the JSXGraph element,\n         * a wrapper div is created which is set to fullscreen.\n         * <p>\n         * The wrapping div has the CSS class 'jxgbox_wrap_private' which is\n         * defined in the file 'jsxgraph.css'\n         * <p>\n         * This feature is not available on iPhones (as of December 2021).\n         *\n         * @param {String} id (Optional) id of the div element which is brought to fullscreen.\n         * If not provided, this defaults to the JSXGraph div. However, it may be necessary for the aspect ratio trick\n         * which using padding-bottom/top and an out div element. Then, the id of the outer div has to be supplied.\n         *\n         * @return {JXG.Board} Reference to the board\n         *\n         * @example\n         * &lt;div id='jxgbox' class='jxgbox' style='width:500px; height:200px;'&gt;&lt;/div&gt;\n         * &lt;button onClick=\"board.toFullscreen()\"&gt;Fullscreen&lt;/button&gt;\n         *\n         * &lt;script language=\"Javascript\" type='text/javascript'&gt;\n         * var board = JXG.JSXGraph.initBoard('jxgbox', {axis:true, boundingbox:[-5,5,5,-5]});\n         * var p = board.create('point', [0, 1]);\n         * &lt;/script&gt;\n         *\n         * </pre><div id=\"JXGd5bab8b6-fd40-11e8-ab14-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *      var board_d5bab8b6;\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXGd5bab8b6-fd40-11e8-ab14-901b0e1b8723',\n         *             {boundingbox:[-5,5,5,-5], axis: true, showcopyright: false, shownavigation: false});\n         *         var p = board.create('point', [0, 1]);\n         *         board_d5bab8b6 = board;\n         *     })();\n         * </script>\n         * <button onClick=\"board_d5bab8b6.toFullscreen()\">Fullscreen</button>\n         * <pre>\n         *\n         * @example\n         * &lt;div id='outer' style='max-width: 500px; margin: 0 auto;'&gt;\n         * &lt;div id='jxgbox' class='jxgbox' style='height: 0; padding-bottom: 100%'&gt;&lt;/div&gt;\n         * &lt;/div&gt;\n         * &lt;button onClick=\"board.toFullscreen('outer')\"&gt;Fullscreen&lt;/button&gt;\n         *\n         * &lt;script language=\"Javascript\" type='text/javascript'&gt;\n         * var board = JXG.JSXGraph.initBoard('jxgbox', {\n         *     axis:true,\n         *     boundingbox:[-5,5,5,-5],\n         *     fullscreen: { id: 'outer' },\n         *     showFullscreen: true\n         * });\n         * var p = board.create('point', [-2, 3], {});\n         * &lt;/script&gt;\n         *\n         * </pre><div id=\"JXG7103f6b_outer\" style='max-width: 500px; margin: 0 auto;'>\n         * <div id=\"JXG7103f6be-6993-4ff8-8133-c78e50a8afac\" class=\"jxgbox\" style=\"height: 0; padding-bottom: 100%;\"></div>\n         * </div>\n         * <button onClick=\"board_JXG7103f6be.toFullscreen('JXG7103f6b_outer')\">Fullscreen</button>\n         * <script type=\"text/javascript\">\n         *     var board_JXG7103f6be;\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG7103f6be-6993-4ff8-8133-c78e50a8afac',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, fullscreen: { id: 'JXG7103f6b_outer' }, showFullscreen: true,\n         *              showcopyright: false, shownavigation: false});\n         *     var p = board.create('point', [-2, 3], {});\n         *     board_JXG7103f6be = board;\n         *     })();\n         *\n         * </script><pre>\n         *\n         *\n         */\n        toFullscreen: function (id) {\n            var wrap_id,\n                wrap_node,\n                inner_node,\n                doc = this.document,\n                fullscreenElement;\n\n            id = id || this.container;\n            this._fullscreen_inner_id = id;\n            inner_node = doc.getElementById(id);\n            wrap_id = \"fullscreenwrap_\" + id;\n\n            // Wrap a div around the JSXGraph div.\n            if (doc.getElementById(wrap_id)) {\n                wrap_node = doc.getElementById(wrap_id);\n            } else {\n                wrap_node = document.createElement(\"div\");\n                wrap_node.classList.add(\"JXG_wrap_private\");\n                wrap_node.setAttribute(\"id\", wrap_id);\n                inner_node.parentNode.insertBefore(wrap_node, inner_node);\n                wrap_node.appendChild(inner_node);\n            }\n\n            // Get the real width and height of the JSXGraph div\n            // and determine the scaling and vertical shift amount\n            // this._fullscreen_res = Env._getScaleFactors(inner_node);\n\n            // Trigger fullscreen mode\n            wrap_node.requestFullscreen =\n                wrap_node.requestFullscreen ||\n                wrap_node.webkitRequestFullscreen ||\n                wrap_node.mozRequestFullScreen ||\n                wrap_node.msRequestFullscreen;\n\n            if (doc.fullscreenElement !== undefined) {\n                fullscreenElement = doc.fullscreenElement;\n            } else if (doc.webkitFullscreenElement !== undefined) {\n                fullscreenElement = doc.webkitFullscreenElement;\n            } else {\n                fullscreenElement = doc.msFullscreenElement;\n            }\n            if (fullscreenElement === null) {\n                // Start fullscreen mode\n                if (wrap_node.requestFullscreen) {\n                    wrap_node.requestFullscreen();\n                }\n            } else {\n                if (Type.exists(document.exitFullscreen)) {\n                    document.exitFullscreen();\n                } else if (Type.exists(document.webkitExitFullscreen)) {\n                    document.webkitExitFullscreen();\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * If fullscreen mode is toggled, the possible CSS transformations\n         * which are applied to the JSXGraph canvas have to be reread.\n         * Otherwise the position of upper left corner is wrongly interpreted.\n         *\n         * @param  {Object} evt fullscreen event object (unused)\n         */\n        fullscreenListener: function (evt) {\n            var inner_id,\n                inner_node,\n                fullscreenElement, // res,\n                doc = this.document;\n\n            inner_id = this._fullscreen_inner_id;\n            if (!Type.exists(inner_id)) {\n                return;\n            }\n\n            if (doc.fullscreenElement !== undefined) {\n                fullscreenElement = doc.fullscreenElement;\n            } else if (doc.webkitFullscreenElement !== undefined) {\n                fullscreenElement = doc.webkitFullscreenElement;\n            } else {\n                fullscreenElement = doc.msFullscreenElement;\n            }\n\n            inner_node = doc.getElementById(inner_id);\n            // If full screen mode is started we have to remove CSS margin around the JSXGraph div.\n            // Otherwise, the positioning of the fullscreen div will be false.\n            // When leaving the fullscreen mode, the margin is put back in.\n            if (fullscreenElement) {\n                // Just entered fullscreen mode\n\n                // Get the data computed in board.toFullscreen()\n                // res = this._fullscreen_res;\n\n                // Store the scaling data.\n                // It is used in AbstractRenderer.updateText to restore the scaling matrix\n                // which is removed by MathJax.\n                // Further, the CSS margin has to be removed when in fullscreen mode,\n                // and must be restored later.\n                inner_node._cssFullscreenStore = {\n                    id: fullscreenElement.id,\n                    isFullscreen: true,\n                    margin: inner_node.style.margin\n                    // width: inner_node.style.width\n                    // scale: res.scale,\n                    // vshift: res.vshift\n                };\n\n                inner_node.style.margin = \"\";\n                // inner_node.style.width = res.width + 'px';\n\n                // Do the shifting and scaling via CSS pseudo rules\n                // We do this after fullscreen mode has been established to get the correct size\n                // of the JSXGraph div.\n                Env.scaleJSXGraphDiv(fullscreenElement.id, inner_id, doc, Type.evaluate(this.attr.fullscreen.scale));\n\n                // Clear this.doc.fullscreenElement, because Safari doesn't to it and\n                // when leaving full screen mode it is still set.\n                fullscreenElement = null;\n            } else if (Type.exists(inner_node._cssFullscreenStore)) {\n                // Just left the fullscreen mode\n\n                // Remove the CSS rules added in Env.scaleJSXGraphDiv\n                try {\n                    doc.styleSheets[doc.styleSheets.length - 1].deleteRule(0);\n                } catch (err) {\n                    console.log(\"JSXGraph: Could not remove CSS rules for full screen mode\");\n                }\n\n                inner_node._cssFullscreenStore.isFullscreen = false;\n                inner_node.style.margin = inner_node._cssFullscreenStore.margin;\n                // inner_node.style.width = inner_node._cssFullscreenStore.width;\n            }\n\n            this.updateCSSTransforms();\n        },\n\n        /**\n         * Add user activity to the array \"board.userLog\".\n         * \n         * @param {String} type Event type, e.g. \"drag\"\n         * @param {Object} obj JSXGraph element object\n         * \n         * @see JXG.Board#userLog\n         * @return {JXG.Board} Reference to the board\n         */\n        addLogEntry: function(type, obj) {\n            var t,\n                id = obj.id,\n                last = this.userLog.length - 1;\n            if (Type.evaluate(this.attr.logging.enabled)) {\n                t = (new Date()).getTime();\n                if (last >= 0 &&\n                    this.userLog[last].type === type &&\n                    this.userLog[last].id === id &&\n                    // Distinguish consecutive drag events of\n                    // the same element\n                    t - this.userLog[last].end < 500) {\n\n                    this.userLog[last].end = t;\n                } else {\n                    this.userLog.push({\n                        type: type,\n                        id: id,\n                        start: t,\n                        end: t\n                    });\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Function to animate a curve rolling on another curve.\n         * @param {Curve} c1 JSXGraph curve building the floor where c2 rolls\n         * @param {Curve} c2 JSXGraph curve which rolls on c1.\n         * @param {number} start_c1 The parameter t such that c1(t) touches c2. This is the start position of the\n         *                          rolling process\n         * @param {Number} stepsize Increase in t in each step for the curve c1\n         * @param {Number} direction\n         * @param {Number} time Delay time for setInterval()\n         * @param {Array} pointlist Array of points which are rolled in each step. This list should contain\n         *      all points which define c2 and gliders on c2.\n         *\n         * @example\n         *\n         * // Line which will be the floor to roll upon.\n         * var line = brd.create('curve', [function (t) { return t;}, function (t){ return 1;}], {strokeWidth:6});\n         * // Center of the rolling circle\n         * var C = brd.create('point',[0,2],{name:'C'});\n         * // Starting point of the rolling circle\n         * var P = brd.create('point',[0,1],{name:'P', trace:true});\n         * // Circle defined as a curve. The circle \"starts\" at P, i.e. circle(0) = P\n         * var circle = brd.create('curve',[\n         *           function (t){var d = P.Dist(C),\n         *                           beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);\n         *                       t += beta;\n         *                       return C.X()+d*Math.cos(t);\n         *           },\n         *           function (t){var d = P.Dist(C),\n         *                           beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);\n         *                       t += beta;\n         *                       return C.Y()+d*Math.sin(t);\n         *           },\n         *           0,2*Math.PI],\n         *           {strokeWidth:6, strokeColor:'green'});\n         *\n         * // Point on circle\n         * var B = brd.create('glider',[0,2,circle],{name:'B', color:'blue',trace:false});\n         * var roll = brd.createRoulette(line, circle, 0, Math.PI/20, 1, 100, [C,P,B]);\n         * roll.start() // Start the rolling, to be stopped by roll.stop()\n         *\n         * </pre><div class=\"jxgbox\" id=\"JXGe5e1b53c-a036-4a46-9e35-190d196beca5\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         * var brd = JXG.JSXGraph.initBoard('JXGe5e1b53c-a036-4a46-9e35-190d196beca5', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright:false, shownavigation: false});\n         * // Line which will be the floor to roll upon.\n         * var line = brd.create('curve', [function (t) { return t;}, function (t){ return 1;}], {strokeWidth:6});\n         * // Center of the rolling circle\n         * var C = brd.create('point',[0,2],{name:'C'});\n         * // Starting point of the rolling circle\n         * var P = brd.create('point',[0,1],{name:'P', trace:true});\n         * // Circle defined as a curve. The circle \"starts\" at P, i.e. circle(0) = P\n         * var circle = brd.create('curve',[\n         *           function (t){var d = P.Dist(C),\n         *                           beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);\n         *                       t += beta;\n         *                       return C.X()+d*Math.cos(t);\n         *           },\n         *           function (t){var d = P.Dist(C),\n         *                           beta = JXG.Math.Geometry.rad([C.X()+1,C.Y()],C,P);\n         *                       t += beta;\n         *                       return C.Y()+d*Math.sin(t);\n         *           },\n         *           0,2*Math.PI],\n         *           {strokeWidth:6, strokeColor:'green'});\n         *\n         * // Point on circle\n         * var B = brd.create('glider',[0,2,circle],{name:'B', color:'blue',trace:false});\n         * var roll = brd.createRoulette(line, circle, 0, Math.PI/20, 1, 100, [C,P,B]);\n         * roll.start() // Start the rolling, to be stopped by roll.stop()\n         * </script><pre>\n         */\n        createRoulette: function (c1, c2, start_c1, stepsize, direction, time, pointlist) {\n            var brd = this,\n                Roulette = function () {\n                    var alpha = 0,\n                        Tx = 0,\n                        Ty = 0,\n                        t1 = start_c1,\n                        t2 = Numerics.root(\n                            function (t) {\n                                var c1x = c1.X(t1),\n                                    c1y = c1.Y(t1),\n                                    c2x = c2.X(t),\n                                    c2y = c2.Y(t);\n\n                                return (c1x - c2x) * (c1x - c2x) + (c1y - c2y) * (c1y - c2y);\n                            },\n                            [0, Math.PI * 2]\n                        ),\n                        t1_new = 0.0,\n                        t2_new = 0.0,\n                        c1dist,\n                        rotation = brd.create(\n                            \"transform\",\n                            [\n                                function () {\n                                    return alpha;\n                                }\n                            ],\n                            { type: \"rotate\" }\n                        ),\n                        rotationLocal = brd.create(\n                            \"transform\",\n                            [\n                                function () {\n                                    return alpha;\n                                },\n                                function () {\n                                    return c1.X(t1);\n                                },\n                                function () {\n                                    return c1.Y(t1);\n                                }\n                            ],\n                            { type: \"rotate\" }\n                        ),\n                        translate = brd.create(\n                            \"transform\",\n                            [\n                                function () {\n                                    return Tx;\n                                },\n                                function () {\n                                    return Ty;\n                                }\n                            ],\n                            { type: \"translate\" }\n                        ),\n                        // arc length via Simpson's rule.\n                        arclen = function (c, a, b) {\n                            var cpxa = Numerics.D(c.X)(a),\n                                cpya = Numerics.D(c.Y)(a),\n                                cpxb = Numerics.D(c.X)(b),\n                                cpyb = Numerics.D(c.Y)(b),\n                                cpxab = Numerics.D(c.X)((a + b) * 0.5),\n                                cpyab = Numerics.D(c.Y)((a + b) * 0.5),\n                                fa = Math.sqrt(cpxa * cpxa + cpya * cpya),\n                                fb = Math.sqrt(cpxb * cpxb + cpyb * cpyb),\n                                fab = Math.sqrt(cpxab * cpxab + cpyab * cpyab);\n\n                            return ((fa + 4 * fab + fb) * (b - a)) / 6;\n                        },\n                        exactDist = function (t) {\n                            return c1dist - arclen(c2, t2, t);\n                        },\n                        beta = Math.PI / 18,\n                        beta9 = beta * 9,\n                        interval = null;\n\n                    this.rolling = function () {\n                        var h, g, hp, gp, z;\n\n                        t1_new = t1 + direction * stepsize;\n\n                        // arc length between c1(t1) and c1(t1_new)\n                        c1dist = arclen(c1, t1, t1_new);\n\n                        // find t2_new such that arc length between c2(t2) and c1(t2_new) equals c1dist.\n                        t2_new = Numerics.root(exactDist, t2);\n\n                        // c1(t) as complex number\n                        h = new Complex(c1.X(t1_new), c1.Y(t1_new));\n\n                        // c2(t) as complex number\n                        g = new Complex(c2.X(t2_new), c2.Y(t2_new));\n\n                        hp = new Complex(Numerics.D(c1.X)(t1_new), Numerics.D(c1.Y)(t1_new));\n                        gp = new Complex(Numerics.D(c2.X)(t2_new), Numerics.D(c2.Y)(t2_new));\n\n                        // z is angle between the tangents of c1 at t1_new, and c2 at t2_new\n                        z = Complex.C.div(hp, gp);\n\n                        alpha = Math.atan2(z.imaginary, z.real);\n                        // Normalizing the quotient\n                        z.div(Complex.C.abs(z));\n                        z.mult(g);\n                        Tx = h.real - z.real;\n\n                        // T = h(t1_new)-g(t2_new)*h'(t1_new)/g'(t2_new);\n                        Ty = h.imaginary - z.imaginary;\n\n                        // -(10-90) degrees: make corners roll smoothly\n                        if (alpha < -beta && alpha > -beta9) {\n                            alpha = -beta;\n                            rotationLocal.applyOnce(pointlist);\n                        } else if (alpha > beta && alpha < beta9) {\n                            alpha = beta;\n                            rotationLocal.applyOnce(pointlist);\n                        } else {\n                            rotation.applyOnce(pointlist);\n                            translate.applyOnce(pointlist);\n                            t1 = t1_new;\n                            t2 = t2_new;\n                        }\n                        brd.update();\n                    };\n\n                    this.start = function () {\n                        if (time > 0) {\n                            interval = window.setInterval(this.rolling, time);\n                        }\n                        return this;\n                    };\n\n                    this.stop = function () {\n                        window.clearInterval(interval);\n                        return this;\n                    };\n                    return this;\n                };\n            return new Roulette();\n        }\n    }\n);\n\nexport default JXG.Board;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */\n/*jslint nomen: true, plusplus: true, newcap:true*/\n\nimport JXG from \"../jxg\";\nimport Options from \"../options\";\nimport AbstractRenderer from \"./abstract\";\nimport Const from \"../base/constants\";\nimport Type from \"../utils/type\";\nimport Color from \"../utils/color\";\nimport Base64 from \"../utils/base64\";\nimport Numerics from \"../math/numerics\";\n\n/**\n * Uses SVG to implement the rendering methods defined in {@link JXG.AbstractRenderer}.\n * @class JXG.SVGRenderer\n * @augments JXG.AbstractRenderer\n * @param {Node} container Reference to a DOM node containing the board.\n * @param {Object} dim The dimensions of the board\n * @param {Number} dim.width\n * @param {Number} dim.height\n * @see JXG.AbstractRenderer\n */\nJXG.SVGRenderer = function (container, dim) {\n    var i;\n\n    // docstring in AbstractRenderer\n    this.type = \"svg\";\n\n    this.isIE =\n        navigator.appVersion.indexOf(\"MSIE\") !== -1 || navigator.userAgent.match(/Trident\\//);\n\n    /**\n     * SVG root node\n     * @type Node\n     */\n    this.svgRoot = null;\n\n    /**\n     * The SVG Namespace used in JSXGraph.\n     * @see http://www.w3.org/TR/SVG/\n     * @type String\n     * @default http://www.w3.org/2000/svg\n     */\n    this.svgNamespace = \"http://www.w3.org/2000/svg\";\n\n    /**\n     * The xlink namespace. This is used for images.\n     * @see http://www.w3.org/TR/xlink/\n     * @type String\n     * @default http://www.w3.org/1999/xlink\n     */\n    this.xlinkNamespace = \"http://www.w3.org/1999/xlink\";\n\n    // container is documented in AbstractRenderer\n    this.container = container;\n\n    // prepare the div container and the svg root node for use with JSXGraph\n    this.container.style.MozUserSelect = \"none\";\n    this.container.style.userSelect = \"none\";\n\n    this.container.style.overflow = \"hidden\";\n    if (this.container.style.position === \"\") {\n        this.container.style.position = \"relative\";\n    }\n\n    this.svgRoot = this.container.ownerDocument.createElementNS(this.svgNamespace, \"svg\");\n    this.svgRoot.style.overflow = \"hidden\";\n    this.svgRoot.style.display = \"block\";\n\n    this.resize(dim.width, dim.height);\n\n    //this.svgRoot.setAttributeNS(null, 'shape-rendering', 'crispEdge'); //'optimizeQuality'); //geometricPrecision');\n\n    this.container.appendChild(this.svgRoot);\n\n    /**\n     * The <tt>defs</tt> element is a container element to reference reusable SVG elements.\n     * @type Node\n     * @see http://www.w3.org/TR/SVG/struct.html#DefsElement\n     */\n    this.defs = this.container.ownerDocument.createElementNS(this.svgNamespace, \"defs\");\n    this.svgRoot.appendChild(this.defs);\n\n        /**\n         * Filters are used to apply shadows.\n         * @type Node\n         * @see http://www.w3.org/TR/SVG/filters.html#FilterElement\n         */\n\n        /**\n         * Create an SVG shadow filter. If the object's RGB color is [r,g,b], it's opacity is op, and\n         * the parameter color is given as [r', g', b'] with opacity op'\n         * the shadow will have RGB color [blend*r + r', blend*g + g', blend*b + b'] and the opacity will be equal to op * op'.\n         * Further, blur and offset can be adjusted.\n         * \n         * The shadow color is [r*ble\n         * @param {String} id Node is of the filter.\n         * @param {Array|String} rgb RGB value for the blend color or the string 'none' for default values. Default 'black'.\n         * @param {Number} opacity Value between 0 and 1, default is 1.\n         * @param {Number} blend  Value between 0 and 1, default is 0.1.\n         * @param {Number} blur  Default: 3\n         * @param {Array} offset [dx, dy]. Default is [5,5].\n         * @returns DOM node to be added to this.defs.\n         * @private\n         */\n        this.createShadowFilter = function(id, rgb, opacity, blend, blur, offset) {\n            var filter = this.container.ownerDocument.createElementNS(this.svgNamespace, 'filter'),\n                feOffset, feColor, feGaussianBlur, feBlend,\n                mat;\n\n            filter.setAttributeNS(null, 'id', id);\n            filter.setAttributeNS(null, 'width', '300%');\n            filter.setAttributeNS(null, 'height', '300%');\n            filter.setAttributeNS(null, 'filterUnits', 'userSpaceOnUse');\n\n            feOffset = this.container.ownerDocument.createElementNS(this.svgNamespace, 'feOffset');\n            feOffset.setAttributeNS(null, 'in', 'SourceGraphic'); // b/w: SourceAlpha, Color: SourceGraphic\n            feOffset.setAttributeNS(null, 'result', 'offOut');\n            feOffset.setAttributeNS(null, 'dx', offset[0]);\n            feOffset.setAttributeNS(null, 'dy', offset[1]);\n            filter.appendChild(feOffset);\n\n            feColor = this.container.ownerDocument.createElementNS(this.svgNamespace, 'feColorMatrix');\n            feColor.setAttributeNS(null, 'in', 'offOut');\n            feColor.setAttributeNS(null, 'result', 'colorOut');\n            feColor.setAttributeNS(null, 'type', 'matrix');\n            // See https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feColorMatrix\n            if (rgb === 'none' || !Type.isArray(rgb) || rgb.length < 3) {\n                feColor.setAttributeNS(null, 'values', '0.1 0 0 0 0  0 0.1 0 0 0  0 0 0.1 0 0  0 0 0 ' + opacity + ' 0');\n            } else {\n                rgb[0] /= 255;\n                rgb[1] /= 255;\n                rgb[2] /= 255;\n                mat = blend + ' 0 0 0 ' + rgb[0] +\n                          '  0 ' + blend + ' 0 0 ' + rgb[1] +\n                          '  0 0 ' + blend + ' 0 ' + rgb[2] +\n                          '  0 0 0 ' + opacity + ' 0';\n                feColor.setAttributeNS(null, 'values', mat);\n            }\n            filter.appendChild(feColor);\n\n            feGaussianBlur = this.container.ownerDocument.createElementNS(this.svgNamespace, 'feGaussianBlur');\n            feGaussianBlur.setAttributeNS(null, 'in', 'colorOut');\n            feGaussianBlur.setAttributeNS(null, 'result', 'blurOut');\n            feGaussianBlur.setAttributeNS(null, 'stdDeviation', blur);\n            filter.appendChild(feGaussianBlur);\n\n            feBlend = this.container.ownerDocument.createElementNS(this.svgNamespace, 'feBlend');\n            feBlend.setAttributeNS(null, 'in', 'SourceGraphic');\n            feBlend.setAttributeNS(null, 'in2', 'blurOut');\n            feBlend.setAttributeNS(null, 'mode', 'normal');\n            filter.appendChild(feBlend);\n\n            return filter;\n        };\n        /* Default shadow filter */\n        this.defs.appendChild(this.createShadowFilter(this.container.id + '_' + 'f1', 'none', 1, 0.1, 3, [5, 5]));\n\n        /**\n         * JSXGraph uses a layer system to sort the elements on the board. This puts certain types of elements in front\n         * of other types of elements. For the order used see {@link JXG.Options.layer}. The number of layers is documented\n         * there, too. The higher the number, the \"more on top\" are the elements on this layer.\n         * @type Array\n         */\n        this.layer = [];\n        for (i = 0; i < Options.layer.numlayers; i++) {\n            this.layer[i] = this.container.ownerDocument.createElementNS(this.svgNamespace, 'g');\n            this.svgRoot.appendChild(this.layer[i]);\n        }\n\n    // Already documented in JXG.AbstractRenderer\n    this.supportsForeignObject = document.implementation.hasFeature(\n        \"http://w3.org/TR/SVG11/feature#Extensibility\",\n        \"1.1\"\n    );\n\n    if (this.supportsForeignObject) {\n        this.foreignObjLayer = this.container.ownerDocument.createElementNS(\n            this.svgNamespace,\n            \"foreignObject\"\n        );\n        this.foreignObjLayer.setAttribute(\"display\", \"none\");\n        this.foreignObjLayer.setAttribute(\"x\", 0);\n        this.foreignObjLayer.setAttribute(\"y\", 0);\n        this.foreignObjLayer.setAttribute(\"width\", \"100%\");\n        this.foreignObjLayer.setAttribute(\"height\", \"100%\");\n        this.foreignObjLayer.setAttribute(\"id\", this.container.id + \"_foreignObj\");\n        this.svgRoot.appendChild(this.foreignObjLayer);\n    }\n\n    /**\n     * Defines dash patterns. Defined styles are: <ol>\n     * <li value=\"-1\"> 2px dash, 2px space</li>\n     * <li> 5px dash, 5px space</li>\n     * <li> 10px dash, 10px space</li>\n     * <li> 20px dash, 20px space</li>\n     * <li> 20px dash, 10px space, 10px dash, 10px dash</li>\n     * <li> 20px dash, 5px space, 10px dash, 5px space</li></ol>\n     * @type Array\n     * @default ['2, 2', '5, 5', '10, 10', '20, 20', '20, 10, 10, 10', '20, 5, 10, 5']\n     * @see http://www.w3.org/TR/SVG/painting.html#StrokeProperties\n     */\n    this.dashArray = [\"2, 2\", \"5, 5\", \"10, 10\", \"20, 20\", \"20, 10, 10, 10\", \"20, 5, 10, 5\"];\n};\n\nJXG.SVGRenderer.prototype = new AbstractRenderer();\n\nJXG.extend(\n    JXG.SVGRenderer.prototype,\n    /** @lends JXG.SVGRenderer.prototype */ {\n        /**\n         * Creates an arrow DOM node. Arrows are displayed in SVG with a <em>marker</em> tag.\n         * @private\n         * @param {JXG.GeometryElement} el A JSXGraph element, preferably one that can have an arrow attached.\n         * @param {String} [idAppendix=''] A string that is added to the node's id.\n         * @returns {Node} Reference to the node added to the DOM.\n         */\n        _createArrowHead: function (el, idAppendix, type) {\n            var node2,\n                node3,\n                id = el.id + \"Triangle\",\n                //type = null,\n                v,\n                h;\n\n            if (Type.exists(idAppendix)) {\n                id += idAppendix;\n            }\n            node2 = this.createPrim(\"marker\", id);\n\n            node2.setAttributeNS(null, \"stroke\", Type.evaluate(el.visProp.strokecolor));\n            node2.setAttributeNS(\n                null,\n                \"stroke-opacity\",\n                Type.evaluate(el.visProp.strokeopacity)\n            );\n            node2.setAttributeNS(null, \"fill\", Type.evaluate(el.visProp.strokecolor));\n            node2.setAttributeNS(null, \"fill-opacity\", Type.evaluate(el.visProp.strokeopacity));\n            node2.setAttributeNS(null, \"stroke-width\", 0); // this is the stroke-width of the arrow head.\n            // Should be zero to simplify the calculations\n\n            node2.setAttributeNS(null, \"orient\", \"auto\");\n            node2.setAttributeNS(null, \"markerUnits\", \"strokeWidth\"); // 'strokeWidth' 'userSpaceOnUse');\n\n            /*\n               Types 1, 2:\n               The arrow head is an isosceles triangle with base length 10 and height 10.\n\n               Type 3:\n               A rectangle\n\n               Types 4, 5, 6:\n               Defined by Bezier curves from mp_arrowheads.html\n\n               In any case but type 3 the arrow head is 10 units long,\n               type 3 is 10 unitsb high.\n               These 10 units are scaled to strokeWidth * arrowSize pixels, see\n               this._setArrowWidth().\n\n               See also abstractRenderer.updateLine() where the line path is shortened accordingly.\n\n               Changes here are also necessary in setArrowWidth().\n\n               So far, lines with arrow heads are shortenend to avoid overlapping of\n               arrow head and line. This is not the case for curves, yet.\n               Therefore, the offset refX has to be adapted to the path type.\n            */\n            node3 = this.container.ownerDocument.createElementNS(this.svgNamespace, \"path\");\n            h = 5;\n            if (idAppendix === \"End\") {\n                // First arrow\n                //type = a.typeFirst;\n                // if (JXG.exists(ev_fa.type)) {\n                //     type = Type.evaluate(ev_fa.type);\n                // }\n\n                v = 0;\n                if (type === 2) {\n                    node3.setAttributeNS(null, \"d\", \"M 10,0 L 0,5 L 10,10 L 5,5 z\");\n                } else if (type === 3) {\n                    node3.setAttributeNS(null, \"d\", \"M 0,0 L 3.33,0 L 3.33,10 L 0,10 z\");\n                } else if (type === 4) {\n                    // insetRatio:0.8 tipAngle:45 wingCurve:15 tailCurve:0\n                    h = 3.31;\n                    node3.setAttributeNS(\n                        null,\n                        \"d\",\n                        \"M 0.00,3.31 C 3.53,3.84 7.13,4.50 10.00,6.63 C 9.33,5.52 8.67,4.42 8.00,3.31 C 8.67,2.21 9.33,1.10 10.00,0.00 C 7.13,2.13 3.53,2.79 0.00,3.31\"\n                    );\n                } else if (type === 5) {\n                    // insetRatio:0.9 tipAngle:40 wingCurve:5 tailCurve:15\n                    h = 3.28;\n                    node3.setAttributeNS(\n                        null,\n                        \"d\",\n                        \"M 0.00,3.28 C 3.39,4.19 6.81,5.07 10.00,6.55 C 9.38,5.56 9.00,4.44 9.00,3.28 C 9.00,2.11 9.38,0.99 10.00,0.00 C 6.81,1.49 3.39,2.37 0.00,3.28\"\n                    );\n                } else if (type === 6) {\n                    // insetRatio:0.9 tipAngle:35 wingCurve:5 tailCurve:0\n                    h = 2.84;\n                    node3.setAttributeNS(\n                        null,\n                        \"d\",\n                        \"M 0.00,2.84 C 3.39,3.59 6.79,4.35 10.00,5.68 C 9.67,4.73 9.33,3.78 9.00,2.84 C 9.33,1.89 9.67,0.95 10.00,0.00 C 6.79,1.33 3.39,2.09 0.00,2.84\"\n                    );\n                } else if (type === 7) {\n                    // insetRatio:0.9 tipAngle:60 wingCurve:30 tailCurve:0\n                    h = 5.2;\n                    node3.setAttributeNS(\n                        null,\n                        \"d\",\n                        \"M 0.00,5.20 C 4.04,5.20 7.99,6.92 10.00,10.39 M 10.00,0.00 C 7.99,3.47 4.04,5.20 0.00,5.20\"\n                    );\n                } else {\n                    // type == 1 or > 6\n                    node3.setAttributeNS(null, \"d\", \"M 10,0 L 0,5 L 10,10 z\");\n                }\n                if (\n                    // !Type.exists(el.rendNode.getTotalLength) &&\n                    el.elementClass === Const.OBJECT_CLASS_LINE\n                ) {\n                    if (type === 2) {\n                        v = 4.9;\n                    } else if (type === 3) {\n                        v = 3.3;\n                    } else if (type === 4 || type === 5 || type === 6) {\n                        v = 6.66;\n                    } else if (type === 7) {\n                        v = 0.0;\n                    } else {\n                        v = 10.0;\n                    }\n                }\n            } else {\n                // Last arrow\n                // if (JXG.exists(ev_la.type)) {\n                //     type = Type.evaluate(ev_la.type);\n                // }\n                //type = a.typeLast;\n\n                v = 10.0;\n                if (type === 2) {\n                    node3.setAttributeNS(null, \"d\", \"M 0,0 L 10,5 L 0,10 L 5,5 z\");\n                } else if (type === 3) {\n                    v = 3.3;\n                    node3.setAttributeNS(null, \"d\", \"M 0,0 L 3.33,0 L 3.33,10 L 0,10 z\");\n                } else if (type === 4) {\n                    // insetRatio:0.8 tipAngle:45 wingCurve:15 tailCurve:0\n                    h = 3.31;\n                    node3.setAttributeNS(\n                        null,\n                        \"d\",\n                        \"M 10.00,3.31 C 6.47,3.84 2.87,4.50 0.00,6.63 C 0.67,5.52 1.33,4.42 2.00,3.31 C 1.33,2.21 0.67,1.10 0.00,0.00 C 2.87,2.13 6.47,2.79 10.00,3.31\"\n                    );\n                } else if (type === 5) {\n                    // insetRatio:0.9 tipAngle:40 wingCurve:5 tailCurve:15\n                    h = 3.28;\n                    node3.setAttributeNS(\n                        null,\n                        \"d\",\n                        \"M 10.00,3.28 C 6.61,4.19 3.19,5.07 0.00,6.55 C 0.62,5.56 1.00,4.44 1.00,3.28 C 1.00,2.11 0.62,0.99 0.00,0.00 C 3.19,1.49 6.61,2.37 10.00,3.28\"\n                    );\n                } else if (type === 6) {\n                    // insetRatio:0.9 tipAngle:35 wingCurve:5 tailCurve:0\n                    h = 2.84;\n                    node3.setAttributeNS(\n                        null,\n                        \"d\",\n                        \"M 10.00,2.84 C 6.61,3.59 3.21,4.35 0.00,5.68 C 0.33,4.73 0.67,3.78 1.00,2.84 C 0.67,1.89 0.33,0.95 0.00,0.00 C 3.21,1.33 6.61,2.09 10.00,2.84\"\n                    );\n                } else if (type === 7) {\n                    // insetRatio:0.9 tipAngle:60 wingCurve:30 tailCurve:0\n                    h = 5.2;\n                    node3.setAttributeNS(\n                        null,\n                        \"d\",\n                        \"M 10.00,5.20 C 5.96,5.20 2.01,6.92 0.00,10.39 M 0.00,0.00 C 2.01,3.47 5.96,5.20 10.00,5.20\"\n                    );\n                } else {\n                    // type == 1 or > 6\n                    node3.setAttributeNS(null, \"d\", \"M 0,0 L 10,5 L 0,10 z\");\n                }\n                if (\n                    // !Type.exists(el.rendNode.getTotalLength) &&\n                    el.elementClass === Const.OBJECT_CLASS_LINE\n                ) {\n                    if (type === 2) {\n                        v = 5.1;\n                    } else if (type === 3) {\n                        v = 0.02;\n                    } else if (type === 4 || type === 5 || type === 6) {\n                        v = 3.33;\n                    } else if (type === 7) {\n                        v = 10.0;\n                    } else {\n                        v = 0.05;\n                    }\n                }\n            }\n            if (type === 7) {\n                node2.setAttributeNS(null, \"fill\", \"none\");\n                node2.setAttributeNS(null, \"stroke-width\", 1); // this is the stroke-width of the arrow head.\n            }\n            node2.setAttributeNS(null, \"refY\", h);\n            node2.setAttributeNS(null, \"refX\", v);\n\n            node2.appendChild(node3);\n            return node2;\n        },\n\n        /**\n         * Updates color of an arrow DOM node.\n         * @param {Node} node The arrow node.\n         * @param {String} color Color value in a HTML compatible format, e.g. <tt>#00ff00</tt> or <tt>green</tt> for green.\n         * @param {Number} opacity\n         * @param {JXG.GeometryElement} el The element the arrows are to be attached to\n         */\n        _setArrowColor: function (node, color, opacity, el, type) {\n            if (node) {\n                if (Type.isString(color)) {\n                    if (type !== 7) {\n                        this._setAttribute(function () {\n                            node.setAttributeNS(null, \"stroke\", color);\n                            node.setAttributeNS(null, \"fill\", color);\n                            node.setAttributeNS(null, \"stroke-opacity\", opacity);\n                            node.setAttributeNS(null, \"fill-opacity\", opacity);\n                        }, el.visPropOld.fillcolor);\n                    } else {\n                        this._setAttribute(function () {\n                            node.setAttributeNS(null, \"fill\", \"none\");\n                            node.setAttributeNS(null, \"stroke\", color);\n                            node.setAttributeNS(null, \"stroke-opacity\", opacity);\n                        }, el.visPropOld.fillcolor);\n                    }\n                }\n\n                if (this.isIE) {\n                    el.rendNode.parentNode.insertBefore(el.rendNode, el.rendNode);\n                }\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        _setArrowWidth: function (node, width, parentNode, size) {\n            var s, d;\n\n            if (node) {\n                // if (width === 0) {\n                //     // display:none does not work well in webkit\n                //     node.setAttributeNS(null, 'display', 'none');\n                // } else {\n                s = width;\n                d = s * size;\n                node.setAttributeNS(null, \"viewBox\", 0 + \" \" + 0 + \" \" + s * 10 + \" \" + s * 10);\n                node.setAttributeNS(null, \"markerHeight\", d);\n                node.setAttributeNS(null, \"markerWidth\", d);\n                node.setAttributeNS(null, \"display\", \"inherit\");\n                // }\n\n                if (this.isIE) {\n                    parentNode.parentNode.insertBefore(parentNode, parentNode);\n                }\n            }\n        },\n\n        /* ******************************** *\n         *  This renderer does not need to\n         *  override draw/update* methods\n         *  since it provides draw/update*Prim\n         *  methods except for some cases like\n         *  internal texts or images.\n         * ******************************** */\n\n        /* **************************\n         *    Lines\n         * **************************/\n\n        // documented in AbstractRenderer\n        updateTicks: function (ticks) {\n            var i,\n                j,\n                c,\n                node,\n                x,\n                y,\n                tickStr = \"\",\n                len = ticks.ticks.length,\n                len2,\n                str,\n                isReal = true;\n\n            for (i = 0; i < len; i++) {\n                c = ticks.ticks[i];\n                x = c[0];\n                y = c[1];\n\n                len2 = x.length;\n                str = \" M \" + x[0] + \" \" + y[0];\n                if (!Type.isNumber(x[0])) {\n                    isReal = false;\n                }\n                for (j = 1; isReal && j < len2; ++j) {\n                    if (Type.isNumber(x[j])) {\n                        str += \" L \" + x[j] + \" \" + y[j];\n                    } else {\n                        isReal = false;\n                    }\n                }\n                if (isReal) {\n                    tickStr += str;\n                }\n            }\n\n            node = ticks.rendNode;\n\n            if (!Type.exists(node)) {\n                node = this.createPrim(\"path\", ticks.id);\n                this.appendChildPrim(node, Type.evaluate(ticks.visProp.layer));\n                ticks.rendNode = node;\n            }\n\n            node.setAttributeNS(null, \"stroke\", Type.evaluate(ticks.visProp.strokecolor));\n            node.setAttributeNS(null, \"fill\", \"none\");\n            // node.setAttributeNS(null, 'fill', Type.evaluate(ticks.visProp.fillcolor));\n            // node.setAttributeNS(null, 'fill-opacity', Type.evaluate(ticks.visProp.fillopacity));\n            node.setAttributeNS(\n                null,\n                \"stroke-opacity\",\n                Type.evaluate(ticks.visProp.strokeopacity)\n            );\n            node.setAttributeNS(null, \"stroke-width\", Type.evaluate(ticks.visProp.strokewidth));\n            this.updatePathPrim(node, tickStr, ticks.board);\n        },\n\n        /* **************************\n         *    Text related stuff\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        displayCopyright: function (str, fontsize) {\n            var node = this.createPrim(\"text\", \"licenseText\"),\n                t;\n            node.setAttributeNS(null, \"x\", \"20px\");\n            node.setAttributeNS(null, \"y\", 2 + fontsize + \"px\");\n            node.setAttributeNS(\n                null,\n                \"style\",\n                \"font-family:Arial,Helvetica,sans-serif; font-size:\" +\n                    fontsize +\n                    \"px; fill:#356AA0;  opacity:0.3;\"\n            );\n            t = this.container.ownerDocument.createTextNode(str);\n            node.appendChild(t);\n            this.appendChildPrim(node, 0);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        drawInternalText: function (el) {\n            var node = this.createPrim(\"text\", el.id);\n\n            //node.setAttributeNS(null, \"style\", \"alignment-baseline:middle\"); // Not yet supported by Firefox\n            // Preserve spaces\n            //node.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"space\", \"preserve\");\n            node.style.whiteSpace = \"nowrap\";\n\n            el.rendNodeText = this.container.ownerDocument.createTextNode(\"\");\n            node.appendChild(el.rendNodeText);\n            this.appendChildPrim(node, Type.evaluate(el.visProp.layer));\n\n            return node;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateInternalText: function (el) {\n            var content = el.plaintext,\n                v,\n                ev_ax = el.getAnchorX(),\n                ev_ay = el.getAnchorY();\n\n            if (el.rendNode.getAttributeNS(null, \"class\") !== el.visProp.cssclass) {\n                el.rendNode.setAttributeNS(null, \"class\", Type.evaluate(el.visProp.cssclass));\n                el.needsSizeUpdate = true;\n            }\n\n            if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {\n                // Horizontal\n                v = el.coords.scrCoords[1];\n                if (el.visPropOld.left !== ev_ax + v) {\n                    el.rendNode.setAttributeNS(null, \"x\", v + \"px\");\n\n                    if (ev_ax === \"left\") {\n                        el.rendNode.setAttributeNS(null, \"text-anchor\", \"start\");\n                    } else if (ev_ax === \"right\") {\n                        el.rendNode.setAttributeNS(null, \"text-anchor\", \"end\");\n                    } else if (ev_ax === \"middle\") {\n                        el.rendNode.setAttributeNS(null, \"text-anchor\", \"middle\");\n                    }\n                    el.visPropOld.left = ev_ax + v;\n                }\n\n                // Vertical\n                v = el.coords.scrCoords[2];\n                if (el.visPropOld.top !== ev_ay + v) {\n                    el.rendNode.setAttributeNS(null, \"y\", v + this.vOffsetText * 0.5 + \"px\");\n\n                    if (ev_ay === \"bottom\") {\n                        el.rendNode.setAttributeNS(\n                            null,\n                            \"dominant-baseline\",\n                            \"text-after-edge\"\n                        );\n                    } else if (ev_ay === \"top\") {\n                        el.rendNode.setAttributeNS(null, \"dy\", \"1.6ex\");\n                        //el.rendNode.setAttributeNS(null, 'dominant-baseline', 'text-before-edge'); // Not supported by IE, edge\n                    } else if (ev_ay === \"middle\") {\n                        //el.rendNode.setAttributeNS(null, 'dominant-baseline', 'middle');\n                        el.rendNode.setAttributeNS(null, \"dy\", \"0.6ex\");\n                    }\n                    el.visPropOld.top = ev_ay + v;\n                }\n            }\n            if (el.htmlStr !== content) {\n                el.rendNodeText.data = content;\n                el.htmlStr = content;\n            }\n            this.transformImage(el, el.transformations);\n        },\n\n        /**\n         * Set color and opacity of internal texts.\n         * SVG needs its own version.\n         * @private\n         * @see JXG.AbstractRenderer#updateTextStyle\n         * @see JXG.AbstractRenderer#updateInternalTextStyle\n         */\n        updateInternalTextStyle: function (el, strokeColor, strokeOpacity, duration) {\n            this.setObjectFillColor(el, strokeColor, strokeOpacity);\n        },\n\n        /* **************************\n         *    Image related stuff\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        drawImage: function (el) {\n            var node = this.createPrim(\"image\", el.id);\n\n            node.setAttributeNS(null, \"preserveAspectRatio\", \"none\");\n            this.appendChildPrim(node, Type.evaluate(el.visProp.layer));\n            el.rendNode = node;\n\n            this.updateImage(el);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        transformImage: function (el, t) {\n            var s,\n                m,\n                node = el.rendNode,\n                str = \"\",\n                len = t.length;\n\n            if (len > 0) {\n                m = this.joinTransforms(el, t);\n                s = [m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]].join(\",\");\n                str += \" matrix(\" + s + \") \";\n                node.setAttributeNS(null, \"transform\", str);\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateImageURL: function (el) {\n            var url = Type.evaluate(el.url);\n\n            if (el._src !== url) {\n                el.imgIsLoaded = false;\n                el.rendNode.setAttributeNS(this.xlinkNamespace, \"xlink:href\", url);\n                el._src = url;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateImageStyle: function (el, doHighlight) {\n            var css = Type.evaluate(\n                doHighlight ? el.visProp.highlightcssclass : el.visProp.cssclass\n            );\n\n            el.rendNode.setAttributeNS(null, \"class\", css);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        drawForeignObject: function (el) {\n            el.rendNode = this.appendChildPrim(\n                this.createPrim(\"foreignObject\", el.id),\n                Type.evaluate(el.visProp.layer)\n            );\n\n            this.appendNodesToElement(el, \"foreignObject\");\n            this.updateForeignObject(el);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateForeignObject: function (el) {\n            if (el._useUserSize) {\n                el.rendNode.style.overflow = \"hidden\";\n            } else {\n                el.rendNode.style.overflow = \"visible\";\n            }\n\n            this.updateRectPrim(\n                el.rendNode,\n                el.coords.scrCoords[1],\n                el.coords.scrCoords[2] - el.size[1],\n                el.size[0],\n                el.size[1]\n            );\n\n            el.rendNode.innerHTML = el.content;\n            this._updateVisual(el, { stroke: true, dash: true }, true);\n        },\n\n        /* **************************\n         * Render primitive objects\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        appendChildPrim: function (node, level) {\n            if (!Type.exists(level)) {\n                // trace nodes have level not set\n                level = 0;\n            } else if (level >= Options.layer.numlayers) {\n                level = Options.layer.numlayers - 1;\n            }\n\n            this.layer[level].appendChild(node);\n\n            return node;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        createPrim: function (type, id) {\n            var node = this.container.ownerDocument.createElementNS(this.svgNamespace, type);\n            node.setAttributeNS(null, \"id\", this.container.id + \"_\" + id);\n            node.style.position = \"absolute\";\n            if (type === \"path\") {\n                node.setAttributeNS(null, \"stroke-linecap\", \"round\");\n                node.setAttributeNS(null, \"stroke-linejoin\", \"round\");\n                node.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n            }\n            return node;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        remove: function (shape) {\n            if (Type.exists(shape) && Type.exists(shape.parentNode)) {\n                shape.parentNode.removeChild(shape);\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        setLayer: function (el, level) {\n            if (!Type.exists(level)) {\n                level = 0;\n            } else if (level >= Options.layer.numlayers) {\n                level = Options.layer.numlayers - 1;\n            }\n\n            this.layer[level].appendChild(el.rendNode);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        makeArrows: function (el, a) {\n            var node2,\n                ev_fa = a.evFirst,\n                ev_la = a.evLast;\n\n            // Test if the arrow heads already exist\n            if (el.visPropOld.firstarrow === ev_fa && el.visPropOld.lastarrow === ev_la) {\n                if (this.isIE && el.visPropCalc.visible && (ev_fa || ev_la)) {\n                    el.rendNode.parentNode.insertBefore(el.rendNode, el.rendNode);\n                }\n                return;\n            }\n\n            if (ev_fa) {\n                node2 = el.rendNodeTriangleStart;\n                if (!Type.exists(node2)) {\n                    node2 = this._createArrowHead(el, \"End\", a.typeFirst);\n                    this.defs.appendChild(node2);\n                    el.rendNodeTriangleStart = node2;\n                    el.rendNode.setAttributeNS(\n                        null,\n                        \"marker-start\",\n                        \"url(#\" + this.container.id + \"_\" + el.id + \"TriangleEnd)\"\n                    );\n                } else {\n                    this.defs.appendChild(node2);\n                }\n            } else {\n                node2 = el.rendNodeTriangleStart;\n                if (Type.exists(node2)) {\n                    this.remove(node2);\n                }\n            }\n            if (ev_la) {\n                node2 = el.rendNodeTriangleEnd;\n                if (!Type.exists(node2)) {\n                    node2 = this._createArrowHead(el, \"Start\", a.typeLast);\n                    this.defs.appendChild(node2);\n                    el.rendNodeTriangleEnd = node2;\n                    el.rendNode.setAttributeNS(\n                        null,\n                        \"marker-end\",\n                        \"url(#\" + this.container.id + \"_\" + el.id + \"TriangleStart)\"\n                    );\n                } else {\n                    this.defs.appendChild(node2);\n                }\n            } else {\n                node2 = el.rendNodeTriangleEnd;\n                if (Type.exists(node2)) {\n                    this.remove(node2);\n                }\n            }\n            el.visPropOld.firstarrow = ev_fa;\n            el.visPropOld.lastarrow = ev_la;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateEllipsePrim: function (node, x, y, rx, ry) {\n            var huge = 1000000;\n\n            huge = 200000; // IE\n            // webkit does not like huge values if the object is dashed\n            // iE doesn't like huge values above 216000\n            x = Math.abs(x) < huge ? x : (huge * x) / Math.abs(x);\n            y = Math.abs(y) < huge ? y : (huge * y) / Math.abs(y);\n            rx = Math.abs(rx) < huge ? rx : (huge * rx) / Math.abs(rx);\n            ry = Math.abs(ry) < huge ? ry : (huge * ry) / Math.abs(ry);\n\n            node.setAttributeNS(null, \"cx\", x);\n            node.setAttributeNS(null, \"cy\", y);\n            node.setAttributeNS(null, \"rx\", Math.abs(rx));\n            node.setAttributeNS(null, \"ry\", Math.abs(ry));\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateLinePrim: function (node, p1x, p1y, p2x, p2y) {\n            var huge = 1000000;\n\n            huge = 200000; //IE\n            if (!isNaN(p1x + p1y + p2x + p2y)) {\n                // webkit does not like huge values if the object is dashed\n                // IE doesn't like huge values above 216000\n                p1x = Math.abs(p1x) < huge ? p1x : (huge * p1x) / Math.abs(p1x);\n                p1y = Math.abs(p1y) < huge ? p1y : (huge * p1y) / Math.abs(p1y);\n                p2x = Math.abs(p2x) < huge ? p2x : (huge * p2x) / Math.abs(p2x);\n                p2y = Math.abs(p2y) < huge ? p2y : (huge * p2y) / Math.abs(p2y);\n\n                node.setAttributeNS(null, \"x1\", p1x);\n                node.setAttributeNS(null, \"y1\", p1y);\n                node.setAttributeNS(null, \"x2\", p2x);\n                node.setAttributeNS(null, \"y2\", p2y);\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathPrim: function (node, pointString) {\n            if (pointString === \"\") {\n                pointString = \"M 0 0\";\n            }\n            node.setAttributeNS(null, \"d\", pointString);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathStringPoint: function (el, size, type) {\n            var s = \"\",\n                scr = el.coords.scrCoords,\n                sqrt32 = size * Math.sqrt(3) * 0.5,\n                s05 = size * 0.5;\n\n            if (type === \"x\") {\n                s =\n                    \" M \" +\n                    (scr[1] - size) +\n                    \" \" +\n                    (scr[2] - size) +\n                    \" L \" +\n                    (scr[1] + size) +\n                    \" \" +\n                    (scr[2] + size) +\n                    \" M \" +\n                    (scr[1] + size) +\n                    \" \" +\n                    (scr[2] - size) +\n                    \" L \" +\n                    (scr[1] - size) +\n                    \" \" +\n                    (scr[2] + size);\n            } else if (type === \"+\") {\n                s =\n                    \" M \" +\n                    (scr[1] - size) +\n                    \" \" +\n                    scr[2] +\n                    \" L \" +\n                    (scr[1] + size) +\n                    \" \" +\n                    scr[2] +\n                    \" M \" +\n                    scr[1] +\n                    \" \" +\n                    (scr[2] - size) +\n                    \" L \" +\n                    scr[1] +\n                    \" \" +\n                    (scr[2] + size);\n            } else if (type === \"<>\") {\n                s =\n                    \" M \" +\n                    (scr[1] - size) +\n                    \" \" +\n                    scr[2] +\n                    \" L \" +\n                    scr[1] +\n                    \" \" +\n                    (scr[2] + size) +\n                    \" L \" +\n                    (scr[1] + size) +\n                    \" \" +\n                    scr[2] +\n                    \" L \" +\n                    scr[1] +\n                    \" \" +\n                    (scr[2] - size) +\n                    \" Z \";\n            } else if (type === \"^\") {\n                s =\n                    \" M \" +\n                    scr[1] +\n                    \" \" +\n                    (scr[2] - size) +\n                    \" L \" +\n                    (scr[1] - sqrt32) +\n                    \" \" +\n                    (scr[2] + s05) +\n                    \" L \" +\n                    (scr[1] + sqrt32) +\n                    \" \" +\n                    (scr[2] + s05) +\n                    \" Z \"; // close path\n            } else if (type === \"v\") {\n                s =\n                    \" M \" +\n                    scr[1] +\n                    \" \" +\n                    (scr[2] + size) +\n                    \" L \" +\n                    (scr[1] - sqrt32) +\n                    \" \" +\n                    (scr[2] - s05) +\n                    \" L \" +\n                    (scr[1] + sqrt32) +\n                    \" \" +\n                    (scr[2] - s05) +\n                    \" Z \";\n            } else if (type === \">\") {\n                s =\n                    \" M \" +\n                    (scr[1] + size) +\n                    \" \" +\n                    scr[2] +\n                    \" L \" +\n                    (scr[1] - s05) +\n                    \" \" +\n                    (scr[2] - sqrt32) +\n                    \" L \" +\n                    (scr[1] - s05) +\n                    \" \" +\n                    (scr[2] + sqrt32) +\n                    \" Z \";\n            } else if (type === \"<\") {\n                s =\n                    \" M \" +\n                    (scr[1] - size) +\n                    \" \" +\n                    scr[2] +\n                    \" L \" +\n                    (scr[1] + s05) +\n                    \" \" +\n                    (scr[2] - sqrt32) +\n                    \" L \" +\n                    (scr[1] + s05) +\n                    \" \" +\n                    (scr[2] + sqrt32) +\n                    \" Z \";\n            }\n            return s;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathStringPrim: function (el) {\n            var i,\n                scr,\n                len,\n                symbm = \" M \",\n                symbl = \" L \",\n                symbc = \" C \",\n                nextSymb = symbm,\n                maxSize = 5000.0,\n                pStr = \"\";\n\n            if (el.numberPoints <= 0) {\n                return \"\";\n            }\n\n            len = Math.min(el.points.length, el.numberPoints);\n\n            if (el.bezierDegree === 1) {\n                for (i = 0; i < len; i++) {\n                    scr = el.points[i].scrCoords;\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        // Chrome has problems with values being too far away.\n                        scr[1] = Math.max(Math.min(scr[1], maxSize), -maxSize);\n                        scr[2] = Math.max(Math.min(scr[2], maxSize), -maxSize);\n\n                        // Attention: first coordinate may be inaccurate if far way\n                        //pStr += [nextSymb, scr[1], ' ', scr[2]].join('');\n                        pStr += nextSymb + scr[1] + \" \" + scr[2]; // Seems to be faster now (webkit and firefox)\n                        nextSymb = symbl;\n                    }\n                }\n            } else if (el.bezierDegree === 3) {\n                i = 0;\n                while (i < len) {\n                    scr = el.points[i].scrCoords;\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        pStr += nextSymb + scr[1] + \" \" + scr[2];\n                        if (nextSymb === symbc) {\n                            i += 1;\n                            scr = el.points[i].scrCoords;\n                            pStr += \" \" + scr[1] + \" \" + scr[2];\n                            i += 1;\n                            scr = el.points[i].scrCoords;\n                            pStr += \" \" + scr[1] + \" \" + scr[2];\n                        }\n                        nextSymb = symbc;\n                    }\n                    i += 1;\n                }\n            }\n            return pStr;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathStringBezierPrim: function (el) {\n            var i,\n                j,\n                k,\n                scr,\n                lx,\n                ly,\n                len,\n                symbm = \" M \",\n                symbl = \" C \",\n                nextSymb = symbm,\n                maxSize = 5000.0,\n                pStr = \"\",\n                f = Type.evaluate(el.visProp.strokewidth),\n                isNoPlot = Type.evaluate(el.visProp.curvetype) !== \"plot\";\n\n            if (el.numberPoints <= 0) {\n                return \"\";\n            }\n\n            if (isNoPlot && el.board.options.curve.RDPsmoothing) {\n                el.points = Numerics.RamerDouglasPeucker(el.points, 0.5);\n            }\n\n            len = Math.min(el.points.length, el.numberPoints);\n            for (j = 1; j < 3; j++) {\n                nextSymb = symbm;\n                for (i = 0; i < len; i++) {\n                    scr = el.points[i].scrCoords;\n\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        // Chrome has problems with values being too far away.\n                        scr[1] = Math.max(Math.min(scr[1], maxSize), -maxSize);\n                        scr[2] = Math.max(Math.min(scr[2], maxSize), -maxSize);\n\n                        // Attention: first coordinate may be inaccurate if far way\n                        if (nextSymb === symbm) {\n                            //pStr += [nextSymb, scr[1], ' ', scr[2]].join('');\n                            pStr += nextSymb + scr[1] + \" \" + scr[2]; // Seems to be faster now (webkit and firefox)\n                        } else {\n                            k = 2 * j;\n                            pStr += [\n                                nextSymb,\n                                lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j),\n                                \" \",\n                                ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j),\n                                \" \",\n                                lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j),\n                                \" \",\n                                ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j),\n                                \" \",\n                                scr[1],\n                                \" \",\n                                scr[2]\n                            ].join(\"\");\n                        }\n\n                        nextSymb = symbl;\n                        lx = scr[1];\n                        ly = scr[2];\n                    }\n                }\n            }\n            return pStr;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePolygonPrim: function (node, el) {\n            var i,\n                pStr = \"\",\n                scrCoords,\n                len = el.vertices.length;\n\n            node.setAttributeNS(null, \"stroke\", \"none\");\n            node.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n            if (el.elType === \"polygonalchain\") {\n                len++;\n            }\n\n            for (i = 0; i < len - 1; i++) {\n                if (el.vertices[i].isReal) {\n                    scrCoords = el.vertices[i].coords.scrCoords;\n                    pStr = pStr + scrCoords[1] + \",\" + scrCoords[2];\n                } else {\n                    node.setAttributeNS(null, \"points\", \"\");\n                    return;\n                }\n\n                if (i < len - 2) {\n                    pStr += \" \";\n                }\n            }\n            if (pStr.indexOf(\"NaN\") === -1) {\n                node.setAttributeNS(null, \"points\", pStr);\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateRectPrim: function (node, x, y, w, h) {\n            node.setAttributeNS(null, \"x\", x);\n            node.setAttributeNS(null, \"y\", y);\n            node.setAttributeNS(null, \"width\", w);\n            node.setAttributeNS(null, \"height\", h);\n        },\n\n        /* **************************\n         *  Set Attributes\n         * **************************/\n\n        // documented in JXG.AbstractRenderer\n        setPropertyPrim: function (node, key, val) {\n            if (key === \"stroked\") {\n                return;\n            }\n            node.setAttributeNS(null, key, val);\n        },\n\n        display: function (el, val) {\n            var node;\n\n            if (el && el.rendNode) {\n                el.visPropOld.visible = val;\n                node = el.rendNode;\n                if (val) {\n                    node.setAttributeNS(null, \"display\", \"inline\");\n                    node.style.visibility = \"inherit\";\n                } else {\n                    node.setAttributeNS(null, \"display\", \"none\");\n                    node.style.visibility = \"hidden\";\n                }\n            }\n        },\n\n        // documented in JXG.AbstractRenderer\n        show: function (el) {\n            JXG.deprecated(\"Board.renderer.show()\", \"Board.renderer.display()\");\n            this.display(el, true);\n            // var node;\n            //\n            // if (el && el.rendNode) {\n            //     node = el.rendNode;\n            //     node.setAttributeNS(null, 'display', 'inline');\n            //     node.style.visibility = \"inherit\";\n            // }\n        },\n\n        // documented in JXG.AbstractRenderer\n        hide: function (el) {\n            JXG.deprecated(\"Board.renderer.hide()\", \"Board.renderer.display()\");\n            this.display(el, false);\n            // var node;\n            //\n            // if (el && el.rendNode) {\n            //     node = el.rendNode;\n            //     node.setAttributeNS(null, 'display', 'none');\n            //     node.style.visibility = \"hidden\";\n            // }\n        },\n\n        // documented in JXG.AbstractRenderer\n        setBuffering: function (el, type) {\n            el.rendNode.setAttribute(\"buffered-rendering\", type);\n        },\n\n        // documented in JXG.AbstractRenderer\n        setDashStyle: function (el) {\n            var dashStyle = Type.evaluate(el.visProp.dash),\n                node = el.rendNode;\n\n            if (dashStyle > 0) {\n                node.setAttributeNS(null, \"stroke-dasharray\", this.dashArray[dashStyle - 1]);\n            } else {\n                if (node.hasAttributeNS(null, \"stroke-dasharray\")) {\n                    node.removeAttributeNS(null, \"stroke-dasharray\");\n                }\n            }\n        },\n\n        // documented in JXG.AbstractRenderer\n        setGradient: function (el) {\n            var fillNode = el.rendNode,\n                node,\n                node2,\n                node3,\n                ev_g = Type.evaluate(el.visProp.gradient);\n\n            if (ev_g === \"linear\" || ev_g === \"radial\") {\n                node = this.createPrim(ev_g + \"Gradient\", el.id + \"_gradient\");\n                node2 = this.createPrim(\"stop\", el.id + \"_gradient1\");\n                node3 = this.createPrim(\"stop\", el.id + \"_gradient2\");\n                node.appendChild(node2);\n                node.appendChild(node3);\n                this.defs.appendChild(node);\n                fillNode.setAttributeNS(\n                    null,\n                    \"style\",\n                    \"fill:url(#\" + this.container.id + \"_\" + el.id + \"_gradient)\"\n                );\n                el.gradNode1 = node2;\n                el.gradNode2 = node3;\n                el.gradNode = node;\n            } else {\n                fillNode.removeAttributeNS(null, \"style\");\n            }\n        },\n\n        /**\n         * Set the gradient angle for linear color gradients.\n         *\n         * @private\n         * @param {SVGnode} node SVG gradient node of an arbitrary JSXGraph element.\n         * @param {Number} radians angle value in radians. 0 is horizontal from left to right, Pi/4 is vertical from top to bottom.\n         */\n        updateGradientAngle: function (node, radians) {\n            // Angles:\n            // 0: ->\n            // 90: down\n            // 180: <-\n            // 90: up\n            var f = 1.0,\n                co = Math.cos(radians),\n                si = Math.sin(radians);\n\n            if (Math.abs(co) > Math.abs(si)) {\n                f /= Math.abs(co);\n            } else {\n                f /= Math.abs(si);\n            }\n\n            if (co >= 0) {\n                node.setAttributeNS(null, \"x1\", 0);\n                node.setAttributeNS(null, \"x2\", co * f);\n            } else {\n                node.setAttributeNS(null, \"x1\", -co * f);\n                node.setAttributeNS(null, \"x2\", 0);\n            }\n            if (si >= 0) {\n                node.setAttributeNS(null, \"y1\", 0);\n                node.setAttributeNS(null, \"y2\", si * f);\n            } else {\n                node.setAttributeNS(null, \"y1\", -si * f);\n                node.setAttributeNS(null, \"y2\", 0);\n            }\n        },\n\n        /**\n         * Set circles for radial color gradients.\n         *\n         * @private\n         * @param {SVGnode} node SVG gradient node\n         * @param {Number} cx SVG value cx (value between 0 and 1)\n         * @param {Number} cy  SVG value cy (value between 0 and 1)\n         * @param {Number} r  SVG value r (value between 0 and 1)\n         * @param {Number} fx  SVG value fx (value between 0 and 1)\n         * @param {Number} fy  SVG value fy (value between 0 and 1)\n         * @param {Number} fr  SVG value fr (value between 0 and 1)\n         */\n        updateGradientCircle: function (node, cx, cy, r, fx, fy, fr) {\n            node.setAttributeNS(null, \"cx\", cx * 100 + \"%\"); // Center first color\n            node.setAttributeNS(null, \"cy\", cy * 100 + \"%\");\n            node.setAttributeNS(null, \"r\", r * 100 + \"%\");\n            node.setAttributeNS(null, \"fx\", fx * 100 + \"%\"); // Center second color / focal point\n            node.setAttributeNS(null, \"fy\", fy * 100 + \"%\");\n            node.setAttributeNS(null, \"fr\", fr * 100 + \"%\");\n        },\n\n        // documented in JXG.AbstractRenderer\n        updateGradient: function (el) {\n            var col,\n                op,\n                node2 = el.gradNode1,\n                node3 = el.gradNode2,\n                ev_g = Type.evaluate(el.visProp.gradient);\n\n            if (!Type.exists(node2) || !Type.exists(node3)) {\n                return;\n            }\n\n            op = Type.evaluate(el.visProp.fillopacity);\n            op = op > 0 ? op : 0;\n            col = Type.evaluate(el.visProp.fillcolor);\n\n            node2.setAttributeNS(null, \"style\", \"stop-color:\" + col + \";stop-opacity:\" + op);\n            node3.setAttributeNS(\n                null,\n                \"style\",\n                \"stop-color:\" +\n                    Type.evaluate(el.visProp.gradientsecondcolor) +\n                    \";stop-opacity:\" +\n                    Type.evaluate(el.visProp.gradientsecondopacity)\n            );\n            node2.setAttributeNS(\n                null,\n                \"offset\",\n                Type.evaluate(el.visProp.gradientstartoffset) * 100 + \"%\"\n            );\n            node3.setAttributeNS(\n                null,\n                \"offset\",\n                Type.evaluate(el.visProp.gradientendoffset) * 100 + \"%\"\n            );\n            if (ev_g === \"linear\") {\n                this.updateGradientAngle(el.gradNode, Type.evaluate(el.visProp.gradientangle));\n            } else if (ev_g === \"radial\") {\n                this.updateGradientCircle(\n                    el.gradNode,\n                    Type.evaluate(el.visProp.gradientcx),\n                    Type.evaluate(el.visProp.gradientcy),\n                    Type.evaluate(el.visProp.gradientr),\n                    Type.evaluate(el.visProp.gradientfx),\n                    Type.evaluate(el.visProp.gradientfy),\n                    Type.evaluate(el.visProp.gradientfr)\n                );\n            }\n        },\n\n        // documented in JXG.AbstractRenderer\n        setObjectTransition: function (el, duration) {\n            var node,\n                transitionStr,\n                i, len,\n                nodes = [\"rendNode\", \"rendNodeTriangleStart\", \"rendNodeTriangleEnd\"];\n\n            if (duration === undefined) {\n                duration = Type.evaluate(el.visProp.transitionduration);\n            }\n\n            if (duration === el.visPropOld.transitionduration) {\n                return;\n            }\n\n            if (\n                el.elementClass === Const.OBJECT_CLASS_TEXT &&\n                Type.evaluate(el.visProp.display) === \"html\"\n            ) {\n                // transitionStr = \" color \" + duration + \"ms,\" +\n                //     \" opacity \" + duration + \"ms\";\n                transitionStr = \" all \" + duration + \"ms ease\";\n            } else {\n                transitionStr =\n                    \" fill \" + duration + \"ms,\" +\n                    \" fill-opacity \" + duration + \"ms,\" +\n                    \" stroke \" + duration + \"ms,\" +\n                    \" stroke-opacity \" + duration + \"ms,\" +\n                    \" stroke-width \" + duration + \"ms,\" +\n                    \" width \" + duration + \"ms,\" +\n                    \" height \" + duration + \"ms,\" +\n                    \" rx \" + duration + \"ms,\" +\n                    \" ry \" + duration + \"ms\";\n            }\n\n            len = nodes.length;\n            for (i = 0; i < len; ++i) {\n                if (el[nodes[i]]) {\n                    node = el[nodes[i]];\n                    node.style.transition = transitionStr;\n                }\n            }\n\n            el.visPropOld.transitionduration = duration;\n        },\n\n        /**\n         * Call user-defined function to set visual attributes.\n         * If \"testAttribute\" is the empty string, the function\n         * is called immediately, otherwise it is called in a timeOut.\n         *\n         * This is necessary to realize smooth transitions but avoid transitions\n         * when first creating the objects.\n         *\n         * Usually, the string in testAttribute is the visPropOld attribute\n         * of the values which are set.\n         *\n         * @param {Function} setFunc       Some function which usually sets some attributes\n         * @param {String} testAttribute If this string is the empty string  the function is called immediately,\n         *                               otherwise it is called in a setImeout.\n         * @see JXG.SVGRenderer#setObjectFillColor\n         * @see JXG.SVGRenderer#setObjectStrokeColor\n         * @see JXG.SVGRenderer#_setArrowColor\n         * @private\n         */\n        _setAttribute: function (setFunc, testAttribute) {\n            if (testAttribute === \"\") {\n                setFunc();\n            } else {\n                window.setTimeout(setFunc, 1);\n            }\n        },\n\n        // documented in JXG.AbstractRenderer\n        setObjectFillColor: function (el, color, opacity, rendNode) {\n            var node, c, rgbo, oo,\n                rgba = Type.evaluate(color),\n                o = Type.evaluate(opacity),\n                grad = Type.evaluate(el.visProp.gradient);\n\n            o = o > 0 ? o : 0;\n\n            // TODO  save gradient and gradientangle\n            if (\n                el.visPropOld.fillcolor === rgba &&\n                el.visPropOld.fillopacity === o &&\n                grad === null\n            ) {\n                return;\n            }\n\n            if (Type.exists(rgba) && rgba !== false) {\n                if (rgba.length !== 9) {\n                    // RGB, not RGBA\n                    c = rgba;\n                    oo = o;\n                } else {\n                    // True RGBA, not RGB\n                    rgbo = Color.rgba2rgbo(rgba);\n                    c = rgbo[0];\n                    oo = o * rgbo[1];\n                }\n\n                if (rendNode === undefined) {\n                    node = el.rendNode;\n                } else {\n                    node = rendNode;\n                }\n\n                if (c !== \"none\") {\n                    this._setAttribute(function () {\n                        node.setAttributeNS(null, \"fill\", c);\n                    }, el.visPropOld.fillcolor);\n                }\n\n                if (el.type === JXG.OBJECT_TYPE_IMAGE) {\n                    this._setAttribute(function () {\n                        node.setAttributeNS(null, \"opacity\", oo);\n                    }, el.visPropOld.fillopacity);\n                    //node.style['opacity'] = oo;  // This would overwrite values set by CSS class.\n                } else {\n                    if (c === \"none\") {\n                        // This is done only for non-images\n                        // because images have no fill color.\n                        oo = 0;\n                        // This is necessary if there is a foreignObject below.\n                        node.setAttributeNS(null, \"pointer-events\", \"visibleStroke\");\n                    } else {\n                        // This is the default\n                        node.setAttributeNS(null, \"pointer-events\", \"visiblePainted\");\n                    }\n                    this._setAttribute(function () {\n                        node.setAttributeNS(null, \"fill-opacity\", oo);\n                    }, el.visPropOld.fillopacity);\n                }\n\n                if (grad === \"linear\" || grad === \"radial\") {\n                    this.updateGradient(el);\n                }\n            }\n            el.visPropOld.fillcolor = rgba;\n            el.visPropOld.fillopacity = o;\n        },\n\n        // documented in JXG.AbstractRenderer\n        setObjectStrokeColor: function (el, color, opacity) {\n            var rgba = Type.evaluate(color),\n                c, rgbo,\n                o = Type.evaluate(opacity),\n                oo, node;\n\n            o = o > 0 ? o : 0;\n\n            if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {\n                return;\n            }\n\n            if (Type.exists(rgba) && rgba !== false) {\n                if (rgba.length !== 9) {\n                    // RGB, not RGBA\n                    c = rgba;\n                    oo = o;\n                } else {\n                    // True RGBA, not RGB\n                    rgbo = Color.rgba2rgbo(rgba);\n                    c = rgbo[0];\n                    oo = o * rgbo[1];\n                }\n\n                node = el.rendNode;\n\n                if (el.elementClass === Const.OBJECT_CLASS_TEXT) {\n                    if (Type.evaluate(el.visProp.display) === \"html\") {\n                        this._setAttribute(function () {\n                            node.style.color = c;\n                            node.style.opacity = oo;\n                        }, el.visPropOld.strokecolor);\n                    } else {\n                        this._setAttribute(function () {\n                            node.setAttributeNS(null, \"style\", \"fill:\" + c);\n                            node.setAttributeNS(null, \"style\", \"fill-opacity:\" + oo);\n                        }, el.visPropOld.strokecolor);\n                    }\n                } else {\n                    this._setAttribute(function () {\n                        node.setAttributeNS(null, \"stroke\", c);\n                        node.setAttributeNS(null, \"stroke-opacity\", oo);\n                    }, el.visPropOld.strokecolor);\n                }\n\n                if (\n                    el.elementClass === Const.OBJECT_CLASS_CURVE ||\n                    el.elementClass === Const.OBJECT_CLASS_LINE\n                ) {\n                    if (Type.evaluate(el.visProp.firstarrow)) {\n                        this._setArrowColor(\n                            el.rendNodeTriangleStart,\n                            c,\n                            oo,\n                            el,\n                            el.visPropCalc.typeFirst\n                        );\n                    }\n\n                    if (Type.evaluate(el.visProp.lastarrow)) {\n                        this._setArrowColor(\n                            el.rendNodeTriangleEnd,\n                            c,\n                            oo,\n                            el,\n                            el.visPropCalc.typeLast\n                        );\n                    }\n                }\n            }\n\n            el.visPropOld.strokecolor = rgba;\n            el.visPropOld.strokeopacity = o;\n        },\n\n        // documented in JXG.AbstractRenderer\n        setObjectStrokeWidth: function (el, width) {\n            var node,\n                w = Type.evaluate(width);\n\n            if (isNaN(w) || el.visPropOld.strokewidth === w) {\n                return;\n            }\n\n            node = el.rendNode;\n            this.setPropertyPrim(node, \"stroked\", \"true\");\n            if (Type.exists(w)) {\n                this.setPropertyPrim(node, \"stroke-width\", w + \"px\");\n\n                // if (el.elementClass === Const.OBJECT_CLASS_CURVE ||\n                // el.elementClass === Const.OBJECT_CLASS_LINE) {\n                //     if (Type.evaluate(el.visProp.firstarrow)) {\n                //         this._setArrowWidth(el.rendNodeTriangleStart, w, el.rendNode);\n                //     }\n                //\n                //     if (Type.evaluate(el.visProp.lastarrow)) {\n                //         this._setArrowWidth(el.rendNodeTriangleEnd, w, el.rendNode);\n                //     }\n                // }\n            }\n            el.visPropOld.strokewidth = w;\n        },\n\n        // documented in JXG.AbstractRenderer\n        setLineCap: function (el) {\n            var capStyle = Type.evaluate(el.visProp.linecap);\n\n            if (\n                capStyle === undefined ||\n                capStyle === \"\" ||\n                el.visPropOld.linecap === capStyle ||\n                !Type.exists(el.rendNode)\n            ) {\n                return;\n            }\n\n            this.setPropertyPrim(el.rendNode, \"stroke-linecap\", capStyle);\n            el.visPropOld.linecap = capStyle;\n        },\n\n        // documented in JXG.AbstractRenderer\n        setShadow: function (el) {\n            var ev_s = Type.evaluate(el.visProp.shadow),\n                ev_s_json, c, b, bl, o, op, id, node,\n                use_board_filter = true,\n                show = false;\n\n            ev_s_json = JSON.stringify(ev_s);\n            if (ev_s_json === el.visPropOld.shadow) {\n                return;\n            }\n\n            if (typeof ev_s === 'boolean') {\n                use_board_filter = true;\n                show = ev_s;\n                c = 'none';\n                b = 3;\n                bl = 0.1;\n                o = [5, 5];\n                op = 1;\n            } else {\n                if (Type.evaluate(ev_s.enabled)) {\n                    use_board_filter = false;\n                    show = true;\n                    c = JXG.rgbParser(Type.evaluate(ev_s.color));\n                    b = Type.evaluate(ev_s.blur);\n                    bl = Type.evaluate(ev_s.blend);\n                    o = Type.evaluate(ev_s.offset);\n                    op = Type.evaluate(ev_s.opacity);\n                } else {\n                    show = false;\n                }\n            }\n\n            if (Type.exists(el.rendNode)) {\n                if (show) {\n                    if (use_board_filter) {\n                        el.rendNode.setAttributeNS(null, 'filter', 'url(#' + this.container.id + '_' + 'f1)');\n                    } else {\n                        node = this.container.ownerDocument.getElementById(id);\n                        if (node) {\n                            this.defs.removeChild(node);\n                        }\n                        id = el.rendNode.id + '_' + 'f1';\n                        this.defs.appendChild(this.createShadowFilter(id, c, op, bl, b, o));\n                        el.rendNode.setAttributeNS(null, 'filter', 'url(#' + id + ')');\n                    }\n                } else {\n                    el.rendNode.removeAttributeNS(null, 'filter');\n                }\n            }\n\n            el.visPropOld.shadow = ev_s_json;\n        },\n\n        /* **************************\n         * renderer control\n         * **************************/\n\n        // documented in JXG.AbstractRenderer\n        suspendRedraw: function () {\n            // It seems to be important for the Linux version of firefox\n            //this.suspendHandle = this.svgRoot.suspendRedraw(10000);\n        },\n\n        // documented in JXG.AbstractRenderer\n        unsuspendRedraw: function () {\n            //this.svgRoot.unsuspendRedraw(this.suspendHandle);\n            //this.svgRoot.unsuspendRedrawAll();\n            //this.svgRoot.forceRedraw();\n        },\n\n        // documented in AbstractRenderer\n        resize: function (w, h) {\n            // this.svgRoot.style.width  = parseFloat(w) + 'px';\n            // this.svgRoot.style.height = parseFloat(h) + 'px';\n\n            this.svgRoot.setAttribute(\"width\", parseFloat(w));\n            this.svgRoot.setAttribute(\"height\", parseFloat(h));\n            // this.svgRoot.setAttribute('width',  '100%');\n            // this.svgRoot.setAttribute('height', '100%');\n        },\n\n        // documented in JXG.AbstractRenderer\n        createTouchpoints: function (n) {\n            var i, na1, na2, node;\n            this.touchpoints = [];\n            for (i = 0; i < n; i++) {\n                na1 = \"touchpoint1_\" + i;\n                node = this.createPrim(\"path\", na1);\n                this.appendChildPrim(node, 19);\n                node.setAttributeNS(null, \"d\", \"M 0 0\");\n                this.touchpoints.push(node);\n\n                this.setPropertyPrim(node, \"stroked\", \"true\");\n                this.setPropertyPrim(node, \"stroke-width\", \"1px\");\n                node.setAttributeNS(null, \"stroke\", \"#000000\");\n                node.setAttributeNS(null, \"stroke-opacity\", 1.0);\n                node.setAttributeNS(null, \"display\", \"none\");\n\n                na2 = \"touchpoint2_\" + i;\n                node = this.createPrim(\"ellipse\", na2);\n                this.appendChildPrim(node, 19);\n                this.updateEllipsePrim(node, 0, 0, 0, 0);\n                this.touchpoints.push(node);\n\n                this.setPropertyPrim(node, \"stroked\", \"true\");\n                this.setPropertyPrim(node, \"stroke-width\", \"1px\");\n                node.setAttributeNS(null, \"stroke\", \"#000000\");\n                node.setAttributeNS(null, \"stroke-opacity\", 1.0);\n                node.setAttributeNS(null, \"fill\", \"#ffffff\");\n                node.setAttributeNS(null, \"fill-opacity\", 0.0);\n\n                node.setAttributeNS(null, \"display\", \"none\");\n            }\n        },\n\n        // documented in JXG.AbstractRenderer\n        showTouchpoint: function (i) {\n            if (this.touchpoints && i >= 0 && 2 * i < this.touchpoints.length) {\n                this.touchpoints[2 * i].setAttributeNS(null, \"display\", \"inline\");\n                this.touchpoints[2 * i + 1].setAttributeNS(null, \"display\", \"inline\");\n            }\n        },\n\n        // documented in JXG.AbstractRenderer\n        hideTouchpoint: function (i) {\n            if (this.touchpoints && i >= 0 && 2 * i < this.touchpoints.length) {\n                this.touchpoints[2 * i].setAttributeNS(null, \"display\", \"none\");\n                this.touchpoints[2 * i + 1].setAttributeNS(null, \"display\", \"none\");\n            }\n        },\n\n        // documented in JXG.AbstractRenderer\n        updateTouchpoint: function (i, pos) {\n            var x,\n                y,\n                d = 37;\n\n            if (this.touchpoints && i >= 0 && 2 * i < this.touchpoints.length) {\n                x = pos[0];\n                y = pos[1];\n\n                this.touchpoints[2 * i].setAttributeNS(\n                    null,\n                    \"d\",\n                    \"M \" +\n                        (x - d) +\n                        \" \" +\n                        y +\n                        \" \" +\n                        \"L \" +\n                        (x + d) +\n                        \" \" +\n                        y +\n                        \" \" +\n                        \"M \" +\n                        x +\n                        \" \" +\n                        (y - d) +\n                        \" \" +\n                        \"L \" +\n                        x +\n                        \" \" +\n                        (y + d)\n                );\n                this.updateEllipsePrim(this.touchpoints[2 * i + 1], pos[0], pos[1], 25, 25);\n            }\n        },\n\n        /**\n         * Walk recursively through the DOM subtree of a node and collect all\n         * value attributes together with the id of that node.\n         * <b>Attention:</b> Only values of nodes having a valid id are taken.\n         * @param  {Node} node   root node of DOM subtree that will be searched recursively.\n         * @return {Array}      Array with entries of the form [id, value]\n         * @private\n         */\n        _getValuesOfDOMElements: function (node) {\n            var values = [];\n            if (node.nodeType === 1) {\n                node = node.firstChild;\n                while (node) {\n                    if (node.id !== undefined && node.value !== undefined) {\n                        values.push([node.id, node.value]);\n                    }\n                    values = values.concat(this._getValuesOfDOMElements(node));\n                    node = node.nextSibling;\n                }\n            }\n            return values;\n        },\n\n        _getDataUri: function (url, callback) {\n            var image = new Image();\n\n            image.onload = function () {\n                var canvas = document.createElement(\"canvas\");\n                canvas.width = this.naturalWidth; // or 'width' if you want a special/scaled size\n                canvas.height = this.naturalHeight; // or 'height' if you want a special/scaled size\n\n                canvas.getContext(\"2d\").drawImage(this, 0, 0);\n\n                callback(canvas.toDataURL(\"image/png\"));\n                canvas.remove();\n            };\n\n            image.src = url;\n        },\n\n        _getImgDataURL: function (svgRoot) {\n            var images, len, canvas, ctx, ur, i;\n\n            images = svgRoot.getElementsByTagName(\"image\");\n            len = images.length;\n            if (len > 0) {\n                canvas = document.createElement(\"canvas\");\n                //img = new Image();\n                for (i = 0; i < len; i++) {\n                    images[i].setAttribute(\"crossorigin\", \"anonymous\");\n                    //img.src = images[i].href;\n                    //img.onload = function() {\n                    // img.crossOrigin = \"anonymous\";\n                    ctx = canvas.getContext(\"2d\");\n                    canvas.width = images[i].getAttribute(\"width\");\n                    canvas.height = images[i].getAttribute(\"height\");\n                    try {\n                        ctx.drawImage(images[i], 0, 0, canvas.width, canvas.height);\n\n                        // If the image is not png, the format must be specified here\n                        ur = canvas.toDataURL();\n                        images[i].setAttribute(\"xlink:href\", ur);\n                    } catch (err) {\n                        console.log(\"CORS problem! Image can not be used\", err);\n                    }\n                }\n                //canvas.remove();\n            }\n            return true;\n        },\n\n        /**\n         * Return a data URI of the SVG code representeing the construction.\n         * The SVG code of the construction is base64 encoded. The return string starts\n         * with \"data:image/svg+xml;base64,...\".\n         *\n         * @param {Boolean} ignoreTexts If true, the foreignObject tag is set to display=none.\n         * This is necessary for older versions of Safari. Default: false\n         * @returns {String}  data URI string\n         */\n        dumpToDataURI: function (ignoreTexts) {\n            var svgRoot = this.svgRoot,\n                btoa = window.btoa || Base64.encode,\n                svg,\n                virtualNode,\n                doc,\n                i,\n                len,\n                values = [];\n\n            // Move all HTML tags (beside the SVG root) of the container\n            // to the foreignObject element inside of the svgRoot node\n            // Problem:\n            // input values are not copied. This can be verified by looking at an innerHTML output\n            // of an input element. Therefore, we do it \"by hand\".\n            if (this.container.hasChildNodes() && Type.exists(this.foreignObjLayer)) {\n                if (!ignoreTexts) {\n                    this.foreignObjLayer.setAttribute(\"display\", \"inline\");\n                }\n                while (svgRoot.nextSibling) {\n                    // Copy all value attributes\n                    values = values.concat(this._getValuesOfDOMElements(svgRoot.nextSibling));\n\n                    this.foreignObjLayer.appendChild(svgRoot.nextSibling);\n                }\n            }\n\n            this._getImgDataURL(svgRoot);\n\n            // Convert the SVG graphic into a string containing SVG code\n            svgRoot.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n            svg = new XMLSerializer().serializeToString(svgRoot);\n\n            if (ignoreTexts !== true) {\n                // Handle SVG texts\n                // Insert all value attributes back into the svg string\n                len = values.length;\n                for (i = 0; i < len; i++) {\n                    svg = svg.replace(\n                        'id=\"' + values[i][0] + '\"',\n                        'id=\"' + values[i][0] + '\" value=\"' + values[i][1] + '\"'\n                    );\n                }\n            }\n\n            // if (false) {\n            //     // Debug: use example svg image\n            //     svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"220\" height=\"220\"><rect width=\"66\" height=\"30\" x=\"21\" y=\"32\" stroke=\"#204a87\" stroke-width=\"2\" fill=\"none\" /></svg>';\n            // }\n\n            // In IE we have to remove the namespace again.\n            if ((svg.match(/xmlns=\"http:\\/\\/www.w3.org\\/2000\\/svg\"/g) || []).length > 1) {\n                svg = svg.replace(/xmlns=\"http:\\/\\/www.w3.org\\/2000\\/svg\"/g, \"\");\n            }\n\n            // Safari fails if the svg string contains a \"&nbsp;\"\n            // Obsolete with Safari 12+\n            svg = svg.replace(/&nbsp;/g, \" \");\n\n            // Move all HTML tags back from\n            // the foreignObject element to the container\n            if (Type.exists(this.foreignObjLayer) && this.foreignObjLayer.hasChildNodes()) {\n                // Restore all HTML elements\n                while (this.foreignObjLayer.firstChild) {\n                    this.container.appendChild(this.foreignObjLayer.firstChild);\n                }\n                this.foreignObjLayer.setAttribute(\"display\", \"none\");\n            }\n\n            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n        },\n\n        /**\n         * Convert the SVG construction into an HTML canvas image.\n         * This works for all SVG supporting browsers. Implemented as Promise.\n         * <p>\n         * For IE, it is realized as function.\n         * It works from version 9, with the exception that HTML texts\n         * are ignored on IE. The drawing is done with a delay of\n         * 200 ms. Otherwise there would be problems with IE.\n         *\n         * @param {String} canvasId Id of an HTML canvas element\n         * @param {Number} w Width in pixel of the dumped image, i.e. of the canvas tag.\n         * @param {Number} h Height in pixel of the dumped image, i.e. of the canvas tag.\n         * @param {Boolean} ignoreTexts If true, the foreignObject tag is taken out from the SVG root.\n         * This is necessary for older versions of Safari. Default: false\n         * @returns {Promise}  Promise object\n         *\n         * @example\n         * \tboard.renderer.dumpToCanvas('canvas').then(function() { console.log('done'); });\n         *\n         * @example\n         *  // IE 11 example:\n         * \tboard.renderer.dumpToCanvas('canvas');\n         * \tsetTimeout(function() { console.log('done'); }, 400);\n         */\n        dumpToCanvas: function (canvasId, w, h, ignoreTexts) {\n            var svg,\n                tmpImg,\n                cv,\n                ctx,\n                doc = this.container.ownerDocument;\n\n            // Prepare the canvas element\n            cv = doc.getElementById(canvasId);\n\n            // Clear the canvas\n            /* eslint-disable no-self-assign */\n            cv.width = cv.width;\n            /* eslint-enable no-self-assign */\n\n            ctx = cv.getContext(\"2d\");\n            if (w !== undefined && h !== undefined) {\n                cv.style.width = parseFloat(w) + \"px\";\n                cv.style.height = parseFloat(h) + \"px\";\n                // Scale twice the CSS size to make the image crisp\n                // cv.setAttribute('width', 2 * parseFloat(wOrg));\n                // cv.setAttribute('height', 2 * parseFloat(hOrg));\n                // ctx.scale(2 * wOrg / w, 2 * hOrg / h);\n                cv.setAttribute(\"width\", parseFloat(w));\n                cv.setAttribute(\"height\", parseFloat(h));\n            }\n\n            // Display the SVG string as data-uri in an HTML img.\n            tmpImg = new Image();\n            svg = this.dumpToDataURI(ignoreTexts);\n            tmpImg.src = svg;\n\n            // Finally, draw the HTML img in the canvas.\n            if (!(\"Promise\" in window)) {\n                tmpImg.onload = function () {\n                    // IE needs a pause...\n                    // Seems to be broken\n                    window.setTimeout(function () {\n                        try {\n                            ctx.drawImage(tmpImg, 0, 0, w, h);\n                        } catch (err) {\n                            console.log(\"screenshots not longer supported on IE\");\n                        }\n                    }, 200);\n                };\n                return this;\n            }\n\n            return new Promise(function (resolve, reject) {\n                try {\n                    tmpImg.onload = function () {\n                        ctx.drawImage(tmpImg, 0, 0, w, h);\n                        resolve();\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        },\n\n        /**\n         * Display SVG image in html img-tag which enables\n         * easy download for the user.\n         *\n         * Support:\n         * <ul>\n         * <li> IE: No\n         * <li> Edge: full\n         * <li>Firefox: full\n         * <li> Chrome: full\n         * <li> Safari: full (No text support in versions prior to 12).\n         * </ul>\n         *\n         * @param {JXG.Board} board Link to the board.\n         * @param {String} imgId Optional id of an img object. If given and different from the empty string,\n         * the screenshot is copied to this img object. The width and height will be set to the values of the\n         * JSXGraph container.\n         * @param {Boolean} ignoreTexts If set to true, the foreignObject is taken out of the\n         *  SVGRoot and texts are not displayed. This is mandatory for Safari. Default: false\n         * @return {Object}       the svg renderer object\n         */\n        screenshot: function (board, imgId, ignoreTexts) {\n            var node,\n                doc = this.container.ownerDocument,\n                parent = this.container.parentNode,\n                cPos,\n                canvas,\n                id,\n                img,\n                button,\n                buttonText,\n                w,\n                h,\n                bas = board.attr.screenshot,\n                zbar,\n                zbarDisplay,\n                cssTxt,\n                newImg = false,\n                _copyCanvasToImg,\n                isDebug = false;\n\n            if (this.type === \"no\") {\n                return this;\n            }\n\n            w = bas.scale * this.container.getBoundingClientRect().width;\n            h = bas.scale * this.container.getBoundingClientRect().height;\n\n            if (imgId === undefined || imgId === \"\") {\n                newImg = true;\n                img = new Image(); //doc.createElement('img');\n                img.style.width = w + \"px\";\n                img.style.height = h + \"px\";\n            } else {\n                newImg = false;\n                img = doc.getElementById(imgId);\n            }\n            // img.crossOrigin = 'anonymous';\n\n            // Create div which contains canvas element and close button\n            if (newImg) {\n                node = doc.createElement(\"div\");\n                node.style.cssText = bas.css;\n                node.style.width = w + \"px\";\n                node.style.height = h + \"px\";\n                node.style.zIndex = this.container.style.zIndex + 120;\n\n                // Try to position the div exactly over the JSXGraph board\n                node.style.position = \"absolute\";\n                node.style.top = this.container.offsetTop + \"px\";\n                node.style.left = this.container.offsetLeft + \"px\";\n            }\n\n            if (!isDebug) {\n                // Create canvas element and add it to the DOM\n                // It will be removed after the image has been stored.\n                canvas = doc.createElement(\"canvas\");\n                id = Math.random().toString(36).substr(2, 5);\n                canvas.setAttribute(\"id\", id);\n                canvas.setAttribute(\"width\", w);\n                canvas.setAttribute(\"height\", h);\n                canvas.style.width = w + \"px\";\n                canvas.style.height = w + \"px\";\n                canvas.style.display = \"none\";\n                parent.appendChild(canvas);\n            } else {\n                // Debug: use canvas element 'jxgbox_canvas' from jsxdev/dump.html\n                id = \"jxgbox_canvas\";\n                // canvas = document.getElementById(id);\n                canvas = doc.getElementById(id);\n            }\n\n            if (newImg) {\n                // Create close button\n                button = doc.createElement(\"span\");\n                buttonText = doc.createTextNode(\"\\u2716\");\n                button.style.cssText = bas.cssButton;\n                button.appendChild(buttonText);\n                button.onclick = function () {\n                    node.parentNode.removeChild(node);\n                };\n\n                // Add all nodes\n                node.appendChild(img);\n                node.appendChild(button);\n                parent.insertBefore(node, this.container.nextSibling);\n            }\n\n            // Hide navigation bar in board\n            // zbar = document.getElementById(this.container.id + '_navigationbar');\n            zbar = doc.getElementById(this.container.id + \"_navigationbar\");\n            if (Type.exists(zbar)) {\n                zbarDisplay = zbar.style.display;\n                zbar.style.display = \"none\";\n            }\n\n            _copyCanvasToImg = function () {\n                // Show image in img tag\n                img.src = canvas.toDataURL(\"image/png\");\n\n                // Remove canvas node\n                if (!isDebug) {\n                    parent.removeChild(canvas);\n                }\n            };\n\n            // Create screenshot in image element\n            if (\"Promise\" in window) {\n                this.dumpToCanvas(id, w, h, ignoreTexts).then(_copyCanvasToImg);\n            } else {\n                // IE\n                this.dumpToCanvas(id, w, h, ignoreTexts);\n                window.setTimeout(_copyCanvasToImg, 200);\n            }\n\n            // Show navigation bar in board\n            if (Type.exists(zbar)) {\n                zbar.style.display = zbarDisplay;\n            }\n\n            return this;\n        }\n    }\n);\n\nexport default JXG.SVGRenderer;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */\n/*jslint nomen: true, plusplus: true, newcap:true*/\n\nimport JXG from \"../jxg\";\nimport AbstractRenderer from \"./abstract\";\nimport Const from \"../base/constants\";\nimport Type from \"../utils/type\";\nimport Color from \"../utils/color\";\nimport Mat from \"../math/math\";\nimport Numerics from \"../math/numerics\";\n\n/**\n * Uses VML to implement the rendering methods defined in {@link JXG.AbstractRenderer}.\n * VML was used in very old Internet Explorer versions upto IE 8.\n *\n *\n * @class JXG.VMLRenderer\n * @augments JXG.AbstractRenderer\n * @param {Node} container Reference to a DOM node containing the board.\n * @see JXG.AbstractRenderer\n * @deprecated\n */\nJXG.VMLRenderer = function (container) {\n    this.type = \"vml\";\n\n    this.container = container;\n    this.container.style.overflow = \"hidden\";\n    if (this.container.style.position === \"\") {\n        this.container.style.position = \"relative\";\n    }\n    this.container.onselectstart = function () {\n        return false;\n    };\n\n    this.resolution = 10; // Paths are drawn with a a resolution of this.resolution/pixel.\n\n    // Add VML includes and namespace\n    // Original: IE <=7\n    //container.ownerDocument.createStyleSheet().addRule(\"v\\\\:*\", \"behavior: url(#default#VML);\");\n    if (!Type.exists(JXG.vmlStylesheet)) {\n        container.ownerDocument.namespaces.add(\"jxgvml\", \"urn:schemas-microsoft-com:vml\");\n        JXG.vmlStylesheet = this.container.ownerDocument.createStyleSheet();\n        JXG.vmlStylesheet.addRule(\".jxgvml\", \"behavior:url(#default#VML)\");\n    }\n\n    try {\n        if (!container.ownerDocument.namespaces.jxgvml) {\n            container.ownerDocument.namespaces.add(\"jxgvml\", \"urn:schemas-microsoft-com:vml\");\n        }\n\n        this.createNode = function (tagName) {\n            return container.ownerDocument.createElement(\n                \"<jxgvml:\" + tagName + ' class=\"jxgvml\">'\n            );\n        };\n    } catch (e) {\n        this.createNode = function (tagName) {\n            return container.ownerDocument.createElement(\n                \"<\" + tagName + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"jxgvml\">'\n            );\n        };\n    }\n\n    // dash styles\n    this.dashArray = [\n        \"Solid\",\n        \"1 1\",\n        \"ShortDash\",\n        \"Dash\",\n        \"LongDash\",\n        \"ShortDashDot\",\n        \"LongDashDot\"\n    ];\n};\n\nJXG.VMLRenderer.prototype = new AbstractRenderer();\n\nJXG.extend(\n    JXG.VMLRenderer.prototype,\n    /** @lends JXG.VMLRenderer.prototype */ {\n        /**\n         * Sets attribute <tt>key</tt> of node <tt>node</tt> to <tt>value</tt>.\n         * @param {Node} node A DOM node.\n         * @param {String} key Name of the attribute.\n         * @param {String} val New value of the attribute.\n         * @param {Boolean} [iFlag=false] If false, the attribute's name is case insensitive.\n         */\n        _setAttr: function (node, key, val, iFlag) {\n            try {\n                if (this.container.ownerDocument.documentMode === 8) {\n                    node[key] = val;\n                } else {\n                    node.setAttribute(key, val, iFlag);\n                }\n            } catch (e) {\n                JXG.debug(\"_setAttr:\" /*node.id*/ + \" \" + key + \" \" + val + \"<br>\\n\");\n            }\n        },\n\n        /* ******************************** *\n         *  This renderer does not need to\n         *  override draw/update* methods\n         *  since it provides draw/update*Prim\n         *  methods.\n         * ******************************** */\n\n        /* **************************\n         *    Lines\n         * **************************/\n\n        // documented in AbstractRenderer\n        updateTicks: function (ticks) {\n            var i,\n                len,\n                c,\n                x,\n                y,\n                r = this.resolution,\n                tickArr = [];\n\n            len = ticks.ticks.length;\n            for (i = 0; i < len; i++) {\n                c = ticks.ticks[i];\n                x = c[0];\n                y = c[1];\n\n                if (Type.isNumber(x[0]) && Type.isNumber(x[1])) {\n                    tickArr.push(\n                        \" m \" +\n                            Math.round(r * x[0]) +\n                            \", \" +\n                            Math.round(r * y[0]) +\n                            \" l \" +\n                            Math.round(r * x[1]) +\n                            \", \" +\n                            Math.round(r * y[1]) +\n                            \" \"\n                    );\n                }\n            }\n\n            if (!Type.exists(ticks.rendNode)) {\n                ticks.rendNode = this.createPrim(\"path\", ticks.id);\n                this.appendChildPrim(ticks.rendNode, Type.evaluate(ticks.visProp.layer));\n            }\n\n            this._setAttr(ticks.rendNode, \"stroked\", \"true\");\n            this._setAttr(\n                ticks.rendNode,\n                \"strokecolor\",\n                Type.evaluate(ticks.visProp.strokecolor),\n                1\n            );\n            this._setAttr(\n                ticks.rendNode,\n                \"strokeweight\",\n                Type.evaluate(ticks.visProp.strokewidth)\n            );\n            this._setAttr(\n                ticks.rendNodeStroke,\n                \"opacity\",\n                Type.evaluate(ticks.visProp.strokeopacity) * 100 + \"%\"\n            );\n            this.updatePathPrim(ticks.rendNode, tickArr, ticks.board);\n        },\n\n        /* **************************\n         *    Text related stuff\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        displayCopyright: function (str, fontsize) {\n            var node, t;\n\n            node = this.createNode(\"textbox\");\n            node.style.position = \"absolute\";\n            this._setAttr(node, \"id\", this.container.id + \"_\" + \"licenseText\");\n\n            node.style.left = 20;\n            node.style.top = 2;\n            node.style.fontSize = fontsize;\n            node.style.color = \"#356AA0\";\n            node.style.fontFamily = \"Arial,Helvetica,sans-serif\";\n            this._setAttr(node, \"opacity\", \"30%\");\n            node.style.filter =\n                \"progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand', enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 30, enabled = true)\";\n\n            t = this.container.ownerDocument.createTextNode(str);\n            node.appendChild(t);\n            this.appendChildPrim(node, 0);\n        },\n\n        // documented in AbstractRenderer\n        drawInternalText: function (el) {\n            var node;\n            node = this.createNode(\"textbox\");\n            node.style.position = \"absolute\";\n            el.rendNodeText = this.container.ownerDocument.createTextNode(\"\");\n            node.appendChild(el.rendNodeText);\n            this.appendChildPrim(node, 9);\n            node.style.filter =\n                \"progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand', enabled = false) progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)\";\n\n            return node;\n        },\n\n        // documented in AbstractRenderer\n        updateInternalText: function (el) {\n            var v,\n                content = el.plaintext,\n                m = this.joinTransforms(el, el.transformations),\n                offset = [0, 0],\n                maxX,\n                maxY,\n                minX,\n                minY,\n                i,\n                node = el.rendNode,\n                p = [],\n                ev_ax = el.getAnchorX(),\n                ev_ay = el.getAnchorY();\n\n            if (!isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {\n                // Horizontal\n                if (ev_ax === \"right\") {\n                    offset[0] = 1;\n                } else if (ev_ax === \"middle\") {\n                    offset[0] = 0.5;\n                } // default (ev_ax === 'left') offset[0] = 0;\n\n                // Vertical\n                if (ev_ay === \"bottom\") {\n                    offset[1] = 1;\n                } else if (ev_ay === \"middle\") {\n                    offset[1] = 0.5;\n                } // default (ev_ay === 'top') offset[1] = 0;\n\n                // Compute maxX, maxY, minX, minY\n                p[0] = Mat.matVecMult(m, [\n                    1,\n                    el.coords.scrCoords[1] - offset[0] * el.size[0],\n                    el.coords.scrCoords[2] + (1 - offset[1]) * el.size[1] + this.vOffsetText\n                ]);\n                p[0][1] /= p[0][0];\n                p[0][2] /= p[0][0];\n                p[1] = Mat.matVecMult(m, [\n                    1,\n                    el.coords.scrCoords[1] + (1 - offset[0]) * el.size[0],\n                    el.coords.scrCoords[2] + (1 - offset[1]) * el.size[1] + this.vOffsetText\n                ]);\n                p[1][1] /= p[1][0];\n                p[1][2] /= p[1][0];\n                p[2] = Mat.matVecMult(m, [\n                    1,\n                    el.coords.scrCoords[1] + (1 - offset[0]) * el.size[0],\n                    el.coords.scrCoords[2] - offset[1] * el.size[1] + this.vOffsetText\n                ]);\n                p[2][1] /= p[2][0];\n                p[2][2] /= p[2][0];\n                p[3] = Mat.matVecMult(m, [\n                    1,\n                    el.coords.scrCoords[1] - offset[0] * el.size[0],\n                    el.coords.scrCoords[2] - offset[1] * el.size[1] + this.vOffsetText\n                ]);\n                p[3][1] /= p[3][0];\n                p[3][2] /= p[3][0];\n                maxX = p[0][1];\n                minX = p[0][1];\n                maxY = p[0][2];\n                minY = p[0][2];\n\n                for (i = 1; i < 4; i++) {\n                    maxX = Math.max(maxX, p[i][1]);\n                    minX = Math.min(minX, p[i][1]);\n                    maxY = Math.max(maxY, p[i][2]);\n                    minY = Math.min(minY, p[i][2]);\n                }\n\n                // Horizontal\n                v =\n                    offset[0] === 1\n                        ? Math.floor(el.board.canvasWidth - maxX)\n                        : Math.floor(minX);\n                if (el.visPropOld.left !== ev_ax + v) {\n                    if (offset[0] === 1) {\n                        el.rendNode.style.right = v + \"px\";\n                        el.rendNode.style.left = \"auto\";\n                    } else {\n                        el.rendNode.style.left = v + \"px\";\n                        el.rendNode.style.right = \"auto\";\n                    }\n                    el.visPropOld.left = ev_ax + v;\n                }\n\n                // Vertical\n                v =\n                    offset[1] === 1\n                        ? Math.floor(el.board.canvasHeight - maxY)\n                        : Math.floor(minY);\n                if (el.visPropOld.top !== ev_ay + v) {\n                    if (offset[1] === 1) {\n                        el.rendNode.style.bottom = v + \"px\";\n                        el.rendNode.style.top = \"auto\";\n                    } else {\n                        el.rendNode.style.top = v + \"px\";\n                        el.rendNode.style.bottom = \"auto\";\n                    }\n                    el.visPropOld.top = ev_ay + v;\n                }\n            }\n\n            if (el.htmlStr !== content) {\n                el.rendNodeText.data = content;\n                el.htmlStr = content;\n            }\n\n            //this.transformImage(el, el.transformations);\n            node.filters.item(0).M11 = m[1][1];\n            node.filters.item(0).M12 = m[1][2];\n            node.filters.item(0).M21 = m[2][1];\n            node.filters.item(0).M22 = m[2][2];\n            node.filters.item(0).enabled = true;\n        },\n\n        /* **************************\n         *    Image related stuff\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        drawImage: function (el) {\n            // IE 8: Bilder ueber data URIs werden bis 32kB unterstuetzt.\n            var node;\n\n            node = this.container.ownerDocument.createElement(\"img\");\n            node.style.position = \"absolute\";\n            this._setAttr(node, \"id\", this.container.id + \"_\" + el.id);\n\n            this.container.appendChild(node);\n            this.appendChildPrim(node, Type.evaluate(el.visProp.layer));\n\n            // Adding the rotation filter. This is always filter item 0:\n            // node.filters.item(0), see transformImage\n            // Also add the alpha filter. This is always filter item 1\n            // node.filters.item(1), see setObjectFillColor and setObjectSTrokeColor\n            //node.style.filter = node.style['-ms-filter'] = \"progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand')\";\n            node.style.filter =\n                \"progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand') progid:DXImageTransform.Microsoft.Alpha(opacity = 100, enabled = false)\";\n            el.rendNode = node;\n            this.updateImage(el);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        transformImage: function (el, t) {\n            var m,\n                s,\n                maxX,\n                maxY,\n                minX,\n                minY,\n                i,\n                nt,\n                node = el.rendNode,\n                p = [],\n                len = t.length;\n\n            if (len > 0) {\n                /*\n                nt = el.rendNode.style.filter.toString();\n                if (!nt.match(/DXImageTransform/)) {\n                    node.style.filter = \"progid:DXImageTransform.Microsoft.Matrix(M11='1.0', sizingMethod='auto expand') \" + nt;\n                }\n                */\n\n                m = this.joinTransforms(el, t);\n                p[0] = Mat.matVecMult(m, el.coords.scrCoords);\n                p[0][1] /= p[0][0];\n                p[0][2] /= p[0][0];\n                p[1] = Mat.matVecMult(m, [\n                    1,\n                    el.coords.scrCoords[1] + el.size[0],\n                    el.coords.scrCoords[2]\n                ]);\n                p[1][1] /= p[1][0];\n                p[1][2] /= p[1][0];\n                p[2] = Mat.matVecMult(m, [\n                    1,\n                    el.coords.scrCoords[1] + el.size[0],\n                    el.coords.scrCoords[2] - el.size[1]\n                ]);\n                p[2][1] /= p[2][0];\n                p[2][2] /= p[2][0];\n                p[3] = Mat.matVecMult(m, [\n                    1,\n                    el.coords.scrCoords[1],\n                    el.coords.scrCoords[2] - el.size[1]\n                ]);\n                p[3][1] /= p[3][0];\n                p[3][2] /= p[3][0];\n                maxX = p[0][1];\n                minX = p[0][1];\n                maxY = p[0][2];\n                minY = p[0][2];\n\n                for (i = 1; i < 4; i++) {\n                    maxX = Math.max(maxX, p[i][1]);\n                    minX = Math.min(minX, p[i][1]);\n                    maxY = Math.max(maxY, p[i][2]);\n                    minY = Math.min(minY, p[i][2]);\n                }\n                node.style.left = Math.floor(minX) + \"px\";\n                node.style.top = Math.floor(minY) + \"px\";\n\n                node.filters.item(0).M11 = m[1][1];\n                node.filters.item(0).M12 = m[1][2];\n                node.filters.item(0).M21 = m[2][1];\n                node.filters.item(0).M22 = m[2][2];\n                node.filters.item(0).enabled = true;\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateImageURL: function (el) {\n            var url = Type.evaluate(el.url);\n\n            this._setAttr(el.rendNode, \"src\", url);\n        },\n\n        /* **************************\n         * Render primitive objects\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        appendChildPrim: function (node, level) {\n            // For trace nodes\n            if (!Type.exists(level)) {\n                level = 0;\n            }\n\n            node.style.zIndex = level;\n            this.container.appendChild(node);\n\n            return node;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        appendNodesToElement: function (el, type) {\n            if (type === \"shape\" || type === \"path\" || type === \"polygon\") {\n                el.rendNodePath = this.getElementById(el.id + \"_path\");\n            }\n            el.rendNodeFill = this.getElementById(el.id + \"_fill\");\n            el.rendNodeStroke = this.getElementById(el.id + \"_stroke\");\n            el.rendNodeShadow = this.getElementById(el.id + \"_shadow\");\n            el.rendNode = this.getElementById(el.id);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        createPrim: function (type, id) {\n            var node,\n                pathNode,\n                fillNode = this.createNode(\"fill\"),\n                strokeNode = this.createNode(\"stroke\"),\n                shadowNode = this.createNode(\"shadow\");\n\n            this._setAttr(fillNode, \"id\", this.container.id + \"_\" + id + \"_fill\");\n            this._setAttr(strokeNode, \"id\", this.container.id + \"_\" + id + \"_stroke\");\n            this._setAttr(shadowNode, \"id\", this.container.id + \"_\" + id + \"_shadow\");\n\n            if (type === \"circle\" || type === \"ellipse\") {\n                node = this.createNode(\"oval\");\n                node.appendChild(fillNode);\n                node.appendChild(strokeNode);\n                node.appendChild(shadowNode);\n            } else if (\n                type === \"polygon\" ||\n                type === \"path\" ||\n                type === \"shape\" ||\n                type === \"line\"\n            ) {\n                node = this.createNode(\"shape\");\n                node.appendChild(fillNode);\n                node.appendChild(strokeNode);\n                node.appendChild(shadowNode);\n                pathNode = this.createNode(\"path\");\n                this._setAttr(pathNode, \"id\", this.container.id + \"_\" + id + \"_path\");\n                node.appendChild(pathNode);\n            } else {\n                node = this.createNode(type);\n                node.appendChild(fillNode);\n                node.appendChild(strokeNode);\n                node.appendChild(shadowNode);\n            }\n\n            node.style.position = \"absolute\";\n            node.style.left = \"0px\";\n            node.style.top = \"0px\";\n            this._setAttr(node, \"id\", this.container.id + \"_\" + id);\n\n            return node;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        remove: function (node) {\n            if (Type.exists(node)) {\n                node.removeNode(true);\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        makeArrows: function (el) {\n            var nodeStroke,\n                ev_fa = Type.evaluate(el.visProp.firstarrow),\n                ev_la = Type.evaluate(el.visProp.lastarrow);\n\n            if (el.visPropOld.firstarrow === ev_fa && el.visPropOld.lastarrow === ev_la) {\n                return;\n            }\n\n            if (ev_fa) {\n                nodeStroke = el.rendNodeStroke;\n                this._setAttr(nodeStroke, \"startarrow\", \"block\");\n                this._setAttr(nodeStroke, \"startarrowlength\", \"long\");\n            } else {\n                nodeStroke = el.rendNodeStroke;\n                if (Type.exists(nodeStroke)) {\n                    this._setAttr(nodeStroke, \"startarrow\", \"none\");\n                }\n            }\n\n            if (ev_la) {\n                nodeStroke = el.rendNodeStroke;\n                this._setAttr(nodeStroke, \"id\", this.container.id + \"_\" + el.id + \"stroke\");\n                this._setAttr(nodeStroke, \"endarrow\", \"block\");\n                this._setAttr(nodeStroke, \"endarrowlength\", \"long\");\n            } else {\n                nodeStroke = el.rendNodeStroke;\n                if (Type.exists(nodeStroke)) {\n                    this._setAttr(nodeStroke, \"endarrow\", \"none\");\n                }\n            }\n            el.visPropOld.firstarrow = ev_fa;\n            el.visPropOld.lastarrow = ev_la;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateEllipsePrim: function (node, x, y, rx, ry) {\n            node.style.left = Math.floor(x - rx) + \"px\";\n            node.style.top = Math.floor(y - ry) + \"px\";\n            node.style.width = Math.floor(Math.abs(rx) * 2) + \"px\";\n            node.style.height = Math.floor(Math.abs(ry) * 2) + \"px\";\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateLinePrim: function (node, p1x, p1y, p2x, p2y, board) {\n            var s,\n                r = this.resolution;\n\n            if (!isNaN(p1x + p1y + p2x + p2y)) {\n                s = [\n                    \"m \",\n                    Math.floor(r * p1x),\n                    \", \",\n                    Math.floor(r * p1y),\n                    \" l \",\n                    Math.floor(r * p2x),\n                    \", \",\n                    Math.floor(r * p2y)\n                ];\n                this.updatePathPrim(node, s, board);\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathPrim: function (node, pointString, board) {\n            var x = board.canvasWidth,\n                y = board.canvasHeight;\n            if (pointString.length <= 0) {\n                pointString = [\"m 0,0\"];\n            }\n            node.style.width = x;\n            node.style.height = y;\n            this._setAttr(\n                node,\n                \"coordsize\",\n                [Math.floor(this.resolution * x), Math.floor(this.resolution * y)].join(\",\")\n            );\n            this._setAttr(node, \"path\", pointString.join(\"\"));\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathStringPoint: function (el, size, type) {\n            var s = [],\n                mround = Math.round,\n                scr = el.coords.scrCoords,\n                sqrt32 = size * Math.sqrt(3) * 0.5,\n                s05 = size * 0.5,\n                r = this.resolution;\n\n            if (type === \"x\") {\n                s.push(\n                    [\n                        \" m \",\n                        mround(r * (scr[1] - size)),\n                        \", \",\n                        mround(r * (scr[2] - size)),\n                        \" l \",\n                        mround(r * (scr[1] + size)),\n                        \", \",\n                        mround(r * (scr[2] + size)),\n                        \" m \",\n                        mround(r * (scr[1] + size)),\n                        \", \",\n                        mround(r * (scr[2] - size)),\n                        \" l \",\n                        mround(r * (scr[1] - size)),\n                        \", \",\n                        mround(r * (scr[2] + size))\n                    ].join(\"\")\n                );\n            } else if (type === \"+\") {\n                s.push(\n                    [\n                        \" m \",\n                        mround(r * (scr[1] - size)),\n                        \", \",\n                        mround(r * scr[2]),\n                        \" l \",\n                        mround(r * (scr[1] + size)),\n                        \", \",\n                        mround(r * scr[2]),\n                        \" m \",\n                        mround(r * scr[1]),\n                        \", \",\n                        mround(r * (scr[2] - size)),\n                        \" l \",\n                        mround(r * scr[1]),\n                        \", \",\n                        mround(r * (scr[2] + size))\n                    ].join(\"\")\n                );\n            } else if (type === \"<>\") {\n                s.push(\n                    [\n                        \" m \",\n                        mround(r * (scr[1] - size)),\n                        \", \",\n                        mround(r * scr[2]),\n                        \" l \",\n                        mround(r * scr[1]),\n                        \", \",\n                        mround(r * (scr[2] + size)),\n                        \" l \",\n                        mround(r * (scr[1] + size)),\n                        \", \",\n                        mround(r * scr[2]),\n                        \" l \",\n                        mround(r * scr[1]),\n                        \", \",\n                        mround(r * (scr[2] - size)),\n                        \" x e \"\n                    ].join(\"\")\n                );\n            } else if (type === \"^\") {\n                s.push(\n                    [\n                        \" m \",\n                        mround(r * scr[1]),\n                        \", \",\n                        mround(r * (scr[2] - size)),\n                        \" l \",\n                        mround(r * (scr[1] - sqrt32)),\n                        \", \",\n                        mround(r * (scr[2] + s05)),\n                        \" l \",\n                        mround(r * (scr[1] + sqrt32)),\n                        \", \",\n                        mround(r * (scr[2] + s05)),\n                        \" x e \"\n                    ].join(\"\")\n                );\n            } else if (type === \"v\") {\n                s.push(\n                    [\n                        \" m \",\n                        mround(r * scr[1]),\n                        \", \",\n                        mround(r * (scr[2] + size)),\n                        \" l \",\n                        mround(r * (scr[1] - sqrt32)),\n                        \", \",\n                        mround(r * (scr[2] - s05)),\n                        \" l \",\n                        mround(r * (scr[1] + sqrt32)),\n                        \", \",\n                        mround(r * (scr[2] - s05)),\n                        \" x e \"\n                    ].join(\"\")\n                );\n            } else if (type === \">\") {\n                s.push(\n                    [\n                        \" m \",\n                        mround(r * (scr[1] + size)),\n                        \", \",\n                        mround(r * scr[2]),\n                        \" l \",\n                        mround(r * (scr[1] - s05)),\n                        \", \",\n                        mround(r * (scr[2] - sqrt32)),\n                        \" l \",\n                        mround(r * (scr[1] - s05)),\n                        \", \",\n                        mround(r * (scr[2] + sqrt32)),\n                        \" l \",\n                        mround(r * (scr[1] + size)),\n                        \", \",\n                        mround(r * scr[2])\n                    ].join(\"\")\n                );\n            } else if (type === \"<\") {\n                s.push(\n                    [\n                        \" m \",\n                        mround(r * (scr[1] - size)),\n                        \", \",\n                        mround(r * scr[2]),\n                        \" l \",\n                        mround(r * (scr[1] + s05)),\n                        \", \",\n                        mround(r * (scr[2] - sqrt32)),\n                        \" l \",\n                        mround(r * (scr[1] + s05)),\n                        \", \",\n                        mround(r * (scr[2] + sqrt32)),\n                        \" x e \"\n                    ].join(\"\")\n                );\n            }\n\n            return s;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathStringPrim: function (el) {\n            var i,\n                scr,\n                pStr = [],\n                r = this.resolution,\n                mround = Math.round,\n                symbm = \" m \",\n                symbl = \" l \",\n                symbc = \" c \",\n                nextSymb = symbm,\n                len = Math.min(el.numberPoints, 8192); // otherwise IE 7 crashes in hilbert.html\n\n            if (el.numberPoints <= 0) {\n                return \"\";\n            }\n            len = Math.min(len, el.points.length);\n\n            if (el.bezierDegree === 1) {\n                /*\n                if (isNotPlot && el.board.options.curve.RDPsmoothing) {\n                    el.points = Numerics.RamerDouglasPeucker(el.points, 1.0);\n                }\n                */\n\n                for (i = 0; i < len; i++) {\n                    scr = el.points[i].scrCoords;\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        // IE has problems with values  being too far away.\n                        if (scr[1] > 20000.0) {\n                            scr[1] = 20000.0;\n                        } else if (scr[1] < -20000.0) {\n                            scr[1] = -20000.0;\n                        }\n\n                        if (scr[2] > 20000.0) {\n                            scr[2] = 20000.0;\n                        } else if (scr[2] < -20000.0) {\n                            scr[2] = -20000.0;\n                        }\n\n                        pStr.push(\n                            [nextSymb, mround(r * scr[1]), \", \", mround(r * scr[2])].join(\"\")\n                        );\n                        nextSymb = symbl;\n                    }\n                }\n            } else if (el.bezierDegree === 3) {\n                i = 0;\n                while (i < len) {\n                    scr = el.points[i].scrCoords;\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        pStr.push(\n                            [nextSymb, mround(r * scr[1]), \", \", mround(r * scr[2])].join(\"\")\n                        );\n                        if (nextSymb === symbc) {\n                            i += 1;\n                            scr = el.points[i].scrCoords;\n                            pStr.push(\n                                [\" \", mround(r * scr[1]), \", \", mround(r * scr[2])].join(\"\")\n                            );\n                            i += 1;\n                            scr = el.points[i].scrCoords;\n                            pStr.push(\n                                [\" \", mround(r * scr[1]), \", \", mround(r * scr[2])].join(\"\")\n                            );\n                        }\n                        nextSymb = symbc;\n                    }\n                    i += 1;\n                }\n            }\n            pStr.push(\" e\");\n            return pStr;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathStringBezierPrim: function (el) {\n            var i,\n                j,\n                k,\n                scr,\n                lx,\n                ly,\n                pStr = [],\n                f = Type.evaluate(el.visProp.strokewidth),\n                r = this.resolution,\n                mround = Math.round,\n                symbm = \" m \",\n                symbl = \" c \",\n                nextSymb = symbm,\n                isNoPlot = Type.evaluate(el.visProp.curvetype) !== \"plot\",\n                len = Math.min(el.numberPoints, 8192); // otherwise IE 7 crashes in hilbert.html\n\n            if (el.numberPoints <= 0) {\n                return \"\";\n            }\n            if (isNoPlot && el.board.options.curve.RDPsmoothing) {\n                el.points = Numerics.RamerDouglasPeucker(el.points, 1.0);\n            }\n            len = Math.min(len, el.points.length);\n\n            for (j = 1; j < 3; j++) {\n                nextSymb = symbm;\n                for (i = 0; i < len; i++) {\n                    scr = el.points[i].scrCoords;\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        // IE has problems with values  being too far away.\n                        if (scr[1] > 20000.0) {\n                            scr[1] = 20000.0;\n                        } else if (scr[1] < -20000.0) {\n                            scr[1] = -20000.0;\n                        }\n\n                        if (scr[2] > 20000.0) {\n                            scr[2] = 20000.0;\n                        } else if (scr[2] < -20000.0) {\n                            scr[2] = -20000.0;\n                        }\n\n                        if (nextSymb === symbm) {\n                            pStr.push(\n                                [nextSymb, mround(r * scr[1]), \" \", mround(r * scr[2])].join(\"\")\n                            );\n                        } else {\n                            k = 2 * j;\n                            pStr.push(\n                                [\n                                    nextSymb,\n                                    mround(\n                                        r *\n                                            (lx +\n                                                (scr[1] - lx) * 0.333 +\n                                                f * (k * Math.random() - j))\n                                    ),\n                                    \" \",\n                                    mround(\n                                        r *\n                                            (ly +\n                                                (scr[2] - ly) * 0.333 +\n                                                f * (k * Math.random() - j))\n                                    ),\n                                    \" \",\n                                    mround(\n                                        r *\n                                            (lx +\n                                                (scr[1] - lx) * 0.666 +\n                                                f * (k * Math.random() - j))\n                                    ),\n                                    \" \",\n                                    mround(\n                                        r *\n                                            (ly +\n                                                (scr[2] - ly) * 0.666 +\n                                                f * (k * Math.random() - j))\n                                    ),\n                                    \" \",\n                                    mround(r * scr[1]),\n                                    \" \",\n                                    mround(r * scr[2])\n                                ].join(\"\")\n                            );\n                        }\n                        nextSymb = symbl;\n                        lx = scr[1];\n                        ly = scr[2];\n                    }\n                }\n            }\n            pStr.push(\" e\");\n            return pStr;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePolygonPrim: function (node, el) {\n            var i,\n                len = el.vertices.length,\n                r = this.resolution,\n                scr,\n                pStr = [];\n\n            this._setAttr(node, \"stroked\", \"false\");\n            scr = el.vertices[0].coords.scrCoords;\n\n            if (isNaN(scr[1] + scr[2])) {\n                return;\n            }\n\n            pStr.push(\n                [\"m \", Math.floor(r * scr[1]), \",\", Math.floor(r * scr[2]), \" l \"].join(\"\")\n            );\n\n            for (i = 1; i < len - 1; i++) {\n                if (el.vertices[i].isReal) {\n                    scr = el.vertices[i].coords.scrCoords;\n\n                    if (isNaN(scr[1] + scr[2])) {\n                        return;\n                    }\n\n                    pStr.push(Math.floor(r * scr[1]) + \",\" + Math.floor(r * scr[2]));\n                } else {\n                    this.updatePathPrim(node, \"\", el.board);\n                    return;\n                }\n                if (i < len - 2) {\n                    pStr.push(\", \");\n                }\n            }\n            pStr.push(\" x e\");\n            this.updatePathPrim(node, pStr, el.board);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateRectPrim: function (node, x, y, w, h) {\n            node.style.left = Math.floor(x) + \"px\";\n            node.style.top = Math.floor(y) + \"px\";\n\n            if (w >= 0) {\n                node.style.width = w + \"px\";\n            }\n\n            if (h >= 0) {\n                node.style.height = h + \"px\";\n            }\n        },\n\n        /* **************************\n         *  Set Attributes\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        setPropertyPrim: function (node, key, val) {\n            var keyVml = \"\",\n                v;\n\n            switch (key) {\n                case \"stroke\":\n                    keyVml = \"strokecolor\";\n                    break;\n                case \"stroke-width\":\n                    keyVml = \"strokeweight\";\n                    break;\n                case \"stroke-dasharray\":\n                    keyVml = \"dashstyle\";\n                    break;\n            }\n\n            if (keyVml !== \"\") {\n                v = Type.evaluate(val);\n                this._setAttr(node, keyVml, v);\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        display: function (el, val) {\n            if (el && el.rendNode) {\n                el.visPropOld.visible = val;\n                if (val) {\n                    el.rendNode.style.visibility = \"inherit\";\n                } else {\n                    el.rendNode.style.visibility = \"hidden\";\n                }\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        show: function (el) {\n            JXG.deprecated(\"Board.renderer.show()\", \"Board.renderer.display()\");\n\n            if (el && el.rendNode) {\n                el.rendNode.style.visibility = \"inherit\";\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        hide: function (el) {\n            JXG.deprecated(\"Board.renderer.hide()\", \"Board.renderer.display()\");\n\n            if (el && el.rendNode) {\n                el.rendNode.style.visibility = \"hidden\";\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        setDashStyle: function (el, visProp) {\n            var node;\n            if (visProp.dash >= 0) {\n                node = el.rendNodeStroke;\n                this._setAttr(node, \"dashstyle\", this.dashArray[visProp.dash]);\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        setGradient: function (el) {\n            var nodeFill = el.rendNodeFill,\n                ev_g = Type.evaluate(el.visProp.gradient);\n\n            if (ev_g === \"linear\") {\n                this._setAttr(nodeFill, \"type\", \"gradient\");\n                this._setAttr(\n                    nodeFill,\n                    \"color2\",\n                    Type.evaluate(el.visProp.gradientsecondcolor)\n                );\n                this._setAttr(\n                    nodeFill,\n                    \"opacity2\",\n                    Type.evaluate(el.visProp.gradientsecondopacity)\n                );\n                this._setAttr(nodeFill, \"angle\", Type.evaluate(el.visProp.gradientangle));\n            } else if (ev_g === \"radial\") {\n                this._setAttr(nodeFill, \"type\", \"gradientradial\");\n                this._setAttr(\n                    nodeFill,\n                    \"color2\",\n                    Type.evaluate(el.visProp.gradientsecondcolor)\n                );\n                this._setAttr(\n                    nodeFill,\n                    \"opacity2\",\n                    Type.evaluate(el.visProp.gradientsecondopacity)\n                );\n                this._setAttr(\n                    nodeFill,\n                    \"focusposition\",\n                    Type.evaluate(el.visProp.gradientpositionx) * 100 +\n                        \"%,\" +\n                        Type.evaluate(el.visProp.gradientpositiony) * 100 +\n                        \"%\"\n                );\n                this._setAttr(nodeFill, \"focussize\", \"0,0\");\n            } else {\n                this._setAttr(nodeFill, \"type\", \"solid\");\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        setObjectFillColor: function (el, color, opacity) {\n            var rgba = Type.evaluate(color),\n                c,\n                rgbo,\n                o = Type.evaluate(opacity),\n                oo,\n                node = el.rendNode,\n                t;\n\n            o = o > 0 ? o : 0;\n\n            if (el.visPropOld.fillcolor === rgba && el.visPropOld.fillopacity === o) {\n                return;\n            }\n\n            if (Type.exists(rgba) && rgba !== false) {\n                // RGB, not RGBA\n                if (rgba.length !== 9) {\n                    c = rgba;\n                    oo = o;\n                    // True RGBA, not RGB\n                } else {\n                    rgbo = Color.rgba2rgbo(rgba);\n                    c = rgbo[0];\n                    oo = o * rgbo[1];\n                }\n                if (c === \"none\" || c === false) {\n                    this._setAttr(el.rendNode, \"filled\", \"false\");\n                } else {\n                    this._setAttr(el.rendNode, \"filled\", \"true\");\n                    this._setAttr(el.rendNode, \"fillcolor\", c);\n\n                    if (Type.exists(oo) && el.rendNodeFill) {\n                        this._setAttr(el.rendNodeFill, \"opacity\", oo * 100 + \"%\");\n                    }\n                }\n                if (el.type === Const.OBJECT_TYPE_IMAGE) {\n                    /*\n                    t = el.rendNode.style.filter.toString();\n                    if (t.match(/alpha/)) {\n                        el.rendNode.style.filter = t.replace(/alpha\\(opacity *= *[0-9\\.]+\\)/, 'alpha(opacity = ' + (oo * 100) + ')');\n                    } else {\n                        el.rendNode.style.filter += ' alpha(opacity = ' + (oo * 100) + ')';\n                    }\n                    */\n                    if (node.filters.length > 1) {\n                        // Why am I sometimes seeing node.filters.length==0 here when I move the pointer around near [0,0]?\n                        // Setting axes:true shows text labels!\n                        node.filters.item(1).opacity = Math.round(oo * 100); // Why does setObjectFillColor not use Math.round?\n                        node.filters.item(1).enabled = true;\n                    }\n                }\n            }\n            el.visPropOld.fillcolor = rgba;\n            el.visPropOld.fillopacity = o;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        setObjectStrokeColor: function (el, color, opacity) {\n            var rgba = Type.evaluate(color),\n                c,\n                rgbo,\n                t,\n                o = Type.evaluate(opacity),\n                oo,\n                node = el.rendNode,\n                nodeStroke;\n\n            o = o > 0 ? o : 0;\n\n            if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {\n                return;\n            }\n\n            // this looks like it could be merged with parts of VMLRenderer.setObjectFillColor\n\n            if (Type.exists(rgba) && rgba !== false) {\n                // RGB, not RGBA\n                if (rgba.length !== 9) {\n                    c = rgba;\n                    oo = o;\n                    // True RGBA, not RGB\n                } else {\n                    rgbo = color.rgba2rgbo(rgba);\n                    c = rgbo[0];\n                    oo = o * rgbo[1];\n                }\n                if (el.elementClass === Const.OBJECT_CLASS_TEXT) {\n                    //node.style.filter = ' alpha(opacity = ' + oo + ')';\n                    /*\n                    t = node.style.filter.toString();\n                    if (t.match(/alpha/)) {\n                        node.style.filter =\n                        t.replace(/alpha\\(opacity *= *[0-9\\.]+\\)/, 'alpha(opacity = ' + oo + ')');\n                    } else {\n                        node.style.filter += ' alpha(opacity = ' + oo + ')';\n                    }\n                    */\n                    if (node.filters.length > 1) {\n                        // Why am I sometimes seeing node.filters.length==0 here when I move the pointer around near [0,0]?\n                        // Setting axes:true shows text labels!\n                        node.filters.item(1).opacity = Math.round(oo * 100);\n                        node.filters.item(1).enabled = true;\n                    }\n\n                    node.style.color = c;\n                } else {\n                    if (c !== false) {\n                        this._setAttr(node, \"stroked\", \"true\");\n                        this._setAttr(node, \"strokecolor\", c);\n                    }\n\n                    nodeStroke = el.rendNodeStroke;\n                    if (Type.exists(oo) && el.type !== Const.OBJECT_TYPE_IMAGE) {\n                        this._setAttr(nodeStroke, \"opacity\", oo * 100 + \"%\");\n                    }\n                }\n            }\n            el.visPropOld.strokecolor = rgba;\n            el.visPropOld.strokeopacity = o;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        setObjectStrokeWidth: function (el, width) {\n            var w = Type.evaluate(width),\n                node;\n\n            if (isNaN(w) || el.visPropOld.strokewidth === w) {\n                return;\n            }\n\n            node = el.rendNode;\n            this.setPropertyPrim(node, \"stroked\", \"true\");\n\n            if (Type.exists(w)) {\n                this.setPropertyPrim(node, \"stroke-width\", w);\n                if (w === 0 && Type.exists(el.rendNodeStroke)) {\n                    this._setAttr(node, \"stroked\", \"false\");\n                }\n            }\n\n            el.visPropOld.strokewidth = w;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        setShadow: function (el) {\n            var nodeShadow = el.rendNodeShadow,\n                ev_s = Type.evaluate(el.visProp.shadow);\n\n            if (!nodeShadow || el.visPropOld.shadow === ev_s) {\n                return;\n            }\n\n            if (ev_s) {\n                this._setAttr(nodeShadow, \"On\", \"True\");\n                this._setAttr(nodeShadow, \"Offset\", \"3pt,3pt\");\n                this._setAttr(nodeShadow, \"Opacity\", \"60%\");\n                this._setAttr(nodeShadow, \"Color\", \"#aaaaaa\");\n            } else {\n                this._setAttr(nodeShadow, \"On\", \"False\");\n            }\n\n            el.visPropOld.shadow = ev_s;\n        },\n\n        /* **************************\n         * renderer control\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        suspendRedraw: function () {\n            this.container.style.display = \"none\";\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        unsuspendRedraw: function () {\n            this.container.style.display = \"\";\n        }\n    }\n);\n\nexport default JXG.VMLRenderer;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, document: true, Image: true, module: true, require: true */\n/*jslint nomen: true, plusplus: true, newcap:true*/\n\nimport JXG from \"../jxg\";\nimport AbstractRenderer from \"./abstract\";\nimport Const from \"../base/constants\";\nimport Env from \"../utils/env\";\nimport Type from \"../utils/type\";\nimport UUID from \"../utils/uuid\";\nimport Color from \"../utils/color\";\nimport Coords from \"../base/coords\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Numerics from \"../math/numerics\";\n// import $__canvas from \"canvas\";\n\n/**\n * Uses HTML Canvas to implement the rendering methods defined in {@link JXG.AbstractRenderer}.\n *\n * @class JXG.CanvasRenderer\n * @augments JXG.AbstractRenderer\n * @param {Node} container Reference to a DOM node containing the board.\n * @param {Object} dim The dimensions of the board\n * @param {Number} dim.width\n * @param {Number} dim.height\n * @see JXG.AbstractRenderer\n */\nJXG.CanvasRenderer = function (container, dim) {\n    this.type = \"canvas\";\n\n    this.canvasRoot = null;\n    this.suspendHandle = null;\n    this.canvasId = UUID.genUUID();\n\n    this.canvasNamespace = null;\n\n    if (Env.isBrowser) {\n        this.container = container;\n        this.container.style.MozUserSelect = \"none\";\n        this.container.style.userSelect = \"none\";\n\n        this.container.style.overflow = \"hidden\";\n        if (this.container.style.position === \"\") {\n            this.container.style.position = \"relative\";\n        }\n\n        this.container.innerHTML = [\n            '<canvas id=\"',\n            this.canvasId,\n            '\" width=\"',\n            dim.width,\n            'px\" height=\"',\n            dim.height,\n            'px\"><',\n            \"/canvas>\"\n        ].join(\"\");\n        this.canvasRoot = this.container.ownerDocument.getElementById(this.canvasId);\n        this.canvasRoot.style.display = \"block\";\n        this.context = this.canvasRoot.getContext(\"2d\");\n    } else if (Env.isNode()) {\n        // Do not use try to get more concise error message\n        // try {\n            // this.canvasId = typeof module === \"object\" ? module.require(\"canvas\") : $__canvas;\n            // this.canvasRoot = new this.canvasId(500, 500);\n            this.canvasId = typeof module === \"object\" ? module.require('canvas') : import('canvas');\n            // this.canvasId = (typeof module === 'object' ? module.require('canvas') : require('canvas'));\n            this.canvasRoot = this.canvasId.createCanvas(500, 500);\n            this.context = this.canvasRoot.getContext(\"2d\");\n        // } catch (err) {\n        //     console.log(\n        //         \"Warning: 'canvas' not found. You might need to call 'npm install canvas'\"\n        //     );\n        // }\n    }\n\n    this.dashArray = [\n        [2, 2],\n        [5, 5],\n        [10, 10],\n        [20, 20],\n        [20, 10, 10, 10],\n        [20, 5, 10, 5]\n    ];\n};\n\nJXG.CanvasRenderer.prototype = new AbstractRenderer();\n\nJXG.extend(\n    JXG.CanvasRenderer.prototype,\n    /** @lends JXG.CanvasRenderer.prototype */ {\n        /* **************************\n         *   private methods only used\n         *   in this renderer. Should\n         *   not be called from outside.\n         * **************************/\n\n        /**\n         * Draws a filled polygon.\n         * @param {Array} shape A matrix presented by a two dimensional array of numbers.\n         * @see JXG.AbstractRenderer#drawArrows\n         * @private\n         */\n        _drawPolygon: function (shape, degree, doFill) {\n            var i,\n                len = shape.length,\n                context = this.context;\n\n            if (len > 0) {\n                if (doFill) {\n                    context.lineWidth = 0;\n                }\n                context.beginPath();\n                context.moveTo(shape[0][0], shape[0][1]);\n                if (degree === 1) {\n                    for (i = 1; i < len; i++) {\n                        context.lineTo(shape[i][0], shape[i][1]);\n                    }\n                } else {\n                    for (i = 1; i < len; i += 3) {\n                        context.bezierCurveTo(\n                            shape[i][0],\n                            shape[i][1],\n                            shape[i + 1][0],\n                            shape[i + 1][1],\n                            shape[i + 2][0],\n                            shape[i + 2][1]\n                        );\n                    }\n                }\n                if (doFill) {\n                    context.lineTo(shape[0][0], shape[0][1]);\n                    context.closePath();\n                    context.fill(\"evenodd\");\n                } else {\n                    context.stroke();\n                }\n            }\n        },\n\n        /**\n         * Sets the fill color and fills an area.\n         * @param {JXG.GeometryElement} el An arbitrary JSXGraph element, preferably one with an area.\n         * @private\n         */\n        _fill: function (el) {\n            var context = this.context;\n\n            context.save();\n            if (this._setColor(el, \"fill\")) {\n                context.fill(\"evenodd\");\n            }\n            context.restore();\n        },\n\n        /**\n         * Rotates a point around <tt>(0, 0)</tt> by a given angle.\n         * @param {Number} angle An angle, given in rad.\n         * @param {Number} x X coordinate of the point.\n         * @param {Number} y Y coordinate of the point.\n         * @returns {Array} An array containing the x and y coordinate of the rotated point.\n         * @private\n         */\n        _rotatePoint: function (angle, x, y) {\n            return [\n                x * Math.cos(angle) - y * Math.sin(angle),\n                x * Math.sin(angle) + y * Math.cos(angle)\n            ];\n        },\n\n        /**\n         * Rotates an array of points around <tt>(0, 0)</tt>.\n         * @param {Array} shape An array of array of point coordinates.\n         * @param {Number} angle The angle in rad the points are rotated by.\n         * @returns {Array} Array of array of two dimensional point coordinates.\n         * @private\n         */\n        _rotateShape: function (shape, angle) {\n            var i,\n                rv = [],\n                len = shape.length;\n\n            if (len <= 0) {\n                return shape;\n            }\n\n            for (i = 0; i < len; i++) {\n                rv.push(this._rotatePoint(angle, shape[i][0], shape[i][1]));\n            }\n\n            return rv;\n        },\n\n        /**\n         * Set the gradient angle for linear color gradients.\n         *\n         * @private\n         * @param {JXG.GeometryElement} node An arbitrary JSXGraph element, preferably one with an area.\n         * @param {Number} radians angle value in radians. 0 is horizontal from left to right, Pi/4 is vertical from top to bottom.\n         */\n        updateGradientAngle: function (el, radians) {\n            // Angles:\n            // 0: ->\n            // 90: down\n            // 180: <-\n            // 90: up\n            var f = 1.0,\n                co = Math.cos(-radians),\n                si = Math.sin(-radians),\n                bb = el.getBoundingBox(),\n                c1,\n                c2,\n                x1,\n                x2,\n                y1,\n                y2,\n                x1s,\n                x2s,\n                y1s,\n                y2s,\n                dx,\n                dy;\n\n            if (Math.abs(co) > Math.abs(si)) {\n                f /= Math.abs(co);\n            } else {\n                f /= Math.abs(si);\n            }\n            if (co >= 0) {\n                x1 = 0;\n                x2 = co * f;\n            } else {\n                x1 = -co * f;\n                x2 = 0;\n            }\n            if (si >= 0) {\n                y1 = 0;\n                y2 = si * f;\n            } else {\n                y1 = -si * f;\n                y2 = 0;\n            }\n\n            c1 = new Coords(Const.COORDS_BY_USER, [bb[0], bb[1]], el.board);\n            c2 = new Coords(Const.COORDS_BY_USER, [bb[2], bb[3]], el.board);\n            dx = c2.scrCoords[1] - c1.scrCoords[1];\n            dy = c2.scrCoords[2] - c1.scrCoords[2];\n            x1s = c1.scrCoords[1] + dx * x1;\n            y1s = c1.scrCoords[2] + dy * y1;\n            x2s = c1.scrCoords[1] + dx * x2;\n            y2s = c1.scrCoords[2] + dy * y2;\n\n            return this.context.createLinearGradient(x1s, y1s, x2s, y2s);\n        },\n\n        /**\n         * Set circles for radial color gradients.\n         *\n         * @private\n         * @param {SVGnode} node SVG gradient node\n         * @param {Number} cx Canvas value x1 (but value between 0 and 1)\n         * @param {Number} cy  Canvas value y1 (but value between 0 and 1)\n         * @param {Number} r  Canvas value r1 (but value between 0 and 1)\n         * @param {Number} fx  Canvas value x0 (but value between 0 and 1)\n         * @param {Number} fy  Canvas value x1 (but value between 0 and 1)\n         * @param {Number} fr  Canvas value r0 (but value between 0 and 1)\n         */\n        updateGradientCircle: function (el, cx, cy, r, fx, fy, fr) {\n            var bb = el.getBoundingBox(),\n                c1,\n                c2,\n                cxs,\n                cys,\n                rs,\n                fxs,\n                fys,\n                frs,\n                dx,\n                dy;\n\n            c1 = new Coords(Const.COORDS_BY_USER, [bb[0], bb[1]], el.board);\n            c2 = new Coords(Const.COORDS_BY_USER, [bb[2], bb[3]], el.board);\n            dx = c2.scrCoords[1] - c1.scrCoords[1];\n            dy = c1.scrCoords[2] - c2.scrCoords[2];\n\n            cxs = c1.scrCoords[1] + dx * cx;\n            cys = c2.scrCoords[2] + dy * cy;\n            fxs = c1.scrCoords[1] + dx * fx;\n            fys = c2.scrCoords[2] + dy * fy;\n            rs = r * (dx + dy) * 0.5;\n            frs = fr * (dx + dy) * 0.5;\n\n            return this.context.createRadialGradient(fxs, fys, frs, cxs, cys, rs);\n        },\n\n        // documented in JXG.AbstractRenderer\n        updateGradient: function (el) {\n            var col,\n                op,\n                ev_g = Type.evaluate(el.visProp.gradient),\n                gradient;\n\n            op = Type.evaluate(el.visProp.fillopacity);\n            op = op > 0 ? op : 0;\n            col = Type.evaluate(el.visProp.fillcolor);\n\n            if (ev_g === \"linear\") {\n                gradient = this.updateGradientAngle(\n                    el,\n                    Type.evaluate(el.visProp.gradientangle)\n                );\n            } else if (ev_g === \"radial\") {\n                gradient = this.updateGradientCircle(\n                    el,\n                    Type.evaluate(el.visProp.gradientcx),\n                    Type.evaluate(el.visProp.gradientcy),\n                    Type.evaluate(el.visProp.gradientr),\n                    Type.evaluate(el.visProp.gradientfx),\n                    Type.evaluate(el.visProp.gradientfy),\n                    Type.evaluate(el.visProp.gradientfr)\n                );\n            }\n            gradient.addColorStop(Type.evaluate(el.visProp.gradientstartoffset), col);\n            gradient.addColorStop(\n                Type.evaluate(el.visProp.gradientendoffset),\n                Type.evaluate(el.visProp.gradientsecondcolor)\n            );\n            return gradient;\n        },\n\n        /**\n         * Sets color and opacity for filling and stroking.\n         * type is the attribute from visProp and targetType the context[targetTypeStyle].\n         * This is necessary, because the fill style of a text is set by the stroke attributes of the text element.\n         * @param {JXG.GeometryElement} el Any JSXGraph element.\n         * @param {String} [type='stroke'] Either <em>fill</em> or <em>stroke</em>.\n         * @param {String} [targetType=type] (optional) Either <em>fill</em> or <em>stroke</em>.\n         * @returns {Boolean} If the color could be set, <tt>true</tt> is returned.\n         * @private\n         */\n        _setColor: function (el, type, targetType) {\n            var hasColor = true,\n                ev = el.visProp,\n                hl,\n                sw,\n                rgba,\n                rgbo,\n                c,\n                o,\n                oo,\n                grad;\n\n            type = type || \"stroke\";\n            targetType = targetType || type;\n\n            hl = this._getHighlighted(el);\n\n            grad = Type.evaluate(el.visProp.gradient);\n            if (grad === \"linear\" || grad === \"radial\") {\n                // TODO: opacity\n                this.context[targetType + \"Style\"] = this.updateGradient(el);\n                return hasColor;\n            }\n\n            // type is equal to 'fill' or 'stroke'\n            rgba = Type.evaluate(ev[hl + type + \"color\"]);\n            if (rgba !== \"none\" && rgba !== false) {\n                o = Type.evaluate(ev[hl + type + \"opacity\"]);\n                o = o > 0 ? o : 0;\n\n                // RGB, not RGBA\n                if (rgba.length !== 9) {\n                    c = rgba;\n                    oo = o;\n                    // True RGBA, not RGB\n                } else {\n                    rgbo = Color.rgba2rgbo(rgba);\n                    c = rgbo[0];\n                    oo = o * rgbo[1];\n                }\n                this.context.globalAlpha = oo;\n\n                this.context[targetType + \"Style\"] = c;\n            } else {\n                hasColor = false;\n            }\n\n            sw = parseFloat(Type.evaluate(ev[hl + \"strokewidth\"]));\n            if (type === \"stroke\" && !isNaN(sw)) {\n                if (sw === 0) {\n                    this.context.globalAlpha = 0;\n                } else {\n                    this.context.lineWidth = sw;\n                }\n            }\n\n            if (type === \"stroke\" && ev.linecap !== undefined && ev.linecap !== \"\") {\n                this.context.lineCap = ev.linecap;\n            }\n\n            return hasColor;\n        },\n\n        /**\n         * Sets color and opacity for drawing paths and lines and draws the paths and lines.\n         * @param {JXG.GeometryElement} el An JSXGraph element with a stroke.\n         * @private\n         */\n        _stroke: function (el) {\n            var context = this.context,\n                ev_dash = Type.evaluate(el.visProp.dash);\n\n            context.save();\n\n            if (ev_dash > 0) {\n                if (context.setLineDash) {\n                    context.setLineDash(this.dashArray[ev_dash]);\n                }\n            } else {\n                this.context.lineDashArray = [];\n            }\n\n            if (this._setColor(el, \"stroke\")) {\n                context.stroke();\n            }\n\n            context.restore();\n        },\n\n        /**\n         * Translates a set of points.\n         * @param {Array} shape An array of point coordinates.\n         * @param {Number} x Translation in X direction.\n         * @param {Number} y Translation in Y direction.\n         * @returns {Array} An array of translated point coordinates.\n         * @private\n         */\n        _translateShape: function (shape, x, y) {\n            var i,\n                rv = [],\n                len = shape.length;\n\n            if (len <= 0) {\n                return shape;\n            }\n\n            for (i = 0; i < len; i++) {\n                rv.push([shape[i][0] + x, shape[i][1] + y]);\n            }\n\n            return rv;\n        },\n\n        /* ******************************** *\n         *    Point drawing and updating    *\n         * ******************************** */\n\n        // documented in AbstractRenderer\n        drawPoint: function (el) {\n            var f = Type.evaluate(el.visProp.face),\n                size = Type.evaluate(el.visProp.size),\n                scr = el.coords.scrCoords,\n                sqrt32 = size * Math.sqrt(3) * 0.5,\n                s05 = size * 0.5,\n                stroke05 = parseFloat(Type.evaluate(el.visProp.strokewidth)) / 2.0,\n                context = this.context;\n\n            if (!el.visPropCalc.visible) {\n                return;\n            }\n\n            switch (f) {\n                case \"cross\": // x\n                case \"x\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2] - size);\n                    context.lineTo(scr[1] + size, scr[2] + size);\n                    context.moveTo(scr[1] + size, scr[2] - size);\n                    context.lineTo(scr[1] - size, scr[2] + size);\n                    context.lineCap = \"round\";\n                    context.lineJoin = \"round\";\n                    context.closePath();\n                    this._stroke(el);\n                    break;\n                case \"circle\": // dot\n                case \"o\":\n                    context.beginPath();\n                    context.arc(scr[1], scr[2], size + 1 + stroke05, 0, 2 * Math.PI, false);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"square\": // rectangle\n                case \"[]\":\n                    if (size <= 0) {\n                        break;\n                    }\n\n                    context.save();\n                    if (this._setColor(el, \"stroke\", \"fill\")) {\n                        context.fillRect(\n                            scr[1] - size - stroke05,\n                            scr[2] - size - stroke05,\n                            size * 2 + 3 * stroke05,\n                            size * 2 + 3 * stroke05\n                        );\n                    }\n                    context.restore();\n                    context.save();\n                    this._setColor(el, \"fill\");\n                    context.fillRect(\n                        scr[1] - size + stroke05,\n                        scr[2] - size + stroke05,\n                        size * 2 - stroke05,\n                        size * 2 - stroke05\n                    );\n                    context.restore();\n                    break;\n                case \"plus\": // +\n                case \"+\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2]);\n                    context.lineTo(scr[1] + size, scr[2]);\n                    context.moveTo(scr[1], scr[2] - size);\n                    context.lineTo(scr[1], scr[2] + size);\n                    context.lineCap = \"round\";\n                    context.lineJoin = \"round\";\n                    context.closePath();\n                    this._stroke(el);\n                    break;\n                case \"diamond\": // <>\n                case \"<>\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2]);\n                    context.lineTo(scr[1], scr[2] + size);\n                    context.lineTo(scr[1] + size, scr[2]);\n                    context.lineTo(scr[1], scr[2] - size);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"triangleup\":\n                case \"a\":\n                case \"^\":\n                    context.beginPath();\n                    context.moveTo(scr[1], scr[2] - size);\n                    context.lineTo(scr[1] - sqrt32, scr[2] + s05);\n                    context.lineTo(scr[1] + sqrt32, scr[2] + s05);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"triangledown\":\n                case \"v\":\n                    context.beginPath();\n                    context.moveTo(scr[1], scr[2] + size);\n                    context.lineTo(scr[1] - sqrt32, scr[2] - s05);\n                    context.lineTo(scr[1] + sqrt32, scr[2] - s05);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"triangleleft\":\n                case \"<\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2]);\n                    context.lineTo(scr[1] + s05, scr[2] - sqrt32);\n                    context.lineTo(scr[1] + s05, scr[2] + sqrt32);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"triangleright\":\n                case \">\":\n                    context.beginPath();\n                    context.moveTo(scr[1] + size, scr[2]);\n                    context.lineTo(scr[1] - s05, scr[2] - sqrt32);\n                    context.lineTo(scr[1] - s05, scr[2] + sqrt32);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n            }\n        },\n\n        // documented in AbstractRenderer\n        updatePoint: function (el) {\n            this.drawPoint(el);\n        },\n\n        /* ******************************** *\n         *           Lines                  *\n         * ******************************** */\n\n        /**\n         * Draws arrows of an element (usually a line) in canvas renderer.\n         * @param {JXG.GeometryElement} el Line to be drawn.\n         * @param {Array} scr1 Screen coordinates of the start position of the line or curve.\n         * @param {Array} scr2 Screen coordinates of the end position of the line or curve.\n         * @param {String} hl String which carries information if the element is highlighted. Used for getting the correct attribute.\n         * @private\n         */\n        drawArrows: function (el, scr1, scr2, hl, a) {\n            var x1,\n                y1,\n                x2,\n                y2,\n                w0,\n                w,\n                arrowHead,\n                arrowTail,\n                context = this.context,\n                size = 6,\n                type = 1,\n                type_fa,\n                type_la,\n                degree_fa = 1,\n                degree_la = 1,\n                doFill,\n                i,\n                len,\n                d1x,\n                d1y,\n                d2x,\n                d2y,\n                last,\n                ang1,\n                ang2,\n                ev_fa = a.evFirst,\n                ev_la = a.evLast;\n\n            if (Type.evaluate(el.visProp.strokecolor) !== \"none\" && (ev_fa || ev_la)) {\n                if (el.elementClass === Const.OBJECT_CLASS_LINE) {\n                    x1 = scr1.scrCoords[1];\n                    y1 = scr1.scrCoords[2];\n                    x2 = scr2.scrCoords[1];\n                    y2 = scr2.scrCoords[2];\n                    ang1 = ang2 = Math.atan2(y2 - y1, x2 - x1);\n                } else {\n                    x1 = el.points[0].scrCoords[1];\n                    y1 = el.points[0].scrCoords[2];\n\n                    last = el.points.length - 1;\n                    if (last < 1) {\n                        // No arrows for curves consisting of 1 point\n                        return;\n                    }\n                    x2 = el.points[el.points.length - 1].scrCoords[1];\n                    y2 = el.points[el.points.length - 1].scrCoords[2];\n\n                    d1x = el.points[1].scrCoords[1] - el.points[0].scrCoords[1];\n                    d1y = el.points[1].scrCoords[2] - el.points[0].scrCoords[2];\n                    d2x = el.points[last].scrCoords[1] - el.points[last - 1].scrCoords[1];\n                    d2y = el.points[last].scrCoords[2] - el.points[last - 1].scrCoords[2];\n                    if (ev_fa) {\n                        ang1 = Math.atan2(d1y, d1x);\n                    }\n                    if (ev_la) {\n                        ang2 = Math.atan2(d2y, d2x);\n                    }\n                }\n\n                w0 = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n\n                if (ev_fa) {\n                    size = a.sizeFirst;\n\n                    w = w0 * size;\n\n                    type = a.typeFirst;\n                    type_fa = type;\n\n                    if (type === 2) {\n                        arrowTail = [\n                            [w, -w * 0.5],\n                            [0.0, 0.0],\n                            [w, w * 0.5],\n                            [w * 0.5, 0.0]\n                        ];\n                    } else if (type === 3) {\n                        arrowTail = [\n                            [w / 3.0, -w * 0.5],\n                            [0.0, -w * 0.5],\n                            [0.0, w * 0.5],\n                            [w / 3.0, w * 0.5]\n                        ];\n                    } else if (type === 4) {\n                        w /= 10;\n                        degree_fa = 3;\n                        arrowTail = [\n                            [10.0, 3.31],\n                            [6.47, 3.84],\n                            [2.87, 4.5],\n                            [0.0, 6.63],\n                            [0.67, 5.52],\n                            [1.33, 4.42],\n                            [2.0, 3.31],\n                            [1.33, 2.21],\n                            [0.67, 1.1],\n                            [0.0, 0.0],\n                            [2.87, 2.13],\n                            [6.47, 2.79],\n                            [10.0, 3.31]\n                        ];\n                        len = arrowTail.length;\n                        for (i = 0; i < len; i++) {\n                            arrowTail[i][0] *= -w;\n                            arrowTail[i][1] *= w;\n                            arrowTail[i][0] += 10 * w;\n                            arrowTail[i][1] -= 3.31 * w;\n                        }\n                    } else if (type === 5) {\n                        w /= 10;\n                        degree_fa = 3;\n                        arrowTail = [\n                            [10.0, 3.28],\n                            [6.61, 4.19],\n                            [3.19, 5.07],\n                            [0.0, 6.55],\n                            [0.62, 5.56],\n                            [1.0, 4.44],\n                            [1.0, 3.28],\n                            [1.0, 2.11],\n                            [0.62, 0.99],\n                            [0.0, 0.0],\n                            [3.19, 1.49],\n                            [6.61, 2.37],\n                            [10.0, 3.28]\n                        ];\n                        len = arrowTail.length;\n                        for (i = 0; i < len; i++) {\n                            arrowTail[i][0] *= -w;\n                            arrowTail[i][1] *= w;\n                            arrowTail[i][0] += 10 * w;\n                            arrowTail[i][1] -= 3.28 * w;\n                        }\n                    } else if (type === 6) {\n                        w /= 10;\n                        degree_fa = 3;\n                        arrowTail = [\n                            [10.0, 2.84],\n                            [6.61, 3.59],\n                            [3.21, 4.35],\n                            [0.0, 5.68],\n                            [0.33, 4.73],\n                            [0.67, 3.78],\n                            [1.0, 2.84],\n                            [0.67, 1.89],\n                            [0.33, 0.95],\n                            [0.0, 0.0],\n                            [3.21, 1.33],\n                            [6.61, 2.09],\n                            [10.0, 2.84]\n                        ];\n                        len = arrowTail.length;\n                        for (i = 0; i < len; i++) {\n                            arrowTail[i][0] *= -w;\n                            arrowTail[i][1] *= w;\n                            arrowTail[i][0] += 10 * w;\n                            arrowTail[i][1] -= 2.84 * w;\n                        }\n                    } else if (type === 7) {\n                        w = w0;\n                        degree_fa = 3;\n                        arrowTail = [\n                            [0.0, 10.39],\n                            [2.01, 6.92],\n                            [5.96, 5.2],\n                            [10.0, 5.2],\n                            [5.96, 5.2],\n                            [2.01, 3.47],\n                            [0.0, 0.0]\n                        ];\n                        len = arrowTail.length;\n                        for (i = 0; i < len; i++) {\n                            arrowTail[i][0] *= -w;\n                            arrowTail[i][1] *= w;\n                            arrowTail[i][0] += 10 * w;\n                            arrowTail[i][1] -= 5.2 * w;\n                        }\n                    } else {\n                        arrowTail = [\n                            [w, -w * 0.5],\n                            [0.0, 0.0],\n                            [w, w * 0.5]\n                        ];\n                    }\n                }\n\n                if (ev_la) {\n                    size = a.sizeLast;\n                    w = w0 * size;\n\n                    type = a.typeLast;\n                    type_la = type;\n                    if (type === 2) {\n                        arrowHead = [\n                            [-w, -w * 0.5],\n                            [0.0, 0.0],\n                            [-w, w * 0.5],\n                            [-w * 0.5, 0.0]\n                        ];\n                    } else if (type === 3) {\n                        arrowHead = [\n                            [-w / 3.0, -w * 0.5],\n                            [0.0, -w * 0.5],\n                            [0.0, w * 0.5],\n                            [-w / 3.0, w * 0.5]\n                        ];\n                    } else if (type === 4) {\n                        w /= 10;\n                        degree_la = 3;\n                        arrowHead = [\n                            [10.0, 3.31],\n                            [6.47, 3.84],\n                            [2.87, 4.5],\n                            [0.0, 6.63],\n                            [0.67, 5.52],\n                            [1.33, 4.42],\n                            [2.0, 3.31],\n                            [1.33, 2.21],\n                            [0.67, 1.1],\n                            [0.0, 0.0],\n                            [2.87, 2.13],\n                            [6.47, 2.79],\n                            [10.0, 3.31]\n                        ];\n                        len = arrowHead.length;\n                        for (i = 0; i < len; i++) {\n                            arrowHead[i][0] *= w;\n                            arrowHead[i][1] *= w;\n                            arrowHead[i][0] -= 10 * w;\n                            arrowHead[i][1] -= 3.31 * w;\n                        }\n                    } else if (type === 5) {\n                        w /= 10;\n                        degree_la = 3;\n                        arrowHead = [\n                            [10.0, 3.28],\n                            [6.61, 4.19],\n                            [3.19, 5.07],\n                            [0.0, 6.55],\n                            [0.62, 5.56],\n                            [1.0, 4.44],\n                            [1.0, 3.28],\n                            [1.0, 2.11],\n                            [0.62, 0.99],\n                            [0.0, 0.0],\n                            [3.19, 1.49],\n                            [6.61, 2.37],\n                            [10.0, 3.28]\n                        ];\n                        len = arrowHead.length;\n                        for (i = 0; i < len; i++) {\n                            arrowHead[i][0] *= w;\n                            arrowHead[i][1] *= w;\n                            arrowHead[i][0] -= 10 * w;\n                            arrowHead[i][1] -= 3.28 * w;\n                        }\n                    } else if (type === 6) {\n                        w /= 10;\n                        degree_la = 3;\n                        arrowHead = [\n                            [10.0, 2.84],\n                            [6.61, 3.59],\n                            [3.21, 4.35],\n                            [0.0, 5.68],\n                            [0.33, 4.73],\n                            [0.67, 3.78],\n                            [1.0, 2.84],\n                            [0.67, 1.89],\n                            [0.33, 0.95],\n                            [0.0, 0.0],\n                            [3.21, 1.33],\n                            [6.61, 2.09],\n                            [10.0, 2.84]\n                        ];\n                        len = arrowHead.length;\n                        for (i = 0; i < len; i++) {\n                            arrowHead[i][0] *= w;\n                            arrowHead[i][1] *= w;\n                            arrowHead[i][0] -= 10 * w;\n                            arrowHead[i][1] -= 2.84 * w;\n                        }\n                    } else if (type === 7) {\n                        w = w0;\n                        degree_la = 3;\n                        arrowHead = [\n                            [0.0, 10.39],\n                            [2.01, 6.92],\n                            [5.96, 5.2],\n                            [10.0, 5.2],\n                            [5.96, 5.2],\n                            [2.01, 3.47],\n                            [0.0, 0.0]\n                        ];\n                        len = arrowHead.length;\n                        for (i = 0; i < len; i++) {\n                            arrowHead[i][0] *= w;\n                            arrowHead[i][1] *= w;\n                            arrowHead[i][0] -= 10 * w;\n                            arrowHead[i][1] -= 5.2 * w;\n                        }\n                    } else {\n                        arrowHead = [\n                            [-w, -w * 0.5],\n                            [0.0, 0.0],\n                            [-w, w * 0.5]\n                        ];\n                    }\n                }\n\n                context.save();\n                if (this._setColor(el, \"stroke\", \"fill\")) {\n                    this._setColor(el, \"stroke\");\n                    if (ev_fa) {\n                        if (type_fa === 7) {\n                            doFill = false;\n                        } else {\n                            doFill = true;\n                        }\n                        this._drawPolygon(\n                            this._translateShape(this._rotateShape(arrowTail, ang1), x1, y1),\n                            degree_fa,\n                            doFill\n                        );\n                    }\n                    if (ev_la) {\n                        if (type_la === 7) {\n                            doFill = false;\n                        } else {\n                            doFill = true;\n                        }\n                        this._drawPolygon(\n                            this._translateShape(this._rotateShape(arrowHead, ang2), x2, y2),\n                            degree_la,\n                            doFill\n                        );\n                    }\n                }\n                context.restore();\n            }\n        },\n\n        // documented in AbstractRenderer\n        drawLine: function (el) {\n            var c1_org,\n                c2_org,\n                c1 = new Coords(Const.COORDS_BY_USER, el.point1.coords.usrCoords, el.board),\n                c2 = new Coords(Const.COORDS_BY_USER, el.point2.coords.usrCoords, el.board),\n                margin = null,\n                hl,\n                w,\n                arrowData;\n\n            if (!el.visPropCalc.visible) {\n                return;\n            }\n\n            hl = this._getHighlighted(el);\n            w = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n            arrowData = this.getArrowHeadData(el, w, hl);\n\n            if (arrowData.evFirst || arrowData.evLast) {\n                margin = -4;\n            }\n            Geometry.calcStraight(el, c1, c2, margin);\n            this.handleTouchpoints(el, c1, c2, arrowData);\n\n            c1_org = new Coords(Const.COORDS_BY_USER, c1.usrCoords, el.board);\n            c2_org = new Coords(Const.COORDS_BY_USER, c2.usrCoords, el.board);\n\n            this.getPositionArrowHead(el, c1, c2, arrowData);\n\n            this.context.beginPath();\n            this.context.moveTo(c1.scrCoords[1], c1.scrCoords[2]);\n            this.context.lineTo(c2.scrCoords[1], c2.scrCoords[2]);\n            this._stroke(el);\n\n            if (\n                arrowData.evFirst /* && obj.sFirst > 0*/ ||\n                arrowData.evLast /* && obj.sLast > 0*/\n            ) {\n                this.drawArrows(el, c1_org, c2_org, hl, arrowData);\n            }\n        },\n\n        // documented in AbstractRenderer\n        updateLine: function (el) {\n            this.drawLine(el);\n        },\n\n        // documented in AbstractRenderer\n        drawTicks: function () {\n            // this function is supposed to initialize the svg/vml nodes in the SVG/VMLRenderer.\n            // but in canvas there are no such nodes, hence we just do nothing and wait until\n            // updateTicks is called.\n        },\n\n        // documented in AbstractRenderer\n        updateTicks: function (ticks) {\n            var i,\n                c,\n                x,\n                y,\n                len = ticks.ticks.length,\n                len2,\n                j,\n                context = this.context;\n\n            context.beginPath();\n            for (i = 0; i < len; i++) {\n                c = ticks.ticks[i];\n                x = c[0];\n                y = c[1];\n\n                // context.moveTo(x[0], y[0]);\n                // context.lineTo(x[1], y[1]);\n                len2 = x.length;\n                context.moveTo(x[0], y[0]);\n                for (j = 1; j < len2; ++j) {\n                    context.lineTo(x[j], y[j]);\n                }\n            }\n            // Labels\n            // for (i = 0; i < len; i++) {\n            //     c = ticks.ticks[i].scrCoords;\n            //     if (ticks.ticks[i].major &&\n            //             (ticks.board.needsFullUpdate || ticks.needsRegularUpdate) &&\n            //             ticks.labels[i] &&\n            //             ticks.labels[i].visPropCalc.visible) {\n            //         this.updateText(ticks.labels[i]);\n            //     }\n            // }\n            context.lineCap = \"round\";\n            this._stroke(ticks);\n        },\n\n        /* **************************\n         *    Curves\n         * **************************/\n\n        // documented in AbstractRenderer\n        drawCurve: function (el) {\n            var hl, w, arrowData;\n\n            if (Type.evaluate(el.visProp.handdrawing)) {\n                this.updatePathStringBezierPrim(el);\n            } else {\n                this.updatePathStringPrim(el);\n            }\n            if (el.numberPoints > 1) {\n                hl = this._getHighlighted(el);\n                w = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n                arrowData = this.getArrowHeadData(el, w, hl);\n                if (\n                    arrowData.evFirst /* && obj.sFirst > 0*/ ||\n                    arrowData.evLast /* && obj.sLast > 0*/\n                ) {\n                    this.drawArrows(el, null, null, hl, arrowData);\n                }\n            }\n        },\n\n        // documented in AbstractRenderer\n        updateCurve: function (el) {\n            this.drawCurve(el);\n        },\n\n        /* **************************\n         *    Circle related stuff\n         * **************************/\n\n        // documented in AbstractRenderer\n        drawEllipse: function (el) {\n            var m1 = el.center.coords.scrCoords[1],\n                m2 = el.center.coords.scrCoords[2],\n                sX = el.board.unitX,\n                sY = el.board.unitY,\n                rX = 2 * el.Radius(),\n                rY = 2 * el.Radius(),\n                aWidth = rX * sX,\n                aHeight = rY * sY,\n                aX = m1 - aWidth / 2,\n                aY = m2 - aHeight / 2,\n                hB = (aWidth / 2) * 0.5522848,\n                vB = (aHeight / 2) * 0.5522848,\n                eX = aX + aWidth,\n                eY = aY + aHeight,\n                mX = aX + aWidth / 2,\n                mY = aY + aHeight / 2,\n                context = this.context;\n\n            if (rX > 0.0 && rY > 0.0 && !isNaN(m1 + m2)) {\n                context.beginPath();\n                context.moveTo(aX, mY);\n                context.bezierCurveTo(aX, mY - vB, mX - hB, aY, mX, aY);\n                context.bezierCurveTo(mX + hB, aY, eX, mY - vB, eX, mY);\n                context.bezierCurveTo(eX, mY + vB, mX + hB, eY, mX, eY);\n                context.bezierCurveTo(mX - hB, eY, aX, mY + vB, aX, mY);\n                context.closePath();\n                this._fill(el);\n                this._stroke(el);\n            }\n        },\n\n        // documented in AbstractRenderer\n        updateEllipse: function (el) {\n            return this.drawEllipse(el);\n        },\n\n        /* **************************\n         *    Polygon\n         * **************************/\n\n        // nothing here, using AbstractRenderer implementations\n\n        /* **************************\n         *    Text related stuff\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        displayCopyright: function (str, fontSize) {\n            var context = this.context;\n\n            // this should be called on EVERY update, otherwise it won't be shown after the first update\n            context.save();\n            context.font = fontSize + \"px Arial\";\n            context.fillStyle = \"#aaa\";\n            context.lineWidth = 0.5;\n            context.fillText(str, 10, 2 + fontSize);\n            context.restore();\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        drawInternalText: function (el) {\n            var ev_fs = Type.evaluate(el.visProp.fontsize),\n                fontUnit = Type.evaluate(el.visProp.fontunit),\n                ev_ax = el.getAnchorX(),\n                ev_ay = el.getAnchorY(),\n                context = this.context;\n\n            context.save();\n            if (\n                this._setColor(el, \"stroke\", \"fill\") &&\n                !isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])\n            ) {\n                context.font = (ev_fs > 0 ? ev_fs : 0) + fontUnit + \" Arial\";\n\n                this.transformImage(el, el.transformations);\n                if (ev_ax === \"left\") {\n                    context.textAlign = \"left\";\n                } else if (ev_ax === \"right\") {\n                    context.textAlign = \"right\";\n                } else if (ev_ax === \"middle\") {\n                    context.textAlign = \"center\";\n                }\n                if (ev_ay === \"bottom\") {\n                    context.textBaseline = \"bottom\";\n                } else if (ev_ay === \"top\") {\n                    context.textBaseline = \"top\";\n                } else if (ev_ay === \"middle\") {\n                    context.textBaseline = \"middle\";\n                }\n                context.fillText(el.plaintext, el.coords.scrCoords[1], el.coords.scrCoords[2]);\n            }\n            context.restore();\n            return null;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateInternalText: function (el) {\n            this.drawInternalText(el);\n        },\n\n        // documented in JXG.AbstractRenderer\n        // Only necessary for texts\n        setObjectStrokeColor: function (el, color, opacity) {\n            var rgba = Type.evaluate(color),\n                c,\n                rgbo,\n                o = Type.evaluate(opacity),\n                oo,\n                node;\n\n            o = o > 0 ? o : 0;\n\n            if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {\n                return;\n            }\n\n            // Check if this could be merged with _setColor\n\n            if (Type.exists(rgba) && rgba !== false) {\n                // RGB, not RGBA\n                if (rgba.length !== 9) {\n                    c = rgba;\n                    oo = o;\n                    // True RGBA, not RGB\n                } else {\n                    rgbo = Color.rgba2rgbo(rgba);\n                    c = rgbo[0];\n                    oo = o * rgbo[1];\n                }\n                node = el.rendNode;\n                if (\n                    el.elementClass === Const.OBJECT_CLASS_TEXT &&\n                    Type.evaluate(el.visProp.display) === \"html\"\n                ) {\n                    node.style.color = c;\n                    node.style.opacity = oo;\n                }\n            }\n\n            el.visPropOld.strokecolor = rgba;\n            el.visPropOld.strokeopacity = o;\n        },\n\n        /* **************************\n         *    Image related stuff\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        drawImage: function (el) {\n            el.rendNode = new Image();\n            // Store the file name of the image.\n            // Before, this was done in el.rendNode.src\n            // But there, the file name is expanded to\n            // the full url. This may be different from\n            // the url computed in updateImageURL().\n            el._src = \"\";\n            this.updateImage(el);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateImage: function (el) {\n            var context = this.context,\n                o = Type.evaluate(el.visProp.fillopacity),\n                paintImg = Type.bind(function () {\n                    el.imgIsLoaded = true;\n                    if (el.size[0] <= 0 || el.size[1] <= 0) {\n                        return;\n                    }\n                    context.save();\n                    context.globalAlpha = o;\n                    // If det(el.transformations)=0, FireFox 3.6. breaks down.\n                    // This is tested in transformImage\n                    this.transformImage(el, el.transformations);\n                    context.drawImage(\n                        el.rendNode,\n                        el.coords.scrCoords[1],\n                        el.coords.scrCoords[2] - el.size[1],\n                        el.size[0],\n                        el.size[1]\n                    );\n                    context.restore();\n                }, this);\n\n            if (this.updateImageURL(el)) {\n                el.rendNode.onload = paintImg;\n            } else {\n                if (el.imgIsLoaded) {\n                    paintImg();\n                }\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        transformImage: function (el, t) {\n            var m,\n                len = t.length,\n                ctx = this.context;\n\n            if (len > 0) {\n                m = this.joinTransforms(el, t);\n                if (Math.abs(Numerics.det(m)) >= Mat.eps) {\n                    ctx.transform(m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]);\n                }\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateImageURL: function (el) {\n            var url;\n\n            url = Type.evaluate(el.url);\n            if (el._src !== url) {\n                el.imgIsLoaded = false;\n                el.rendNode.src = url;\n                el._src = url;\n                return true;\n            }\n\n            return false;\n        },\n\n        /* **************************\n         * Render primitive objects\n         * **************************/\n\n        // documented in AbstractRenderer\n        remove: function (shape) {\n            // sounds odd for a pixel based renderer but we need this for html texts\n            if (Type.exists(shape) && Type.exists(shape.parentNode)) {\n                shape.parentNode.removeChild(shape);\n            }\n        },\n\n        // documented in AbstractRenderer\n        updatePathStringPrim: function (el) {\n            var i,\n                scr,\n                scr1,\n                scr2,\n                len,\n                symbm = \"M\",\n                symbl = \"L\",\n                symbc = \"C\",\n                nextSymb = symbm,\n                maxSize = 5000.0,\n                context = this.context;\n\n            if (el.numberPoints <= 0) {\n                return;\n            }\n\n            len = Math.min(el.points.length, el.numberPoints);\n            context.beginPath();\n\n            if (el.bezierDegree === 1) {\n                /*\n                if (isNotPlot && el.board.options.curve.RDPsmoothing) {\n                    el.points = Numerics.RamerDouglasPeucker(el.points, 0.5);\n                }\n                */\n\n                for (i = 0; i < len; i++) {\n                    scr = el.points[i].scrCoords;\n\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        // Chrome has problems with values  being too far away.\n                        if (scr[1] > maxSize) {\n                            scr[1] = maxSize;\n                        } else if (scr[1] < -maxSize) {\n                            scr[1] = -maxSize;\n                        }\n\n                        if (scr[2] > maxSize) {\n                            scr[2] = maxSize;\n                        } else if (scr[2] < -maxSize) {\n                            scr[2] = -maxSize;\n                        }\n\n                        if (nextSymb === symbm) {\n                            context.moveTo(scr[1], scr[2]);\n                        } else {\n                            context.lineTo(scr[1], scr[2]);\n                        }\n                        nextSymb = symbl;\n                    }\n                }\n            } else if (el.bezierDegree === 3) {\n                i = 0;\n                while (i < len) {\n                    scr = el.points[i].scrCoords;\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        if (nextSymb === symbm) {\n                            context.moveTo(scr[1], scr[2]);\n                        } else {\n                            i += 1;\n                            scr1 = el.points[i].scrCoords;\n                            i += 1;\n                            scr2 = el.points[i].scrCoords;\n                            context.bezierCurveTo(\n                                scr[1],\n                                scr[2],\n                                scr1[1],\n                                scr1[2],\n                                scr2[1],\n                                scr2[2]\n                            );\n                        }\n                        nextSymb = symbc;\n                    }\n                    i += 1;\n                }\n            }\n            context.lineCap = \"round\";\n            this._fill(el);\n            this._stroke(el);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathStringBezierPrim: function (el) {\n            var i,\n                j,\n                k,\n                scr,\n                lx,\n                ly,\n                len,\n                symbm = \"M\",\n                symbl = \"C\",\n                nextSymb = symbm,\n                maxSize = 5000.0,\n                f = Type.evaluate(el.visProp.strokewidth),\n                isNoPlot = Type.evaluate(el.visProp.curvetype) !== \"plot\",\n                context = this.context;\n\n            if (el.numberPoints <= 0) {\n                return;\n            }\n\n            if (isNoPlot && el.board.options.curve.RDPsmoothing) {\n                el.points = Numerics.RamerDouglasPeucker(el.points, 0.5);\n            }\n\n            len = Math.min(el.points.length, el.numberPoints);\n            context.beginPath();\n\n            for (j = 1; j < 3; j++) {\n                nextSymb = symbm;\n                for (i = 0; i < len; i++) {\n                    scr = el.points[i].scrCoords;\n\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        // Chrome has problems with values being too far away.\n                        if (scr[1] > maxSize) {\n                            scr[1] = maxSize;\n                        } else if (scr[1] < -maxSize) {\n                            scr[1] = -maxSize;\n                        }\n\n                        if (scr[2] > maxSize) {\n                            scr[2] = maxSize;\n                        } else if (scr[2] < -maxSize) {\n                            scr[2] = -maxSize;\n                        }\n\n                        if (nextSymb === symbm) {\n                            context.moveTo(scr[1], scr[2]);\n                        } else {\n                            k = 2 * j;\n                            context.bezierCurveTo(\n                                lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j),\n                                ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j),\n                                lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j),\n                                ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j),\n                                scr[1],\n                                scr[2]\n                            );\n                        }\n                        nextSymb = symbl;\n                        lx = scr[1];\n                        ly = scr[2];\n                    }\n                }\n            }\n            context.lineCap = \"round\";\n            this._fill(el);\n            this._stroke(el);\n        },\n\n        // documented in AbstractRenderer\n        updatePolygonPrim: function (node, el) {\n            var scrCoords,\n                i,\n                j,\n                len = el.vertices.length,\n                context = this.context,\n                isReal = true;\n\n            if (len <= 0 || !el.visPropCalc.visible) {\n                return;\n            }\n            if (el.elType === \"polygonalchain\") {\n                len++;\n            }\n\n            context.beginPath();\n            i = 0;\n            while (!el.vertices[i].isReal && i < len - 1) {\n                i++;\n                isReal = false;\n            }\n            scrCoords = el.vertices[i].coords.scrCoords;\n            context.moveTo(scrCoords[1], scrCoords[2]);\n\n            for (j = i; j < len - 1; j++) {\n                if (!el.vertices[j].isReal) {\n                    isReal = false;\n                }\n                scrCoords = el.vertices[j].coords.scrCoords;\n                context.lineTo(scrCoords[1], scrCoords[2]);\n            }\n            context.closePath();\n\n            if (isReal) {\n                this._fill(el); // The edges of a polygon are displayed separately (as segments).\n            }\n        },\n\n        // **************************  Set Attributes *************************\n\n        // Already documented in JXG.AbstractRenderer\n        display: function (el, val) {\n            if (el && el.rendNode) {\n                el.visPropOld.visible = val;\n                if (val) {\n                    el.rendNode.style.visibility = \"inherit\";\n                } else {\n                    el.rendNode.style.visibility = \"hidden\";\n                }\n            }\n        },\n\n        // documented in AbstractRenderer\n        show: function (el) {\n            JXG.deprecated(\"Board.renderer.show()\", \"Board.renderer.display()\");\n\n            if (Type.exists(el.rendNode)) {\n                el.rendNode.style.visibility = \"inherit\";\n            }\n        },\n\n        // documented in AbstractRenderer\n        hide: function (el) {\n            JXG.deprecated(\"Board.renderer.hide()\", \"Board.renderer.display()\");\n\n            if (Type.exists(el.rendNode)) {\n                el.rendNode.style.visibility = \"hidden\";\n            }\n        },\n\n        // documented in AbstractRenderer\n        setGradient: function (el) {\n            var // col,\n                op;\n\n            op = Type.evaluate(el.visProp.fillopacity);\n            op = op > 0 ? op : 0;\n\n            // col = Type.evaluate(el.visProp.fillcolor);\n        },\n\n        // documented in AbstractRenderer\n        setShadow: function (el) {\n            if (el.visPropOld.shadow === el.visProp.shadow) {\n                return;\n            }\n\n            // not implemented yet\n            // we simply have to redraw the element\n            // probably the best way to do so would be to call el.updateRenderer(), i think.\n\n            el.visPropOld.shadow = el.visProp.shadow;\n        },\n\n        // documented in AbstractRenderer\n        highlight: function (obj) {\n            if (\n                obj.elementClass === Const.OBJECT_CLASS_TEXT &&\n                Type.evaluate(obj.visProp.display) === \"html\"\n            ) {\n                this.updateTextStyle(obj, true);\n            } else {\n                obj.board.prepareUpdate();\n                obj.board.renderer.suspendRedraw(obj.board);\n                obj.board.updateRenderer();\n                obj.board.renderer.unsuspendRedraw();\n            }\n            return this;\n        },\n\n        // documented in AbstractRenderer\n        noHighlight: function (obj) {\n            if (\n                obj.elementClass === Const.OBJECT_CLASS_TEXT &&\n                Type.evaluate(obj.visProp.display) === \"html\"\n            ) {\n                this.updateTextStyle(obj, false);\n            } else {\n                obj.board.prepareUpdate();\n                obj.board.renderer.suspendRedraw(obj.board);\n                obj.board.updateRenderer();\n                obj.board.renderer.unsuspendRedraw();\n            }\n            return this;\n        },\n\n        /* **************************\n         * renderer control\n         * **************************/\n\n        // documented in AbstractRenderer\n        suspendRedraw: function (board) {\n            this.context.save();\n            this.context.clearRect(0, 0, this.canvasRoot.width, this.canvasRoot.height);\n\n            if (board && board.attr.showcopyright) {\n                this.displayCopyright(JXG.licenseText, 12);\n            }\n        },\n\n        // documented in AbstractRenderer\n        unsuspendRedraw: function () {\n            this.context.restore();\n        },\n\n        // document in AbstractRenderer\n        resize: function (w, h) {\n            if (this.container) {\n                this.canvasRoot.style.width = parseFloat(w) + \"px\";\n                this.canvasRoot.style.height = parseFloat(h) + \"px\";\n\n                this.canvasRoot.setAttribute(\"width\", 2 * parseFloat(w) + \"px\");\n                this.canvasRoot.setAttribute(\"height\", 2 * parseFloat(h) + \"px\");\n            } else {\n                this.canvasRoot.width = 2 * parseFloat(w);\n                this.canvasRoot.height = 2 * parseFloat(h);\n            }\n            this.context = this.canvasRoot.getContext(\"2d\");\n            // The width and height of the canvas is set to twice the CSS values,\n            // followed by an appropiate scaling.\n            // See http://stackoverflow.com/questions/22416462/canvas-element-with-blurred-lines\n            this.context.scale(2, 2);\n        },\n\n        removeToInsertLater: function () {\n            return function () {};\n        }\n    }\n);\n\nexport default JXG.CanvasRenderer;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */\n/*jslint nomen: true, plusplus: true, newcap:true, unparam: true*/\n/*eslint no-unused-vars: \"off\"*/\n\n/**\n * @fileoverview JSXGraph can use various technologies to render the contents of a construction, e.g.\n * SVG, VML, and HTML5 Canvas. To accomplish this, The rendering and the logic and control mechanisms\n * are completely separated from each other. Every rendering technology has it's own class, called\n * Renderer, e.g. SVGRenderer for SVG, the same for VML and Canvas. The common base for all available\n * renderers is the class AbstractRenderer.\n */\n\nimport JXG from \"../jxg\";\nimport AbstractRenderer from \"./abstract\";\n\n/**\n * This renderer draws nothing. It is intended to be used in environments where none of our rendering engines\n * are available, e.g. WebWorkers. All methods are empty.\n *\n * @class JXG.NoRenderer\n * @augments JXG.AbstractRenderer\n * @see JXG.AbstractRenderer\n */\nJXG.NoRenderer = function () {\n    /**\n     * If this property is set to <tt>true</tt> the visual properties of the elements are updated\n     * on every update. Visual properties means: All the stuff stored in the\n     * {@link JXG.GeometryElement#visProp} property won't be set if enhancedRendering is <tt>false</tt>\n     * @type Boolean\n     * @default true\n     */\n    this.enhancedRendering = false;\n\n    /**\n     * This is used to easily determine which renderer we are using\n     * @example if (board.renderer.type === 'vml') {\n     *     // do something\n     * }\n     * @type String\n     */\n    this.type = \"no\";\n};\n\nJXG.extend(\n    JXG.NoRenderer.prototype,\n    /** @lends JXG.NoRenderer.prototype */ {\n        /* ******************************** *\n         *    Point drawing and updating    *\n         * ******************************** */\n\n        /**\n         * Draws a point on the {@link JXG.Board}.\n         * @param {JXG.Point} element Reference to a {@link JXG.Point} object that has to be drawn.\n         * @see Point\n         * @see JXG.Point\n         * @see JXG.AbstractRenderer#updatePoint\n         * @see JXG.AbstractRenderer#changePointStyle\n         */\n        drawPoint: function (element) {},\n\n        /**\n         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Point}.\n         * @param {JXG.Point} element Reference to a {@link JXG.Point} object, that has to be updated.\n         * @see Point\n         * @see JXG.Point\n         * @see JXG.AbstractRenderer#drawPoint\n         * @see JXG.AbstractRenderer#changePointStyle\n         */\n        updatePoint: function (element) {},\n\n        /**\n         * Changes the style of a {@link JXG.Point}. This is required because the point styles differ in what\n         * elements have to be drawn, e.g. if the point is marked by a \"x\" or a \"+\" two lines are drawn, if\n         * it's marked by spot a circle is drawn. This method removes the old renderer element(s) and creates\n         * the new one(s).\n         * @param {JXG.Point} element Reference to a {@link JXG.Point} object, that's style is changed.\n         * @see Point\n         * @see JXG.Point\n         * @see JXG.AbstractRenderer#updatePoint\n         * @see JXG.AbstractRenderer#drawPoint\n         */\n        changePointStyle: function (element) {},\n\n        /* ******************************** *\n         *           Lines                  *\n         * ******************************** */\n\n        /**\n         * Draws a line on the {@link JXG.Board}.\n         * @param {JXG.Line} element Reference to a line object, that has to be drawn.\n         * @see Line\n         * @see JXG.Line\n         * @see JXG.AbstractRenderer#updateLine\n         */\n        drawLine: function (element) {},\n\n        /**\n         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Line}.\n         * @param {JXG.Line} element Reference to the {@link JXG.Line} object that has to be updated.\n         * @see Line\n         * @see JXG.Line\n         * @see JXG.AbstractRenderer#drawLine\n         */\n        updateLine: function (element) {},\n\n        /**\n         * Creates a rendering node for ticks added to a line.\n         * @param {JXG.Line} element A arbitrary line.\n         * @see Line\n         * @see Ticks\n         * @see JXG.Line\n         * @see JXG.Ticks\n         * @see JXG.AbstractRenderer#updateTicks\n         */\n        drawTicks: function (element) {},\n\n        /**\n         * Update {@link Ticks} on a {@link JXG.Line}. This method is only a stub and has to be implemented\n         * in any descendant renderer class.\n         * @param {JXG.Line} element Reference of an line object, thats ticks have to be updated.\n         * @see Line\n         * @see Ticks\n         * @see JXG.Line\n         * @see JXG.Ticks\n         * @see JXG.AbstractRenderer#drawTicks\n         */\n        updateTicks: function (element) {\n            /* stub */\n        },\n\n        /* **************************\n         *    Curves\n         * **************************/\n\n        /**\n         * Draws a {@link JXG.Curve} on the {@link JXG.Board}.\n         * @param {JXG.Curve} element Reference to a graph object, that has to be plotted.\n         * @see Curve\n         * @see JXG.Curve\n         * @see JXG.AbstractRenderer#updateCurve\n         */\n        drawCurve: function (element) {},\n\n        /**\n         * Updates visual appearance of the renderer element assigned to the given {@link JXG.Curve}.\n         * @param {JXG.Curve} element Reference to a {@link JXG.Curve} object, that has to be updated.\n         * @see Curve\n         * @see JXG.Curve\n         * @see JXG.AbstractRenderer#drawCurve\n         */\n        updateCurve: function (element) {},\n\n        /* **************************\n         *    Circle related stuff\n         * **************************/\n\n        /**\n         * Draws a {@link JXG.Circle}\n         * @param {JXG.Circle} element Reference to a {@link JXG.Circle} object that has to be drawn.\n         * @see Circle\n         * @see JXG.Circle\n         * @see JXG.AbstractRenderer#updateEllipse\n         */\n        drawEllipse: function (element) {},\n\n        /**\n         * Updates visual appearance of a given {@link JXG.Circle} on the {@link JXG.Board}.\n         * @param {JXG.Circle} element Reference to a {@link JXG.Circle} object, that has to be updated.\n         * @see Circle\n         * @see JXG.Circle\n         * @see JXG.AbstractRenderer#drawEllipse\n         */\n        updateEllipse: function (element) {},\n\n        /* **************************\n         *   Polygon related stuff\n         * **************************/\n\n        /**\n         * Draws a {@link JXG.Polygon} on the {@link JXG.Board}.\n         * @param {JXG.Polygon} element Reference to a Polygon object, that is to be drawn.\n         * @see Polygon\n         * @see JXG.Polygon\n         * @see JXG.AbstractRenderer#updatePolygon\n         */\n        drawPolygon: function (element) {},\n\n        /**\n         * Updates properties of a {@link JXG.Polygon}'s rendering node.\n         * @param {JXG.Polygon} element Reference to a {@link JXG.Polygon} object, that has to be updated.\n         * @see Polygon\n         * @see JXG.Polygon\n         * @see JXG.AbstractRenderer#drawPolygon\n         */\n        updatePolygon: function (element) {},\n\n        /* **************************\n         *    Text related stuff\n         * **************************/\n\n        /**\n         * Shows a small copyright notice in the top left corner of the board.\n         * @param {String} str The copyright notice itself\n         * @param {Number} fontsize Size of the font the copyright notice is written in\n         */\n        displayCopyright: function (str, fontsize) {\n            /* stub */\n        },\n\n        /**\n         * An internal text is a {@link JXG.Text} element which is drawn using only\n         * the given renderer but no HTML. This method is only a stub, the drawing\n         * is done in the special renderers.\n         * @param {JXG.Text} element Reference to a {@link JXG.Text} object\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#updateInternalText\n         * @see JXG.AbstractRenderer#drawText\n         * @see JXG.AbstractRenderer#updateText\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        drawInternalText: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Updates visual properties of an already existing {@link JXG.Text} element.\n         * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be updated.\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#drawInternalText\n         * @see JXG.AbstractRenderer#drawText\n         * @see JXG.AbstractRenderer#updateText\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        updateInternalText: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Displays a {@link JXG.Text} on the {@link JXG.Board} by putting a HTML div over it.\n         * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be displayed\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#drawInternalText\n         * @see JXG.AbstractRenderer#updateText\n         * @see JXG.AbstractRenderer#updateInternalText\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        drawText: function (element) {},\n\n        /**\n         * Updates visual properties of an already existing {@link JXG.Text} element.\n         * @param {JXG.Text} element Reference to an {@link JXG.Text} object, that has to be updated.\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#drawText\n         * @see JXG.AbstractRenderer#drawInternalText\n         * @see JXG.AbstractRenderer#updateInternalText\n         * @see JXG.AbstractRenderer#updateTextStyle\n         */\n        updateText: function (element) {},\n\n        /**\n         * Updates CSS style properties of a {@link JXG.Text} node.\n         * @param {JXG.Text} element Reference to the {@link JXG.Text} object, that has to be updated.\n         * @param {Boolean} doHighlight\n         * @see Text\n         * @see JXG.Text\n         * @see JXG.AbstractRenderer#drawText\n         * @see JXG.AbstractRenderer#drawInternalText\n         * @see JXG.AbstractRenderer#updateText\n         * @see JXG.AbstractRenderer#updateInternalText\n         */\n        updateTextStyle: function (element, doHighlight) {},\n\n        /**\n         * Set color and opacity of internal texts.\n         * SVG needs its own version.\n         * @private\n         * @see JXG.AbstractRenderer#updateTextStyle\n         * @see JXG.AbstractRenderer#updateInternalTextStyle\n         */\n        updateInternalTextStyle: function (element, strokeColor, strokeOpacity) {\n            /* stub */\n        },\n\n        /* **************************\n         *    Image related stuff\n         * **************************/\n\n        /**\n         * Draws an {@link JXG.Image} on a board; This is just a template that has to be implemented by special renderers.\n         * @param {JXG.Image} element Reference to the image object that is to be drawn\n         * @see Image\n         * @see JXG.Image\n         * @see JXG.AbstractRenderer#updateImage\n         */\n        drawImage: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Updates the properties of an {@link JXG.Image} element.\n         * @param {JXG.Image} element Reference to an {@link JXG.Image} object, that has to be updated.\n         * @see Image\n         * @see JXG.Image\n         * @see JXG.AbstractRenderer#drawImage\n         */\n        updateImage: function (element) {},\n\n        /**\n         * Applies transformations on images and text elements. This method is just a stub and has to be implemented in all\n         * descendant classes where text and image transformations are to be supported.\n         * @param {JXG.Image|JXG.Text} element A {@link JXG.Image} or {@link JXG.Text} object.\n         * @param {Array} transformations An array of {@link JXG.Transformation} objects. This is usually the transformations property\n         * of the given element <tt>el</tt>.\n         */\n        transformImage: function (element, transformations) {\n            /* stub */\n        },\n\n        /**\n         * If the URL of the image is provided by a function the URL has to be updated during updateImage()\n         * @param {JXG.Image} element Reference to an image object.\n         * @see JXG.AbstractRenderer#updateImage\n         */\n        updateImageURL: function (element) {\n            /* stub */\n        },\n\n        /* **************************\n         * Render primitive objects\n         * **************************/\n\n        /**\n         * Appends a node to a specific layer level. This is just an abstract method and has to be implemented\n         * in all renderers that want to use the <tt>createPrim</tt> model to draw.\n         * @param {Node} node A DOM tree node.\n         * @param {Number} level The layer the node is attached to. This is the index of the layer in\n         * {@link JXG.SVGRenderer#layer} or the <tt>z-index</tt> style property of the node in VMLRenderer.\n         */\n        appendChildPrim: function (node, level) {\n            /* stub */\n        },\n\n        /**\n         * Stores the rendering nodes. This is an abstract method which has to be implemented in all renderers that use\n         * the <tt>createPrim</tt> method.\n         * @param {JXG.GeometryElement} element A JSXGraph element.\n         * @param {String} type The XML node name. Only used in VMLRenderer.\n         */\n        appendNodesToElement: function (element, type) {\n            /* stub */\n        },\n\n        /**\n         * Creates a node of a given type with a given id.\n         * @param {String} type The type of the node to create.\n         * @param {String} id Set the id attribute to this.\n         * @returns {Node} Reference to the created node.\n         */\n        createPrim: function (type, id) {\n            /* stub */\n            return null;\n        },\n\n        /**\n         * Removes an element node. Just a stub.\n         * @param {Node} node The node to remove.\n         */\n        remove: function (node) {\n            /* stub */\n        },\n\n        /**\n         * Can be used to create the nodes to display arrows. This is an abstract method which has to be implemented\n         * in any descendant renderer.\n         * @param {JXG.GeometryElement} element The element the arrows are to be attached to.\n         */\n        makeArrows: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Updates an ellipse node primitive. This is an abstract method which has to be implemented in all renderers\n         * that use the <tt>createPrim</tt> method.\n         * @param {Node} node Reference to the node.\n         * @param {Number} x Centre X coordinate\n         * @param {Number} y Centre Y coordinate\n         * @param {Number} rx The x-axis radius.\n         * @param {Number} ry The y-axis radius.\n         */\n        updateEllipsePrim: function (node, x, y, rx, ry) {\n            /* stub */\n        },\n\n        /**\n         * Refreshes a line node. This is an abstract method which has to be implemented in all renderers that use\n         * the <tt>createPrim</tt> method.\n         * @param {Node} node The node to be refreshed.\n         * @param {Number} p1x The first point's x coordinate.\n         * @param {Number} p1y The first point's y coordinate.\n         * @param {Number} p2x The second point's x coordinate.\n         * @param {Number} p2y The second point's y coordinate.\n         * @param {JXG.Board} board\n         */\n        updateLinePrim: function (node, p1x, p1y, p2x, p2y, board) {\n            /* stub */\n        },\n\n        /**\n         * Updates a path element. This is an abstract method which has to be implemented in all renderers that use\n         * the <tt>createPrim</tt> method.\n         * @param {Node} node The path node.\n         * @param {String} pathString A string formatted like e.g. <em>'M 1,2 L 3,1 L5,5'</em>. The format of the string\n         * depends on the rendering engine.\n         * @param {JXG.Board} board Reference to the element's board.\n         */\n        updatePathPrim: function (node, pathString, board) {\n            /* stub */\n        },\n\n        /**\n         * Builds a path data string to draw a point with a face other than <em>rect</em> and <em>circle</em>. Since\n         * the format of such a string usually depends on the renderer this method\n         * is only an abstract method. Therefore, it has to be implemented in the descendant renderer itself unless\n         * the renderer does not use the createPrim interface but the draw* interfaces to paint.\n         * @param {JXG.Point} element The point element\n         * @param {Number} size A positive number describing the size. Usually the half of the width and height of\n         * the drawn point.\n         * @param {String} type A string describing the point's face. This method only accepts the shortcut version of\n         * each possible face: <tt>x, +, <>, ^, v, >, <\n         */\n        updatePathStringPoint: function (element, size, type) {\n            /* stub */\n        },\n\n        /**\n         * Builds a path data string from a {@link JXG.Curve} element. Since the path data strings heavily depend on the\n         * underlying rendering technique this method is just a stub. Although such a path string is of no use for the\n         * CanvasRenderer, this method is used there to draw a path directly.\n         * @param element\n         */\n        updatePathStringPrim: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Builds a path data string from a {@link JXG.Curve} element such that the curve looks like\n         * hand drawn.\n         * Since the path data strings heavily depend on the\n         * underlying rendering technique this method is just a stub. Although such a path string is of no use for the\n         * CanvasRenderer, this method is used there to draw a path directly.\n         * @param element\n         */\n        updatePathStringBezierPrim: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Update a polygon primitive.\n         * @param {Node} node\n         * @param {JXG.Polygon} element A JSXGraph element of type {@link JXG.Polygon}\n         */\n        updatePolygonPrim: function (node, element) {\n            /* stub */\n        },\n\n        /**\n         * Update a rectangle primitive. This is used only for points with face of type 'rect'.\n         * @param {Node} node The node yearning to be updated.\n         * @param {Number} x x coordinate of the top left vertex.\n         * @param {Number} y y coordinate of the top left vertex.\n         * @param {Number} w Width of the rectangle.\n         * @param {Number} h The rectangle's height.\n         */\n        updateRectPrim: function (node, x, y, w, h) {\n            /* stub */\n        },\n\n        /* **************************\n         *  Set Attributes\n         * **************************/\n\n        /**\n         * Sets a node's attribute.\n         * @param {Node} node The node that is to be updated.\n         * @param {String} key Name of the attribute.\n         * @param {String} val New value for the attribute.\n         */\n        setPropertyPrim: function (node, key, val) {\n            /* stub */\n        },\n\n        /**\n         * Shows or hides an element on the canvas; Only a stub, requires implementation in the derived renderer.\n         * @param {JXG.GeometryElement} element Reference to the object that has to appear.\n         * @param {Boolean} value true to show the element, false to hide the element.\n         */\n        display: function (element, value) {\n            if (element) {\n                element.visPropOld.visible = value;\n            }\n        },\n\n        /**\n         * Shows a hidden element on the canvas; Only a stub, requires implementation in the derived renderer.\n         *\n         * Please use JXG.AbstractRenderer#display instead\n         * @param {JXG.GeometryElement} element Reference to the object that has to appear.\n         * @see JXG.AbstractRenderer#hide\n         * @deprecated\n         */\n        show: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Hides an element on the canvas; Only a stub, requires implementation in the derived renderer.\n         *\n         * Please use JXG.AbstractRenderer#display instead\n         * @param {JXG.GeometryElement} element Reference to the geometry element that has to disappear.\n         * @see JXG.AbstractRenderer#show\n         * @deprecated\n         */\n        hide: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Sets the buffering as recommended by SVGWG. Until now only Opera supports this and will be ignored by\n         * other browsers. Although this feature is only supported by SVG we have this method in {@link JXG.AbstractRenderer}\n         * because it is called from outside the renderer.\n         * @param {Node} node The SVG DOM Node which buffering type to update.\n         * @param {String} type Either 'auto', 'dynamic', or 'static'. For an explanation see\n         *   {@link http://www.w3.org/TR/SVGTiny12/painting.html#BufferedRenderingProperty}.\n         */\n        setBuffering: function (node, type) {\n            /* stub */\n        },\n\n        /**\n         * Sets an element's dash style.\n         * @param {JXG.GeometryElement} element An JSXGraph element.\n         */\n        setDashStyle: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Puts an object into draft mode, i.e. it's visual appearance will be changed. For GEONE<sub>x</sub>T backwards compatibility.\n         * @param {JXG.GeometryElement} element Reference of the object that is in draft mode.\n         */\n        setDraft: function (element) {},\n\n        /**\n         * Puts an object from draft mode back into normal mode.\n         * @param {JXG.GeometryElement} element Reference of the object that no longer is in draft mode.\n         */\n        removeDraft: function (element) {},\n\n        /**\n         * Sets up nodes for rendering a gradient fill.\n         * @param element\n         */\n        setGradient: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Updates the gradient fill.\n         * @param {JXG.GeometryElement} element An JSXGraph element with an area that can be filled.\n         */\n        updateGradient: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Sets the transition duration (in milliseconds) for fill color and stroke\n         * color and opacity.\n         * @param {JXG.GeometryElement} element Reference of the object that wants a\n         *         new transition duration.\n         * @param {Number} duration (Optional) duration in milliseconds. If not given,\n         *        element.visProp.transitionDuration is taken. This is the default.\n         */\n        setObjectTransition: function (element, duration) {\n            /* stub */\n        },\n\n        /**\n         * Sets an objects fill color.\n         * @param {JXG.GeometryElement} element Reference of the object that wants a new fill color.\n         * @param {String} color Color in a HTML/CSS compatible format. If you don't want any fill color at all, choose 'none'.\n         * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.\n         */\n        setObjectFillColor: function (element, color, opacity) {\n            /* stub */\n        },\n\n        /**\n         * Changes an objects stroke color to the given color.\n         * @param {JXG.GeometryElement} element Reference of the {@link JXG.GeometryElement} that gets a new stroke color.\n         * @param {String} color Color value in a HTML compatible format, e.g. <strong>#00ff00</strong> or <strong>green</strong> for green.\n         * @param {Number} opacity Opacity of the fill color. Must be between 0 and 1.\n         */\n        setObjectStrokeColor: function (element, color, opacity) {\n            /* stub */\n        },\n\n        /**\n         * Sets an element's stroke width.\n         * @param {JXG.GeometryElement} element Reference to the geometry element.\n         * @param {Number} width The new stroke width to be assigned to the element.\n         */\n        setObjectStrokeWidth: function (element, width) {\n            /* stub */\n        },\n\n        /**\n         * Sets the shadow properties to a geometry element. This method is only a stub, it is implemented in the actual renderers.\n         * @param {JXG.GeometryElement} element Reference to a geometry object, that should get a shadow\n         */\n        setShadow: function (element) {\n            /* stub */\n        },\n\n        /**\n         * Highlights an object, i.e. changes the current colors of the object to its highlighting colors\n         * @param {JXG.GeometryElement} element Reference of the object that will be highlighted.\n         * @returns {JXG.AbstractRenderer} Reference to the renderer\n         */\n        highlight: function (element) {},\n\n        /**\n         * Uses the normal colors of an object, i.e. the opposite of {@link JXG.AbstractRenderer#highlight}.\n         * @param {JXG.GeometryElement} element Reference of the object that will get its normal colors.\n         * @returns {JXG.AbstractRenderer} Reference to the renderer\n         */\n        noHighlight: function (element) {},\n\n        /* **************************\n         * renderer control\n         * **************************/\n\n        /**\n         * Stop redraw. This method is called before every update, so a non-vector-graphics based renderer\n         * can use this method to delete the contents of the drawing panel. This is an abstract method every\n         * descendant renderer should implement, if appropriate.\n         * @see JXG.AbstractRenderer#unsuspendRedraw\n         */\n        suspendRedraw: function () {\n            /* stub */\n        },\n\n        /**\n         * Restart redraw. This method is called after updating all the rendering node attributes.\n         * @see JXG.AbstractRenderer#suspendRedraw\n         */\n        unsuspendRedraw: function () {\n            /* stub */\n        },\n\n        /**\n         * The tiny zoom bar shown on the bottom of a board (if showNavigation on board creation is true).\n         * @param {JXG.Board} board Reference to a JSXGraph board.\n         */\n        drawZoomBar: function (board) {},\n\n        /**\n         * Wrapper for getElementById for maybe other renderers which elements are not directly accessible by DOM methods like document.getElementById().\n         * @param {String} id Unique identifier for element.\n         * @returns {Object} Reference to a JavaScript object. In case of SVG/VMLRenderer it's a reference to a SVG/VML node.\n         */\n        getElementById: function (id) {\n            return null;\n        },\n\n        /**\n         * Resizes the rendering element\n         * @param {Number} w New width\n         * @param {Number} h New height\n         */\n        resize: function (w, h) {\n            /* stub */\n        },\n\n        removeToInsertLater: function () {\n            return function () {};\n        }\n    }\n);\n\n/**\n * @ignore\n */\nJXG.NoRenderer.prototype = new AbstractRenderer();\n\nexport default JXG.NoRenderer;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, document:true, jQuery:true, define: true, window: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The JSXGraph object is defined in this file. JXG.JSXGraph controls all boards.\n * It has methods to create, save, load and free boards. Additionally some helper functions are\n * defined in this file directly in the JXG namespace.\n * @version 0.99\n */\n\nimport JXG from \"./jxg\";\nimport Env from \"./utils/env\";\nimport Type from \"./utils/type\";\nimport Board from \"./base/board\";\nimport FileReader from \"./reader/file\";\nimport Options from \"./options\";\nimport SVGRenderer from \"./renderer/svg\";\nimport VMLRenderer from \"./renderer/vml\";\nimport CanvasRenderer from \"./renderer/canvas\";\nimport NoRenderer from \"./renderer/no\";\n\n/**\n * Constructs a new JSXGraph singleton object.\n * @class The JXG.JSXGraph singleton stores all properties required\n * to load, save, create and free a board.\n */\nJXG.JSXGraph = {\n    /**\n     * Stores the renderer that is used to draw the boards.\n     * @type String\n     */\n    rendererType: (function () {\n        Options.board.renderer = \"no\";\n\n        if (Env.supportsVML()) {\n            Options.board.renderer = \"vml\";\n            // Ok, this is some real magic going on here. IE/VML always was so\n            // terribly slow, except in one place: Examples placed in a moodle course\n            // was almost as fast as in other browsers. So i grabbed all the css and\n            // lib scripts from our moodle, added them to a jsxgraph example and it\n            // worked. next step was to strip all the css/lib code which didn't affect\n            // the VML update speed. The following five lines are what was left after\n            // the last step and yes - it basically does nothing but reads two\n            // properties of document.body on every mouse move. why? we don't know. if\n            // you know, please let us know.\n            //\n            // If we want to use the strict mode we have to refactor this a little bit. Let's\n            // hope the magic isn't gone now. Anywho... it's only useful in old versions of IE\n            // which should not be used anymore.\n            document.onmousemove = function () {\n                var t;\n\n                if (document.body) {\n                    t = document.body.scrollLeft;\n                    t += document.body.scrollTop;\n                }\n\n                return t;\n            };\n        }\n\n        if (Env.supportsCanvas()) {\n            Options.board.renderer = \"canvas\";\n        }\n\n        if (Env.supportsSVG()) {\n            Options.board.renderer = \"svg\";\n        }\n\n        // we are inside node\n        if (Env.isNode() && Env.supportsCanvas()) {\n            Options.board.renderer = \"canvas\";\n        }\n\n        if (Env.isNode() || Options.renderer === \"no\") {\n            Options.text.display = \"internal\";\n            Options.infobox.display = \"internal\";\n        }\n\n        return Options.board.renderer;\n    })(),\n\n    /**\n     * Initialize the rendering engine\n     *\n     * @param  {String} box        HTML id of the div-element which hosts the JSXGraph construction\n     * @param  {Object} dim        The dimensions of the board\n     * @param  {Object} doc        Usually, this is document object of the browser window.  If false or null, this defaults\n     * to the document object of the browser.\n     * @param  {Object} attrRenderer Attribute 'renderer', speficies the rendering engine. Possible values are 'auto', 'svg',\n     *  'canvas', 'no', and 'vml'.\n     * @returns {Object}           Reference to the rendering engine object.\n     * @private\n     */\n    initRenderer: function (box, dim, doc, attrRenderer) {\n        var boxid, renderer;\n\n        // Former version:\n        // doc = doc || document\n        if ((!Type.exists(doc) || doc === false) && typeof document === \"object\") {\n            doc = document;\n        }\n\n        if (typeof doc === \"object\" && box !== null) {\n            boxid = doc.getElementById(box);\n\n            // Remove everything from the container before initializing the renderer and the board\n            while (boxid.firstChild) {\n                boxid.removeChild(boxid.firstChild);\n            }\n        } else {\n            boxid = box;\n        }\n\n        // If attrRenderer is not supplied take the first available renderer\n        if (attrRenderer === undefined || attrRenderer === \"auto\") {\n            attrRenderer = this.rendererType;\n        }\n        // create the renderer\n        if (attrRenderer === \"svg\") {\n            renderer = new SVGRenderer(boxid, dim);\n        } else if (attrRenderer === \"vml\") {\n            renderer = new VMLRenderer(boxid);\n        } else if (attrRenderer === \"canvas\") {\n            renderer = new CanvasRenderer(boxid, dim);\n        } else {\n            renderer = new NoRenderer();\n        }\n\n        return renderer;\n    },\n\n    /**\n     * Merge the user supplied attributes with the attributes in options.js\n     *\n     * @param {Object} attributes User supplied attributes\n     * @returns {Object} Merged attributes for the board\n     *\n     * @private\n     */\n    _setAttributes: function (attributes) {\n        // merge attributes\n        var attr = Type.copyAttributes(attributes, Options, \"board\");\n\n        // The attributes which are objects have to be copied separately\n        attr.zoom = Type.copyAttributes(attr, Options, \"board\", \"zoom\");\n        attr.pan = Type.copyAttributes(attr, Options, \"board\", \"pan\");\n        attr.drag = Type.copyAttributes(attr, Options, \"board\", \"drag\");\n        attr.keyboard = Type.copyAttributes(attr, Options, \"board\", \"keyboard\");\n        attr.selection = Type.copyAttributes(attr, Options, \"board\", \"selection\");\n        attr.navbar = Type.copyAttributes(attr.navbar, Options, \"navbar\");\n        attr.screenshot = Type.copyAttributes(attr, Options, \"board\", \"screenshot\");\n        attr.resize = Type.copyAttributes(attr, Options, \"board\", \"resize\");\n        attr.fullscreen = Type.copyAttributes(attr, Options, \"board\", \"fullscreen\");\n        attr.logging = Type.copyAttributes(attr, Options, 'board', 'logging');\n\n        // Treat moveTarget separately, because deepCopy will not work here.\n        // Reason: moveTarget will be an HTML node and it is prevented that Type.deepCopy will copy it.\n        attr.movetarget =\n            attributes.moveTarget || attributes.movetarget || Options.board.moveTarget;\n\n        return attr;\n    },\n\n    /**\n     * Further initialization of the board. Set some properties from attribute values.\n     *\n     * @param {JXG.Board} board\n     * @param {Object} attr attributes object\n     * @param {Object} dimensions Object containing dimensions of the canvas\n     *\n     * @private\n     */\n    _fillBoard: function (board, attr, dimensions) {\n        board.initInfobox();\n        board.maxboundingbox = attr.maxboundingbox;\n        board.resizeContainer(dimensions.width, dimensions.height, true, true);\n        board._createSelectionPolygon(attr);\n        board.renderer.drawZoomBar(board, attr.navbar);\n        JXG.boards[board.id] = board;\n    },\n\n    /**\n     *\n     * @param {String} container HTML-ID to the HTML-element in which the board is painted.\n     * @param {*} attr An object that sets some of the board properties.\n     *\n     * @private\n     */\n    _setARIA: function (container, attr) {\n        var doc = attr.document,\n            doc_glob,\n            node_jsx,\n            newNode,\n            parent,\n            id_label,\n            id_description;\n\n            if (typeof doc !== 'object') {\n                if (!Env.isBrowser) {\n                    return;\n                }\n                doc = document;\n            }\n\n        node_jsx = doc.getElementById(container);\n        doc_glob = node_jsx.ownerDocument; // This is the window.document element, needed below.\n        parent = node_jsx.parentNode;\n\n        id_label = container + \"_ARIAlabel\";\n        id_description = container + \"_ARIAdescription\";\n\n        newNode = doc_glob.createElement(\"div\");\n        newNode.innerHTML = attr.title;\n        newNode.setAttribute(\"id\", id_label);\n        newNode.style.display = \"none\";\n        parent.insertBefore(newNode, node_jsx);\n\n        newNode = doc_glob.createElement(\"div\");\n        newNode.innerHTML = attr.description;\n        newNode.setAttribute(\"id\", id_description);\n        newNode.style.display = \"none\";\n        parent.insertBefore(newNode, node_jsx);\n\n        node_jsx.setAttribute(\"aria-labelledby\", id_label);\n        node_jsx.setAttribute(\"aria-describedby\", id_description);\n    },\n\n    /**\n     * Remove the two corresponding ARIA divs when freeing a board\n     *\n     * @param {JXG.Board} board\n     *\n     * @private\n     */\n    _removeARIANodes: function (board) {\n        var node, id, doc;\n\n        doc = board.document || document;\n        if (typeof doc !== \"object\") {\n            return;\n        }\n\n        id = board.containerObj.getAttribute(\"aria-labelledby\");\n        node = doc.getElementById(id);\n        if (node && node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n        id = board.containerObj.getAttribute(\"aria-describedby\");\n        node = doc.getElementById(id);\n        if (node && node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    },\n\n    /**\n     * Initialise a new board.\n     * @param {String} box HTML-ID to the HTML-element in which the board is painted.\n     * @param {Object} attributes An object that sets some of the board properties. Most of these properties can be set via JXG.Options.\n     * @param {Array} [attributes.boundingbox=[-5, 5, 5, -5]] An array containing four numbers describing the left, top, right and bottom boundary of the board in user coordinates\n     * @param {Boolean} [attributes.keepaspectratio=false] If <tt>true</tt>, the bounding box is adjusted to the same aspect ratio as the aspect ratio of the div containing the board.\n     * @param {Boolean} [attributes.showCopyright=false] Show the copyright string in the top left corner.\n     * @param {Boolean} [attributes.showNavigation=false] Show the navigation buttons in the bottom right corner.\n     * @param {Object} [attributes.zoom] Allow the user to zoom with the mouse wheel or the two-fingers-zoom gesture.\n     * @param {Object} [attributes.pan] Allow the user to pan with shift+drag mouse or two-fingers-pan gesture.\n     * @param {Object} [attributes.drag] Allow the user to drag objects with a pointer device.\n     * @param {Object} [attributes.keyboard] Allow the user to drag objects with arrow keys on keyboard.\n     * @param {Boolean} [attributes.axis=false] If set to true, show the axis. Can also be set to an object that is given to both axes as an attribute object.\n     * @param {Boolean|Object} [attributes.grid] If set to true, shows the grid. Can also be set to an object that is given to the grid as its attribute object.\n     * @param {Boolean} [attributes.registerEvents=true] Register mouse / touch events.\n     * @returns {JXG.Board} Reference to the created board.\n     *\n     * @see JXG.AbstractRenderer#drawZoomBar\n     */\n    initBoard: function (box, attributes) {\n        var originX,\n            originY,\n            unitX,\n            unitY,\n            renderer,\n            offX = 0,\n            offY = 0,\n            w,\n            h,\n            dimensions,\n            bbox,\n            attr,\n            axattr,\n            axattr_x,\n            axattr_y,\n            board;\n\n        attributes = attributes || {};\n        attr = this._setAttributes(attributes);\n\n        dimensions = Env.getDimensions(box, attr.document);\n\n        if (attr.unitx || attr.unity) {\n            originX = Type.def(attr.originx, 150);\n            originY = Type.def(attr.originy, 150);\n            unitX = Type.def(attr.unitx, 50);\n            unitY = Type.def(attr.unity, 50);\n        } else {\n            bbox = attr.boundingbox;\n            if (bbox[0] < attr.maxboundingbox[0]) {\n                bbox[0] = attr.maxboundingbox[0];\n            }\n            if (bbox[1] > attr.maxboundingbox[1]) {\n                bbox[1] = attr.maxboundingbox[1];\n            }\n            if (bbox[2] > attr.maxboundingbox[2]) {\n                bbox[2] = attr.maxboundingbox[2];\n            }\n            if (bbox[3] < attr.maxboundingbox[3]) {\n                bbox[3] = attr.maxboundingbox[3];\n            }\n\n            w = parseInt(dimensions.width, 10);\n            h = parseInt(dimensions.height, 10);\n\n            if (Type.exists(bbox) && attr.keepaspectratio) {\n                /*\n                 * If the boundingbox attribute is given and the ratio of height and width of the\n                 * sides defined by the bounding box and the ratio of the dimensions of the div tag\n                 * which contains the board do not coincide, then the smaller side is chosen.\n                 */\n                unitX = w / (bbox[2] - bbox[0]);\n                unitY = h / (bbox[1] - bbox[3]);\n\n                if (Math.abs(unitX) < Math.abs(unitY)) {\n                    unitY = (Math.abs(unitX) * unitY) / Math.abs(unitY);\n                    // Add the additional units in equal portions above and below\n                    offY = (h / unitY - (bbox[1] - bbox[3])) * 0.5;\n                } else {\n                    unitX = (Math.abs(unitY) * unitX) / Math.abs(unitX);\n                    // Add the additional units in equal portions left and right\n                    offX = (w / unitX - (bbox[2] - bbox[0])) * 0.5;\n                }\n            } else {\n                unitX = w / (bbox[2] - bbox[0]);\n                unitY = h / (bbox[1] - bbox[3]);\n            }\n            originX = -unitX * (bbox[0] - offX);\n            originY = unitY * (bbox[1] + offY);\n        }\n\n        renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);\n        this._setARIA(box, attr);\n\n        // create the board\n        board = new Board(\n            box,\n            renderer,\n            attr.id,\n            [originX, originY],\n            attr.zoomfactor * attr.zoomx,\n            attr.zoomfactor * attr.zoomy,\n            unitX,\n            unitY,\n            dimensions.width,\n            dimensions.height,\n            attr\n        );\n\n        board.keepaspectratio = attr.keepaspectratio;\n\n        this._fillBoard(board, attr, dimensions);\n\n        // create elements like axes, grid, navigation, ...\n        board.suspendUpdate();\n        if (attr.axis) {\n            axattr = typeof attr.axis === \"object\" ? attr.axis : {};\n\n            // The defaultAxes attributes are overwritten by user supplied axis object.\n            axattr_x = Type.deepCopy(Options.board.defaultAxes.x, axattr);\n            axattr_y = Type.deepCopy(Options.board.defaultAxes.y, axattr);\n            // The user supplied defaultAxes attributes are merged in.\n            if (attr.defaultaxes.x) {\n                axattr_x = Type.deepCopy(axattr_x, attr.defaultaxes.x);\n            }\n            if (attr.defaultaxes.y) {\n                axattr_y = Type.deepCopy(axattr_y, attr.defaultaxes.y);\n            }\n\n            board.defaultAxes = {};\n            board.defaultAxes.x = board.create(\n                \"axis\",\n                [\n                    [0, 0],\n                    [1, 0]\n                ],\n                axattr_x\n            );\n            board.defaultAxes.y = board.create(\n                \"axis\",\n                [\n                    [0, 0],\n                    [0, 1]\n                ],\n                axattr_y\n            );\n        }\n        if (attr.grid) {\n            board.create(\"grid\", [], typeof attr.grid === \"object\" ? attr.grid : {});\n        }\n        board.unsuspendUpdate();\n\n        return board;\n    },\n\n    /**\n     * Load a board from a file containing a construction made with either GEONExT,\n     * Intergeo, Geogebra, or Cinderella.\n     * @param {String} box HTML-ID to the HTML-element in which the board is painted.\n     * @param {String} file base64 encoded string.\n     * @param {String} format containing the file format: 'Geonext' or 'Intergeo'.\n     * @param {Object} attributes Attributes for the board and 'encoding'.\n     *  Compressed files need encoding 'iso-8859-1'. Otherwise it probably is 'utf-8'.\n     * @param {Function} callback\n     * @returns {JXG.Board} Reference to the created board.\n     * @see JXG.FileReader\n     * @see JXG.GeonextReader\n     * @see JXG.GeogebraReader\n     * @see JXG.IntergeoReader\n     * @see JXG.CinderellaReader\n     *\n     * @example\n     * // Uncompressed file\n     * var board = JXG.JSXGraph.loadBoardFromFile('jxgbox', 'filename', 'geonext',\n     *      {encoding: 'utf-8'},\n     *      function (board) { console.log(\"Done loading\"); }\n     * );\n     * // Compressed file\n     * var board = JXG.JSXGraph.loadBoardFromFile('jxgbox', 'filename', 'geonext',\n     *      {encoding: 'iso-8859-1'},\n     *      function (board) { console.log(\"Done loading\"); }\n     * );\n     *\n     * @example\n     * // From <input type=\"file\" id=\"localfile\" />\n     * var file = document.getElementById('localfile').files[0];\n     * JXG.JSXGraph.loadBoardFromFile('jxgbox', file, 'geonext',\n     *      {encoding: 'utf-8'},\n     *      function (board) { console.log(\"Done loading\"); }\n     * );\n     */\n    loadBoardFromFile: function (box, file, format, attributes, callback) {\n        var attr, renderer, board, dimensions, encoding;\n\n        attributes = attributes || {};\n        attr = this._setAttributes(attributes);\n\n        dimensions = Env.getDimensions(box, attr.document);\n        renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);\n        this._setARIA(box, attr);\n\n        /* User default parameters, in parse* the values in the gxt files are submitted to board */\n        board = new Board(\n            box,\n            renderer,\n            \"\",\n            [150, 150],\n            1,\n            1,\n            50,\n            50,\n            dimensions.width,\n            dimensions.height,\n            attr\n        );\n        this._fillBoard(board, attr, dimensions);\n        encoding = attr.encoding || \"iso-8859-1\";\n        FileReader.parseFileContent(file, board, format, true, encoding, callback);\n\n        return board;\n    },\n\n    /**\n     * Load a board from a base64 encoded string containing a construction made with either GEONExT,\n     * Intergeo, Geogebra, or Cinderella.\n     * @param {String} box HTML-ID to the HTML-element in which the board is painted.\n     * @param {String} string base64 encoded string.\n     * @param {String} format containing the file format: 'Geonext', 'Intergeo', 'Geogebra'.\n     * @param {Object} attributes Attributes for the board and 'encoding'.\n     *  Compressed files need encoding 'iso-8859-1'. Otherwise it probably is 'utf-8'.\n     * @param {Function} callback\n     * @returns {JXG.Board} Reference to the created board.\n     * @see JXG.FileReader\n     * @see JXG.GeonextReader\n     * @see JXG.GeogebraReader\n     * @see JXG.IntergeoReader\n     * @see JXG.CinderellaReader\n     */\n    loadBoardFromString: function (box, string, format, attributes, callback) {\n        var attr, renderer, board, dimensions;\n\n        attributes = attributes || {};\n        attr = this._setAttributes(attributes);\n\n            dimensions = Env.getDimensions(box, attr.document);\n            renderer = this.initRenderer(box, dimensions, attr.document, attr.renderer);\n            this._setARIA(box, attr);\n\n        /* User default parameters, in parse* the values in the gxt files are submitted to board */\n        board = new Board(\n            box,\n            renderer,\n            \"\",\n            [150, 150],\n            1.0,\n            1.0,\n            50,\n            50,\n            dimensions.width,\n            dimensions.height,\n            attr\n        );\n        this._fillBoard(board, attr, dimensions);\n        FileReader.parseString(string, board, format, true, callback);\n\n        return board;\n    },\n\n    /**\n     * Delete a board and all its contents.\n     * @param {JXG.Board,String} board HTML-ID to the DOM-element in which the board is drawn.\n     */\n    freeBoard: function (board) {\n        var el;\n\n        if (typeof board === \"string\") {\n            board = JXG.boards[board];\n        }\n\n        this._removeARIANodes(board);\n        board.removeEventHandlers();\n        board.suspendUpdate();\n\n        // Remove all objects from the board.\n        for (el in board.objects) {\n            if (board.objects.hasOwnProperty(el)) {\n                board.objects[el].remove();\n            }\n        }\n\n        // Remove all the other things, left on the board, XHTML save\n        while (board.containerObj.firstChild) {\n            board.containerObj.removeChild(board.containerObj.firstChild);\n        }\n\n        // Tell the browser the objects aren't needed anymore\n        for (el in board.objects) {\n            if (board.objects.hasOwnProperty(el)) {\n                delete board.objects[el];\n            }\n        }\n\n        // Free the renderer and the algebra object\n        delete board.renderer;\n\n        // clear the creator cache\n        board.jc.creator.clearCache();\n        delete board.jc;\n\n        // Finally remove the board itself from the boards array\n        delete JXG.boards[board.id];\n    },\n\n    /**\n     * @deprecated Use JXG#registerElement\n     * @param element\n     * @param creator\n     */\n    registerElement: function (element, creator) {\n        JXG.deprecated(\"JXG.JSXGraph.registerElement()\", \"JXG.registerElement()\");\n        JXG.registerElement(element, creator);\n    }\n};\n\n// JessieScript/JessieCode startup:\n// Search for script tags of type text/jessiescript and interprete them.\nif (Env.isBrowser && typeof window === \"object\" && typeof document === \"object\") {\n    Env.addEvent(\n        window,\n        \"load\",\n        function () {\n            var type,\n                i,\n                j,\n                div,\n                id,\n                board,\n                txt,\n                width,\n                height,\n                maxWidth,\n                aspectRatio,\n                cssClasses,\n                bbox,\n                axis,\n                grid,\n                code,\n                src,\n                request,\n                postpone = false,\n                scripts = document.getElementsByTagName(\"script\"),\n                init = function (code, type, bbox) {\n                    var board = JXG.JSXGraph.initBoard(id, {\n                        boundingbox: bbox,\n                        keepaspectratio: true,\n                        grid: grid,\n                        axis: axis,\n                        showReload: true\n                    });\n\n                    if (type.toLowerCase().indexOf(\"script\") > -1) {\n                        board.construct(code);\n                    } else {\n                        try {\n                            board.jc.parse(code);\n                        } catch (e2) {\n                            JXG.debug(e2);\n                        }\n                    }\n\n                    return board;\n                },\n                makeReload = function (board, code, type, bbox) {\n                    return function () {\n                        var newBoard;\n\n                        JXG.JSXGraph.freeBoard(board);\n                        newBoard = init(code, type, bbox);\n                        newBoard.reload = makeReload(newBoard, code, type, bbox);\n                    };\n                };\n\n            for (i = 0; i < scripts.length; i++) {\n                type = scripts[i].getAttribute(\"type\", false);\n\n                if (\n                    Type.exists(type) &&\n                    (type.toLowerCase() === \"text/jessiescript\" ||\n                        type.toLowerCase() === \"jessiescript\" ||\n                        type.toLowerCase() === \"text/jessiecode\" ||\n                        type.toLowerCase() === \"jessiecode\")\n                ) {\n                    cssClasses = scripts[i].getAttribute(\"class\", false) || \"\";\n                    width = scripts[i].getAttribute(\"width\", false) || \"\";\n                    height = scripts[i].getAttribute(\"height\", false) || \"\";\n                    maxWidth = scripts[i].getAttribute(\"maxwidth\", false) || \"100%\";\n                    aspectRatio = scripts[i].getAttribute(\"aspectratio\", false) || \"1/1\";\n                    bbox = scripts[i].getAttribute(\"boundingbox\", false) || \"-5, 5, 5, -5\";\n                    id = scripts[i].getAttribute(\"container\", false);\n                    src = scripts[i].getAttribute(\"src\", false);\n\n                    bbox = bbox.split(\",\");\n                    if (bbox.length !== 4) {\n                        bbox = [-5, 5, 5, -5];\n                    } else {\n                        for (j = 0; j < bbox.length; j++) {\n                            bbox[j] = parseFloat(bbox[j]);\n                        }\n                    }\n                    axis = Type.str2Bool(scripts[i].getAttribute(\"axis\", false) || \"false\");\n                    grid = Type.str2Bool(scripts[i].getAttribute(\"grid\", false) || \"false\");\n\n                    if (!Type.exists(id)) {\n                        id = \"jessiescript_autgen_jxg_\" + i;\n                        div = document.createElement(\"div\");\n                        div.setAttribute(\"id\", id);\n\n                        txt = width !== \"\" ? \"width:\" + width + \";\" : \"\";\n                        txt += height !== \"\" ? \"height:\" + height + \";\" : \"\";\n                        txt += maxWidth !== \"\" ? \"max-width:\" + maxWidth + \";\" : \"\";\n                        txt += aspectRatio !== \"\" ? \"aspect-ratio:\" + aspectRatio + \";\" : \"\";\n\n                        div.setAttribute(\"style\", txt);\n                        div.setAttribute(\"class\", \"jxgbox \" + cssClasses);\n                        try {\n                            document.body.insertBefore(div, scripts[i]);\n                        } catch (e) {\n                            // there's probably jquery involved...\n                            if (typeof jQuery === \"object\") {\n                                jQuery(div).insertBefore(scripts[i]);\n                            }\n                        }\n                    } else {\n                        div = document.getElementById(id);\n                    }\n\n                    code = \"\";\n\n                    if (Type.exists(src)) {\n                        postpone = true;\n                        request = new XMLHttpRequest();\n                        request.open(\"GET\", src);\n                        request.overrideMimeType(\"text/plain; charset=x-user-defined\");\n                        /* jshint ignore:start */\n                        request.addEventListener(\"load\", function () {\n                            if (this.status < 400) {\n                                code = this.responseText + \"\\n\" + code;\n                                board = init(code, type, bbox);\n                                board.reload = makeReload(board, code, type, bbox);\n                            } else {\n                                throw new Error(\n                                    \"\\nJSXGraph: failed to load file\",\n                                    src,\n                                    \":\",\n                                    this.responseText\n                                );\n                            }\n                        });\n                        request.addEventListener(\"error\", function (e) {\n                            throw new Error(\"\\nJSXGraph: failed to load file\", src, \":\", e);\n                        });\n                        /* jshint ignore:end */\n                        request.send();\n                    } else {\n                        postpone = false;\n                    }\n\n                    if (document.getElementById(id)) {\n                        code = scripts[i].innerHTML;\n                        code = code.replace(/<!\\[CDATA\\[/g, \"\").replace(/\\]\\]>/g, \"\");\n                        scripts[i].innerHTML = code;\n\n                        if (!postpone) {\n                            // Do no wait for data from \"src\" attribute\n                            board = init(code, type, bbox);\n                            board.reload = makeReload(board, code, type, bbox);\n                        }\n                    } else {\n                        JXG.debug(\n                            \"JSXGraph: Apparently the div injection failed. Can't create a board, sorry.\"\n                        );\n                    }\n                }\n            }\n        },\n        window\n    );\n}\n\nexport default JXG.JSXGraph;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, console: true, window: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The geometry object Point is defined in this file. Point stores all\n * style and functional properties that are required to draw and move a point on\n * a board.\n */\n\nimport JXG from \"../jxg\";\nimport Options from \"../options\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Const from \"./constants\";\nimport GeometryElement from \"./element\";\nimport Type from \"../utils/type\";\nimport CoordsElement from \"./coordselement\";\n\n/**\n * A point is the basic geometric element. Based on points lines and circles can be constructed which can be intersected\n * which in turn are points again which can be used to construct new lines, circles, polygons, etc. This class holds methods for\n * all kind of points like free points, gliders, and intersection points.\n * @class Creates a new point object. Do not use this constructor to create a point. Use {@link JXG.Board#create} with\n * type {@link Point}, {@link Glider}, or {@link Intersection} instead.\n * @augments JXG.GeometryElement\n * @augments JXG.CoordsElement\n * @param {string|JXG.Board} board The board the new point is drawn on.\n * @param {Array} coordinates An array with the user coordinates of the point.\n * @param {Object} attributes An object containing visual properties like in {@link JXG.Options#point} and\n * {@link JXG.Options#elements}, and optional a name and an id.\n * @see JXG.Board#generateName\n */\nJXG.Point = function (board, coordinates, attributes) {\n    this.constructor(board, attributes, Const.OBJECT_TYPE_POINT, Const.OBJECT_CLASS_POINT);\n    this.element = this.board.select(attributes.anchor);\n    this.coordsConstructor(coordinates);\n\n    this.elType = \"point\";\n\n    /* Register point at board. */\n    this.id = this.board.setId(this, \"P\");\n    this.board.renderer.drawPoint(this);\n    this.board.finalizeAdding(this);\n\n    this.createGradient();\n    this.createLabel();\n};\n\n/**\n * Inherits here from {@link JXG.GeometryElement}.\n */\nJXG.Point.prototype = new GeometryElement();\nType.copyPrototypeMethods(JXG.Point, CoordsElement, \"coordsConstructor\");\n\nJXG.extend(\n    JXG.Point.prototype,\n    /** @lends JXG.Point.prototype */ {\n        /**\n         * Checks whether (x,y) is near the point.\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} True if (x,y) is near the point, False otherwise.\n         * @private\n         */\n        hasPoint: function (x, y) {\n            var coordsScr = this.coords.scrCoords,\n                r,\n                prec,\n                type,\n                unit = Type.evaluate(this.visProp.sizeunit);\n\n            if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n                type = this.board._inputDevice;\n                prec = Type.evaluate(this.visProp.precision[type]);\n            } else {\n                // 'inherit'\n                prec = this.board.options.precision.hasPoint;\n            }\n            r = parseFloat(Type.evaluate(this.visProp.size));\n            if (unit === \"user\") {\n                r *= Math.sqrt(this.board.unitX * this.board.unitY);\n            }\n\n            r += parseFloat(Type.evaluate(this.visProp.strokewidth)) * 0.5;\n            if (r < prec) {\n                r = prec;\n            }\n\n            return Math.abs(coordsScr[1] - x) < r + 2 && Math.abs(coordsScr[2] - y) < r + 2;\n        },\n\n        /**\n         * Updates the position of the point.\n         */\n        update: function (fromParent) {\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            this.updateCoords(fromParent);\n\n            if (Type.evaluate(this.visProp.trace)) {\n                this.cloneToBackground(true);\n            }\n\n            return this;\n        },\n\n        /**\n         * Applies the transformations of the element to {@link JXG.Point#baseElement}.\n         * Point transformations are relative to a base element.\n         * @param {Boolean} fromParent True if the drag comes from a child element. This is the case if a line\n         *    through two points is dragged. Otherwise, the element is the drag element and we apply the\n         *    the inverse transformation to the baseElement if is different from the element.\n         * @returns {JXG.CoordsElement} Reference to this object.\n         */\n        updateTransform: function (fromParent) {\n            var c, i;\n\n            if (this.transformations.length === 0 || this.baseElement === null) {\n                return this;\n            }\n\n            if (this === this.baseElement) {\n                // Case of bindTo\n                c = this.transformations[0].apply(this.baseElement, \"self\");\n                this.coords.setCoordinates(Const.COORDS_BY_USER, c);\n            } else {\n                c = this.transformations[0].apply(this.baseElement);\n            }\n            this.coords.setCoordinates(Const.COORDS_BY_USER, c);\n\n            for (i = 1; i < this.transformations.length; i++) {\n                this.coords.setCoordinates(\n                    Const.COORDS_BY_USER,\n                    this.transformations[i].apply(this)\n                );\n            }\n            return this;\n        },\n\n        /**\n         * Calls the renderer to update the drawing.\n         * @private\n         */\n        updateRenderer: function () {\n            this.updateRendererGeneric(\"updatePoint\");\n            return this;\n        },\n\n        // documented in JXG.GeometryElement\n        bounds: function () {\n            return this.coords.usrCoords.slice(1).concat(this.coords.usrCoords.slice(1));\n        },\n\n        /**\n         * Convert the point to intersection point and update the construction.\n         * To move the point visual onto the intersection, a call of board update is necessary.\n         *\n         * @param {String|Object} el1, el2, i, j The intersecting objects and the numbers.\n         **/\n        makeIntersection: function (el1, el2, i, j) {\n            var func;\n\n            el1 = this.board.select(el1);\n            el2 = this.board.select(el2);\n\n            func = Geometry.intersectionFunction(\n                this.board,\n                el1,\n                el2,\n                i,\n                j,\n                Type.evaluate(this.visProp.alwaysintersect)\n            );\n            this.addConstraint([func]);\n\n            try {\n                el1.addChild(this);\n                el2.addChild(this);\n            } catch (e) {\n                throw new Error(\n                    \"JSXGraph: Can't create 'intersection' with parent types '\" +\n                        typeof el1 +\n                        \"' and '\" +\n                        typeof el2 +\n                        \"'.\"\n                );\n            }\n\n            this.type = Const.OBJECT_TYPE_INTERSECTION;\n            this.elType = \"intersection\";\n            this.parents = [el1.id, el2.id, i, j];\n\n            this.generatePolynomial = function () {\n                var poly1 = el1.generatePolynomial(this),\n                    poly2 = el2.generatePolynomial(this);\n\n                if (poly1.length === 0 || poly2.length === 0) {\n                    return [];\n                }\n\n                return [poly1[0], poly2[0]];\n            };\n\n            this.prepareUpdate().update();\n        },\n\n        /**\n         * Set the style of a point.\n         * Used for GEONExT import and should not be used to set the point's face and size.\n         * @param {Number} i Integer to determine the style.\n         * @private\n         */\n        setStyle: function (i) {\n            var facemap = [\n                    // 0-2\n                    \"cross\",\n                    \"cross\",\n                    \"cross\",\n                    // 3-6\n                    \"circle\",\n                    \"circle\",\n                    \"circle\",\n                    \"circle\",\n                    // 7-9\n                    \"square\",\n                    \"square\",\n                    \"square\",\n                    // 10-12\n                    \"plus\",\n                    \"plus\",\n                    \"plus\"\n                ],\n                sizemap = [\n                    // 0-2\n                    2, 3, 4,\n                    // 3-6\n                    1, 2, 3, 4,\n                    // 7-9\n                    2, 3, 4,\n                    // 10-12\n                    2, 3, 4\n                ];\n\n            this.visProp.face = facemap[i];\n            this.visProp.size = sizemap[i];\n\n            this.board.renderer.changePointStyle(this);\n            return this;\n        },\n\n        /**\n         * @deprecated Use JXG#normalizePointFace instead\n         * @param s\n         * @returns {*}\n         */\n        normalizeFace: function (s) {\n            JXG.deprecated(\"Point.normalizeFace()\", \"JXG.normalizePointFace()\");\n            return Options.normalizePointFace(s);\n        },\n\n        /**\n         * Set the face of a point element.\n         * @param {String} f String which determines the face of the point. See {@link JXG.GeometryElement#face} for a list of available faces.\n         * @see JXG.GeometryElement#face\n         * @deprecated Use setAttribute()\n         */\n        face: function (f) {\n            JXG.deprecated(\"Point.face()\", \"Point.setAttribute()\");\n            this.setAttribute({ face: f });\n        },\n\n        /**\n         * Set the size of a point element\n         * @param {Number} s Integer which determines the size of the point.\n         * @see JXG.GeometryElement#size\n         * @deprecated Use setAttribute()\n         */\n        size: function (s) {\n            JXG.deprecated(\"Point.size()\", \"Point.setAttribute()\");\n            this.setAttribute({ size: s });\n        },\n\n        /**\n         * Test if the point is on (is incident with) element \"el\".\n         *\n         * @param {JXG.GeometryElement} el\n         * @param {Number} tol\n         * @returns {Boolean}\n         *\n         * @example\n         * var circ = board.create('circle', [[-2, -2], 1]);\n         * var seg = board.create('segment', [[-1, -3], [0,0]]);\n         * var line = board.create('line', [[1, 3], [2, -2]]);\n         * var po = board.create('point', [-1, 0], {color: 'blue'});\n         * var curve = board.create('functiongraph', ['sin(x)'], {strokeColor: 'blue'});\n         * var pol = board.create('polygon', [[2,2], [4,2], [4,3]], {strokeColor: 'blue'});\n         *\n         * var point = board.create('point', [-1, 1], {\n         *               attractors: [line, seg, circ, po, curve, pol],\n         *               attractorDistance: 0.2\n         *             });\n         *\n         * var txt = board.create('text', [-4, 3, function() {\n         *              return 'point on line: ' + point.isOn(line) + '<br>' +\n         *                 'point on seg: ' + point.isOn(seg) + '<br>' +\n         *                 'point on circ = ' + point.isOn(circ) + '<br>' +\n         *                 'point on point = ' + point.isOn(po) + '<br>' +\n         *                 'point on curve = ' + point.isOn(curve) + '<br>' +\n         *                 'point on polygon = ' + point.isOn(pol) + '<br>';\n         * }]);\n         *\n         * </pre><div id=\"JXG6c7d7404-758a-44eb-802c-e9644b9fab71\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG6c7d7404-758a-44eb-802c-e9644b9fab71',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     var circ = board.create('circle', [[-2, -2], 1]);\n         *     var seg = board.create('segment', [[-1, -3], [0,0]]);\n         *     var line = board.create('line', [[1, 3], [2, -2]]);\n         *     var po = board.create('point', [-1, 0], {color: 'blue'});\n         *     var curve = board.create('functiongraph', ['sin(x)'], {strokeColor: 'blue'});\n         *     var pol = board.create('polygon', [[2,2], [4,2], [4,3]], {strokeColor: 'blue'});\n         *\n         *     var point = board.create('point', [-1, 1], {\n         *                   attractors: [line, seg, circ, po, curve, pol],\n         *                   attractorDistance: 0.2\n         *                 });\n         *\n         *     var txt = board.create('text', [-4, 3, function() {\n         *             return 'point on line: ' + point.isOn(line) + '<br>' +\n         *                     'point on seg: ' + point.isOn(seg) + '<br>' +\n         *                     'point on circ = ' + point.isOn(circ) + '<br>' +\n         *                     'point on point = ' + point.isOn(po) + '<br>' +\n         *                     'point on curve = ' + point.isOn(curve) + '<br>' +\n         *                     'point on polygon = ' + point.isOn(pol) + '<br>';\n         *     }]);\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        isOn: function (el, tol) {\n            var arr, crds;\n\n            tol = tol || Mat.eps;\n\n            if (Type.isPoint(el)) {\n                return this.Dist(el) < tol;\n            } else if (el.elementClass === Const.OBJECT_CLASS_LINE) {\n                if (el.elType === \"segment\" && !Type.evaluate(this.visProp.alwaysintersect)) {\n                    arr = JXG.Math.Geometry.projectCoordsToSegment(\n                        this.coords.usrCoords,\n                        el.point1.coords.usrCoords,\n                        el.point2.coords.usrCoords\n                    );\n                    if (\n                        arr[1] >= 0 &&\n                        arr[1] <= 1 &&\n                        Geometry.distPointLine(this.coords.usrCoords, el.stdform) < tol\n                    ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                } else {\n                    return Geometry.distPointLine(this.coords.usrCoords, el.stdform) < tol;\n                }\n            } else if (el.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                if (Type.evaluate(el.visProp.hasinnerpoints)) {\n                    return this.Dist(el.center) < el.Radius() + tol;\n                }\n                return Math.abs(this.Dist(el.center) - el.Radius()) < tol;\n            } else if (el.elementClass === Const.OBJECT_CLASS_CURVE) {\n                crds = Geometry.projectPointToCurve(this, el, this.board)[0];\n                return Geometry.distance(this.coords.usrCoords, crds.usrCoords, 3) < tol;\n            } else if (el.type === Const.OBJECT_TYPE_POLYGON) {\n                if (Type.evaluate(el.visProp.hasinnerpoints)) {\n                    if (\n                        el.pnpoly(\n                            this.coords.usrCoords[1],\n                            this.coords.usrCoords[2],\n                            JXG.COORDS_BY_USER\n                        )\n                    ) {\n                        return true;\n                    }\n                }\n                arr = Geometry.projectCoordsToPolygon(this.coords.usrCoords, el);\n                return Geometry.distance(this.coords.usrCoords, arr, 3) < tol;\n            } else if (el.type === Const.OBJECT_TYPE_TURTLE) {\n                crds = Geometry.projectPointToTurtle(this, el, this.board);\n                return Geometry.distance(this.coords.usrCoords, crds.usrCoords, 3) < tol;\n            }\n\n            // TODO: Arc, Sector\n            return false;\n        },\n\n        // Already documented in GeometryElement\n        cloneToBackground: function () {\n            var copy = {};\n\n            copy.id = this.id + \"T\" + this.numTraces;\n            this.numTraces += 1;\n\n            copy.coords = this.coords;\n            copy.visProp = Type.deepCopy(this.visProp, this.visProp.traceattributes, true);\n            copy.visProp.layer = this.board.options.layer.trace;\n            copy.elementClass = Const.OBJECT_CLASS_POINT;\n            copy.board = this.board;\n            Type.clearVisPropOld(copy);\n\n            copy.visPropCalc = {\n                visible: Type.evaluate(copy.visProp.visible)\n            };\n\n            this.board.renderer.drawPoint(copy);\n            this.traces[copy.id] = copy.rendNode;\n\n            return this;\n        }\n    }\n);\n\n/**\n * @class This element is used to provide a constructor for a general point. A free point is created if the given parent elements are all numbers\n * and the property fixed is not set or set to false. If one or more parent elements is not a number but a string containing a GEONE<sub>x</sub>T\n * constraint or a function the point will be considered as constrained). That means that the user won't be able to change the point's\n * position directly.\n * @pseudo\n * @description\n * @name Point\n * @augments JXG.Point\n * @constructor\n * @type JXG.Point\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Number,string,function_Number,string,function_Number,string,function} z_,x,y Parent elements can be two or three elements of type number, a string containing a GEONE<sub>x</sub>T\n * constraint, or a function which takes no parameter and returns a number. Every parent element determines one coordinate. If a coordinate is\n * given by a number, the number determines the initial position of a free point. If given by a string or a function that coordinate will be constrained\n * that means the user won't be able to change the point's position directly by mouse because it will be calculated automatically depending on the string\n * or the function's return value. If two parent elements are given the coordinates will be interpreted as 2D affine Euclidean coordinates, if three such\n * parent elements are given they will be interpreted as homogeneous coordinates.\n * @param {JXG.Point_JXG.Transformation_Array} Point,Transformation A point can also be created providing a transformation or an array of transformations.\n * The resulting point is a clone of the base point transformed by the given Transformation. {@see JXG.Transformation}.\n *\n * @example\n * // Create a free point using affine Euclidean coordinates\n * var p1 = board.create('point', [3.5, 2.0]);\n * </pre><div class=\"jxgbox\" id=\"JXG672f1764-7dfa-4abc-a2c6-81fbbf83e44b\" style=\"width: 200px; height: 200px;\"></div>\n * <script type=\"text/javascript\">\n *   var board = JXG.JSXGraph.initBoard('JXG672f1764-7dfa-4abc-a2c6-81fbbf83e44b', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var p1 = board.create('point', [3.5, 2.0]);\n * </script><pre>\n * @example\n * // Create a constrained point using anonymous function\n * var p2 = board.create('point', [3.5, function () { return p1.X(); }]);\n * </pre><div class=\"jxgbox\" id=\"JXG4fd4410c-3383-4e80-b1bb-961f5eeef224\" style=\"width: 200px; height: 200px;\"></div>\n * <script type=\"text/javascript\">\n *   var fpex1_board = JXG.JSXGraph.initBoard('JXG4fd4410c-3383-4e80-b1bb-961f5eeef224', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var fpex1_p1 = fpex1_board.create('point', [3.5, 2.0]);\n *   var fpex1_p2 = fpex1_board.create('point', [3.5, function () { return fpex1_p1.X(); }]);\n * </script><pre>\n * @example\n * // Create a point using transformations\n * var trans = board.create('transform', [2, 0.5], {type:'scale'});\n * var p3 = board.create('point', [p2, trans]);\n * </pre><div class=\"jxgbox\" id=\"JXG630afdf3-0a64-46e0-8a44-f51bd197bb8d\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var fpex2_board = JXG.JSXGraph.initBoard('JXG630afdf3-0a64-46e0-8a44-f51bd197bb8d', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var fpex2_trans = fpex2_board.create('transform', [2, 0.5], {type:'scale'});\n *   var fpex2_p2 = fpex2_board.create('point', [3.5, 2.0]);\n *   var fpex2_p3 = fpex2_board.create('point', [fpex2_p2, fpex2_trans]);\n * </script><pre>\n */\nJXG.createPoint = function (board, parents, attributes) {\n    var el, attr;\n\n    attr = Type.copyAttributes(attributes, board.options, \"point\");\n    el = CoordsElement.create(JXG.Point, board, parents, attr);\n    if (!el) {\n        throw new Error(\n            \"JSXGraph: Can't create point with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [x,y], [z,x,y], [element,transformation]\"\n        );\n    }\n\n    return el;\n};\n\n/**\n * @class This element is used to provide a constructor for a glider point.\n * @pseudo\n * @description A glider is a point which lives on another geometric element like a line, circle, curve, turtle.\n * @name Glider\n * @augments JXG.Point\n * @constructor\n * @type JXG.Point\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Number_Number_Number_JXG.GeometryElement} z_,x_,y_,GlideObject Parent elements can be two or three elements of type number and the object the glider lives on.\n * The coordinates are completely optional. If not given the origin is used. If you provide two numbers for coordinates they will be interpreted as affine Euclidean\n * coordinates, otherwise they will be interpreted as homogeneous coordinates. In any case the point will be projected on the glide object.\n * @example\n * // Create a glider with user defined coordinates. If the coordinates are not on\n * // the circle (like in this case) the point will be projected onto the circle.\n * var p1 = board.create('point', [2.0, 2.0]);\n * var c1 = board.create('circle', [p1, 2.0]);\n * var p2 = board.create('glider', [2.0, 1.5, c1]);\n * </pre><div class=\"jxgbox\" id=\"JXG4f65f32f-e50a-4b50-9b7c-f6ec41652930\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var gpex1_board = JXG.JSXGraph.initBoard('JXG4f65f32f-e50a-4b50-9b7c-f6ec41652930', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var gpex1_p1 = gpex1_board.create('point', [2.0, 2.0]);\n *   var gpex1_c1 = gpex1_board.create('circle', [gpex1_p1, 2.0]);\n *   var gpex1_p2 = gpex1_board.create('glider', [2.0, 1.5, gpex1_c1]);\n * </script><pre>\n * @example\n * // Create a glider with default coordinates (1,0,0). Same premises as above.\n * var p1 = board.create('point', [2.0, 2.0]);\n * var c1 = board.create('circle', [p1, 2.0]);\n * var p2 = board.create('glider', [c1]);\n * </pre><div class=\"jxgbox\" id=\"JXG4de7f181-631a-44b1-a12f-bc4d995609e8\" style=\"width: 200px; height: 200px;\"></div>\n * <script type=\"text/javascript\">\n *   var gpex2_board = JXG.JSXGraph.initBoard('JXG4de7f181-631a-44b1-a12f-bc4d995609e8', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var gpex2_p1 = gpex2_board.create('point', [2.0, 2.0]);\n *   var gpex2_c1 = gpex2_board.create('circle', [gpex2_p1, 2.0]);\n *   var gpex2_p2 = gpex2_board.create('glider', [gpex2_c1]);\n * </script><pre>\n *@example\n * //animate example 2\n * var p1 = board.create('point', [2.0, 2.0]);\n * var c1 = board.create('circle', [p1, 2.0]);\n * var p2 = board.create('glider', [c1]);\n * var button1 = board.create('button', [1, 7, 'start animation',function(){p2.startAnimation(1,4)}]);\n * var button2 = board.create('button', [1, 5, 'stop animation',function(){p2.stopAnimation()}]);\n * </pre><div class=\"jxgbox\" id=\"JXG4de7f181-631a-44b1-a12f-bc4d133709e8\" style=\"width: 200px; height: 200px;\"></div>\n * <script type=\"text/javascript\">\n *   var gpex3_board = JXG.JSXGraph.initBoard('JXG4de7f181-631a-44b1-a12f-bc4d133709e8', {boundingbox: [-1, 10, 10, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var gpex3_p1 = gpex3_board.create('point', [2.0, 2.0]);\n *   var gpex3_c1 = gpex3_board.create('circle', [gpex3_p1, 2.0]);\n *   var gpex3_p2 = gpex3_board.create('glider', [gpex3_c1]);\n *   gpex3_board.create('button', [1, 7, 'start animation',function(){gpex3_p2.startAnimation(1,4)}]);\n *   gpex3_board.create('button', [1, 5, 'stop animation',function(){gpex3_p2.stopAnimation()}]);\n * </script><pre>\n */\nJXG.createGlider = function (board, parents, attributes) {\n    var el,\n        coords,\n        attr = Type.copyAttributes(attributes, board.options, \"glider\");\n\n    if (parents.length === 1) {\n        coords = [0, 0];\n    } else {\n        coords = parents.slice(0, 2);\n    }\n    el = board.create(\"point\", coords, attr);\n\n    // eltype is set in here\n    el.makeGlider(parents[parents.length - 1]);\n\n    return el;\n};\n\n/**\n * @class An intersection point is a point which lives on two JSXGraph elements, i.e. it is one point of the the set\n * consisting of the intersection points of the two elements. The following element types can be (mutually) intersected: line, circle,\n * curve, polygon, polygonal chain.\n *\n * @pseudo\n * @name Intersection\n * @augments JXG.Point\n * @constructor\n * @type JXG.Point\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number} el1,el2,i The result will be a intersection point on el1 and el2. i determines the\n * intersection point if two points are available: <ul>\n *   <li>i==0: use the positive square root,</li>\n *   <li>i==1: use the negative square root.</li></ul>\n * @example\n * // Create an intersection point of circle and line\n * var p1 = board.create('point', [2.0, 2.0]);\n * var c1 = board.create('circle', [p1, 2.0]);\n *\n * var p2 = board.create('point', [2.0, 2.0]);\n * var p3 = board.create('point', [2.0, 2.0]);\n * var l1 = board.create('line', [p2, p3]);\n *\n * var i = board.create('intersection', [c1, l1, 0]);\n * </pre><div class=\"jxgbox\" id=\"JXGe5b0e190-5200-4bc3-b995-b6cc53dc5dc0\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var ipex1_board = JXG.JSXGraph.initBoard('JXGe5b0e190-5200-4bc3-b995-b6cc53dc5dc0', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var ipex1_p1 = ipex1_board.create('point', [4.0, 4.0]);\n *   var ipex1_c1 = ipex1_board.create('circle', [ipex1_p1, 2.0]);\n *   var ipex1_p2 = ipex1_board.create('point', [1.0, 1.0]);\n *   var ipex1_p3 = ipex1_board.create('point', [5.0, 3.0]);\n *   var ipex1_l1 = ipex1_board.create('line', [ipex1_p2, ipex1_p3]);\n *   var ipex1_i = ipex1_board.create('intersection', [ipex1_c1, ipex1_l1, 0]);\n * </script><pre>\n */\nJXG.createIntersectionPoint = function (board, parents, attributes) {\n    var el,\n        el1,\n        el2,\n        func,\n        i,\n        j,\n        attr = Type.copyAttributes(attributes, board.options, \"intersection\");\n\n    // make sure we definitely have the indices\n    parents.push(0, 0);\n\n    el1 = board.select(parents[0]);\n    el2 = board.select(parents[1]);\n\n    i = parents[2] || 0;\n    j = parents[3] || 0;\n\n    el = board.create(\"point\", [0, 0, 0], attr);\n\n    // el.visProp.alwaysintersect is evaluated as late as in the returned function\n    func = Geometry.intersectionFunction(board, el1, el2, i, j, el.visProp.alwaysintersect);\n    el.addConstraint([func]);\n\n    try {\n        el1.addChild(el);\n        el2.addChild(el);\n    } catch (e) {\n        throw new Error(\n            \"JSXGraph: Can't create 'intersection' with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\"\n        );\n    }\n\n    el.type = Const.OBJECT_TYPE_INTERSECTION;\n    el.elType = \"intersection\";\n    el.setParents([el1.id, el2.id]);\n\n    /**\n     * Array of length 2 containing the numbers i and j.\n     * The intersection point is i-th intersection point.\n     * j is unused.\n     * @type Array\n     * @private\n     */\n    el.intersectionNumbers = [i, j];\n    el.getParents = function () {\n        return this.parents.concat(this.intersectionNumbers);\n    };\n\n    el.generatePolynomial = function () {\n        var poly1 = el1.generatePolynomial(el),\n            poly2 = el2.generatePolynomial(el);\n\n        if (poly1.length === 0 || poly2.length === 0) {\n            return [];\n        }\n\n        return [poly1[0], poly2[0]];\n    };\n\n    return el;\n};\n\n/**\n * @class This element is used to provide a constructor for the \"other\" intersection point.\n * @pseudo\n * @description An intersection point is a point which lives on two Lines or Circles or one Line and one Circle at the same time, i.e.\n * an intersection point of the two elements. Additionally, one intersection point is provided. The function returns the other intersection point.\n * @name OtherIntersection\n * @augments JXG.Point\n * @constructor\n * @type JXG.Point\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_JXG.Point} el1,el2,p The result will be a intersection point on el1 and el2. i determines the\n * intersection point different from p:\n * @example\n * // Create an intersection point of circle and line\n * var p1 = board.create('point', [2.0, 2.0]);\n * var c1 = board.create('circle', [p1, 2.0]);\n *\n * var p2 = board.create('point', [2.0, 2.0]);\n * var p3 = board.create('point', [2.0, 2.0]);\n * var l1 = board.create('line', [p2, p3]);\n *\n * var i = board.create('intersection', [c1, l1, 0]);\n * var j = board.create('otherintersection', [c1, l1, i]);\n * </pre><div class=\"jxgbox\" id=\"JXG45e25f12-a1de-4257-a466-27a2ae73614c\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var ipex2_board = JXG.JSXGraph.initBoard('JXG45e25f12-a1de-4257-a466-27a2ae73614c', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var ipex2_p1 = ipex2_board.create('point', [4.0, 4.0]);\n *   var ipex2_c1 = ipex2_board.create('circle', [ipex2_p1, 2.0]);\n *   var ipex2_p2 = ipex2_board.create('point', [1.0, 1.0]);\n *   var ipex2_p3 = ipex2_board.create('point', [5.0, 3.0]);\n *   var ipex2_l1 = ipex2_board.create('line', [ipex2_p2, ipex2_p3]);\n *   var ipex2_i = ipex2_board.create('intersection', [ipex2_c1, ipex2_l1, 0], {name:'D'});\n *   var ipex2_j = ipex2_board.create('otherintersection', [ipex2_c1, ipex2_l1, ipex2_i], {name:'E'});\n * </script><pre>\n */\nJXG.createOtherIntersectionPoint = function (board, parents, attributes) {\n    var el, el1, el2, other;\n\n    if (\n        parents.length !== 3 ||\n        !Type.isPoint(parents[2]) ||\n        (parents[0].elementClass !== Const.OBJECT_CLASS_LINE &&\n            parents[0].elementClass !== Const.OBJECT_CLASS_CIRCLE) ||\n        (parents[1].elementClass !== Const.OBJECT_CLASS_LINE &&\n            parents[1].elementClass !== Const.OBJECT_CLASS_CIRCLE)\n    ) {\n        // Failure\n        throw new Error(\n            \"JSXGraph: Can't create 'other intersection point' with parent types '\" +\n                typeof parents[0] +\n                \"',  '\" +\n                typeof parents[1] +\n                \"'and  '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [circle|line,circle|line,point]\"\n        );\n    }\n\n    el1 = board.select(parents[0]);\n    el2 = board.select(parents[1]);\n    other = board.select(parents[2]);\n\n    el = board.create(\n        \"point\",\n        [\n            function () {\n                var c = Geometry.meet(el1.stdform, el2.stdform, 0, el1.board);\n\n                if (\n                    Math.abs(other.X() - c.usrCoords[1]) > Mat.eps ||\n                    Math.abs(other.Y() - c.usrCoords[2]) > Mat.eps ||\n                    Math.abs(other.Z() - c.usrCoords[0]) > Mat.eps\n                ) {\n                    return c;\n                }\n\n                return Geometry.meet(el1.stdform, el2.stdform, 1, el1.board);\n            }\n        ],\n        attributes\n    );\n\n    el.type = Const.OBJECT_TYPE_INTERSECTION;\n    el.elType = \"otherintersection\";\n    el.setParents([el1.id, el2.id, other]);\n\n    el1.addChild(el);\n    el2.addChild(el);\n\n    el.generatePolynomial = function () {\n        var poly1 = el1.generatePolynomial(el),\n            poly2 = el2.generatePolynomial(el);\n\n        if (poly1.length === 0 || poly2.length === 0) {\n            return [];\n        }\n\n        return [poly1[0], poly2[0]];\n    };\n\n    return el;\n};\n\n/**\n * @class This element is used to provide a constructor for the pole point of a line with respect to a conic or a circle.\n * @pseudo\n * @description The pole point is the unique reciprocal relationship of a line with respect to a conic.\n * The lines tangent to the intersections of a conic and a line intersect at the pole point of that line with respect to that conic.\n * A line tangent to a conic has the pole point of that line with respect to that conic as the tangent point.\n * See {@link http://en.wikipedia.org/wiki/Pole_and_polar} for more information on pole and polar.\n * @name PolePoint\n * @augments JXG.Point\n * @constructor\n * @type JXG.Point\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Conic,JXG.Circle_JXG.Point} el1,el2 or\n * @param {JXG.Point_JXG.Conic,JXG.Circle} el1,el2 The result will be the pole point of the line with respect to the conic or the circle.\n * @example\n * // Create the pole point of a line with respect to a conic\n * var p1 = board.create('point', [-1, 2]);\n * var p2 = board.create('point', [ 1, 4]);\n * var p3 = board.create('point', [-1,-2]);\n * var p4 = board.create('point', [ 0, 0]);\n * var p5 = board.create('point', [ 4,-2]);\n * var c1 = board.create('conic',[p1,p2,p3,p4,p5]);\n * var p6 = board.create('point', [-1, 4]);\n * var p7 = board.create('point', [2, -2]);\n * var l1 = board.create('line', [p6, p7]);\n * var p8 = board.create('polepoint', [c1, l1]);\n * </pre><div class=\"jxgbox\" id=\"JXG7b7233a0-f363-47dd-9df5-8018d0d17a98\" class=\"jxgbox\" style=\"width:400px; height:400px;\"></div>\n * <script type='text/javascript'>\n * var ppex1_board = JXG.JSXGraph.initBoard('JXG7b7233a0-f363-47dd-9df5-8018d0d17a98', {boundingbox: [-3, 5, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n * var ppex1_p1 = ppex1_board.create('point', [-1, 2]);\n * var ppex1_p2 = ppex1_board.create('point', [ 1, 4]);\n * var ppex1_p3 = ppex1_board.create('point', [-1,-2]);\n * var ppex1_p4 = ppex1_board.create('point', [ 0, 0]);\n * var ppex1_p5 = ppex1_board.create('point', [ 4,-2]);\n * var ppex1_c1 = ppex1_board.create('conic',[ppex1_p1,ppex1_p2,ppex1_p3,ppex1_p4,ppex1_p5]);\n * var ppex1_p6 = ppex1_board.create('point', [-1, 4]);\n * var ppex1_p7 = ppex1_board.create('point', [2, -2]);\n * var ppex1_l1 = ppex1_board.create('line', [ppex1_p6, ppex1_p7]);\n * var ppex1_p8 = ppex1_board.create('polepoint', [ppex1_c1, ppex1_l1]);\n * </script><pre>\n * @example\n * // Create the pole point of a line with respect to a circle\n * var p1 = board.create('point', [1, 1]);\n * var p2 = board.create('point', [2, 3]);\n * var c1 = board.create('circle',[p1,p2]);\n * var p3 = board.create('point', [-1, 4]);\n * var p4 = board.create('point', [4, -1]);\n * var l1 = board.create('line', [p3, p4]);\n * var p5 = board.create('polepoint', [c1, l1]);\n * </pre><div class=\"jxgbox\" id=\"JXG7b7233a0-f363-47dd-9df5-9018d0d17a98\" class=\"jxgbox\" style=\"width:400px; height:400px;\"></div>\n * <script type='text/javascript'>\n * var ppex2_board = JXG.JSXGraph.initBoard('JXG7b7233a0-f363-47dd-9df5-9018d0d17a98', {boundingbox: [-3, 7, 7, -3], axis: true, showcopyright: false, shownavigation: false});\n * var ppex2_p1 = ppex2_board.create('point', [1, 1]);\n * var ppex2_p2 = ppex2_board.create('point', [2, 3]);\n * var ppex2_c1 = ppex2_board.create('circle',[ppex2_p1,ppex2_p2]);\n * var ppex2_p3 = ppex2_board.create('point', [-1, 4]);\n * var ppex2_p4 = ppex2_board.create('point', [4, -1]);\n * var ppex2_l1 = ppex2_board.create('line', [ppex2_p3, ppex2_p4]);\n * var ppex2_p5 = ppex2_board.create('polepoint', [ppex2_c1, ppex2_l1]);\n * </script><pre>\n */\nJXG.createPolePoint = function (board, parents, attributes) {\n    var el,\n        el1,\n        el2,\n        firstParentIsConic,\n        secondParentIsConic,\n        firstParentIsLine,\n        secondParentIsLine;\n\n    if (parents.length > 1) {\n        firstParentIsConic =\n            parents[0].type === Const.OBJECT_TYPE_CONIC ||\n            parents[0].elementClass === Const.OBJECT_CLASS_CIRCLE;\n        secondParentIsConic =\n            parents[1].type === Const.OBJECT_TYPE_CONIC ||\n            parents[1].elementClass === Const.OBJECT_CLASS_CIRCLE;\n\n        firstParentIsLine = parents[0].elementClass === Const.OBJECT_CLASS_LINE;\n        secondParentIsLine = parents[1].elementClass === Const.OBJECT_CLASS_LINE;\n    }\n\n    /*        if (parents.length !== 2 || !((\n                parents[0].type === Const.OBJECT_TYPE_CONIC ||\n                parents[0].elementClass === Const.OBJECT_CLASS_CIRCLE) &&\n                parents[1].elementClass === Const.OBJECT_CLASS_LINE ||\n                parents[0].elementClass === Const.OBJECT_CLASS_LINE && (\n                parents[1].type === Const.OBJECT_TYPE_CONIC ||\n                parents[1].elementClass === Const.OBJECT_CLASS_CIRCLE))) {*/\n    if (\n        parents.length !== 2 ||\n        !(\n            (firstParentIsConic && secondParentIsLine) ||\n            (firstParentIsLine && secondParentIsConic)\n        )\n    ) {\n        // Failure\n        throw new Error(\n            \"JSXGraph: Can't create 'pole point' with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent type: [conic|circle,line], [line,conic|circle]\"\n        );\n    }\n\n    if (secondParentIsLine) {\n        el1 = board.select(parents[0]);\n        el2 = board.select(parents[1]);\n    } else {\n        el1 = board.select(parents[1]);\n        el2 = board.select(parents[0]);\n    }\n\n    el = board.create(\n        \"point\",\n        [\n            function () {\n                var q = el1.quadraticform,\n                    s = el2.stdform.slice(0, 3);\n\n                return [\n                    JXG.Math.Numerics.det([s, q[1], q[2]]),\n                    JXG.Math.Numerics.det([q[0], s, q[2]]),\n                    JXG.Math.Numerics.det([q[0], q[1], s])\n                ];\n            }\n        ],\n        attributes\n    );\n\n    el.elType = \"polepoint\";\n    el.setParents([el1.id, el2.id]);\n\n    el1.addChild(el);\n    el2.addChild(el);\n\n    return el;\n};\n\nJXG.registerElement(\"point\", JXG.createPoint);\nJXG.registerElement(\"glider\", JXG.createGlider);\nJXG.registerElement(\"intersection\", JXG.createIntersectionPoint);\nJXG.registerElement(\"otherintersection\", JXG.createOtherIntersectionPoint);\nJXG.registerElement(\"polepoint\", JXG.createPolePoint);\n\nexport default {\n    Point: JXG.Point,\n    createPoint: JXG.createPoint,\n    createGlider: JXG.createGlider,\n    createIntersection: JXG.createIntersectionPoint,\n    createOtherIntersection: JXG.createOtherIntersectionPoint,\n    createPolePoint: JXG.createPolePoint\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The geometry object Line is defined in this file. Line stores all\n * style and functional properties that are required to draw and move a line on\n * a board.\n */\n\nimport JXG from \"../jxg\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Numerics from \"../math/numerics\";\nimport Statistics from \"../math/statistics\";\nimport Const from \"./constants\";\nimport Coords from \"./coords\";\nimport GeometryElement from \"./element\";\nimport Type from \"../utils/type\";\nimport Point from \"./point\";\n\n/**\n * The Line class is a basic class for all kind of line objects, e.g. line, arrow, and axis. It is usually defined by two points and can\n * be intersected with some other geometry elements.\n * @class Creates a new basic line object. Do not use this constructor to create a line.\n * Use {@link JXG.Board#create} with\n * type {@link Line}, {@link Arrow}, or {@link Axis} instead.\n * @constructor\n * @augments JXG.GeometryElement\n * @param {String,JXG.Board} board The board the new line is drawn on.\n * @param {Point} p1 Startpoint of the line.\n * @param {Point} p2 Endpoint of the line.\n * @param {Object} attributes Javascript object containing attributes like name, id and colors.\n */\nJXG.Line = function (board, p1, p2, attributes) {\n    this.constructor(board, attributes, Const.OBJECT_TYPE_LINE, Const.OBJECT_CLASS_LINE);\n\n    /**\n     * Startpoint of the line. You really should not set this field directly as it may break JSXGraph's\n     * update system so your construction won't be updated properly.\n     * @type JXG.Point\n     */\n    this.point1 = this.board.select(p1);\n\n    /**\n     * Endpoint of the line. Just like {@link JXG.Line.point1} you shouldn't write this field directly.\n     * @type JXG.Point\n     */\n    this.point2 = this.board.select(p2);\n\n    /**\n     * Array of ticks storing all the ticks on this line. Do not set this field directly and use\n     * {@link JXG.Line#addTicks} and {@link JXG.Line#removeTicks} to add and remove ticks to and from the line.\n     * @type Array\n     * @see JXG.Ticks\n     */\n    this.ticks = [];\n\n    /**\n     * Reference of the ticks created automatically when constructing an axis.\n     * @type JXG.Ticks\n     * @see JXG.Ticks\n     */\n    this.defaultTicks = null;\n\n    /**\n     * If the line is the border of a polygon, the polygon object is stored, otherwise null.\n     * @type JXG.Polygon\n     * @default null\n     * @private\n     */\n    this.parentPolygon = null;\n\n    /* Register line at board */\n    this.id = this.board.setId(this, \"L\");\n    this.board.renderer.drawLine(this);\n    this.board.finalizeAdding(this);\n\n    this.elType = \"line\";\n\n    /* Add line as child to defining points */\n    if (this.point1._is_new) {\n        this.addChild(this.point1);\n        delete this.point1._is_new;\n    } else {\n        this.point1.addChild(this);\n    }\n    if (this.point2._is_new) {\n        this.addChild(this.point2);\n        delete this.point2._is_new;\n    } else {\n        this.point2.addChild(this);\n    }\n\n    this.inherits.push(this.point1, this.point2);\n\n    this.updateStdform(); // This is needed in the following situation:\n    // * the line is defined by three coordinates\n    // * and it will have a glider\n    // * and board.suspendUpdate() has been called.\n\n    // create Label\n    this.createLabel();\n\n    this.methodMap = JXG.deepCopy(this.methodMap, {\n        point1: \"point1\",\n        point2: \"point2\",\n        getSlope: \"getSlope\",\n        getRise: \"getRise\",\n        getYIntersect: \"getRise\",\n        getAngle: \"getAngle\",\n        L: \"L\",\n        length: \"L\"\n    });\n};\n\nJXG.Line.prototype = new GeometryElement();\n\nJXG.extend(\n    JXG.Line.prototype,\n    /** @lends JXG.Line.prototype */ {\n        /**\n         * Checks whether (x,y) is near the line.\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} True if (x,y) is near the line, False otherwise.\n         */\n        hasPoint: function (x, y) {\n            // Compute the stdform of the line in screen coordinates.\n            var c = [],\n                s,\n                v = [1, x, y],\n                vnew,\n                p1c,\n                p2c,\n                d,\n                pos,\n                i,\n                prec,\n                type,\n                sw = Type.evaluate(this.visProp.strokewidth);\n\n            if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n                type = this.board._inputDevice;\n                prec = Type.evaluate(this.visProp.precision[type]);\n            } else {\n                // 'inherit'\n                prec = this.board.options.precision.hasPoint;\n            }\n            prec += sw * 0.5;\n\n            c[0] =\n                this.stdform[0] -\n                (this.stdform[1] * this.board.origin.scrCoords[1]) / this.board.unitX +\n                (this.stdform[2] * this.board.origin.scrCoords[2]) / this.board.unitY;\n            c[1] = this.stdform[1] / this.board.unitX;\n            c[2] = this.stdform[2] / -this.board.unitY;\n\n            s = Geometry.distPointLine(v, c);\n            if (isNaN(s) || s > prec) {\n                return false;\n            }\n\n            if (\n                Type.evaluate(this.visProp.straightfirst) &&\n                Type.evaluate(this.visProp.straightlast)\n            ) {\n                return true;\n            }\n\n            // If the line is a ray or segment we have to check if the projected point is between P1 and P2.\n            p1c = this.point1.coords;\n            p2c = this.point2.coords;\n\n            // Project the point orthogonally onto the line\n            vnew = [0, c[1], c[2]];\n            // Orthogonal line to c through v\n            vnew = Mat.crossProduct(vnew, v);\n            // Intersect orthogonal line with line\n            vnew = Mat.crossProduct(vnew, c);\n\n            // Normalize the projected point\n            vnew[1] /= vnew[0];\n            vnew[2] /= vnew[0];\n            vnew[0] = 1;\n\n            vnew = new Coords(Const.COORDS_BY_SCREEN, vnew.slice(1), this.board).usrCoords;\n            d = p1c.distance(Const.COORDS_BY_USER, p2c);\n            p1c = p1c.usrCoords.slice(0);\n            p2c = p2c.usrCoords.slice(0);\n\n            // The defining points are identical\n            if (d < Mat.eps) {\n                pos = 0;\n            } else {\n                /*\n                 * Handle the cases, where one of the defining points is an ideal point.\n                 * d is set to something close to infinity, namely 1/eps.\n                 * The ideal point is (temporarily) replaced by a finite point which has\n                 * distance d from the other point.\n                 * This is accomplished by extracting the x- and y-coordinates (x,y)=:v of the ideal point.\n                 * v determines the direction of the line. v is normalized, i.e. set to length 1 by dividing through its length.\n                 * Finally, the new point is the sum of the other point and v*d.\n                 *\n                 */\n\n                // At least one point is an ideal point\n                if (d === Number.POSITIVE_INFINITY) {\n                    d = 1 / Mat.eps;\n\n                    // The second point is an ideal point\n                    if (Math.abs(p2c[0]) < Mat.eps) {\n                        d /= Geometry.distance([0, 0, 0], p2c);\n                        p2c = [1, p1c[1] + p2c[1] * d, p1c[2] + p2c[2] * d];\n                        // The first point is an ideal point\n                    } else {\n                        d /= Geometry.distance([0, 0, 0], p1c);\n                        p1c = [1, p2c[1] + p1c[1] * d, p2c[2] + p1c[2] * d];\n                    }\n                }\n                i = 1;\n                d = p2c[i] - p1c[i];\n\n                if (Math.abs(d) < Mat.eps) {\n                    i = 2;\n                    d = p2c[i] - p1c[i];\n                }\n                pos = (vnew[i] - p1c[i]) / d;\n            }\n\n            if (!Type.evaluate(this.visProp.straightfirst) && pos < 0) {\n                return false;\n            }\n\n            return !(!Type.evaluate(this.visProp.straightlast) && pos > 1);\n        },\n\n        // documented in base/element\n        update: function () {\n            var funps;\n\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            if (this.constrained) {\n                if (Type.isFunction(this.funps)) {\n                    funps = this.funps();\n                    if (funps && funps.length && funps.length === 2) {\n                        this.point1 = funps[0];\n                        this.point2 = funps[1];\n                    }\n                } else {\n                    if (Type.isFunction(this.funp1)) {\n                        funps = this.funp1();\n                        if (Type.isPoint(funps)) {\n                            this.point1 = funps;\n                        } else if (funps && funps.length && funps.length === 2) {\n                            this.point1.setPositionDirectly(Const.COORDS_BY_USER, funps);\n                        }\n                    }\n\n                    if (Type.isFunction(this.funp2)) {\n                        funps = this.funp2();\n                        if (Type.isPoint(funps)) {\n                            this.point2 = funps;\n                        } else if (funps && funps.length && funps.length === 2) {\n                            this.point2.setPositionDirectly(Const.COORDS_BY_USER, funps);\n                        }\n                    }\n                }\n            }\n\n            this.updateSegmentFixedLength();\n            this.updateStdform();\n\n            if (Type.evaluate(this.visProp.trace)) {\n                this.cloneToBackground(true);\n            }\n\n            return this;\n        },\n\n        /**\n         * Update segments with fixed length and at least one movable point.\n         * @private\n         */\n        updateSegmentFixedLength: function () {\n            var d, dnew, d1, d2, drag1, drag2, x, y;\n\n            if (!this.hasFixedLength) {\n                return this;\n            }\n\n            // Compute the actual length of the segment\n            d = this.point1.Dist(this.point2);\n            // Determine the length the segment ought to have\n            dnew = this.fixedLength();\n            // Distances between the two points and their respective\n            // position before the update\n            d1 = this.fixedLengthOldCoords[0].distance(\n                Const.COORDS_BY_USER,\n                this.point1.coords\n            );\n            d2 = this.fixedLengthOldCoords[1].distance(\n                Const.COORDS_BY_USER,\n                this.point2.coords\n            );\n\n            // If the position of the points or the fixed length function has been changed we have to work.\n            if (d1 > Mat.eps || d2 > Mat.eps || d !== dnew) {\n                drag1 =\n                    this.point1.isDraggable &&\n                    this.point1.type !== Const.OBJECT_TYPE_GLIDER &&\n                    !Type.evaluate(this.point1.visProp.fixed);\n                drag2 =\n                    this.point2.isDraggable &&\n                    this.point2.type !== Const.OBJECT_TYPE_GLIDER &&\n                    !Type.evaluate(this.point2.visProp.fixed);\n\n                // First case: the two points are different\n                // Then we try to adapt the point that was not dragged\n                // If this point can not be moved (e.g. because it is a glider)\n                // we try move the other point\n                if (d > Mat.eps) {\n                    if ((d1 > d2 && drag2) || (d1 <= d2 && drag2 && !drag1)) {\n                        this.point2.setPositionDirectly(Const.COORDS_BY_USER, [\n                            this.point1.X() + ((this.point2.X() - this.point1.X()) * dnew) / d,\n                            this.point1.Y() + ((this.point2.Y() - this.point1.Y()) * dnew) / d\n                        ]);\n                        this.point2.fullUpdate();\n                    } else if ((d1 <= d2 && drag1) || (d1 > d2 && drag1 && !drag2)) {\n                        this.point1.setPositionDirectly(Const.COORDS_BY_USER, [\n                            this.point2.X() + ((this.point1.X() - this.point2.X()) * dnew) / d,\n                            this.point2.Y() + ((this.point1.Y() - this.point2.Y()) * dnew) / d\n                        ]);\n                        this.point1.fullUpdate();\n                    }\n                    // Second case: the two points are identical. In this situation\n                    // we choose a random direction.\n                } else {\n                    x = Math.random() - 0.5;\n                    y = Math.random() - 0.5;\n                    d = Math.sqrt(x * x + y * y);\n\n                    if (drag2) {\n                        this.point2.setPositionDirectly(Const.COORDS_BY_USER, [\n                            this.point1.X() + (x * dnew) / d,\n                            this.point1.Y() + (y * dnew) / d\n                        ]);\n                        this.point2.fullUpdate();\n                    } else if (drag1) {\n                        this.point1.setPositionDirectly(Const.COORDS_BY_USER, [\n                            this.point2.X() + (x * dnew) / d,\n                            this.point2.Y() + (y * dnew) / d\n                        ]);\n                        this.point1.fullUpdate();\n                    }\n                }\n                // Finally, we save the position of the two points.\n                this.fixedLengthOldCoords[0].setCoordinates(\n                    Const.COORDS_BY_USER,\n                    this.point1.coords.usrCoords\n                );\n                this.fixedLengthOldCoords[1].setCoordinates(\n                    Const.COORDS_BY_USER,\n                    this.point2.coords.usrCoords\n                );\n            }\n            return this;\n        },\n\n        /**\n         * Updates the stdform derived from the parent point positions.\n         * @private\n         */\n        updateStdform: function () {\n            var v = Mat.crossProduct(\n                this.point1.coords.usrCoords,\n                this.point2.coords.usrCoords\n            );\n\n            this.stdform[0] = v[0];\n            this.stdform[1] = v[1];\n            this.stdform[2] = v[2];\n            this.stdform[3] = 0;\n\n            this.normalize();\n        },\n\n        /**\n         * Uses the boards renderer to update the line.\n         * @private\n         */\n        updateRenderer: function () {\n            //var wasReal;\n\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            if (this.visPropCalc.visible) {\n                // wasReal = this.isReal;\n                this.isReal =\n                    !isNaN(\n                        this.point1.coords.usrCoords[1] +\n                            this.point1.coords.usrCoords[2] +\n                            this.point2.coords.usrCoords[1] +\n                            this.point2.coords.usrCoords[2]\n                    ) && Mat.innerProduct(this.stdform, this.stdform, 3) >= Mat.eps * Mat.eps;\n\n                if (\n                    //wasReal &&\n                    !this.isReal\n                ) {\n                    this.updateVisibility(false);\n                }\n            }\n\n            if (this.visPropCalc.visible) {\n                this.board.renderer.updateLine(this);\n            }\n\n            /* Update the label if visible. */\n            if (\n                this.hasLabel &&\n                this.visPropCalc.visible &&\n                this.label &&\n                this.label.visPropCalc.visible &&\n                this.isReal\n            ) {\n                this.label.update();\n                this.board.renderer.updateText(this.label);\n            }\n\n            // Update rendNode display\n            this.setDisplayRendNode();\n            // if (this.visPropCalc.visible !== this.visPropOld.visible) {\n            //     this.setDisplayRendNode(this.visPropCalc.visible);\n            //     if (this.hasLabel) {\n            //         this.board.renderer.display(this.label, this.label.visPropCalc.visible);\n            //     }\n            // }\n\n            this.needsUpdate = false;\n            return this;\n        },\n\n        /**\n         * Used to generate a polynomial for a point p that lies on this line, i.e. p is collinear to\n         * {@link JXG.Line#point1} and {@link JXG.Line#point2}.\n         *\n         * @param {JXG.Point} p The point for that the polynomial is generated.\n         * @returns {Array} An array containing the generated polynomial.\n         * @private\n         */\n        generatePolynomial: function (p) {\n            var u1 = this.point1.symbolic.x,\n                u2 = this.point1.symbolic.y,\n                v1 = this.point2.symbolic.x,\n                v2 = this.point2.symbolic.y,\n                w1 = p.symbolic.x,\n                w2 = p.symbolic.y;\n\n            /*\n             * The polynomial in this case is determined by three points being collinear:\n             *\n             *      U (u1,u2)      W (w1,w2)                V (v1,v2)\n             *  ----x--------------x------------------------x----------------\n             *\n             *  The collinearity condition is\n             *\n             *      u2-w2       w2-v2\n             *     -------  =  -------           (1)\n             *      u1-w1       w1-v1\n             *\n             * Multiplying (1) with denominators and simplifying is\n             *\n             *    u2w1 - u2v1 + w2v1 - u1w2 + u1v2 - w1v2 = 0\n             */\n\n            return [\n                [\n                    \"(\",\n                    u2,\n                    \")*(\",\n                    w1,\n                    \")-(\",\n                    u2,\n                    \")*(\",\n                    v1,\n                    \")+(\",\n                    w2,\n                    \")*(\",\n                    v1,\n                    \")-(\",\n                    u1,\n                    \")*(\",\n                    w2,\n                    \")+(\",\n                    u1,\n                    \")*(\",\n                    v2,\n                    \")-(\",\n                    w1,\n                    \")*(\",\n                    v2,\n                    \")\"\n                ].join(\"\")\n            ];\n        },\n\n        /**\n         * Calculates the y intersect of the line.\n         * @returns {Number} The y intersect.\n         */\n        getRise: function () {\n            if (Math.abs(this.stdform[2]) >= Mat.eps) {\n                return -this.stdform[0] / this.stdform[2];\n            }\n\n            return Infinity;\n        },\n\n        /**\n         * Calculates the slope of the line.\n         * @returns {Number} The slope of the line or Infinity if the line is parallel to the y-axis.\n         */\n        getSlope: function () {\n            if (Math.abs(this.stdform[2]) >= Mat.eps) {\n                return -this.stdform[1] / this.stdform[2];\n            }\n\n            return Infinity;\n        },\n\n        /**\n         * Determines the angle between the positive x axis and the line.\n         * @returns {Number}\n         */\n        getAngle: function () {\n            return Math.atan2(-this.stdform[1], this.stdform[2]);\n        },\n\n        /**\n         * Determines whether the line is drawn beyond {@link JXG.Line#point1} and\n         * {@link JXG.Line#point2} and updates the line.\n         * @param {Boolean} straightFirst True if the Line shall be drawn beyond\n         * {@link JXG.Line#point1}, false otherwise.\n         * @param {Boolean} straightLast True if the Line shall be drawn beyond\n         * {@link JXG.Line#point2}, false otherwise.\n         * @see #straightFirst\n         * @see #straightLast\n         * @private\n         */\n        setStraight: function (straightFirst, straightLast) {\n            this.visProp.straightfirst = straightFirst;\n            this.visProp.straightlast = straightLast;\n\n            this.board.renderer.updateLine(this);\n            return this;\n        },\n\n        // documented in geometry element\n        getTextAnchor: function () {\n            return new Coords(\n                Const.COORDS_BY_USER,\n                [\n                    0.5 * (this.point2.X() + this.point1.X()),\n                    0.5 * (this.point2.Y() + this.point1.Y())\n                ],\n                this.board\n            );\n        },\n\n        /**\n         * Adjusts Label coords relative to Anchor. DESCRIPTION\n         * @private\n         */\n        setLabelRelativeCoords: function (relCoords) {\n            if (Type.exists(this.label)) {\n                this.label.relativeCoords = new Coords(\n                    Const.COORDS_BY_SCREEN,\n                    [relCoords[0], -relCoords[1]],\n                    this.board\n                );\n            }\n        },\n\n        // documented in geometry element\n        getLabelAnchor: function () {\n            var x,\n                y,\n                fs = 0,\n                c1 = new Coords(Const.COORDS_BY_USER, this.point1.coords.usrCoords, this.board),\n                c2 = new Coords(Const.COORDS_BY_USER, this.point2.coords.usrCoords, this.board),\n                ev_sf = Type.evaluate(this.visProp.straightfirst),\n                ev_sl = Type.evaluate(this.visProp.straightlast);\n\n            if (ev_sf || ev_sl) {\n                Geometry.calcStraight(this, c1, c2, 0);\n            }\n\n            c1 = c1.scrCoords;\n            c2 = c2.scrCoords;\n\n            if (!Type.exists(this.label)) {\n                return new Coords(Const.COORDS_BY_SCREEN, [NaN, NaN], this.board);\n            }\n\n            switch (Type.evaluate(this.label.visProp.position)) {\n                case \"lft\":\n                case \"llft\":\n                case \"ulft\":\n                    if (c1[1] <= c2[1]) {\n                        x = c1[1];\n                        y = c1[2];\n                    } else {\n                        x = c2[1];\n                        y = c2[2];\n                    }\n                    break;\n                case \"rt\":\n                case \"lrt\":\n                case \"urt\":\n                    if (c1[1] > c2[1]) {\n                        x = c1[1];\n                        y = c1[2];\n                    } else {\n                        x = c2[1];\n                        y = c2[2];\n                    }\n                    break;\n                default:\n                    x = 0.5 * (c1[1] + c2[1]);\n                    y = 0.5 * (c1[2] + c2[2]);\n            }\n\n            // Correct coordinates if the label seems to be outside of canvas.\n            if (ev_sf || ev_sl) {\n                if (Type.exists(this.label)) {\n                    // Does not exist during createLabel\n                    fs = Type.evaluate(this.label.visProp.fontsize);\n                }\n\n                if (Math.abs(x) < Mat.eps) {\n                    x = fs;\n                } else if (\n                    this.board.canvasWidth + Mat.eps > x &&\n                    x > this.board.canvasWidth - fs - Mat.eps\n                ) {\n                    x = this.board.canvasWidth - fs;\n                }\n\n                if (Mat.eps + fs > y && y > -Mat.eps) {\n                    y = fs;\n                } else if (\n                    this.board.canvasHeight + Mat.eps > y &&\n                    y > this.board.canvasHeight - fs - Mat.eps\n                ) {\n                    y = this.board.canvasHeight - fs;\n                }\n            }\n\n            return new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board);\n        },\n\n        // documented in geometry element\n        cloneToBackground: function () {\n            var copy = {},\n                r,\n                s,\n                er;\n\n            copy.id = this.id + \"T\" + this.numTraces;\n            copy.elementClass = Const.OBJECT_CLASS_LINE;\n            this.numTraces++;\n            copy.point1 = this.point1;\n            copy.point2 = this.point2;\n\n            copy.stdform = this.stdform;\n\n            copy.board = this.board;\n\n            copy.visProp = Type.deepCopy(this.visProp, this.visProp.traceattributes, true);\n            copy.visProp.layer = this.board.options.layer.trace;\n            Type.clearVisPropOld(copy);\n            copy.visPropCalc = {\n                visible: Type.evaluate(copy.visProp.visible)\n            };\n\n            s = this.getSlope();\n            r = this.getRise();\n            copy.getSlope = function () {\n                return s;\n            };\n            copy.getRise = function () {\n                return r;\n            };\n\n            er = this.board.renderer.enhancedRendering;\n            this.board.renderer.enhancedRendering = true;\n            this.board.renderer.drawLine(copy);\n            this.board.renderer.enhancedRendering = er;\n            this.traces[copy.id] = copy.rendNode;\n\n            return this;\n        },\n\n        /**\n         * Add transformations to this line.\n         * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation} or an array of\n         * {@link JXG.Transformation}s.\n         * @returns {JXG.Line} Reference to this line object.\n         */\n        addTransform: function (transform) {\n            var i,\n                list = Type.isArray(transform) ? transform : [transform],\n                len = list.length;\n\n            for (i = 0; i < len; i++) {\n                this.point1.transformations.push(list[i]);\n                this.point2.transformations.push(list[i]);\n            }\n\n            return this;\n        },\n\n        // see GeometryElement.js\n        snapToGrid: function (pos) {\n            var c1, c2, dc, t, ticks, x, y, sX, sY;\n\n            if (Type.evaluate(this.visProp.snaptogrid)) {\n                if (this.parents.length < 3) {\n                    // Line through two points\n                    this.point1.handleSnapToGrid(true, true);\n                    this.point2.handleSnapToGrid(true, true);\n                } else if (Type.exists(pos)) {\n                    // Free line\n                    sX = Type.evaluate(this.visProp.snapsizex);\n                    sY = Type.evaluate(this.visProp.snapsizey);\n\n                    c1 = new Coords(Const.COORDS_BY_SCREEN, [pos.Xprev, pos.Yprev], this.board);\n\n                    x = c1.usrCoords[1];\n                    y = c1.usrCoords[2];\n\n                    if (\n                        sX <= 0 &&\n                        this.board.defaultAxes &&\n                        this.board.defaultAxes.x.defaultTicks\n                    ) {\n                        ticks = this.board.defaultAxes.x.defaultTicks;\n                        sX = ticks.ticksDelta * (Type.evaluate(ticks.visProp.minorticks) + 1);\n                    }\n                    if (\n                        sY <= 0 &&\n                        this.board.defaultAxes &&\n                        this.board.defaultAxes.y.defaultTicks\n                    ) {\n                        ticks = this.board.defaultAxes.y.defaultTicks;\n                        sY = ticks.ticksDelta * (Type.evaluate(ticks.visProp.minorticks) + 1);\n                    }\n\n                    // if no valid snap sizes are available, don't change the coords.\n                    if (sX > 0 && sY > 0) {\n                        // projectCoordsToLine\n                        /*\n                        v = [0, this.stdform[1], this.stdform[2]];\n                        v = Mat.crossProduct(v, c1.usrCoords);\n                        c2 = Geometry.meetLineLine(v, this.stdform, 0, this.board);\n                        */\n                        c2 = Geometry.projectPointToLine({ coords: c1 }, this, this.board);\n\n                        dc = Statistics.subtract(\n                            [1, Math.round(x / sX) * sX, Math.round(y / sY) * sY],\n                            c2.usrCoords\n                        );\n                        t = this.board.create(\"transform\", dc.slice(1), {\n                            type: \"translate\"\n                        });\n                        t.applyOnce([this.point1, this.point2]);\n                    }\n                }\n            } else {\n                this.point1.handleSnapToGrid(false, true);\n                this.point2.handleSnapToGrid(false, true);\n            }\n\n            return this;\n        },\n\n        // see element.js\n        snapToPoints: function () {\n            var forceIt = Type.evaluate(this.visProp.snaptopoints);\n\n            if (this.parents.length < 3) {\n                // Line through two points\n                this.point1.handleSnapToPoints(forceIt);\n                this.point2.handleSnapToPoints(forceIt);\n            }\n\n            return this;\n        },\n\n        /**\n         * Treat the line as parametric curve in homogeneous coordinates, where the parameter t runs from 0 to 1.\n         * First we transform the interval [0,1] to [-1,1].\n         * If the line has homogeneous coordinates [c, a, b] = stdform[] then the direction of the line is [b, -a].\n         * Now, we take one finite point that defines the line, i.e. we take either point1 or point2\n         * (in case the line is not the ideal line).\n         * Let the coordinates of that point be [z, x, y].\n         * Then, the curve runs linearly from\n         * [0, b, -a] (t=-1) to [z, x, y] (t=0)\n         * and\n         * [z, x, y] (t=0) to [0, -b, a] (t=1)\n         *\n         * @param {Number} t Parameter running from 0 to 1.\n         * @returns {Number} X(t) x-coordinate of the line treated as parametric curve.\n         * */\n        X: function (t) {\n            var x,\n                b = this.stdform[2];\n\n            x =\n                Math.abs(this.point1.coords.usrCoords[0]) > Mat.eps\n                    ? this.point1.coords.usrCoords[1]\n                    : this.point2.coords.usrCoords[1];\n\n            t = (t - 0.5) * 2;\n\n            return (1 - Math.abs(t)) * x - t * b;\n        },\n\n        /**\n         * Treat the line as parametric curve in homogeneous coordinates.\n         * See {@link JXG.Line#X} for a detailed description.\n         * @param {Number} t Parameter running from 0 to 1.\n         * @returns {Number} Y(t) y-coordinate of the line treated as parametric curve.\n         */\n        Y: function (t) {\n            var y,\n                a = this.stdform[1];\n\n            y =\n                Math.abs(this.point1.coords.usrCoords[0]) > Mat.eps\n                    ? this.point1.coords.usrCoords[2]\n                    : this.point2.coords.usrCoords[2];\n\n            t = (t - 0.5) * 2;\n\n            return (1 - Math.abs(t)) * y + t * a;\n        },\n\n        /**\n         * Treat the line as parametric curve in homogeneous coordinates.\n         * See {@link JXG.Line#X} for a detailed description.\n         *\n         * @param {Number} t Parameter running from 0 to 1.\n         * @returns {Number} Z(t) z-coordinate of the line treated as parametric curve.\n         */\n        Z: function (t) {\n            var z =\n                Math.abs(this.point1.coords.usrCoords[0]) > Mat.eps\n                    ? this.point1.coords.usrCoords[0]\n                    : this.point2.coords.usrCoords[0];\n\n            t = (t - 0.5) * 2;\n\n            return (1 - Math.abs(t)) * z;\n        },\n\n        /**\n         * The distance between the two points defining the line.\n         * @returns {Number}\n         */\n        L: function () {\n            return this.point1.Dist(this.point2);\n        },\n\n        /**\n         * Treat the element  as a parametric curve\n         * @private\n         */\n        minX: function () {\n            return 0.0;\n        },\n\n        /**\n         * Treat the element as parametric curve\n         * @private\n         */\n        maxX: function () {\n            return 1.0;\n        },\n\n        // documented in geometry element\n        bounds: function () {\n            var p1c = this.point1.coords.usrCoords,\n                p2c = this.point2.coords.usrCoords;\n\n            return [\n                Math.min(p1c[1], p2c[1]),\n                Math.max(p1c[2], p2c[2]),\n                Math.max(p1c[1], p2c[1]),\n                Math.min(p1c[2], p2c[2])\n            ];\n        },\n\n        // documented in GeometryElement.js\n        remove: function () {\n            this.removeAllTicks();\n            GeometryElement.prototype.remove.call(this);\n        }\n\n        // hideElement: function () {\n        //     var i;\n        //\n        //     GeometryElement.prototype.hideElement.call(this);\n        //\n        //     for (i = 0; i < this.ticks.length; i++) {\n        //         this.ticks[i].hideElement();\n        //     }\n        // },\n        //\n        // showElement: function () {\n        //     var i;\n        //     GeometryElement.prototype.showElement.call(this);\n        //\n        //     for (i = 0; i < this.ticks.length; i++) {\n        //         this.ticks[i].showElement();\n        //     }\n        // }\n    }\n);\n\n/**\n * @class This element is used to provide a constructor for a general line. A general line is given by two points. By setting additional properties\n * a line can be used as an arrow and/or axis.\n * @pseudo\n * @description\n * @name Line\n * @augments JXG.Line\n * @constructor\n * @type JXG.Line\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point,array,function_JXG.Point,array,function} point1,point2 Parent elements can be two elements either of type {@link JXG.Point} or array of\n * numbers describing the coordinates of a point. In the latter case the point will be constructed automatically as a fixed invisible point.\n * It is possible to provide a function returning an array or a point, instead of providing an array or a point.\n * @param {Number,function_Number,function_Number,function} a,b,c A line can also be created providing three numbers. The line is then described by\n * the set of solutions of the equation <tt>a*z+b*x+c*y = 0</tt>. For all finite points, z is normalized to the value 1.\n * It is possible to provide three functions returning numbers, too.\n * @param {function} f This function must return an array containing three numbers forming the line's homogeneous coordinates.\n * <p>\n * Additionally, a line can be created by providing a line and a transformation (or an array of transformations).\n * Then, the result is a line which is the transformation of the supplied line.\n * @example\n * // Create a line using point and coordinates/\n * // The second point will be fixed and invisible.\n * var p1 = board.create('point', [4.5, 2.0]);\n * var l1 = board.create('line', [p1, [1.0, 1.0]]);\n * </pre><div class=\"jxgbox\" id=\"JXGc0ae3461-10c4-4d39-b9be-81d74759d122\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var glex1_board = JXG.JSXGraph.initBoard('JXGc0ae3461-10c4-4d39-b9be-81d74759d122', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var glex1_p1 = glex1_board.create('point', [4.5, 2.0]);\n *   var glex1_l1 = glex1_board.create('line', [glex1_p1, [1.0, 1.0]]);\n * </script><pre>\n * @example\n * // Create a line using three coordinates\n * var l1 = board.create('line', [1.0, -2.0, 3.0]);\n * </pre><div class=\"jxgbox\" id=\"JXGcf45e462-f964-4ba4-be3a-c9db94e2593f\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var glex2_board = JXG.JSXGraph.initBoard('JXGcf45e462-f964-4ba4-be3a-c9db94e2593f', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var glex2_l1 = glex2_board.create('line', [1.0, -2.0, 3.0]);\n * </script><pre>\n * @example\n *         // Create a line (l2) as reflection of another line (l1)\n *         // reflection line\n *         var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *         var reflect = board.create('transform', [li], {type: 'reflect'});\n *\n *         var l1 = board.create('line', [1,-5,1]);\n *         var l2 = board.create('line', [l1, reflect]);\n *\n * </pre><div id=\"JXGJXGa00d7dd6-d38c-11e7-93b3-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGJXGa00d7dd6-d38c-11e7-93b3-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             // reflection line\n *             var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *             var reflect = board.create('transform', [li], {type: 'reflect'});\n *\n *             var l1 = board.create('line', [1,-5,1]);\n *             var l2 = board.create('line', [l1, reflect]);\n *     })();\n *\n * </script><pre>\n *\n * @example\n * var t = board.create('transform', [2, 1.5], {type: 'scale'});\n * var l1 = board.create('line', [1, -5, 1]);\n * var l2 = board.create('line', [l1, t]);\n *\n * </pre><div id=\"d16d5b58-6338-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('d16d5b58-6338-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var t = board.create('transform', [2, 1.5], {type: 'scale'});\n *     var l1 = board.create('line', [1, -5, 1]);\n *     var l2 = board.create('line', [l1, t]);\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * //create line between two points\n * var p1 = board.create('point', [0,0]);\n * var p2 = board.create('point', [2,2]);\n * var l1 = board.create('line', [p1,p2], {straightFirst:false, straightLast:false});\n * </pre><div id=\"d21d5b58-6338-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('d21d5b58-6338-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             var ex5p1 = board.create('point', [0,0]);\n *             var ex5p2 = board.create('point', [2,2]);\n *             var ex5l1 = board.create('line', [ex5p1,ex5p2], {straightFirst:false, straightLast:false});\n *     })();\n *\n * </script><pre>\n */\nJXG.createLine = function (board, parents, attributes) {\n    var ps,\n        el,\n        p1,\n        p2,\n        i,\n        attr,\n        c = [],\n        doTransform = false,\n        constrained = false,\n        isDraggable;\n\n    /**\n     * The line is defined by two points or coordinates of two points.\n     * In the latter case, the points are created.\n     */\n    if (parents.length === 2) {\n        // point 1 given by coordinates\n        if (Type.isArray(parents[0]) && parents[0].length > 1) {\n            attr = Type.copyAttributes(attributes, board.options, \"line\", \"point1\");\n            p1 = board.create(\"point\", parents[0], attr);\n        } else if (Type.isString(parents[0]) || Type.isPoint(parents[0])) {\n            p1 = board.select(parents[0]);\n        } else if (Type.isFunction(parents[0]) && Type.isPoint(parents[0]())) {\n            p1 = parents[0]();\n            constrained = true;\n        } else if (\n            Type.isFunction(parents[0]) &&\n            parents[0]().length &&\n            parents[0]().length >= 2\n        ) {\n            attr = Type.copyAttributes(attributes, board.options, \"line\", \"point1\");\n            p1 = Point.createPoint(board, parents[0](), attr);\n            constrained = true;\n        } else if (Type.isObject(parents[0]) && Type.isTransformationOrArray(parents[1])) {\n            doTransform = true;\n            attr = Type.copyAttributes(attributes, board.options, \"line\", \"point1\");\n            p1 = board.create(\"point\", [parents[0].point1, parents[1]], attr);\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create line with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]\"\n            );\n        }\n\n        // point 2 given by coordinates\n        if (doTransform) {\n            attr = Type.copyAttributes(attributes, board.options, \"line\", \"point2\");\n            p2 = board.create(\"point\", [parents[0].point2, parents[1]], attr);\n        } else if (Type.isArray(parents[1]) && parents[1].length > 1) {\n            attr = Type.copyAttributes(attributes, board.options, \"line\", \"point2\");\n            p2 = board.create(\"point\", parents[1], attr);\n        } else if (Type.isString(parents[1]) || Type.isPoint(parents[1])) {\n            p2 = board.select(parents[1]);\n        } else if (Type.isFunction(parents[1]) && Type.isPoint(parents[1]())) {\n            p2 = parents[1]();\n            constrained = true;\n        } else if (\n            Type.isFunction(parents[1]) &&\n            parents[1]().length &&\n            parents[1]().length >= 2\n        ) {\n            attr = Type.copyAttributes(attributes, board.options, \"line\", \"point2\");\n            p2 = Point.createPoint(board, parents[1](), attr);\n            constrained = true;\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create line with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]\"\n            );\n        }\n\n        attr = Type.copyAttributes(attributes, board.options, \"line\");\n\n        el = new JXG.Line(board, p1, p2, attr);\n\n        if (constrained) {\n            el.constrained = true;\n            el.funp1 = parents[0];\n            el.funp2 = parents[1];\n        } else if (!doTransform) {\n            el.isDraggable = true;\n        }\n\n        //if (!el.constrained) {\n        el.setParents([p1.id, p2.id]);\n        //}\n\n        // Line is defined by three homogeneous coordinates.\n        // Also in this case points are created.\n    } else if (parents.length === 3) {\n        // free line\n        isDraggable = true;\n        for (i = 0; i < 3; i++) {\n            if (Type.isNumber(parents[i])) {\n                // createFunction will just wrap a function around our constant number\n                // that does nothing else but to return that number.\n                c[i] = Type.createFunction(parents[i]);\n            } else if (Type.isFunction(parents[i])) {\n                c[i] = parents[i];\n                isDraggable = false;\n            } else {\n                throw new Error(\n                    \"JSXGraph: Can't create line with parent types '\" +\n                        typeof parents[0] +\n                        \"' and '\" +\n                        typeof parents[1] +\n                        \"' and '\" +\n                        typeof parents[2] +\n                        \"'.\" +\n                        \"\\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]\"\n                );\n            }\n        }\n\n        // point 1 is the midpoint between (0,c,-b) and point 2. => point1 is finite.\n        attr = Type.copyAttributes(attributes, board.options, \"line\", \"point1\");\n        if (isDraggable) {\n            p1 = board.create(\n                \"point\",\n                [\n                    c[2]() * c[2]() + c[1]() * c[1](),\n                    c[2]() - c[1]() * c[0]() + c[2](),\n                    -c[1]() - c[2]() * c[0]() - c[1]()\n                ],\n                attr\n            );\n        } else {\n            p1 = board.create(\n                \"point\",\n                [\n                    function () {\n                        return (c[2]() * c[2]() + c[1]() * c[1]()) * 0.5;\n                    },\n                    function () {\n                        return (c[2]() - c[1]() * c[0]() + c[2]()) * 0.5;\n                    },\n                    function () {\n                        return (-c[1]() - c[2]() * c[0]() - c[1]()) * 0.5;\n                    }\n                ],\n                attr\n            );\n        }\n\n        // point 2: (b^2+c^2,-ba+c,-ca-b)\n        attr = Type.copyAttributes(attributes, board.options, \"line\", \"point2\");\n        if (isDraggable) {\n            p2 = board.create(\n                \"point\",\n                [\n                    c[2]() * c[2]() + c[1]() * c[1](),\n                    -c[1]() * c[0]() + c[2](),\n                    -c[2]() * c[0]() - c[1]()\n                ],\n                attr\n            );\n        } else {\n            p2 = board.create(\n                \"point\",\n                [\n                    function () {\n                        return c[2]() * c[2]() + c[1]() * c[1]();\n                    },\n                    function () {\n                        return -c[1]() * c[0]() + c[2]();\n                    },\n                    function () {\n                        return -c[2]() * c[0]() - c[1]();\n                    }\n                ],\n                attr\n            );\n        }\n\n        // If the line will have a glider and board.suspendUpdate() has been called, we\n        // need to compute the initial position of the two points p1 and p2.\n        p1.prepareUpdate().update();\n        p2.prepareUpdate().update();\n        attr = Type.copyAttributes(attributes, board.options, \"line\");\n        el = new JXG.Line(board, p1, p2, attr);\n        // Not yet working, because the points are not draggable.\n        el.isDraggable = isDraggable;\n        el.setParents([p1, p2]);\n\n        // The parent array contains a function which returns two points.\n    } else if (\n        parents.length === 1 &&\n        Type.isFunction(parents[0]) &&\n        parents[0]().length === 2 &&\n        Type.isPoint(parents[0]()[0]) &&\n        Type.isPoint(parents[0]()[1])\n    ) {\n        ps = parents[0]();\n        attr = Type.copyAttributes(attributes, board.options, \"line\");\n        el = new JXG.Line(board, ps[0], ps[1], attr);\n        el.constrained = true;\n        el.funps = parents[0];\n        el.setParents(ps);\n    } else if (\n        parents.length === 1 &&\n        Type.isFunction(parents[0]) &&\n        parents[0]().length === 3 &&\n        Type.isNumber(parents[0]()[0]) &&\n        Type.isNumber(parents[0]()[1]) &&\n        Type.isNumber(parents[0]()[2])\n    ) {\n        ps = parents[0];\n\n        attr = Type.copyAttributes(attributes, board.options, \"line\", \"point1\");\n        p1 = board.create(\n            \"point\",\n            [\n                function () {\n                    var c = ps();\n\n                    return [\n                        (c[2] * c[2] + c[1] * c[1]) * 0.5,\n                        (c[2] - c[1] * c[0] + c[2]) * 0.5,\n                        (-c[1] - c[2] * c[0] - c[1]) * 0.5\n                    ];\n                }\n            ],\n            attr\n        );\n\n        attr = Type.copyAttributes(attributes, board.options, \"line\", \"point2\");\n        p2 = board.create(\n            \"point\",\n            [\n                function () {\n                    var c = ps();\n\n                    return [\n                        c[2] * c[2] + c[1] * c[1],\n                        -c[1] * c[0] + c[2],\n                        -c[2] * c[0] - c[1]\n                    ];\n                }\n            ],\n            attr\n        );\n\n        attr = Type.copyAttributes(attributes, board.options, \"line\");\n        el = new JXG.Line(board, p1, p2, attr);\n\n        el.constrained = true;\n        el.funps = parents[0];\n        el.setParents([p1, p2]);\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create line with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point], [[x1,y1],[x2,y2]], [a,b,c]\"\n        );\n    }\n\n    return el;\n};\n\nJXG.registerElement(\"line\", JXG.createLine);\n\n/**\n * @class This element is used to provide a constructor for a segment.\n * It's strictly spoken just a wrapper for element {@link Line} with {@link Line#straightFirst}\n * and {@link Line#straightLast} properties set to false. If there is a third variable then the\n * segment has a fixed length (which may be a function, too).\n * @pseudo\n * @description\n * @name Segment\n * @augments JXG.Line\n * @constructor\n * @type JXG.Line\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point,array_JXG.Point,array} point1,point2 Parent elements can be two elements either of type {@link JXG.Point}\n * or array of numbers describing the\n * coordinates of a point. In the latter case the point will be constructed automatically as a fixed invisible point.\n * @param {number,function} length (optional) The points are adapted - if possible - such that their distance\n * has this value.\n * @see Line\n * @example\n * // Create a segment providing two points.\n *   var p1 = board.create('point', [4.5, 2.0]);\n *   var p2 = board.create('point', [1.0, 1.0]);\n *   var l1 = board.create('segment', [p1, p2]);\n * </pre><div class=\"jxgbox\" id=\"JXGd70e6aac-7c93-4525-a94c-a1820fa38e2f\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var slex1_board = JXG.JSXGraph.initBoard('JXGd70e6aac-7c93-4525-a94c-a1820fa38e2f', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var slex1_p1 = slex1_board.create('point', [4.5, 2.0]);\n *   var slex1_p2 = slex1_board.create('point', [1.0, 1.0]);\n *   var slex1_l1 = slex1_board.create('segment', [slex1_p1, slex1_p2]);\n * </script><pre>\n *\n * @example\n * // Create a segment providing two points.\n *   var p1 = board.create('point', [4.0, 1.0]);\n *   var p2 = board.create('point', [1.0, 1.0]);\n *   var l1 = board.create('segment', [p1, p2]);\n *   var p3 = board.create('point', [4.0, 2.0]);\n *   var p4 = board.create('point', [1.0, 2.0]);\n *   var l2 = board.create('segment', [p3, p4, 3]);\n *   var p5 = board.create('point', [4.0, 3.0]);\n *   var p6 = board.create('point', [1.0, 4.0]);\n *   var l3 = board.create('segment', [p5, p6, function(){ return l1.L();} ]);\n * </pre><div class=\"jxgbox\" id=\"JXG617336ba-0705-4b2b-a236-c87c28ef25be\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var slex2_board = JXG.JSXGraph.initBoard('JXG617336ba-0705-4b2b-a236-c87c28ef25be', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var slex2_p1 = slex2_board.create('point', [4.0, 1.0]);\n *   var slex2_p2 = slex2_board.create('point', [1.0, 1.0]);\n *   var slex2_l1 = slex2_board.create('segment', [slex2_p1, slex2_p2]);\n *   var slex2_p3 = slex2_board.create('point', [4.0, 2.0]);\n *   var slex2_p4 = slex2_board.create('point', [1.0, 2.0]);\n *   var slex2_l2 = slex2_board.create('segment', [slex2_p3, slex2_p4, 3]);\n *   var slex2_p5 = slex2_board.create('point', [4.0, 2.0]);\n *   var slex2_p6 = slex2_board.create('point', [1.0, 2.0]);\n *   var slex2_l3 = slex2_board.create('segment', [slex2_p5, slex2_p6, function(){ return slex2_l1.L();}]);\n * </script><pre>\n *\n */\nJXG.createSegment = function (board, parents, attributes) {\n    var el, attr;\n\n    attributes.straightFirst = false;\n    attributes.straightLast = false;\n    attr = Type.copyAttributes(attributes, board.options, \"segment\");\n\n    el = board.create(\"line\", parents.slice(0, 2), attr);\n\n    if (parents.length === 3) {\n        el.hasFixedLength = true;\n\n        if (Type.isNumber(parents[2])) {\n            el.fixedLength = function () {\n                return parents[2];\n            };\n        } else if (Type.isFunction(parents[2])) {\n            el.fixedLength = parents[2];\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create segment with third parent type '\" +\n                    typeof parents[2] +\n                    \"'.\" +\n                    \"\\nPossible third parent types: number or function\"\n            );\n        }\n\n        el.getParents = function () {\n            return this.parents.concat(this.fixedLength());\n        };\n\n        el.fixedLengthOldCoords = [];\n        el.fixedLengthOldCoords[0] = new Coords(\n            Const.COORDS_BY_USER,\n            el.point1.coords.usrCoords.slice(1, 3),\n            board\n        );\n        el.fixedLengthOldCoords[1] = new Coords(\n            Const.COORDS_BY_USER,\n            el.point2.coords.usrCoords.slice(1, 3),\n            board\n        );\n    }\n\n    el.elType = \"segment\";\n\n    return el;\n};\n\nJXG.registerElement(\"segment\", JXG.createSegment);\n\n/**\n * @class This element is used to provide a constructor for arrow, which is just a wrapper for element\n * {@link Line} with {@link Line#straightFirst}\n * and {@link Line#straightLast} properties set to false and {@link Line#lastArrow} set to true.\n * @pseudo\n * @description\n * @name Arrow\n * @augments JXG.Line\n * @constructor\n * @type JXG.Line\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point,array_JXG.Point,array} point1,point2 Parent elements can be two elements either of type {@link JXG.Point} or array of numbers describing the\n * coordinates of a point. In the latter case the point will be constructed automatically as a fixed invisible point.\n * @param {Number_Number_Number} a,b,c A line can also be created providing three numbers. The line is then described by the set of solutions\n * of the equation <tt>a*x+b*y+c*z = 0</tt>.\n * @see Line\n * @example\n * // Create an arrow providing two points.\n *   var p1 = board.create('point', [4.5, 2.0]);\n *   var p2 = board.create('point', [1.0, 1.0]);\n *   var l1 = board.create('arrow', [p1, p2]);\n * </pre><div class=\"jxgbox\" id=\"JXG1d26bd22-7d6d-4018-b164-4c8bc8d22ccf\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var alex1_board = JXG.JSXGraph.initBoard('JXG1d26bd22-7d6d-4018-b164-4c8bc8d22ccf', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var alex1_p1 = alex1_board.create('point', [4.5, 2.0]);\n *   var alex1_p2 = alex1_board.create('point', [1.0, 1.0]);\n *   var alex1_l1 = alex1_board.create('arrow', [alex1_p1, alex1_p2]);\n * </script><pre>\n */\nJXG.createArrow = function (board, parents, attributes) {\n    var el, attr;\n\n    attributes.straightFirst = false;\n    attributes.straightLast = false;\n    attr = Type.copyAttributes(attributes, board.options, \"arrow\");\n    el = board.create(\"line\", parents, attr);\n    //el.setArrow(false, true);\n    el.type = Const.OBJECT_TYPE_VECTOR;\n    el.elType = \"arrow\";\n\n    return el;\n};\n\nJXG.registerElement(\"arrow\", JXG.createArrow);\n\n/**\n * @class This element is used to provide a constructor for an axis. It's strictly spoken just a wrapper for element {@link Line} with {@link Line#straightFirst}\n * and {@link Line#straightLast} properties set to true. Additionally {@link Line#lastArrow} is set to true and default {@link Ticks} will be created.\n * @pseudo\n * @description\n * @name Axis\n * @augments JXG.Line\n * @constructor\n * @type JXG.Line\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point,array_JXG.Point,array} point1,point2 Parent elements can be two elements either of type {@link JXG.Point} or array of numbers describing the\n * coordinates of a point. In the latter case, the point will be constructed automatically as a fixed invisible point.\n * @param {Number_Number_Number} a,b,c A line can also be created providing three numbers. The line is then described by the set of solutions\n * of the equation <tt>a*x+b*y+c*z = 0</tt>.\n * @example\n * // Create an axis providing two coord pairs.\n *   var l1 = board.create('axis', [[0.0, 1.0], [1.0, 1.3]]);\n * </pre><div class=\"jxgbox\" id=\"JXG4f414733-624c-42e4-855c-11f5530383ae\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var axex1_board = JXG.JSXGraph.initBoard('JXG4f414733-624c-42e4-855c-11f5530383ae', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var axex1_l1 = axex1_board.create('axis', [[0.0, 1.0], [1.0, 1.3]]);\n * </script><pre>\n */\nJXG.createAxis = function (board, parents, attributes) {\n    var attr, attr_ticks, el, els, dist;\n\n    // Arrays or points, that is all we need.\n    if (\n        (Type.isArray(parents[0]) || Type.isPoint(parents[0])) &&\n        (Type.isArray(parents[1]) || Type.isPoint(parents[1]))\n    ) {\n        // Create line\n        attr = Type.copyAttributes(attributes, board.options, \"axis\");\n        el = board.create(\"line\", parents, attr);\n        el.type = Const.OBJECT_TYPE_AXIS;\n        el.isDraggable = false;\n        el.point1.isDraggable = false;\n        el.point2.isDraggable = false;\n\n        for (els in el.ancestors) {\n            if (el.ancestors.hasOwnProperty(els)) {\n                el.ancestors[els].type = Const.OBJECT_TYPE_AXISPOINT;\n            }\n        }\n\n        // Create ticks\n        attr_ticks = Type.copyAttributes(attributes, board.options, \"axis\", \"ticks\");\n        if (Type.exists(attr_ticks.ticksdistance)) {\n            dist = attr_ticks.ticksdistance;\n        } else if (Type.isArray(attr_ticks.ticks)) {\n            dist = attr_ticks.ticks;\n        } else {\n            dist = 1.0;\n        }\n\n        /**\n         * The ticks attached to the axis.\n         * @memberOf Axis.prototype\n         * @name defaultTicks\n         * @type JXG.Ticks\n         */\n        el.defaultTicks = board.create(\"ticks\", [el, dist], attr_ticks);\n        el.defaultTicks.dump = false;\n        el.elType = \"axis\";\n        el.subs = {\n            ticks: el.defaultTicks\n        };\n        el.inherits.push(el.defaultTicks);\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create axis with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]\"\n        );\n    }\n\n    return el;\n};\n\nJXG.registerElement(\"axis\", JXG.createAxis);\n\n/**\n * @class With the element tangent the slope of a line, circle, or curve in a certain point can be visualized. A tangent is always constructed\n * by a glider on a line, circle, or curve and describes the tangent in the glider point on that line, circle, or curve.\n * @pseudo\n * @description\n * @name Tangent\n * @augments JXG.Line\n * @constructor\n * @type JXG.Line\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Glider} g A glider on a line, circle, or curve.\n * @example\n * // Create a tangent providing a glider on a function graph\n *   var c1 = board.create('curve', [function(t){return t},function(t){return t*t*t;}]);\n *   var g1 = board.create('glider', [0.6, 1.2, c1]);\n *   var t1 = board.create('tangent', [g1]);\n * </pre><div class=\"jxgbox\" id=\"JXG7b7233a0-f363-47dd-9df5-4018d0d17a98\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var tlex1_board = JXG.JSXGraph.initBoard('JXG7b7233a0-f363-47dd-9df5-4018d0d17a98', {boundingbox: [-6, 6, 6, -6], axis: true, showcopyright: false, shownavigation: false});\n *   var tlex1_c1 = tlex1_board.create('curve', [function(t){return t},function(t){return t*t*t;}]);\n *   var tlex1_g1 = tlex1_board.create('glider', [0.6, 1.2, tlex1_c1]);\n *   var tlex1_t1 = tlex1_board.create('tangent', [tlex1_g1]);\n * </script><pre>\n */\nJXG.createTangent = function (board, parents, attributes) {\n    var p, c, j, el, tangent;\n\n    // One argument: glider on line, circle or curve\n    if (parents.length === 1) {\n        p = parents[0];\n        c = p.slideObject;\n        // Two arguments: (point,F\"|conic) or (line|curve|circle|conic,point). // Not yet: curve!\n    } else if (parents.length === 2) {\n        // In fact, for circles and conics it is the polar\n        if (Type.isPoint(parents[0])) {\n            p = parents[0];\n            c = parents[1];\n        } else if (Type.isPoint(parents[1])) {\n            c = parents[0];\n            p = parents[1];\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create tangent with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [glider], [point,line|curve|circle|conic]\"\n            );\n        }\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create tangent with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [glider], [point,line|curve|circle|conic]\"\n        );\n    }\n\n    if (c.elementClass === Const.OBJECT_CLASS_LINE) {\n        tangent = board.create(\"line\", [c.point1, c.point2], attributes);\n        tangent.glider = p;\n    } else if (\n        c.elementClass === Const.OBJECT_CLASS_CURVE &&\n        c.type !== Const.OBJECT_TYPE_CONIC\n    ) {\n        if (Type.evaluate(c.visProp.curvetype) !== \"plot\") {\n            tangent = board.create(\n                \"line\",\n                [\n                    function () {\n                        var g = c.X,\n                            f = c.Y;\n                        return (\n                            -p.X() * Numerics.D(f)(p.position) +\n                            p.Y() * Numerics.D(g)(p.position)\n                        );\n                    },\n                    function () {\n                        return Numerics.D(c.Y)(p.position);\n                    },\n                    function () {\n                        return -Numerics.D(c.X)(p.position);\n                    }\n                ],\n                attributes\n            );\n\n            p.addChild(tangent);\n            // this is required for the geogebra reader to display a slope\n            tangent.glider = p;\n        } else {\n            // curveType 'plot'\n            // In case of bezierDegree == 1:\n            // Find two points p1, p2 enclosing the glider.\n            // Then the equation of the line segment is: 0 = y*(x1-x2) + x*(y2-y1) + y1*x2-x1*y2,\n            // which is the cross product of p1 and p2.\n            //\n            // In case of bezieDegree === 3:\n            // The slope dy / dx of the tangent is determined. Then the\n            // tangent is computed as cross product between\n            // the glider p and [1, p.X() + dx, p.Y() + dy]\n            //\n            tangent = board.create(\n                \"line\",\n                [\n                    function () {\n                        var i = Math.floor(p.position),\n                            p1,\n                            p2,\n                            t,\n                            A,\n                            B,\n                            C,\n                            D,\n                            dx,\n                            dy,\n                            d;\n\n                        if (c.bezierDegree === 1) {\n                            if (i === c.numberPoints - 1) {\n                                i--;\n                            }\n                        } else if (c.bezierDegree === 3) {\n                            // i is start of the Bezier segment\n                            // t is the position in the Bezier segment\n                            i = Math.floor((p.position * (c.numberPoints - 1)) / 3) * 3;\n                            t = (p.position * (c.numberPoints - 1) - i) / 3;\n                            if (i >= c.numberPoints - 1) {\n                                i = c.numberPoints - 4;\n                                t = 1;\n                            }\n                        } else {\n                            return 0;\n                        }\n\n                        if (i < 0) {\n                            return 1;\n                        }\n\n                        // The curve points are transformed (if there is a transformation)\n                        // c.X(i) is not transformed.\n                        if (c.bezierDegree === 1) {\n                            p1 = c.points[i].usrCoords;\n                            p2 = c.points[i + 1].usrCoords;\n                        } else {\n                            A = c.points[i].usrCoords;\n                            B = c.points[i + 1].usrCoords;\n                            C = c.points[i + 2].usrCoords;\n                            D = c.points[i + 3].usrCoords;\n                            dx =\n                                (1 - t) * (1 - t) * (B[1] - A[1]) +\n                                2 * (1 - t) * t * (C[1] - B[1]) +\n                                t * t * (D[1] - C[1]);\n                            dy =\n                                (1 - t) * (1 - t) * (B[2] - A[2]) +\n                                2 * (1 - t) * t * (C[2] - B[2]) +\n                                t * t * (D[2] - C[2]);\n                            d = Math.sqrt(dx * dx + dy * dy);\n                            dx /= d;\n                            dy /= d;\n                            p1 = p.coords.usrCoords;\n                            p2 = [1, p1[1] + dx, p1[2] + dy];\n                        }\n                        return p1[2] * p2[1] - p1[1] * p2[2];\n                    },\n                    function () {\n                        var i = Math.floor(p.position),\n                            p1,\n                            p2,\n                            t,\n                            A,\n                            B,\n                            C,\n                            D,\n                            dx,\n                            dy,\n                            d;\n\n                        if (c.bezierDegree === 1) {\n                            if (i === c.numberPoints - 1) {\n                                i--;\n                            }\n                        } else if (c.bezierDegree === 3) {\n                            // i is start of the Bezier segment\n                            // t is the position in the Bezier segment\n                            i = Math.floor((p.position * (c.numberPoints - 1)) / 3) * 3;\n                            t = (p.position * (c.numberPoints - 1) - i) / 3;\n                            if (i >= c.numberPoints - 1) {\n                                i = c.numberPoints - 4;\n                                t = 1;\n                            }\n                        } else {\n                            return 0;\n                        }\n\n                        if (i < 0) {\n                            return 0;\n                        }\n\n                        // The curve points are transformed (if there is a transformation)\n                        // c.X(i) is not transformed.\n                        if (c.bezierDegree === 1) {\n                            p1 = c.points[i].usrCoords;\n                            p2 = c.points[i + 1].usrCoords;\n                        } else {\n                            A = c.points[i].usrCoords;\n                            B = c.points[i + 1].usrCoords;\n                            C = c.points[i + 2].usrCoords;\n                            D = c.points[i + 3].usrCoords;\n                            dx =\n                                (1 - t) * (1 - t) * (B[1] - A[1]) +\n                                2 * (1 - t) * t * (C[1] - B[1]) +\n                                t * t * (D[1] - C[1]);\n                            dy =\n                                (1 - t) * (1 - t) * (B[2] - A[2]) +\n                                2 * (1 - t) * t * (C[2] - B[2]) +\n                                t * t * (D[2] - C[2]);\n                            d = Math.sqrt(dx * dx + dy * dy);\n                            dx /= d;\n                            dy /= d;\n                            p1 = p.coords.usrCoords;\n                            p2 = [1, p1[1] + dx, p1[2] + dy];\n                        }\n                        return p2[2] - p1[2];\n                    },\n                    function () {\n                        var i = Math.floor(p.position),\n                            p1,\n                            p2,\n                            t,\n                            A,\n                            B,\n                            C,\n                            D,\n                            dx,\n                            dy,\n                            d;\n\n                        if (c.bezierDegree === 1) {\n                            if (i === c.numberPoints - 1) {\n                                i--;\n                            }\n                        } else if (c.bezierDegree === 3) {\n                            // i is start of the Bezier segment\n                            // t is the position in the Bezier segment\n                            i = Math.floor((p.position * (c.numberPoints - 1)) / 3) * 3;\n                            t = (p.position * (c.numberPoints - 1) - i) / 3;\n                            if (i >= c.numberPoints - 1) {\n                                i = c.numberPoints - 4;\n                                t = 1;\n                            }\n                        } else {\n                            return 0;\n                        }\n\n                        if (i < 0) {\n                            return 0.0;\n                        }\n\n                        // The curve points are transformed (if there is a transformation)\n                        // c.X(i) is not transformed.\n                        if (c.bezierDegree === 1) {\n                            p1 = c.points[i].usrCoords;\n                            p2 = c.points[i + 1].usrCoords;\n                        } else {\n                            A = c.points[i].usrCoords;\n                            B = c.points[i + 1].usrCoords;\n                            C = c.points[i + 2].usrCoords;\n                            D = c.points[i + 3].usrCoords;\n                            dx =\n                                (1 - t) * (1 - t) * (B[1] - A[1]) +\n                                2 * (1 - t) * t * (C[1] - B[1]) +\n                                t * t * (D[1] - C[1]);\n                            dy =\n                                (1 - t) * (1 - t) * (B[2] - A[2]) +\n                                2 * (1 - t) * t * (C[2] - B[2]) +\n                                t * t * (D[2] - C[2]);\n                            d = Math.sqrt(dx * dx + dy * dy);\n                            dx /= d;\n                            dy /= d;\n                            p1 = p.coords.usrCoords;\n                            p2 = [1, p1[1] + dx, p1[2] + dy];\n                        }\n                        return p1[1] - p2[1];\n                    }\n                ],\n                attributes\n            );\n\n            p.addChild(tangent);\n            // this is required for the geogebra reader to display a slope\n            tangent.glider = p;\n        }\n    } else if (c.type === Const.OBJECT_TYPE_TURTLE) {\n        tangent = board.create(\n            \"line\",\n            [\n                function () {\n                    var i = Math.floor(p.position);\n\n                    // run through all curves of this turtle\n                    for (j = 0; j < c.objects.length; j++) {\n                        el = c.objects[j];\n\n                        if (el.type === Const.OBJECT_TYPE_CURVE) {\n                            if (i < el.numberPoints) {\n                                break;\n                            }\n\n                            i -= el.numberPoints;\n                        }\n                    }\n\n                    if (i === el.numberPoints - 1) {\n                        i--;\n                    }\n\n                    if (i < 0) {\n                        return 1;\n                    }\n\n                    return el.Y(i) * el.X(i + 1) - el.X(i) * el.Y(i + 1);\n                },\n                function () {\n                    var i = Math.floor(p.position);\n\n                    // run through all curves of this turtle\n                    for (j = 0; j < c.objects.length; j++) {\n                        el = c.objects[j];\n\n                        if (el.type === Const.OBJECT_TYPE_CURVE) {\n                            if (i < el.numberPoints) {\n                                break;\n                            }\n\n                            i -= el.numberPoints;\n                        }\n                    }\n\n                    if (i === el.numberPoints - 1) {\n                        i--;\n                    }\n                    if (i < 0) {\n                        return 0;\n                    }\n\n                    return el.Y(i + 1) - el.Y(i);\n                },\n                function () {\n                    var i = Math.floor(p.position);\n\n                    // run through all curves of this turtle\n                    for (j = 0; j < c.objects.length; j++) {\n                        el = c.objects[j];\n                        if (el.type === Const.OBJECT_TYPE_CURVE) {\n                            if (i < el.numberPoints) {\n                                break;\n                            }\n                            i -= el.numberPoints;\n                        }\n                    }\n                    if (i === el.numberPoints - 1) {\n                        i--;\n                    }\n\n                    if (i < 0) {\n                        return 0;\n                    }\n\n                    return el.X(i) - el.X(i + 1);\n                }\n            ],\n            attributes\n        );\n        p.addChild(tangent);\n\n        // this is required for the geogebra reader to display a slope\n        tangent.glider = p;\n    } else if (\n        c.elementClass === Const.OBJECT_CLASS_CIRCLE ||\n        c.type === Const.OBJECT_TYPE_CONIC\n    ) {\n        // If p is not on c, the tangent is the polar.\n        // This construction should work on conics, too. p has to lie on c.\n        tangent = board.create(\n            \"line\",\n            [\n                function () {\n                    return Mat.matVecMult(c.quadraticform, p.coords.usrCoords)[0];\n                },\n                function () {\n                    return Mat.matVecMult(c.quadraticform, p.coords.usrCoords)[1];\n                },\n                function () {\n                    return Mat.matVecMult(c.quadraticform, p.coords.usrCoords)[2];\n                }\n            ],\n            attributes\n        );\n\n        p.addChild(tangent);\n        // this is required for the geogebra reader to display a slope\n        tangent.glider = p;\n    }\n\n    if (!Type.exists(tangent)) {\n        throw new Error(\"JSXGraph: Couldn't create tangent with the given parents.\");\n    }\n\n    tangent.elType = \"tangent\";\n    tangent.type = Const.OBJECT_TYPE_TANGENT;\n    tangent.setParents(parents);\n\n    return tangent;\n};\n\n/**\n * @class This element is used to provide a constructor for the radical axis with respect to two circles with distinct centers.\n * The angular bisector of the polar lines of the circle centers with respect to the other circle is always the radical axis.\n * The radical axis passes through the intersection points when the circles intersect.\n * When a circle about the midpoint of circle centers, passing through the circle centers, intersects the circles, the polar lines pass through those intersection points.\n * @pseudo\n * @description\n * @name RadicalAxis\n * @augments JXG.Line\n * @constructor\n * @type JXG.Line\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Circle} circle Circle one of the two respective circles.\n * @param {JXG.Circle} circle Circle the other of the two respective circles.\n * @example\n * // Create the radical axis line with respect to two circles\n *   var board = JXG.JSXGraph.initBoard('7b7233a0-f363-47dd-9df5-5018d0d17a98', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var p1 = board.create('point', [2, 3]);\n *   var p2 = board.create('point', [1, 4]);\n *   var c1 = board.create('circle', [p1, p2]);\n *   var p3 = board.create('point', [6, 5]);\n *   var p4 = board.create('point', [8, 6]);\n *   var c2 = board.create('circle', [p3, p4]);\n *   var r1 = board.create('radicalaxis', [c1, c2]);\n * </pre><div class=\"jxgbox\" id=\"JXG7b7233a0-f363-47dd-9df5-5018d0d17a98\" class=\"jxgbox\" style=\"width:400px; height:400px;\"></div>\n * <script type='text/javascript'>\n *   var rlex1_board = JXG.JSXGraph.initBoard('JXG7b7233a0-f363-47dd-9df5-5018d0d17a98', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var rlex1_p1 = rlex1_board.create('point', [2, 3]);\n *   var rlex1_p2 = rlex1_board.create('point', [1, 4]);\n *   var rlex1_c1 = rlex1_board.create('circle', [rlex1_p1, rlex1_p2]);\n *   var rlex1_p3 = rlex1_board.create('point', [6, 5]);\n *   var rlex1_p4 = rlex1_board.create('point', [8, 6]);\n *   var rlex1_c2 = rlex1_board.create('circle', [rlex1_p3, rlex1_p4]);\n *   var rlex1_r1 = rlex1_board.create('radicalaxis', [rlex1_c1, rlex1_c2]);\n * </script><pre>\n */\nJXG.createRadicalAxis = function (board, parents, attributes) {\n    var el, el1, el2;\n\n    if (\n        parents.length !== 2 ||\n        parents[0].elementClass !== Const.OBJECT_CLASS_CIRCLE ||\n        parents[1].elementClass !== Const.OBJECT_CLASS_CIRCLE\n    ) {\n        // Failure\n        throw new Error(\n            \"JSXGraph: Can't create 'radical axis' with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent type: [circle,circle]\"\n        );\n    }\n\n    el1 = board.select(parents[0]);\n    el2 = board.select(parents[1]);\n\n    el = board.create(\n        \"line\",\n        [\n            function () {\n                var a = el1.stdform,\n                    b = el2.stdform;\n\n                return Mat.matVecMult(Mat.transpose([a.slice(0, 3), b.slice(0, 3)]), [\n                    b[3],\n                    -a[3]\n                ]);\n            }\n        ],\n        attributes\n    );\n\n    el.elType = \"radicalaxis\";\n    el.setParents([el1.id, el2.id]);\n\n    el1.addChild(el);\n    el2.addChild(el);\n\n    return el;\n};\n\n/**\n * @class This element is used to provide a constructor for the polar line of a point with respect to a conic or a circle.\n * @pseudo\n * @description The polar line is the unique reciprocal relationship of a point with respect to a conic.\n * The lines through the intersections of a conic and the polar line of a point with respect to that conic and through that point are tangent to the conic.\n * A point on a conic has the polar line of that point with respect to that conic as the tangent line to that conic at that point.\n * See {@link http://en.wikipedia.org/wiki/Pole_and_polar} for more information on pole and polar.\n * @name PolarLine\n * @augments JXG.Line\n * @constructor\n * @type JXG.Line\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Conic,JXG.Circle_JXG.Point} el1,el2 or\n * @param {JXG.Point_JXG.Conic,JXG.Circle} el1,el2 The result will be the polar line of the point with respect to the conic or the circle.\n * @example\n * // Create the polar line of a point with respect to a conic\n * var p1 = board.create('point', [-1, 2]);\n * var p2 = board.create('point', [ 1, 4]);\n * var p3 = board.create('point', [-1,-2]);\n * var p4 = board.create('point', [ 0, 0]);\n * var p5 = board.create('point', [ 4,-2]);\n * var c1 = board.create('conic',[p1,p2,p3,p4,p5]);\n * var p6 = board.create('point', [-1, 1]);\n * var l1 = board.create('polarline', [c1, p6]);\n * </pre><div class=\"jxgbox\" id=\"JXG7b7233a0-f363-47dd-9df5-6018d0d17a98\" class=\"jxgbox\" style=\"width:400px; height:400px;\"></div>\n * <script type='text/javascript'>\n * var plex1_board = JXG.JSXGraph.initBoard('JXG7b7233a0-f363-47dd-9df5-6018d0d17a98', {boundingbox: [-3, 5, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n * var plex1_p1 = plex1_board.create('point', [-1, 2]);\n * var plex1_p2 = plex1_board.create('point', [ 1, 4]);\n * var plex1_p3 = plex1_board.create('point', [-1,-2]);\n * var plex1_p4 = plex1_board.create('point', [ 0, 0]);\n * var plex1_p5 = plex1_board.create('point', [ 4,-2]);\n * var plex1_c1 = plex1_board.create('conic',[plex1_p1,plex1_p2,plex1_p3,plex1_p4,plex1_p5]);\n * var plex1_p6 = plex1_board.create('point', [-1, 1]);\n * var plex1_l1 = plex1_board.create('polarline', [plex1_c1, plex1_p6]);\n * </script><pre>\n * @example\n * // Create the polar line of a point with respect to a circle.\n * var p1 = board.create('point', [ 1, 1]);\n * var p2 = board.create('point', [ 2, 3]);\n * var c1 = board.create('circle',[p1,p2]);\n * var p3 = board.create('point', [ 6, 6]);\n * var l1 = board.create('polarline', [c1, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG7b7233a0-f363-47dd-9df5-7018d0d17a98\" class=\"jxgbox\" style=\"width:400px; height:400px;\"></div>\n * <script type='text/javascript'>\n * var plex2_board = JXG.JSXGraph.initBoard('JXG7b7233a0-f363-47dd-9df5-7018d0d17a98', {boundingbox: [-3, 7, 7, -3], axis: true, showcopyright: false, shownavigation: false});\n * var plex2_p1 = plex2_board.create('point', [ 1, 1]);\n * var plex2_p2 = plex2_board.create('point', [ 2, 3]);\n * var plex2_c1 = plex2_board.create('circle',[plex2_p1,plex2_p2]);\n * var plex2_p3 = plex2_board.create('point', [ 6, 6]);\n * var plex2_l1 = plex2_board.create('polarline', [plex2_c1, plex2_p3]);\n * </script><pre>\n */\nJXG.createPolarLine = function (board, parents, attributes) {\n    var el,\n        el1,\n        el2,\n        firstParentIsConic,\n        secondParentIsConic,\n        firstParentIsPoint,\n        secondParentIsPoint;\n\n    if (parents.length > 1) {\n        firstParentIsConic =\n            parents[0].type === Const.OBJECT_TYPE_CONIC ||\n            parents[0].elementClass === Const.OBJECT_CLASS_CIRCLE;\n        secondParentIsConic =\n            parents[1].type === Const.OBJECT_TYPE_CONIC ||\n            parents[1].elementClass === Const.OBJECT_CLASS_CIRCLE;\n\n        firstParentIsPoint = Type.isPoint(parents[0]);\n        secondParentIsPoint = Type.isPoint(parents[1]);\n    }\n\n    if (\n        parents.length !== 2 ||\n        !(\n            (firstParentIsConic && secondParentIsPoint) ||\n            (firstParentIsPoint && secondParentIsConic)\n        )\n    ) {\n        // Failure\n        throw new Error(\n            \"JSXGraph: Can't create 'polar line' with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent type: [conic|circle,point], [point,conic|circle]\"\n        );\n    }\n\n    if (secondParentIsPoint) {\n        el1 = board.select(parents[0]);\n        el2 = board.select(parents[1]);\n    } else {\n        el1 = board.select(parents[1]);\n        el2 = board.select(parents[0]);\n    }\n\n    // Polar lines have been already provided in the tangent element.\n    el = board.create(\"tangent\", [el1, el2], attributes);\n\n    el.elType = \"polarline\";\n    return el;\n};\n\n/**\n * Register the element type tangent at JSXGraph\n * @private\n */\nJXG.registerElement(\"tangent\", JXG.createTangent);\nJXG.registerElement(\"polar\", JXG.createTangent);\nJXG.registerElement(\"radicalaxis\", JXG.createRadicalAxis);\nJXG.registerElement(\"polarline\", JXG.createPolarLine);\n\nexport default {\n    Line: JXG.Line,\n    createLine: JXG.createLine,\n    createTangent: JXG.createTangent,\n    createPolar: JXG.createTangent,\n    createSegment: JXG.createSegment,\n    createAxis: JXG.createAxis,\n    createArrow: JXG.createArrow,\n    createRadicalAxis: JXG.createRadicalAxis,\n    createPolarLine: JXG.createPolarLine\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the class Group is defined, a class for\n * managing grouping of points.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Type from \"../utils/type\";\n\n/**\n * Creates a new instance of Group.\n * @class In this class all group management is done.\n * @param {JXG.Board} board\n * @param {String} id Unique identifier for this object.  If null or an empty string is given,\n * an unique id will be generated by Board\n * @param {String} name Not necessarily unique name, displayed on the board.  If null or an\n * empty string is given, an unique name will be generated.\n * @param {Array} objects Array of points to add to this group.\n * @param {Object} attributes Defines the visual appearance of the group.\n * @constructor\n */\nJXG.Group = function (board, id, name, objects, attributes) {\n    var number, objArray, i, obj;\n\n    this.board = board;\n    this.objects = {};\n    number = this.board.numObjects;\n    this.board.numObjects += 1;\n\n    if (id === \"\" || !Type.exists(id)) {\n        this.id = this.board.id + \"Group\" + number;\n    } else {\n        this.id = id;\n    }\n    this.board.groups[this.id] = this;\n\n    this.type = Const.OBJECT_TYPE_POINT;\n    this.elementClass = Const.OBJECT_CLASS_POINT;\n\n    if (name === \"\" || !Type.exists(name)) {\n        this.name = \"group_\" + this.board.generateName(this);\n    } else {\n        this.name = name;\n    }\n    delete this.type;\n\n    /**\n     * Cache coordinates of points. From this and the actual position\n     * of the points, the translation is determined.\n     * It has to be kept updated in this class \"by hand\"-\n     *\n     * @private\n     * @type Object\n     * @see JXG.Group#_updateCoordsCache\n     */\n    this.coords = {};\n    this.needsRegularUpdate = attributes.needsregularupdate;\n\n    this.rotationCenter = \"centroid\";\n    this.scaleCenter = null;\n    this.rotationPoints = [];\n    this.translationPoints = [];\n    this.scalePoints = [];\n    this.scaleDirections = {};\n\n    this.parents = [];\n\n    if (Type.isArray(objects)) {\n        objArray = objects;\n    } else {\n        objArray = Array.prototype.slice.call(arguments, 3);\n    }\n\n    for (i = 0; i < objArray.length; i++) {\n        obj = this.board.select(objArray[i]);\n\n        if (!Type.evaluate(obj.visProp.fixed) && Type.exists(obj.coords)) {\n            this.addPoint(obj);\n        }\n    }\n\n    this.methodMap = {\n        ungroup: \"ungroup\",\n        add: \"addPoint\",\n        addPoint: \"addPoint\",\n        addPoints: \"addPoints\",\n        addGroup: \"addGroup\",\n        remove: \"removePoint\",\n        removePoint: \"removePoint\",\n        setAttribute: \"setAttribute\",\n        setProperty: \"setAttribute\"\n    };\n};\n\nJXG.extend(\n    JXG.Group.prototype,\n    /** @lends JXG.Group.prototype */ {\n        /**\n         * Releases all elements of this group.\n         * @returns {JXG.Group} returns this (empty) group\n         */\n        ungroup: function () {\n            var el, p, i;\n            for (el in this.objects) {\n                if (this.objects.hasOwnProperty(el)) {\n                    p = this.objects[el].point;\n                    if (Type.isArray(p.groups)) {\n                        i = Type.indexOf(p.groups, this.id);\n                        if (i >= 0) {\n                            delete p.groups[i];\n                        }\n                    }\n                }\n            }\n\n            this.objects = {};\n            return this;\n        },\n\n        /**\n         * Adds ids of elements to the array this.parents. This is a copy\n         * of {@link Element.addParents}.\n         * @param {Array} parents Array of elements or ids of elements.\n         * Alternatively, one can give a list of objects as parameters.\n         * @returns {JXG.Object} reference to the object itself.\n         **/\n        addParents: function (parents) {\n            var i, len, par;\n\n            if (Type.isArray(parents)) {\n                par = parents;\n            } else {\n                par = arguments;\n            }\n\n            len = par.length;\n            for (i = 0; i < len; ++i) {\n                if (Type.isId(this.board, par[i])) {\n                    this.parents.push(par[i]);\n                } else if (Type.exists(par[i].id)) {\n                    this.parents.push(par[i].id);\n                }\n            }\n\n            this.parents = Type.uniqueArray(this.parents);\n        },\n\n        /**\n         * Sets ids of elements to the array this.parents. This is a copy\n         * of {@link Element.setParents}\n         * First, this.parents is cleared. See {@link Group#addParents}.\n         * @param {Array} parents Array of elements or ids of elements.\n         * Alternatively, one can give a list of objects as parameters.\n         * @returns {JXG.Object} reference to the object itself.\n         **/\n        setParents: function (parents) {\n            this.parents = [];\n            this.addParents(parents);\n            return this;\n        },\n\n        /**\n         * List of the element ids resp. values used as parents in {@link JXG.Board#create}.\n         * @returns {Array}\n         */\n        getParents: function () {\n            return Type.isArray(this.parents) ? this.parents : [];\n        },\n\n        /**\n         * Update the cached coordinates of a group element.\n         * @param  {String} el element id of the group element whose cached coordinates\n         * are going to be updated.\n         * @return null\n         */\n        _updateCoordsCache: function (el) {\n            var obj;\n            if (el !== \"\" && Type.exists(this.objects[el])) {\n                obj = this.objects[el].point;\n                this.coords[obj.id] = { usrCoords: obj.coords.usrCoords.slice(0) };\n            }\n        },\n\n        /**\n         * Sends an update to all group members.\n         * This method is called from the points' coords object event listeners\n         * and not by the board.\n         * @returns {JXG.Group} returns this group\n         */\n        update: function () {\n            var drag,\n                el,\n                actionCenter,\n                desc,\n                s,\n                sx,\n                sy,\n                alpha,\n                t,\n                center,\n                obj = null;\n\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            drag = this._update_find_drag_type();\n            if (drag.action === \"nothing\") {\n                this._updateCoordsCache(drag.id);\n                return this;\n            }\n\n            obj = this.objects[drag.id].point;\n\n            // Prepare translation, scaling or rotation\n            if (drag.action === \"translation\") {\n                t = [\n                    obj.coords.usrCoords[1] - this.coords[drag.id].usrCoords[1],\n                    obj.coords.usrCoords[2] - this.coords[drag.id].usrCoords[2]\n                ];\n            } else if (drag.action === \"rotation\" || drag.action === \"scaling\") {\n                if (drag.action === \"rotation\") {\n                    actionCenter = \"rotationCenter\";\n                } else {\n                    actionCenter = \"scaleCenter\";\n                }\n\n                if (Type.isPoint(this[actionCenter])) {\n                    center = this[actionCenter].coords.usrCoords.slice(1);\n                } else if (this[actionCenter] === \"centroid\") {\n                    center = this._update_centroid_center();\n                } else if (Type.isArray(this[actionCenter])) {\n                    center = this[actionCenter];\n                } else if (Type.isFunction(this[actionCenter])) {\n                    center = this[actionCenter]();\n                } else {\n                    return this;\n                }\n\n                if (drag.action === \"rotation\") {\n                    alpha = Geometry.rad(\n                        this.coords[drag.id].usrCoords.slice(1),\n                        center,\n                        this.objects[drag.id].point\n                    );\n                    t = this.board.create(\"transform\", [alpha, center[0], center[1]], {\n                        type: \"rotate\"\n                    });\n                    t.update(); // This initializes t.matrix, which is needed if the action element is the first group element.\n                } else if (drag.action === \"scaling\") {\n                    s = Geometry.distance(this.coords[drag.id].usrCoords.slice(1), center);\n                    if (Math.abs(s) < Mat.eps) {\n                        return this;\n                    }\n                    s = Geometry.distance(obj.coords.usrCoords.slice(1), center) / s;\n                    sx = this.scaleDirections[drag.id].indexOf(\"x\") >= 0 ? s : 1.0;\n                    sy = this.scaleDirections[drag.id].indexOf(\"y\") >= 0 ? s : 1.0;\n\n                    // Shift scale center to origin, scale and shift the scale center back.\n                    t = this.board.create(\n                        \"transform\",\n                        [1, 0, 0, center[0] * (1 - sx), sx, 0, center[1] * (1 - sy), 0, sy],\n                        { type: \"generic\" }\n                    );\n                    t.update(); // This initializes t.matrix, which is needed if the action element is the first group element.\n                } else {\n                    return this;\n                }\n            }\n\n            this._update_apply_transformation(drag, t);\n\n            this.needsUpdate = false; // This is needed here to prevent infinite recursion because\n            // of the board.updateElements call below,\n\n            // Prepare dependent objects for update\n            for (el in this.objects) {\n                if (this.objects.hasOwnProperty(el)) {\n                    for (desc in this.objects[el].descendants) {\n                        if (this.objects[el].descendants.hasOwnProperty(desc)) {\n                            this.objects[el].descendants.needsUpdate =\n                                this.objects[el].descendants.needsRegularUpdate ||\n                                this.board.needsFullUpdate;\n                        }\n                    }\n                }\n            }\n            this.board.updateElements(drag);\n\n            // Now, all group elements have their new position and\n            // we can update the bookkeeping of the coordinates of the group elements.\n            for (el in this.objects) {\n                if (this.objects.hasOwnProperty(el)) {\n                    this._updateCoordsCache(el);\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * @private\n         * Determine what the dragging of a group element should do:\n         * rotation, translation, scaling or nothing.\n         */\n        _update_find_drag_type: function () {\n            var el,\n                obj,\n                action = \"nothing\",\n                changed = [],\n                dragObjId;\n\n            // Determine how many elements have changed their position\n            // If more than one element changed its position, it is a translation.\n            // If exactly one element changed its position we have to find the type of the point.\n            for (el in this.objects) {\n                if (this.objects.hasOwnProperty(el)) {\n                    obj = this.objects[el].point;\n\n                    if (obj.coords.distance(Const.COORDS_BY_USER, this.coords[el]) > Mat.eps) {\n                        changed.push(obj.id);\n                    }\n                }\n            }\n\n            // Determine type of action: translation, scaling or rotation\n            if (changed.length === 0) {\n                return {\n                    action: action,\n                    id: \"\",\n                    changed: changed\n                };\n            }\n\n            dragObjId = changed[0];\n            obj = this.objects[dragObjId].point;\n\n            if (changed.length > 1) {\n                // More than one point moved => translation\n                action = \"translation\";\n            } else {\n                // One point moved => we have to determine the type\n                if (\n                    Type.isInArray(this.rotationPoints, obj) &&\n                    Type.exists(this.rotationCenter)\n                ) {\n                    action = \"rotation\";\n                } else if (\n                    Type.isInArray(this.scalePoints, obj) &&\n                    Type.exists(this.scaleCenter)\n                ) {\n                    action = \"scaling\";\n                } else if (Type.isInArray(this.translationPoints, obj)) {\n                    action = \"translation\";\n                }\n            }\n\n            return {\n                action: action,\n                id: dragObjId,\n                changed: changed\n            };\n        },\n\n        /**\n         * @private\n         * Determine the Euclidean coordinates of the centroid of the group.\n         * @returns {Array} array of length two,\n         */\n        _update_centroid_center: function () {\n            var center, len, el;\n\n            center = [0, 0];\n            len = 0;\n            for (el in this.coords) {\n                if (this.coords.hasOwnProperty(el)) {\n                    center[0] += this.coords[el].usrCoords[1];\n                    center[1] += this.coords[el].usrCoords[2];\n                    ++len;\n                }\n            }\n            if (len > 0) {\n                center[0] /= len;\n                center[1] /= len;\n            }\n\n            return center;\n        },\n\n        /**\n         * @private\n         * Apply the transformation to all elements of the group\n         */\n        _update_apply_transformation: function (drag, t) {\n            var el, obj;\n\n            for (el in this.objects) {\n                if (this.objects.hasOwnProperty(el)) {\n                    if (Type.exists(this.board.objects[el])) {\n                        obj = this.objects[el].point;\n\n                        // Here, it is important that we change the position\n                        // of elements by using setCoordinates.\n                        // Thus, we avoid the call of snapToGrid().\n                        // This is done in the subsequent call of board.updateElements()\n                        // in Group.update() above.\n                        if (obj.id !== drag.id) {\n                            if (drag.action === \"translation\") {\n                                if (!Type.isInArray(drag.changed, obj.id)) {\n                                    obj.coords.setCoordinates(Const.COORDS_BY_USER, [\n                                        this.coords[el].usrCoords[1] + t[0],\n                                        this.coords[el].usrCoords[2] + t[1]\n                                    ]);\n                                }\n                            } else if (\n                                drag.action === \"rotation\" ||\n                                drag.action === \"scaling\"\n                            ) {\n                                t.applyOnce([obj]);\n                            }\n                        } else {\n                            if (drag.action === \"rotation\" || drag.action === \"scaling\") {\n                                obj.coords.setCoordinates(\n                                    Const.COORDS_BY_USER,\n                                    Mat.matVecMult(t.matrix, this.coords[obj.id].usrCoords)\n                                );\n                            }\n                        }\n                    } else {\n                        delete this.objects[el];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Adds an Point to this group.\n         * @param {JXG.Point} object The point added to the group.\n         * @returns {JXG.Group} returns this group\n         */\n        addPoint: function (object) {\n            this.objects[object.id] = { point: this.board.select(object) };\n            this._updateCoordsCache(object.id);\n            //this.coords[object.id] = {usrCoords: object.coords.usrCoords.slice(0) };\n            this.translationPoints.push(object);\n\n            object.groups.push(this.id);\n            object.groups = Type.uniqueArray(object.groups);\n\n            return this;\n        },\n\n        /**\n         * Adds multiple points to this group.\n         * @param {Array} objects An array of points to add to the group.\n         * @returns {JXG.Group} returns this group\n         */\n        addPoints: function (objects) {\n            var p;\n\n            for (p = 0; p < objects.length; p++) {\n                this.addPoint(objects[p]);\n            }\n\n            return this;\n        },\n\n        /**\n         * Adds all points in a group to this group.\n         * @param {JXG.Group} group The group added to this group.\n         * @returns {JXG.Group} returns this group\n         */\n        addGroup: function (group) {\n            var el;\n\n            for (el in group.objects) {\n                if (group.objects.hasOwnProperty(el)) {\n                    this.addPoint(group.objects[el].point);\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Removes a point from the group.\n         * @param {JXG.Point} point\n         * @returns {JXG.Group} returns this group\n         */\n        removePoint: function (point) {\n            delete this.objects[point.id];\n\n            return this;\n        },\n\n        /**\n         * Sets the center of rotation for the group. This is either a point or the centroid of the group.\n         * @param {JXG.Point|String} object A point which will be the center of rotation, the string \"centroid\", or\n         * an array of length two, or a function returning an array of length two.\n         * @default 'centroid'\n         * @returns {JXG.Group} returns this group\n         */\n        setRotationCenter: function (object) {\n            this.rotationCenter = object;\n\n            return this;\n        },\n\n        /**\n         * Sets the rotation points of the group. Dragging at one of these points results into a rotation of the whole group around\n         * the rotation center of the group {@see JXG.Group#setRotationCenter}.\n         * @param {Array|JXG.Point} objects Array of {@link JXG.Point} or arbitrary number of {@link JXG.Point} elements.\n         * @returns {JXG.Group} returns this group\n         */\n        setRotationPoints: function (objects) {\n            return this._setActionPoints(\"rotation\", objects);\n        },\n\n        /**\n         * Adds a point to the set of rotation points of the group. Dragging at one of these points results into a rotation of the whole group around\n         * the rotation center of the group {@see JXG.Group#setRotationCenter}.\n         * @param {JXG.Point} point {@link JXG.Point} element.\n         * @returns {JXG.Group} returns this group\n         */\n        addRotationPoint: function (point) {\n            return this._addActionPoint(\"rotation\", point);\n        },\n\n        /**\n         * Removes the rotation property from a point of the group.\n         * @param {JXG.Point} point {@link JXG.Point} element.\n         * @returns {JXG.Group} returns this group\n         */\n        removeRotationPoint: function (point) {\n            return this._removeActionPoint(\"rotation\", point);\n        },\n\n        /**\n         * Sets the translation points of the group. Dragging at one of these points results into a translation of the whole group.\n         * @param {Array|JXG.Point} objects Array of {@link JXG.Point} or arbitrary number of {@link JXG.Point} elements.\n         *\n         * By default, all points of the group are translation points.\n         * @returns {JXG.Group} returns this group\n         */\n        setTranslationPoints: function (objects) {\n            return this._setActionPoints(\"translation\", objects);\n        },\n\n        /**\n         * Adds a point to the set of the translation points of the group.\n         * Dragging one of these points results into a translation of the whole group.\n         * @param {JXG.Point} point {@link JXG.Point} element.\n         * @returns {JXG.Group} returns this group\n         */\n        addTranslationPoint: function (point) {\n            return this._addActionPoint(\"translation\", point);\n        },\n\n        /**\n         * Removes the translation property from a point of the group.\n         * @param {JXG.Point} point {@link JXG.Point} element.\n         * @returns {JXG.Group} returns this group\n         */\n        removeTranslationPoint: function (point) {\n            return this._removeActionPoint(\"translation\", point);\n        },\n\n        /**\n         * Sets the center of scaling for the group. This is either a point or the centroid of the group.\n         * @param {JXG.Point|String} object A point which will be the center of scaling, the string \"centroid\", or\n         * an array of length two, or a function returning an array of length two.\n         * @returns {JXG.Group} returns this group\n         */\n        setScaleCenter: function (object) {\n            this.scaleCenter = object;\n\n            return this;\n        },\n\n        /**\n         * Sets the scale points of the group. Dragging at one of these points results into a scaling of the whole group.\n         * @param {Array|JXG.Point} objects Array of {@link JXG.Point} or arbitrary number of {@link JXG.Point} elements.\n         * @param {String} direction Restricts the directions to be scaled. Possible values are 'x', 'y', 'xy'. Default value is 'xy'.\n         *\n         * By default, all points of the group are translation points.\n         * @returns {JXG.Group} returns this group\n         */\n        setScalePoints: function (objects, direction) {\n            var objs, i, len;\n            if (Type.isArray(objects)) {\n                objs = objects;\n            } else {\n                objs = arguments;\n            }\n\n            len = objs.length;\n            for (i = 0; i < len; ++i) {\n                this.scaleDirections[this.board.select(objs[i]).id] = direction || \"xy\";\n            }\n\n            return this._setActionPoints(\"scale\", objects);\n        },\n\n        /**\n         * Adds a point to the set of the scale points of the group. Dragging at one of these points results into a scaling of the whole group.\n         * @param {JXG.Point} point {@link JXG.Point} element.\n         * @param {String} direction Restricts the directions to be scaled. Possible values are 'x', 'y', 'xy'. Default value is 'xy'.\n         * @returns {JXG.Group} returns this group\n         */\n        addScalePoint: function (point, direction) {\n            this._addActionPoint(\"scale\", point);\n            this.scaleDirections[this.board.select(point).id] = direction || \"xy\";\n\n            return this;\n        },\n\n        /**\n         * Removes the scaling property from a point of the group.\n         * @param {JXG.Point} point {@link JXG.Point} element.\n         * @returns {JXG.Group} returns this group\n         */\n        removeScalePoint: function (point) {\n            return this._removeActionPoint(\"scale\", point);\n        },\n\n        /**\n         * Generic method for {@link JXG.Group@setTranslationPoints} and {@link JXG.Group@setRotationPoints}\n         * @private\n         */\n        _setActionPoints: function (action, objects) {\n            var objs, i, len;\n            if (Type.isArray(objects)) {\n                objs = objects;\n            } else {\n                objs = arguments;\n            }\n\n            len = objs.length;\n            this[action + \"Points\"] = [];\n            for (i = 0; i < len; ++i) {\n                this._addActionPoint(action, objs[i]);\n            }\n\n            return this;\n        },\n\n        /**\n         * Generic method for {@link JXG.Group@addTranslationPoint} and {@link JXG.Group@addRotationPoint}\n         * @private\n         */\n        _addActionPoint: function (action, point) {\n            this[action + \"Points\"].push(this.board.select(point));\n\n            return this;\n        },\n\n        /**\n         * Generic method for {@link JXG.Group@removeTranslationPoint} and {@link JXG.Group@removeRotationPoint}\n         * @private\n         */\n        _removeActionPoint: function (action, point) {\n            var idx = this[action + \"Points\"].indexOf(this.board.select(point));\n            if (idx > -1) {\n                this[action + \"Points\"].splice(idx, 1);\n            }\n\n            return this;\n        },\n\n        /**\n         * @deprecated\n         * Use setAttribute\n         */\n        setProperty: function () {\n            JXG.deprecated(\"Group.setProperty\", \"Group.setAttribute()\");\n            this.setAttribute.apply(this, arguments);\n        },\n\n        setAttribute: function () {\n            var el;\n\n            for (el in this.objects) {\n                if (this.objects.hasOwnProperty(el)) {\n                    this.objects[el].point.setAttribute.apply(\n                        this.objects[el].point,\n                        arguments\n                    );\n                }\n            }\n\n            return this;\n        }\n    }\n);\n\n/**\n * @class This element combines a given set of {@link JXG.Point} elements to a\n *  group. The elements of the group and dependent elements can be translated, rotated and scaled by\n *  dragging one of the group elements.\n *\n *\n * @pseudo\n * @description\n * @name Group\n * @augments JXG.Group\n * @constructor\n * @type JXG.Group\n * @param {JXG.Board} board The board the points are on.\n * @param {Array} parents Array of points to group.\n * @param {Object} attributes Visual properties (unused).\n * @returns {JXG.Group}\n *\n * @example\n *\n *  // Create some free points. e.g. A, B, C, D\n *  // Create a group\n *\n *  var p, col, g;\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *  g = board.create('group', p);\n *\n * </pre><div class=\"jxgbox\" id=\"JXGa2204533-db91-4af9-b720-70394de4d367\" style=\"width: 400px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *  var board, p, col, g;\n *  board = JXG.JSXGraph.initBoard('JXGa2204533-db91-4af9-b720-70394de4d367', {boundingbox:[-5,5,5,-5], keepaspectratio:true, axis:true, showcopyright: false});\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *  g = board.create('group', p);\n *  })();\n * </script><pre>\n *\n *\n * @example\n *\n *  // Create some free points. e.g. A, B, C, D\n *  // Create a group\n *  // If the points define a polygon and the polygon has the attribute hasInnerPoints:true,\n *  // the polygon can be dragged around.\n *\n *  var p, col, pol, g;\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p);\n *\n * </pre><div class=\"jxgbox\" id=\"JXG781b5564-a671-4327-81c6-de915c8f924e\" style=\"width: 400px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *  var board, p, col, pol, g;\n *  board = JXG.JSXGraph.initBoard('JXG781b5564-a671-4327-81c6-de915c8f924e', {boundingbox:[-5,5,5,-5], keepaspectratio:true, axis:true, showcopyright: false});\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p);\n *  })();\n * </script><pre>\n *\n *  @example\n *\n *  // Allow rotations:\n *  // Define a center of rotation and declare points of the group as \"rotation points\".\n *\n *  var p, col, pol, g;\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p);\n *  g.setRotationCenter(p[0]);\n *  g.setRotationPoints([p[1], p[2]]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXGf0491b62-b377-42cb-b55c-4ef5374b39fc\" style=\"width: 400px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *  var board, p, col, pol, g;\n *  board = JXG.JSXGraph.initBoard('JXGf0491b62-b377-42cb-b55c-4ef5374b39fc', {boundingbox:[-5,5,5,-5], keepaspectratio:true, axis:true, showcopyright: false});\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p);\n *  g.setRotationCenter(p[0]);\n *  g.setRotationPoints([p[1], p[2]]);\n *  })();\n * </script><pre>\n *\n *  @example\n *\n *  // Allow rotations:\n *  // As rotation center, arbitrary points, coordinate arrays,\n *  // or functions returning coordinate arrays can be given.\n *  // Another possibility is to use the predefined string 'centroid'.\n *\n *  // The methods to define the rotation points can be chained.\n *\n *  var p, col, pol, g;\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p).setRotationCenter('centroid').setRotationPoints([p[1], p[2]]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXG8785b099-a75e-4769-bfd8-47dd4376fe27\" style=\"width: 400px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *  var board, p, col, pol, g;\n *  board = JXG.JSXGraph.initBoard('JXG8785b099-a75e-4769-bfd8-47dd4376fe27', {boundingbox:[-5,5,5,-5], keepaspectratio:true, axis:true, showcopyright: false});\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p).setRotationCenter('centroid').setRotationPoints([p[1], p[2]]);\n *  })();\n * </script><pre>\n *\n *  @example\n *\n *  // Allow scaling:\n *  // As for rotation one can declare points of the group to trigger a scaling operation.\n *  // For this, one has to define a scaleCenter, in analogy to rotations.\n *\n *  // Here, the yellow  point enables scaling, the red point a rotation.\n *\n *  var p, col, pol, g;\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:'yellow', fillColor:'yellow'}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p).setRotationCenter('centroid').setRotationPoints([p[2]]);\n *  g.setScaleCenter(p[0]).setScalePoints(p[1]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXGc3ca436b-e4fc-4de5-bab4-09790140c675\" style=\"width: 400px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *  var board, p, col, pol, g;\n *  board = JXG.JSXGraph.initBoard('JXGc3ca436b-e4fc-4de5-bab4-09790140c675', {boundingbox:[-5,5,5,-5], keepaspectratio:true, axis:true, showcopyright: false});\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:'yellow', fillColor:'yellow'}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p).setRotationCenter('centroid').setRotationPoints([p[2]]);\n *  g.setScaleCenter(p[0]).setScalePoints(p[1]);\n *  })();\n * </script><pre>\n *\n *  @example\n *\n *  // Allow Translations:\n *  // By default, every point of a group triggers a translation.\n *  // There may be situations, when this is not wanted.\n *\n *  // In this example, E triggers nothing, but itself is rotation center\n *  // and is translated, if other points are moved around.\n *\n *  var p, q, col, pol, g;\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:'yellow', fillColor:'yellow'}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *  q = board.create('point',[0, 0], {size: 5, strokeColor:col, fillColor:col});\n *\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p.concat(q)).setRotationCenter('centroid').setRotationPoints([p[2]]);\n *  g.setScaleCenter(p[0]).setScalePoints(p[1]);\n *  g.removeTranslationPoint(q);\n *\n * </pre><div class=\"jxgbox\" id=\"JXGd19b800a-57a9-4303-b49a-8f5b7a5488f0\" style=\"width: 400px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *  var board, p, q, col, pol, g;\n *  board = JXG.JSXGraph.initBoard('JXGd19b800a-57a9-4303-b49a-8f5b7a5488f0', {boundingbox:[-5,5,5,-5], keepaspectratio:true, axis:true, showcopyright: false});\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -1 ], {size: 5, strokeColor:'yellow', fillColor:'yellow'}));\n *  p.push(board.create('point',[2, 1 ], {size: 5, strokeColor:'red', fillColor:'red'}));\n *  p.push(board.create('point',[-2, 1], {size: 5, strokeColor:col, fillColor:col}));\n *  q = board.create('point',[0, 0], {size: 5, strokeColor:col, fillColor:col});\n *\n *  pol = board.create('polygon', p, {hasInnerPoints: true});\n *  g = board.create('group', p.concat(q)).setRotationCenter('centroid').setRotationPoints([p[2]]);\n *  g.setScaleCenter(p[0]).setScalePoints(p[1]);\n *  g.removeTranslationPoint(q);\n *  })();\n * </script><pre>\n *\n *\n */\nJXG.createGroup = function (board, parents, attributes) {\n    var attr = Type.copyAttributes(attributes, board.options, \"group\"),\n        g = new JXG.Group(board, attr.id, attr.name, parents, attr);\n\n    g.elType = \"group\";\n    g.setParents(parents);\n\n    return g;\n};\n\nJXG.registerElement(\"group\", JXG.createGroup);\n\nexport default {\n    Group: JXG.Group,\n    createGroup: JXG.createGroup\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the conic sections defined.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"../math/math\";\nimport Numerics from \"../math/numerics\";\nimport Geometry from \"../math/geometry\";\nimport Type from \"../utils/type\";\n\n/**\n * @class This element is used to provide a constructor for an ellipse. An ellipse is given by two points (the foci) and a third point on the the ellipse or\n * the length of the major axis.\n * @pseudo\n * @description\n * @name Ellipse\n * @augments Conic\n * @constructor\n * @type JXG.Curve\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point,array_JXG.Point,array_JXG.Point,array} point1,point2,point3 Parent elements can be three elements either of type {@link JXG.Point} or array of\n * numbers describing the coordinates of a point. In the latter case the point will be constructed automatically as a fixed invisible point.\n * @param {JXG.Point,array_JXG.Point,array_number,function} point1,point2,number Parent elements can be two elements either of type {@link JXG.Point} or array of\n * numbers describing the coordinates of a point. The third parameter is a number/function which defines the length of the major axis\n * @param {Number} start (Optional) parameter of the curve start, default: 0.\n * @param {Number} end (Optional) parameter for the curve end, default: 2&pi;.\n * @example\n * // Create an Ellipse by three points\n * var A = board.create('point', [-1,4]);\n * var B = board.create('point', [-1,-4]);\n * var C = board.create('point', [1,1]);\n * var el = board.create('ellipse',[A,B,C]);\n * </pre><div class=\"jxgbox\" id=\"JXGa4d7fb6f-8708-4e45-87f2-2379ae2bd2c0\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   (function() {\n *   var glex1_board = JXG.JSXGraph.initBoard('JXGa4d7fb6f-8708-4e45-87f2-2379ae2bd2c0', {boundingbox:[-6,6,6,-6], keepaspectratio:true, showcopyright: false, shownavigation: false});\n *   var A = glex1_board.create('point', [-1,4]);\n *   var B = glex1_board.create('point', [-1,-4]);\n *   var C = glex1_board.create('point', [1,1]);\n *   var el = glex1_board.create('ellipse',[A,B,C]);\n * })();\n * </script><pre>\n *\n * @example\n * // Create an elliptical arc\n * var p1 = board.create('point', [-1, 2]);\n * var p2 = board.create('point', [ 1, 2]);\n * var p3 = board.create('point', [0, 3]);\n *\n * var ell = board.create('ellipse', [\n *   p1, p2, p3, 0, Math.PI], {\n *   lastArrow: {type: 7}\n * });\n *\n * </pre><div id=\"JXG950f7c07-27a4-4c67-9505-c73c22ce9345\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG950f7c07-27a4-4c67-9505-c73c22ce9345',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p1 = board.create('point', [-1, 2]);\n *     var p2 = board.create('point', [ 1, 2]);\n *     var p3 = board.create('point', [0, 3]);\n *\n *     var ell = board.create('ellipse', [\n *       p1, p2, p3, 0, Math.PI], {\n *       lastArrow: {type: 7}\n *     });\n *\n *     })();\n *\n * </script><pre>\n *\n *\n */\nJXG.createEllipse = function (board, parents, attributes) {\n    var polarForm,\n        curve,\n        M,\n        C,\n        majorAxis,\n        i,\n        hasPointOrg,\n        // focus 1 and focus 2\n        F = [],\n        attr_foci = Type.copyAttributes(attributes, board.options, \"conic\", \"foci\"),\n        attr_center = Type.copyAttributes(attributes, board.options, \"conic\", \"center\"),\n        attr_curve = Type.copyAttributes(attributes, board.options, \"conic\");\n\n    // The foci and the third point are either points or coordinate arrays.\n    for (i = 0; i < 2; i++) {\n        // focus i given by coordinates\n        if (parents[i].length > 1) {\n            F[i] = board.create(\"point\", parents[i], attr_foci);\n            // focus i given by point\n        } else if (Type.isPoint(parents[i])) {\n            F[i] = board.select(parents[i]);\n            // given by function\n        } else if (Type.isFunction(parents[i]) && Type.isPoint(parents[i]())) {\n            F[i] = parents[i]();\n            // focus i given by point name\n        } else if (Type.isString(parents[i])) {\n            F[i] = board.select(parents[i]);\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create Ellipse with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,point,point], [point,point,number|function]\"\n            );\n        }\n    }\n\n    // length of major axis\n    if (Type.isNumber(parents[2])) {\n        majorAxis = Type.createFunction(parents[2], board);\n    } else if (Type.isFunction(parents[2]) && Type.isNumber(parents[2]())) {\n        majorAxis = parents[2];\n    } else {\n        // point on ellipse\n        if (Type.isPoint(parents[2])) {\n            C = board.select(parents[2]);\n            // point on ellipse given by coordinates\n        } else if (parents[2].length > 1) {\n            C = board.create(\"point\", parents[2], attr_foci);\n            // given by function\n        } else if (Type.isFunction(parents[2]) && Type.isPoint(parents[2]())) {\n            C = parents[2]();\n            // focus i given by point name\n        } else if (Type.isString(parents[2])) {\n            C = board.select(parents[2]);\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create Ellipse with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"' and '\" +\n                    typeof parents[2] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,point,point], [point,point,number|function]\"\n            );\n        }\n        /** @ignore */\n        majorAxis = function () {\n            return C.Dist(F[0]) + C.Dist(F[1]);\n        };\n    }\n\n    // to\n    if (!Type.exists(parents[4])) {\n        parents[4] = 2 * Math.PI;\n    }\n\n    // from\n    if (!Type.exists(parents[3])) {\n        parents[3] = 0.0;\n    }\n\n    M = board.create(\n        \"point\",\n        [\n            function () {\n                return (F[0].X() + F[1].X()) * 0.5;\n            },\n            function () {\n                return (F[0].Y() + F[1].Y()) * 0.5;\n            }\n        ],\n        attr_center\n    );\n\n    curve = board.create(\n        \"curve\",\n        [\n            function (x) {\n                return 0;\n            },\n            function (x) {\n                return 0;\n            },\n            parents[3],\n            parents[4]\n        ],\n        attr_curve\n    );\n\n    curve.majorAxis = majorAxis;\n\n    // Save the original hasPoint method. It will be called inside of the new hasPoint method.\n    hasPointOrg = curve.hasPoint;\n\n    /** @ignore */\n    polarForm = function (phi, suspendUpdate) {\n        var r, rr, ax, ay, bx, by, axbx, ayby, f;\n\n        if (!suspendUpdate) {\n            r = majorAxis();\n            rr = r * r;\n            ax = F[0].X();\n            ay = F[0].Y();\n            bx = F[1].X();\n            by = F[1].Y();\n            axbx = ax - bx;\n            ayby = ay - by;\n            f = (rr - ax * ax - ay * ay + bx * bx + by * by) / (2 * r);\n\n            curve.quadraticform = [\n                [f * f - bx * bx - by * by, (f * axbx) / r + bx, (f * ayby) / r + by],\n                [(f * axbx) / r + bx, (axbx * axbx) / rr - 1, (axbx * ayby) / rr],\n                [(f * ayby) / r + by, (axbx * ayby) / rr, (ayby * ayby) / rr - 1]\n            ];\n        }\n    };\n\n    /** @ignore */\n    curve.X = function (phi, suspendUpdate) {\n        var r = majorAxis(),\n            c = F[1].Dist(F[0]),\n            b = (0.5 * (c * c - r * r)) / (c * Math.cos(phi) - r),\n            beta = Math.atan2(F[1].Y() - F[0].Y(), F[1].X() - F[0].X());\n\n        if (!suspendUpdate) {\n            polarForm(phi, suspendUpdate);\n        }\n\n        return F[0].X() + Math.cos(beta + phi) * b;\n    };\n\n    /** @ignore */\n    curve.Y = function (phi, suspendUpdate) {\n        var r = majorAxis(),\n            c = F[1].Dist(F[0]),\n            b = (0.5 * (c * c - r * r)) / (c * Math.cos(phi) - r),\n            beta = Math.atan2(F[1].Y() - F[0].Y(), F[1].X() - F[0].X());\n\n        return F[0].Y() + Math.sin(beta + phi) * b;\n    };\n\n    curve.midpoint = curve.center = M;\n    curve.type = Const.OBJECT_TYPE_CONIC;\n    curve.subs = {\n        center: curve.center\n    };\n    curve.inherits.push(curve.center, F[0], F[1]);\n    if (Type.isPoint(C)) {\n        curve.inherits.push(C);\n    }\n\n    /**\n     * Checks whether (x,y) is near the ellipse line or inside of the ellipse\n     * (in case JXG.Options.conic#hasInnerPoints is true).\n     * @param {Number} x Coordinate in x direction, screen coordinates.\n     * @param {Number} y Coordinate in y direction, screen coordinates.\n     * @returns {Boolean} True if (x,y) is near the ellipse, False otherwise.\n     * @private\n     */\n    curve.hasPoint = function (x, y) {\n        var ac, bc, r, p, dist;\n\n        if (Type.evaluate(this.visProp.hasinnerpoints)) {\n            ac = F[0].coords;\n            bc = F[1].coords;\n            r = this.majorAxis();\n            p = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board);\n            dist = p.distance(Const.COORDS_BY_USER, ac) + p.distance(Const.COORDS_BY_USER, bc);\n\n            return dist <= r;\n        }\n\n        return hasPointOrg.apply(this, arguments);\n    };\n\n    M.addChild(curve);\n    for (i = 0; i < 2; i++) {\n        if (Type.isPoint(F[i])) {\n            F[i].addChild(curve);\n        }\n    }\n    if (Type.isPoint(C)) {\n        C.addChild(curve);\n    }\n    curve.setParents(parents);\n\n    return curve;\n};\n\n/**\n * @class This element is used to provide a constructor for an hyperbola. An hyperbola is given by two points (the foci) and a third point on the the hyperbola or\n * the length of the major axis.\n * @pseudo\n * @description\n * @name Hyperbola\n * @augments Conic\n * @constructor\n * @type JXG.Curve\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point,array_JXG.Point,array_JXG.Point,array} point1,point2,point3 Parent elements can be three elements either of type {@link JXG.Point} or array of\n * numbers describing the coordinates of a point. In the latter case the point will be constructed automatically as a fixed invisible point.\n * @param {JXG.Point,array_JXG.Point,array_number,function} point1,point2,number Parent elements can be two elements either of type {@link JXG.Point} or array of\n * numbers describing the coordinates of a point. The third parameter is a number/function which defines the length of the major axis\n * @param {Number} start (Optional) parameter of the curve start, default: -&pi;.\n * @param {Number} end (Optional) parameter for the curve end, default: &pi;.\n * @example\n * // Create an Hyperbola by three points\n * var A = board.create('point', [-1,4]);\n * var B = board.create('point', [-1,-4]);\n * var C = board.create('point', [1,1]);\n * var el = board.create('hyperbola',[A,B,C]);\n * </pre><div class=\"jxgbox\" id=\"JXGcf99049d-a3fe-407f-b936-27d76550f8c4\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   (function(){\n *   var glex1_board = JXG.JSXGraph.initBoard('JXGcf99049d-a3fe-407f-b936-27d76550f8c4', {boundingbox:[-6,6,6,-6], keepaspectratio:true, showcopyright: false, shownavigation: false});\n *   var A = glex1_board.create('point', [-1,4]);\n *   var B = glex1_board.create('point', [-1,-4]);\n *   var C = glex1_board.create('point', [1,1]);\n *   var el = glex1_board.create('hyperbola',[A,B,C]);\n * })();\n * </script><pre>\n */\nJXG.createHyperbola = function (board, parents, attributes) {\n    var polarForm,\n        curve,\n        M,\n        C,\n        majorAxis,\n        i,\n        // focus 1 and focus 2\n        F = [],\n        attr_foci = Type.copyAttributes(attributes, board.options, \"conic\", \"foci\"),\n        attr_center = Type.copyAttributes(attributes, board.options, \"conic\", \"center\"),\n        attr_curve = Type.copyAttributes(attributes, board.options, \"conic\");\n\n    // The foci and the third point are either points or coordinate arrays.\n    for (i = 0; i < 2; i++) {\n        // focus i given by coordinates\n        if (parents[i].length > 1) {\n            F[i] = board.create(\"point\", parents[i], attr_foci);\n            // focus i given by point\n        } else if (Type.isPoint(parents[i])) {\n            F[i] = board.select(parents[i]);\n            // given by function\n        } else if (Type.isFunction(parents[i]) && Type.isPoint(parents[i]())) {\n            F[i] = parents[i]();\n            // focus i given by point name\n        } else if (Type.isString(parents[i])) {\n            F[i] = board.select(parents[i]);\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create Hyperbola with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,point,point], [point,point,number|function]\"\n            );\n        }\n    }\n\n    // length of major axis\n    if (Type.isNumber(parents[2])) {\n        majorAxis = Type.createFunction(parents[2], board);\n    } else if (Type.isFunction(parents[2]) && Type.isNumber(parents[2]())) {\n        majorAxis = parents[2];\n    } else {\n        // point on ellipse\n        if (Type.isPoint(parents[2])) {\n            C = board.select(parents[2]);\n            // point on ellipse given by coordinates\n        } else if (parents[2].length > 1) {\n            C = board.create(\"point\", parents[2], attr_foci);\n            // given by function\n        } else if (Type.isFunction(parents[2]) && Type.isPoint(parents[2]())) {\n            C = parents[2]();\n            // focus i given by point name\n        } else if (Type.isString(parents[2])) {\n            C = board.select(parents[2]);\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create Hyperbola with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"' and '\" +\n                    typeof parents[2] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,point,point], [point,point,number|function]\"\n            );\n        }\n        /** @ignore */\n        majorAxis = function () {\n            return C.Dist(F[0]) - C.Dist(F[1]);\n        };\n    }\n\n    // to\n    if (!Type.exists(parents[4])) {\n        parents[4] = 1.0001 * Math.PI;\n    }\n\n    // from\n    if (!Type.exists(parents[3])) {\n        parents[3] = -1.0001 * Math.PI;\n    }\n\n    M = board.create(\n        \"point\",\n        [\n            function () {\n                return (F[0].X() + F[1].X()) * 0.5;\n            },\n            function () {\n                return (F[0].Y() + F[1].Y()) * 0.5;\n            }\n        ],\n        attr_center\n    );\n\n    curve = board.create(\n        \"curve\",\n        [\n            function (x) {\n                return 0;\n            },\n            function (x) {\n                return 0;\n            },\n            parents[3],\n            parents[4]\n        ],\n        attr_curve\n    );\n\n    curve.majorAxis = majorAxis;\n\n    // Hyperbola is defined by (a*sec(t),b*tan(t)) and sec(t) = 1/cos(t)\n    /** @ignore */\n    polarForm = function (phi, suspendUpdate) {\n        var r, rr, ax, ay, bx, by, axbx, ayby, f;\n\n        if (!suspendUpdate) {\n            r = majorAxis();\n            rr = r * r;\n            ax = F[0].X();\n            ay = F[0].Y();\n            bx = F[1].X();\n            by = F[1].Y();\n            axbx = ax - bx;\n            ayby = ay - by;\n            f = (rr - ax * ax - ay * ay + bx * bx + by * by) / (2 * r);\n\n            curve.quadraticform = [\n                [f * f - bx * bx - by * by, (f * axbx) / r + bx, (f * ayby) / r + by],\n                [(f * axbx) / r + bx, (axbx * axbx) / rr - 1, (axbx * ayby) / rr],\n                [(f * ayby) / r + by, (axbx * ayby) / rr, (ayby * ayby) / rr - 1]\n            ];\n        }\n    };\n\n    /** @ignore */\n    curve.X = function (phi, suspendUpdate) {\n        var r = majorAxis(),\n            c = F[1].Dist(F[0]),\n            b = (0.5 * (c * c - r * r)) / (c * Math.cos(phi) + r),\n            beta = Math.atan2(F[1].Y() - F[0].Y(), F[1].X() - F[0].X());\n\n        if (!suspendUpdate) {\n            polarForm(phi, suspendUpdate);\n        }\n\n        return F[0].X() + Math.cos(beta + phi) * b;\n    };\n\n    /** @ignore */\n    curve.Y = function (phi, suspendUpdate) {\n        var r = majorAxis(),\n            c = F[1].Dist(F[0]),\n            b = (0.5 * (c * c - r * r)) / (c * Math.cos(phi) + r),\n            beta = Math.atan2(F[1].Y() - F[0].Y(), F[1].X() - F[0].X());\n\n        return F[0].Y() + Math.sin(beta + phi) * b;\n    };\n\n    curve.midpoint = curve.center = M;\n    curve.subs = {\n        center: curve.center\n    };\n    curve.inherits.push(curve.center, F[0], F[1]);\n    if (Type.isPoint(C)) {\n        curve.inherits.push(C);\n    }\n    curve.type = Const.OBJECT_TYPE_CONIC;\n\n    M.addChild(curve);\n    for (i = 0; i < 2; i++) {\n        if (Type.isPoint(F[i])) {\n            F[i].addChild(curve);\n        }\n    }\n    if (Type.isPoint(C)) {\n        C.addChild(curve);\n    }\n    curve.setParents(parents);\n\n    return curve;\n};\n\n/**\n * @class This element is used to provide a constructor for a parabola. A parabola is given by one point (the focus) and a line (the directrix).\n * @pseudo\n * @description\n * @name Parabola\n * @augments Conic\n * @constructor\n * @type JXG.Curve\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point,array_JXG.Line} point,line Parent elements are a point and a line or a pair of coordinates.\n * Optional parameters three and four are numbers which define the curve length (e.g. start/end). Default values are -pi and pi.\n * @example\n * // Create a parabola by a point C and a line l.\n * var A = board.create('point', [-1,4]);\n * var B = board.create('point', [-1,-4]);\n * var l = board.create('line', [A,B]);\n * var C = board.create('point', [1,1]);\n * var el = board.create('parabola',[C,l]);\n * </pre><div class=\"jxgbox\" id=\"JXG524d1aae-217d-44d4-ac58-a19c7ab1de36\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function() {\n *   var glex1_board = JXG.JSXGraph.initBoard('JXG524d1aae-217d-44d4-ac58-a19c7ab1de36', {boundingbox:[-6,6,6,-6], keepaspectratio:true, showcopyright: false, shownavigation: false});\n *   var A = glex1_board.create('point', [-1,4]);\n *   var B = glex1_board.create('point', [-1,-4]);\n *   var l = glex1_board.create('line', [A,B]);\n *   var C = glex1_board.create('point', [1,1]);\n *   var el = glex1_board.create('parabola',[C,l]);\n * })();\n * </script><pre>\n *\n * @example\n * var par = board.create('parabola',[[3.25, 0], [[0.25, 1],[0.25, 0]]]);\n *\n * </pre><div id=\"JXG09252542-b77a-4990-a109-66ffb649a472\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG09252542-b77a-4990-a109-66ffb649a472',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var par = board.create('parabola',[[3.25, 0], [[0.25, 1],[0.25, 0]]]);\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createParabola = function (board, parents, attributes) {\n    var polarForm,\n        curve,\n        M,\n        // focus\n        F1 = parents[0],\n        // directrix\n        l = parents[1],\n        attr_foci = Type.copyAttributes(attributes, board.options, \"conic\", \"foci\"),\n        attr_center = Type.copyAttributes(attributes, board.options, \"conic\", \"center\"),\n        attr_curve = Type.copyAttributes(attributes, board.options, \"conic\"),\n        attr_line;\n\n    // focus 1 given by coordinates\n    if (parents[0].length > 1) {\n        F1 = board.create(\"point\", parents[0], attr_foci);\n        // focus 1 given by point\n    } else if (Type.isPoint(parents[0])) {\n        F1 = board.select(parents[0]);\n        // given by function\n    } else if (Type.isFunction(parents[0]) && Type.isPoint(parents[0]())) {\n        F1 = parents[0]();\n        // focus 1 given by point name\n    } else if (Type.isString(parents[0])) {\n        F1 = board.select(parents[0]);\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create Parabola with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,line]\"\n        );\n    }\n\n    // Create line if given as array of two points.\n    if (Type.isArray(l) && l.length === 2) {\n        attr_line = Type.copyAttributes(attributes, board.options, \"conic\", \"line\");\n        l = board.create(\"line\", l, attr_line);\n    }\n\n    // to\n    if (!Type.exists(parents[3])) {\n        parents[3] = 2 * Math.PI;\n    }\n\n    // from\n    if (!Type.exists(parents[2])) {\n        parents[2] = 0;\n    }\n\n    M = board.create(\n        \"point\",\n        [\n            function () {\n                /*\n                var v = [0, l.stdform[1], l.stdform[2]];\n                v = Mat.crossProduct(v, F1.coords.usrCoords);\n                return Geometry.meetLineLine(v, l.stdform, 0, board).usrCoords;\n                */\n                return Geometry.projectPointToLine(F1, l, board).usrCoords;\n            }\n        ],\n        attr_center\n    );\n\n    /** @ignore */\n    curve = board.create(\n        \"curve\",\n        [\n            function (x) {\n                return 0;\n            },\n            function (x) {\n                return 0;\n            },\n            parents[2],\n            parents[3]\n        ],\n        attr_curve\n    );\n\n    curve.midpoint = curve.center = M;\n    curve.subs = {\n        center: curve.center\n    };\n    curve.inherits.push(curve.center);\n\n    /** @ignore */\n    polarForm = function (t, suspendUpdate) {\n        var a, b, c, ab, px, py;\n\n        if (!suspendUpdate) {\n            a = l.stdform[1];\n            b = l.stdform[2];\n            c = l.stdform[0];\n            ab = a * a + b * b;\n            px = F1.X();\n            py = F1.Y();\n\n            curve.quadraticform = [\n                [c * c - ab * (px * px + py * py), c * a + ab * px, c * b + ab * py],\n                [c * a + ab * px, -b * b, a * b],\n                [c * b + ab * py, a * b, -a * a]\n            ];\n        }\n    };\n\n    /** @ignore */\n    curve.X = function (phi, suspendUpdate) {\n        var a,\n            det,\n            beta = l.getAngle(),\n            d = Geometry.distPointLine(F1.coords.usrCoords, l.stdform),\n            A = l.point1.coords.usrCoords,\n            B = l.point2.coords.usrCoords,\n            M = F1.coords.usrCoords;\n\n        // Handle the case if one of the two defining points of the line is an ideal point\n        if (A[0] === 0) {\n            A = [1, B[1] + l.stdform[2], B[2] - l.stdform[1]];\n        } else if (B[0] === 0) {\n            B = [1, A[1] + l.stdform[2], A[2] - l.stdform[1]];\n        }\n        det = (B[1] - A[1]) * (M[2] - A[2]) - (B[2] - A[2]) * (M[1] - A[1]) >= 0 ? 1 : -1;\n        a = (det * d) / (1 - Math.sin(phi));\n\n        if (!suspendUpdate) {\n            polarForm(phi, suspendUpdate);\n        }\n\n        return F1.X() + Math.cos(phi + beta) * a;\n    };\n\n    /** @ignore */\n    curve.Y = function (phi, suspendUpdate) {\n        var a,\n            det,\n            beta = l.getAngle(),\n            d = Geometry.distPointLine(F1.coords.usrCoords, l.stdform),\n            A = l.point1.coords.usrCoords,\n            B = l.point2.coords.usrCoords,\n            M = F1.coords.usrCoords;\n\n        // Handle the case if one of the two defining points of the line is an ideal point\n        if (A[0] === 0) {\n            A = [1, B[1] + l.stdform[2], B[2] - l.stdform[1]];\n        } else if (B[0] === 0) {\n            B = [1, A[1] + l.stdform[2], A[2] - l.stdform[1]];\n        }\n        det = (B[1] - A[1]) * (M[2] - A[2]) - (B[2] - A[2]) * (M[1] - A[1]) >= 0 ? 1 : -1;\n        a = (det * d) / (1 - Math.sin(phi));\n\n        return F1.Y() + Math.sin(phi + beta) * a;\n    };\n\n    curve.type = Const.OBJECT_TYPE_CONIC;\n    M.addChild(curve);\n\n    if (Type.isPoint(F1)) {\n        F1.addChild(curve);\n        curve.inherits.push(F1);\n    }\n\n    l.addChild(curve);\n    curve.setParents(parents);\n\n    return curve;\n};\n\n/**\n *\n * @class This element is used to provide a constructor for a generic conic section uniquely defined by five points or\n * a conic defined by the coefficients of the equation\n * <p><i>Ax<sup>2</sup>+ Bxy+Cy<sup>2</sup> + Dx + Ey + F = 0</i></p>.\n * Then the parameters are as follows:\n * <pre>\n *     board.create('conic', [A, C, F, B/2, D/2, E/2]);\n * </pre>\n * @pseudo\n * @description\n * @name Conic\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Conic\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point,Array_JXG.Point,Array_JXG.Point,Array_JXG.Point,Array_JXG.Point,Array} a,b,c,d,e Parent elements are five points.\n * @param {Number_Number_Number_Number_Number_Number} a_00,a_11,a_22,a_01,a_02,a_12 6 numbers, i.e. A, C, F, B/2, D/2, E/2\n * @example\n * // Create a conic section through the points A, B, C, D, and E.\n *  var A = board.create('point', [1,5]);\n *  var B = board.create('point', [1,2]);\n *  var C = board.create('point', [2,0]);\n *  var D = board.create('point', [0,0]);\n *  var E = board.create('point', [-1,5]);\n *  var conic = board.create('conic',[A,B,C,D,E]);\n * </pre><div class=\"jxgbox\" id=\"JXG2d79bd6a-db9b-423c-9cba-2497f0b06320\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function(){\n *   var glex1_board = JXG.JSXGraph.initBoard('JXG2d79bd6a-db9b-423c-9cba-2497f0b06320', {boundingbox:[-6,6,6,-6], keepaspectratio:true, showcopyright: false, shownavigation: false});\n *   var A = glex1_board.create('point', [1,5]);\n *   var B = glex1_board.create('point', [1,2]);\n *   var C = glex1_board.create('point', [2,0]);\n *   var D = glex1_board.create('point', [0,0]);\n *   var E = glex1_board.create('point', [-1,5]);\n *   var conic = glex1_board.create('conic',[A,B,C,D,E]);\n * })();\n * </script><pre>\n *\n * @example\n * // Parameters: A, C, F, B/2, D/2, E/2\n * var conic = board.create('conic', [1, 2, -4, 0, 0, 0]);\n *\n * </pre><div id=\"JXG8576a04a-52d8-4a7e-8d54-e32443910b97\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG8576a04a-52d8-4a7e-8d54-e32443910b97',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     // Parameters: A, C, F, B/2, D/2, E/2\n *     var conic = board.create('conic', [1, 2, -4, 0, 0, 0]);\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createConic = function (board, parents, attributes) {\n    var polarForm,\n        curve,\n        fitConic,\n        degconic,\n        sym,\n        eigen,\n        a,\n        b,\n        c,\n        c1,\n        c2,\n        i,\n        definingMat,\n        givenByPoints,\n        rotationMatrix = [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ],\n        M = [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ],\n        points = [],\n        p = [],\n        attr_point = Type.copyAttributes(attributes, board.options, \"conic\", \"point\"),\n        attr_center = Type.copyAttributes(attributes, board.options, \"conic\", \"center\"),\n        attr_curve = Type.copyAttributes(attributes, board.options, \"conic\");\n\n    if (parents.length === 5) {\n        givenByPoints = true;\n    } else if (parents.length === 6) {\n        givenByPoints = false;\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create generic Conic with \" + parents.length + \" parameters.\"\n        );\n    }\n\n    if (givenByPoints) {\n        for (i = 0; i < 5; i++) {\n            // point i given by coordinates\n            if (parents[i].length > 1) {\n                points[i] = board.create(\"point\", parents[i], attr_point);\n                // point i given by point\n            } else if (Type.isPoint(parents[i])) {\n                points[i] = board.select(parents[i]);\n                // given by function\n            } else if (Type.isFunction(parents[i]) && Type.isPoint(parents[i]())) {\n                points[i] = parents[i]();\n                // point i given by point name\n            } else if (Type.isString(parents[i])) {\n                points[i] = board.select(parents[i]);\n            } else {\n                throw new Error(\n                    \"JSXGraph: Can't create Conic section with parent types '\" +\n                        typeof parents[i] +\n                        \"'.\" +\n                        \"\\nPossible parent types: [point,point,point,point,point], [a00,a11,a22,a01,a02,a12]\"\n                );\n            }\n        }\n    } else {\n        /* Usual notation (x,y,z):\n         *  [[A0,A3,A4],\n         *   [A3,A1,A5],\n         *   [A4,A5,A2]].\n         * Our notation (z,x,y):\n         *  [[A2, A4, A5],\n         *   [A4, A0, A3],\n         *   [A5, A3, A1]]\n         */\n        definingMat = [\n            [0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]\n        ];\n        definingMat[0][0] = Type.isFunction(parents[2])\n            ? function () {\n                  return parents[2]();\n              }\n            : function () {\n                  return parents[2];\n              };\n        definingMat[0][1] = Type.isFunction(parents[4])\n            ? function () {\n                  return parents[4]();\n              }\n            : function () {\n                  return parents[4];\n              };\n        definingMat[0][2] = Type.isFunction(parents[5])\n            ? function () {\n                  return parents[5]();\n              }\n            : function () {\n                  return parents[5];\n              };\n        definingMat[1][1] = Type.isFunction(parents[0])\n            ? function () {\n                  return parents[0]();\n              }\n            : function () {\n                  return parents[0];\n              };\n        definingMat[1][2] = Type.isFunction(parents[3])\n            ? function () {\n                  return parents[3]();\n              }\n            : function () {\n                  return parents[3];\n              };\n        definingMat[2][2] = Type.isFunction(parents[1])\n            ? function () {\n                  return parents[1]();\n              }\n            : function () {\n                  return parents[1];\n              };\n    }\n\n    // sym(A) = A + A^t . Manipulates A in place.\n    sym = function (A) {\n        var i, j;\n        for (i = 0; i < 3; i++) {\n            for (j = i; j < 3; j++) {\n                A[i][j] += A[j][i];\n            }\n        }\n        for (i = 0; i < 3; i++) {\n            for (j = 0; j < i; j++) {\n                A[i][j] = A[j][i];\n            }\n        }\n        return A;\n    };\n\n    // degconic(v,w) = sym(v*w^t)\n    degconic = function (v, w) {\n        var i,\n            j,\n            mat = [\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ];\n\n        for (i = 0; i < 3; i++) {\n            for (j = 0; j < 3; j++) {\n                mat[i][j] = v[i] * w[j];\n            }\n        }\n\n        return sym(mat);\n    };\n\n    // (p^t*B*p)*A-(p^t*A*p)*B\n    fitConic = function (A, B, p) {\n        var i,\n            j,\n            pBp,\n            pAp,\n            Mv,\n            mat = [\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ];\n\n        Mv = Mat.matVecMult(B, p);\n        pBp = Mat.innerProduct(p, Mv);\n        Mv = Mat.matVecMult(A, p);\n        pAp = Mat.innerProduct(p, Mv);\n\n        for (i = 0; i < 3; i++) {\n            for (j = 0; j < 3; j++) {\n                mat[i][j] = pBp * A[i][j] - pAp * B[i][j];\n            }\n        }\n        return mat;\n    };\n\n    // Here, the defining functions for the curve are just dummy functions.\n    // In polarForm there is a reference to curve.quadraticform.\n    curve = board.create(\n        \"curve\",\n        [\n            function (x) {\n                return 0;\n            },\n            function (x) {\n                return 0;\n            },\n            0,\n            2 * Math.PI\n        ],\n        attr_curve\n    );\n\n    /** @ignore */\n    polarForm = function (phi, suspendUpdate) {\n        var i, j, len, v;\n\n        if (!suspendUpdate) {\n            if (givenByPoints) {\n                // Copy the point coordinate vectors\n                for (i = 0; i < 5; i++) {\n                    p[i] = points[i].coords.usrCoords;\n                }\n\n                // Compute the quadratic form\n                c1 = degconic(Mat.crossProduct(p[0], p[1]), Mat.crossProduct(p[2], p[3]));\n                c2 = degconic(Mat.crossProduct(p[0], p[2]), Mat.crossProduct(p[1], p[3]));\n                M = fitConic(c1, c2, p[4]);\n            } else {\n                for (i = 0; i < 3; i++) {\n                    for (j = i; j < 3; j++) {\n                        M[i][j] = definingMat[i][j]();\n                        if (j > i) {\n                            M[j][i] = M[i][j];\n                        }\n                    }\n                }\n            }\n\n            // Here is the reference back to the curve.\n            curve.quadraticform = M;\n\n            // Compute Eigenvalues and Eigenvectors\n            eigen = Numerics.Jacobi(M);\n\n            // Scale the Eigenvalues such that the first Eigenvalue is positive\n            if (eigen[0][0][0] < 0) {\n                eigen[0][0][0] *= -1;\n                eigen[0][1][1] *= -1;\n                eigen[0][2][2] *= -1;\n            }\n\n            // Normalize the Eigenvectors\n            for (i = 0; i < 3; i++) {\n                len = 0.0;\n                for (j = 0; j < 3; j++) {\n                    len += eigen[1][j][i] * eigen[1][j][i];\n                }\n                len = Math.sqrt(len);\n                /*for (j = 0; j < 3; j++) {\n                        //eigen[1][j][i] /= len;\n                    }*/\n            }\n            rotationMatrix = eigen[1];\n            c = Math.sqrt(Math.abs(eigen[0][0][0]));\n            a = Math.sqrt(Math.abs(eigen[0][1][1]));\n            b = Math.sqrt(Math.abs(eigen[0][2][2]));\n        }\n\n        // The degenerate cases with eigen[0][i][i]==0 are not handled correct yet.\n        if (eigen[0][1][1] <= 0.0 && eigen[0][2][2] <= 0.0) {\n            v = Mat.matVecMult(rotationMatrix, [1 / c, Math.cos(phi) / a, Math.sin(phi) / b]);\n        } else if (eigen[0][1][1] <= 0.0 && eigen[0][2][2] > 0.0) {\n            v = Mat.matVecMult(rotationMatrix, [Math.cos(phi) / c, 1 / a, Math.sin(phi) / b]);\n        } else if (eigen[0][2][2] < 0.0) {\n            v = Mat.matVecMult(rotationMatrix, [Math.sin(phi) / c, Math.cos(phi) / a, 1 / b]);\n        }\n\n        if (Type.exists(v)) {\n            // Normalize\n            v[1] /= v[0];\n            v[2] /= v[0];\n            v[0] = 1.0;\n        } else {\n            v = [1, NaN, NaN];\n        }\n\n        return v;\n    };\n\n    /** @ignore */\n    curve.X = function (phi, suspendUpdate) {\n        return polarForm(phi, suspendUpdate)[1];\n    };\n\n    /** @ignore */\n    curve.Y = function (phi, suspendUpdate) {\n        return polarForm(phi, suspendUpdate)[2];\n    };\n\n    // Center coordinates see http://en.wikipedia.org/wiki/Matrix_representation_of_conic_sections\n    curve.midpoint = board.create(\n        \"point\",\n        [\n            function () {\n                var m = curve.quadraticform;\n\n                return [\n                    m[1][1] * m[2][2] - m[1][2] * m[1][2],\n                    m[1][2] * m[0][2] - m[2][2] * m[0][1],\n                    m[0][1] * m[1][2] - m[1][1] * m[0][2]\n                ];\n            }\n        ],\n        attr_center\n    );\n\n    curve.type = Const.OBJECT_TYPE_CONIC;\n    curve.center = curve.midpoint;\n    curve.subs = {\n        center: curve.center\n    };\n    curve.inherits.push(curve.center);\n    curve.inherits = curve.inherits.concat(points);\n\n    if (givenByPoints) {\n        for (i = 0; i < 5; i++) {\n            if (Type.isPoint(points[i])) {\n                points[i].addChild(curve);\n            }\n        }\n        curve.setParents(parents);\n    }\n    curve.addChild(curve.center);\n\n    return curve;\n};\n\nJXG.registerElement(\"ellipse\", JXG.createEllipse);\nJXG.registerElement(\"hyperbola\", JXG.createHyperbola);\nJXG.registerElement(\"parabola\", JXG.createParabola);\nJXG.registerElement(\"conic\", JXG.createConic);\n\nexport default {\n    createEllipse: JXG.createEllipse,\n    createHyperbola: JXG.createHyperbola,\n    createParabola: JXG.createParabola,\n    createConic: JXG.createConic\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The geometry object Circle is defined in this file. Circle stores all\n * style and functional properties that are required to draw and move a circle on\n * a board.\n */\n\nimport JXG from \"../jxg\";\nimport GeometryElement from \"./element\";\nimport Coords from \"./coords\";\nimport Const from \"./constants\";\nimport Conic from \"../element/conic\";\nimport GeonextParser from \"../parser/geonext\";\nimport Type from \"../utils/type\";\n\n/**\n * A circle consists of all points with a given distance from one point. This point is called center, the distance is called radius.\n * A circle can be constructed by providing a center and a point on the circle or a center and a radius (given as a number, function,\n * line, or circle).\n * @class Creates a new circle object. Do not use this constructor to create a circle. Use {@link JXG.Board#create} with\n * type {@link Circle} instead.\n * @constructor\n * @augments JXG.GeometryElement\n * @param {JXG.Board} board The board the new circle is drawn on.\n * @param {String} method Can be\n * <ul><li> <b>'twoPoints'</b> which means the circle is defined by its center and a point on the circle.</li>\n * <li><b>'pointRadius'</b> which means the circle is defined by its center and its radius in user units</li>\n * <li><b>'pointLine'</b> which means the circle is defined by its center and its radius given by the distance from the startpoint and the endpoint of the line</li>\n * <li><b>'pointCircle'</b> which means the circle is defined by its center and its radius given by the radius of another circle</li></ul>\n * The parameters p1, p2 and radius must be set according to this method parameter.\n * @param {JXG.Point} par1 center of the circle.\n * @param {JXG.Point|JXG.Line|JXG.Circle} par2 Can be\n * <ul><li>a point on the circle if method is 'twoPoints'</li>\n * <li>a line if the method is 'pointLine'</li>\n * <li>a circle if the method is 'pointCircle'</li></ul>\n * @param {Object} attributes\n * @see JXG.Board#generateName\n */\nJXG.Circle = function (board, method, par1, par2, attributes) {\n    // Call the constructor of GeometryElement\n    this.constructor(board, attributes, Const.OBJECT_TYPE_CIRCLE, Const.OBJECT_CLASS_CIRCLE);\n\n    /**\n     * Stores the given method.\n     * Can be\n     * <ul><li><b>'twoPoints'</b> which means the circle is defined by its center and a point on the circle.</li>\n     * <li><b>'pointRadius'</b> which means the circle is defined by its center and its radius given in user units or as term.</li>\n     * <li><b>'pointLine'</b> which means the circle is defined by its center and its radius given by the distance from the startpoint and the endpoint of the line.</li>\n     * <li><b>'pointCircle'</b> which means the circle is defined by its center and its radius given by the radius of another circle.</li></ul>\n     * @type String\n     * @see #center\n     * @see #point2\n     * @see #radius\n     * @see #line\n     * @see #circle\n     */\n    this.method = method;\n\n    // this is kept so existing code won't ne broken\n    this.midpoint = this.board.select(par1);\n\n    /**\n     * The circles center. Do not set this parameter directly as it will break JSXGraph's update system.\n     * @type JXG.Point\n     */\n    this.center = this.board.select(par1);\n\n    /** Point on the circle only set if method equals 'twoPoints'. Do not set this parameter directly as it will break JSXGraph's update system.\n     * @type JXG.Point\n     * @see #method\n     */\n    this.point2 = null;\n\n    /** Radius of the circle\n     * only set if method equals 'pointRadius'\n     * @type Number\n     * @default null\n     * @see #method\n     */\n    this.radius = 0;\n\n    /** Line defining the radius of the circle given by the distance from the startpoint and the endpoint of the line\n     * only set if method equals 'pointLine'. Do not set this parameter directly as it will break JSXGraph's update system.\n     * @type JXG.Line\n     * @default null\n     * @see #method\n     */\n    this.line = null;\n\n    /** Circle defining the radius of the circle given by the radius of the other circle\n     * only set if method equals 'pointLine'. Do not set this parameter directly as it will break JSXGraph's update system.\n     * @type JXG.Circle\n     * @default null\n     * @see #method\n     */\n    this.circle = null;\n\n    this.points = [];\n\n    if (method === \"twoPoints\") {\n        this.point2 = board.select(par2);\n        this.radius = this.Radius();\n    } else if (method === \"pointRadius\") {\n        this.gxtterm = par2;\n        // Converts GEONExT syntax into JavaScript syntax and generally ensures that the radius is a function\n        this.updateRadius = Type.createFunction(par2, this.board, null, true);\n        // First evaluation of the radius function\n        this.updateRadius();\n    } else if (method === \"pointLine\") {\n        // dann ist p2 die Id eines Objekts vom Typ Line!\n        this.line = board.select(par2);\n        this.radius = this.line.point1.coords.distance(\n            Const.COORDS_BY_USER,\n            this.line.point2.coords\n        );\n    } else if (method === \"pointCircle\") {\n        // dann ist p2 die Id eines Objekts vom Typ Circle!\n        this.circle = board.select(par2);\n        this.radius = this.circle.Radius();\n    }\n\n    // create Label\n    this.id = this.board.setId(this, \"C\");\n    this.board.renderer.drawEllipse(this);\n    this.board.finalizeAdding(this);\n\n    this.createGradient();\n    this.elType = \"circle\";\n    this.createLabel();\n\n    if (Type.exists(this.center._is_new)) {\n        this.addChild(this.center);\n        delete this.center._is_new;\n    } else {\n        this.center.addChild(this);\n    }\n\n    if (method === \"pointRadius\") {\n        this.notifyParents(par2);\n    } else if (method === \"pointLine\") {\n        this.line.addChild(this);\n    } else if (method === \"pointCircle\") {\n        this.circle.addChild(this);\n    } else if (method === \"twoPoints\") {\n        if (Type.exists(this.point2._is_new)) {\n            this.addChild(this.point2);\n            delete this.point2._is_new;\n        } else {\n            this.point2.addChild(this);\n        }\n    }\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        setRadius: \"setRadius\",\n        getRadius: \"getRadius\",\n        Area: \"Area\",\n        area: \"Area\",\n        radius: \"Radius\",\n        center: \"center\",\n        line: \"line\",\n        point2: \"point2\"\n    });\n};\n\nJXG.Circle.prototype = new GeometryElement();\n\nJXG.extend(\n    JXG.Circle.prototype,\n    /** @lends JXG.Circle.prototype */ {\n        /**\n         * Checks whether (x,y) is near the circle line or inside of the ellipse\n         * (in case JXG.Options.conic#hasInnerPoints is true).\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} True if (x,y) is near the circle, False otherwise.\n         * @private\n         */\n        hasPoint: function (x, y) {\n            var prec,\n                type,\n                mp = this.center.coords.usrCoords,\n                p = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board),\n                r = this.Radius(),\n                dx,\n                dy,\n                dist;\n\n            if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n                type = this.board._inputDevice;\n                prec = Type.evaluate(this.visProp.precision[type]);\n            } else {\n                // 'inherit'\n                prec = this.board.options.precision.hasPoint;\n            }\n            dx = mp[1] - p.usrCoords[1];\n            dy = mp[2] - p.usrCoords[2];\n            dist = Math.sqrt(dx * dx + dy * dy);\n            // We have to use usrCoords, since Radius is available in usrCoords only.\n            prec += Type.evaluate(this.visProp.strokewidth) * 0.5;\n            prec /= Math.sqrt(this.board.unitX * this.board.unitY);\n\n            if (Type.evaluate(this.visProp.hasinnerpoints)) {\n                return dist < r + prec;\n            }\n\n            return Math.abs(dist - r) < prec;\n        },\n\n        /**\n         * Used to generate a polynomial for a point p that lies on this circle.\n         * @param {JXG.Point} p The point for which the polynomial is generated.\n         * @returns {Array} An array containing the generated polynomial.\n         * @private\n         */\n        generatePolynomial: function (p) {\n            /*\n             * We have four methods to construct a circle:\n             *   (a) Two points\n             *   (b) center and radius\n             *   (c) center and radius given by length of a segment\n             *   (d) center and radius given by another circle\n             *\n             * In case (b) we have to distinguish two cases:\n             *  (i)  radius is given as a number\n             *  (ii) radius is given as a function\n             * In the latter case there's no guarantee the radius depends on other geometry elements\n             * in a polynomial way so this case has to be omitted.\n             *\n             * Another tricky case is case (d):\n             * The radius depends on another circle so we have to cycle through the ancestors of each circle\n             * until we reach one that's radius does not depend on another circles radius.\n             *\n             *\n             * All cases (a) to (d) vary only in calculation of the radius. So the basic formulae for\n             * a glider G (g1,g2) on a circle with center M (m1,m2) and radius r is just:\n             *\n             *     (g1-m1)^2 + (g2-m2)^2 - r^2 = 0\n             *\n             * So the easiest case is (b) with a fixed radius given as a number. The other two cases (a)\n             * and (c) are quite the same: Euclidean distance between two points A (a1,a2) and B (b1,b2),\n             * squared:\n             *\n             *     r^2 = (a1-b1)^2 + (a2-b2)^2\n             *\n             * For case (d) we have to cycle recursively through all defining circles and finally return the\n             * formulae for calculating r^2. For that we use JXG.Circle.symbolic.generateRadiusSquared().\n             */\n            var m1 = this.center.symbolic.x,\n                m2 = this.center.symbolic.y,\n                g1 = p.symbolic.x,\n                g2 = p.symbolic.y,\n                rsq = this.generateRadiusSquared();\n\n            /* No radius can be calculated (Case b.ii) */\n            if (rsq === \"\") {\n                return [];\n            }\n\n            return [\n                \"((\" + g1 + \")-(\" + m1 + \"))^2 + ((\" + g2 + \")-(\" + m2 + \"))^2 - (\" + rsq + \")\"\n            ];\n        },\n\n        /**\n         * Generate symbolic radius calculation for loci determination with Groebner-Basis algorithm.\n         * @returns {String} String containing symbolic calculation of the circle's radius or an empty string\n         * if the radius can't be expressed in a polynomial equation.\n         * @private\n         */\n        generateRadiusSquared: function () {\n            /*\n             * Four cases:\n             *\n             *   (a) Two points\n             *   (b) center and radius\n             *   (c) center and radius given by length of a segment\n             *   (d) center and radius given by another circle\n             */\n            var m1,\n                m2,\n                p1,\n                p2,\n                q1,\n                q2,\n                rsq = \"\";\n\n            if (this.method === \"twoPoints\") {\n                m1 = this.center.symbolic.x;\n                m2 = this.center.symbolic.y;\n                p1 = this.point2.symbolic.x;\n                p2 = this.point2.symbolic.y;\n\n                rsq = \"((\" + p1 + \")-(\" + m1 + \"))^2 + ((\" + p2 + \")-(\" + m2 + \"))^2\";\n            } else if (this.method === \"pointRadius\") {\n                if (Type.isNumber(this.radius)) {\n                    rsq = (this.radius * this.radius).toString();\n                }\n            } else if (this.method === \"pointLine\") {\n                p1 = this.line.point1.symbolic.x;\n                p2 = this.line.point1.symbolic.y;\n\n                q1 = this.line.point2.symbolic.x;\n                q2 = this.line.point2.symbolic.y;\n\n                rsq = \"((\" + p1 + \")-(\" + q1 + \"))^2 + ((\" + p2 + \")-(\" + q2 + \"))^2\";\n            } else if (this.method === \"pointCircle\") {\n                rsq = this.circle.Radius();\n            }\n\n            return rsq;\n        },\n\n        /**\n         * Uses the boards renderer to update the circle.\n         */\n        update: function () {\n            var x, y, z, r, c, i;\n\n            if (this.needsUpdate) {\n                if (Type.evaluate(this.visProp.trace)) {\n                    this.cloneToBackground(true);\n                }\n\n                if (this.method === \"pointLine\") {\n                    this.radius = this.line.point1.coords.distance(\n                        Const.COORDS_BY_USER,\n                        this.line.point2.coords\n                    );\n                } else if (this.method === \"pointCircle\") {\n                    this.radius = this.circle.Radius();\n                } else if (this.method === \"pointRadius\") {\n                    this.radius = this.updateRadius();\n                }\n\n                this.updateStdform();\n                this.updateQuadraticform();\n\n                // Approximate the circle by 4 Bezier segments\n                // This will be used for intersections of type curve / circle.\n                // See https://spencermortensen.com/articles/bezier-circle/\n                z = this.center.coords.usrCoords[0];\n                x = this.center.coords.usrCoords[1] / z;\n                y = this.center.coords.usrCoords[2] / z;\n                z /= z;\n                r = this.Radius();\n                c = 0.551915024494;\n\n                this.numberPoints = 13;\n                this.dataX = [\n                    x + r,\n                    x + r,\n                    x + r * c,\n                    x,\n                    x - r * c,\n                    x - r,\n                    x - r,\n                    x - r,\n                    x - r * c,\n                    x,\n                    x + r * c,\n                    x + r,\n                    x + r\n                ];\n                this.dataY = [\n                    y,\n                    y + r * c,\n                    y + r,\n                    y + r,\n                    y + r,\n                    y + r * c,\n                    y,\n                    y - r * c,\n                    y - r,\n                    y - r,\n                    y - r,\n                    y - r * c,\n                    y\n                ];\n                this.bezierDegree = 3;\n                for (i = 0; i < this.numberPoints; i++) {\n                    this.points[i] = new Coords(\n                        Const.COORDS_BY_USER,\n                        [this.dataX[i], this.dataY[i]],\n                        this.board\n                    );\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Updates this circle's {@link JXG.Circle#quadraticform}.\n         * @private\n         */\n        updateQuadraticform: function () {\n            var m = this.center,\n                mX = m.X(),\n                mY = m.Y(),\n                r = this.Radius();\n\n            this.quadraticform = [\n                [mX * mX + mY * mY - r * r, -mX, -mY],\n                [-mX, 1, 0],\n                [-mY, 0, 1]\n            ];\n        },\n\n        /**\n         * Updates the stdform derived from the position of the center and the circle's radius.\n         * @private\n         */\n        updateStdform: function () {\n            this.stdform[3] = 0.5;\n            this.stdform[4] = this.Radius();\n            this.stdform[1] = -this.center.coords.usrCoords[1];\n            this.stdform[2] = -this.center.coords.usrCoords[2];\n            if (!isFinite(this.stdform[4])) {\n                this.stdform[0] = Type.exists(this.point2)\n                    ? -(\n                          this.stdform[1] * this.point2.coords.usrCoords[1] +\n                          this.stdform[2] * this.point2.coords.usrCoords[2]\n                      )\n                    : 0;\n            }\n            this.normalize();\n        },\n\n        /**\n         * Uses the boards renderer to update the circle.\n         * @private\n         */\n        updateRenderer: function () {\n            // var wasReal;\n\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            if (this.visPropCalc.visible) {\n                // wasReal = this.isReal;\n                this.isReal =\n                    !isNaN(\n                        this.center.coords.usrCoords[1] +\n                            this.center.coords.usrCoords[2] +\n                            this.Radius()\n                    ) && this.center.isReal;\n\n                if (\n                    //wasReal &&\n                    !this.isReal\n                ) {\n                    this.updateVisibility(false);\n                }\n            }\n\n            // Update the position\n            if (this.visPropCalc.visible) {\n                this.board.renderer.updateEllipse(this);\n            }\n\n            // Update the label if visible.\n            if (\n                this.hasLabel &&\n                this.visPropCalc.visible &&\n                this.label &&\n                this.label.visPropCalc.visible &&\n                this.isReal\n            ) {\n                this.label.update();\n                this.board.renderer.updateText(this.label);\n            }\n\n            // Update rendNode display\n            this.setDisplayRendNode();\n            // if (this.visPropCalc.visible !== this.visPropOld.visible) {\n            //     this.board.renderer.display(this, this.visPropCalc.visible);\n            //     this.visPropOld.visible = this.visPropCalc.visible;\n            //\n            //     if (this.hasLabel) {\n            //         this.board.renderer.display(this.label, this.label.visPropCalc.visible);\n            //     }\n            // }\n\n            this.needsUpdate = false;\n            return this;\n        },\n\n        /**\n         * Finds dependencies in a given term and resolves them by adding the elements referenced in this\n         * string to the circle's list of ancestors.\n         * @param {String} contentStr\n         * @private\n         */\n        notifyParents: function (contentStr) {\n            if (Type.isString(contentStr)) {\n                GeonextParser.findDependencies(this, contentStr, this.board);\n            }\n        },\n\n        /**\n         * Set a new radius, then update the board.\n         * @param {String|Number|function} r A string, function or number describing the new radius.\n         * @returns {JXG.Circle} Reference to this circle\n         */\n        setRadius: function (r) {\n            this.updateRadius = Type.createFunction(r, this.board, null, true);\n            this.board.update();\n\n            return this;\n        },\n\n        /**\n         * Calculates the radius of the circle.\n         * @param {String|Number|function} [value] Set new radius\n         * @returns {Number} The radius of the circle\n         */\n        Radius: function (value) {\n            if (Type.exists(value)) {\n                this.setRadius(value);\n                return this.Radius();\n            }\n\n            if (this.method === \"twoPoints\") {\n                if (\n                    Type.cmpArrays(this.point2.coords.usrCoords, [0, 0, 0]) ||\n                    Type.cmpArrays(this.center.coords.usrCoords, [0, 0, 0])\n                ) {\n                    return NaN;\n                }\n\n                return this.center.Dist(this.point2);\n            }\n\n            if (this.method === \"pointLine\" || this.method === \"pointCircle\") {\n                return this.radius;\n            }\n\n            if (this.method === \"pointRadius\") {\n                return this.updateRadius();\n            }\n\n            return NaN;\n        },\n\n        /**\n         * Use {@link JXG.Circle#Radius}.\n         * @deprecated\n         */\n        getRadius: function () {\n            JXG.deprecated(\"Circle.getRadius()\", \"Circle.Radius()\");\n            return this.Radius();\n        },\n\n        // documented in geometry element\n        getTextAnchor: function () {\n            return this.center.coords;\n        },\n\n        // documented in geometry element\n        getLabelAnchor: function () {\n            var x,\n                y,\n                r = this.Radius(),\n                c = this.center.coords.usrCoords,\n                SQRTH = 7.071067811865e-1; // sqrt(2)/2\n\n            switch (Type.evaluate(this.visProp.label.position)) {\n                case \"lft\":\n                    x = c[1] - r;\n                    y = c[2];\n                    break;\n                case \"llft\":\n                    x = c[1] - SQRTH * r;\n                    y = c[2] - SQRTH * r;\n                    break;\n                case \"rt\":\n                    x = c[1] + r;\n                    y = c[2];\n                    break;\n                case \"lrt\":\n                    x = c[1] + SQRTH * r;\n                    y = c[2] - SQRTH * r;\n                    break;\n                case \"urt\":\n                    x = c[1] + SQRTH * r;\n                    y = c[2] + SQRTH * r;\n                    break;\n                case \"top\":\n                    x = c[1];\n                    y = c[2] + r;\n                    break;\n                case \"bot\":\n                    x = c[1];\n                    y = c[2] - r;\n                    break;\n                default:\n                    // includes case 'ulft'\n                    x = c[1] - SQRTH * r;\n                    y = c[2] + SQRTH * r;\n                    break;\n            }\n\n            return new Coords(Const.COORDS_BY_USER, [x, y], this.board);\n        },\n\n        // documented in geometry element\n        cloneToBackground: function () {\n            var er,\n                r = this.Radius(),\n                copy = {\n                    id: this.id + \"T\" + this.numTraces,\n                    elementClass: Const.OBJECT_CLASS_CIRCLE,\n                    center: {\n                        coords: this.center.coords\n                    },\n                    Radius: function () {\n                        return r;\n                    },\n                    getRadius: function () {\n                        return r;\n                    },\n                    board: this.board,\n                    visProp: Type.deepCopy(this.visProp, this.visProp.traceattributes, true)\n                };\n\n            copy.visProp.layer = this.board.options.layer.trace;\n\n            this.numTraces++;\n            Type.clearVisPropOld(copy);\n            copy.visPropCalc = {\n                visible: Type.evaluate(copy.visProp.visible)\n            };\n\n            er = this.board.renderer.enhancedRendering;\n            this.board.renderer.enhancedRendering = true;\n            this.board.renderer.drawEllipse(copy);\n            this.board.renderer.enhancedRendering = er;\n            this.traces[copy.id] = copy.rendNode;\n\n            return this;\n        },\n\n        /**\n         * Add transformations to this circle.\n         * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation} or an array of {@link JXG.Transformation}s.\n         * @returns {JXG.Circle} Reference to this circle object.\n         */\n        addTransform: function (transform) {\n            var i,\n                list = Type.isArray(transform) ? transform : [transform],\n                len = list.length;\n\n            for (i = 0; i < len; i++) {\n                this.center.transformations.push(list[i]);\n\n                if (this.method === \"twoPoints\") {\n                    this.point2.transformations.push(list[i]);\n                }\n            }\n\n            return this;\n        },\n\n        // see element.js\n        snapToGrid: function () {\n            var forceIt = Type.evaluate(this.visProp.snaptogrid);\n\n            this.center.handleSnapToGrid(forceIt, true);\n            if (this.method === \"twoPoints\") {\n                this.point2.handleSnapToGrid(forceIt, true);\n            }\n\n            return this;\n        },\n\n        // see element.js\n        snapToPoints: function () {\n            var forceIt = Type.evaluate(this.visProp.snaptopoints);\n\n            this.center.handleSnapToPoints(forceIt);\n            if (this.method === \"twoPoints\") {\n                this.point2.handleSnapToPoints(forceIt);\n            }\n\n            return this;\n        },\n\n        /**\n         * Treats the circle as parametric curve and calculates its X coordinate.\n         * @param {Number} t Number between 0 and 1.\n         * @returns {Number} <tt>X(t)= radius*cos(t)+centerX</tt>.\n         */\n        X: function (t) {\n            return this.Radius() * Math.cos(t * 2 * Math.PI) + this.center.coords.usrCoords[1];\n        },\n\n        /**\n         * Treats the circle as parametric curve and calculates its Y coordinate.\n         * @param {Number} t Number between 0 and 1.\n         * @returns {Number} <tt>X(t)= radius*sin(t)+centerY</tt>.\n         */\n        Y: function (t) {\n            return this.Radius() * Math.sin(t * 2 * Math.PI) + this.center.coords.usrCoords[2];\n        },\n\n        /**\n         * Treat the circle as parametric curve and calculates its Z coordinate.\n         * @param {Number} t ignored\n         * @returns {Number} 1.0\n         */\n        Z: function (t) {\n            return 1.0;\n        },\n\n        /**\n         * Returns 0.\n         * @private\n         */\n        minX: function () {\n            return 0.0;\n        },\n\n        /**\n         * Returns 1.\n         * @private\n         */\n        maxX: function () {\n            return 1.0;\n        },\n\n        /**\n         * Circle area\n         * @returns {Number} area of the circle.\n         */\n        Area: function () {\n            var r = this.Radius();\n\n            return r * r * Math.PI;\n        },\n\n        /**\n         * Get bounding box of the circle.\n         * @returns {Array} [x1, y1, x2, y2]\n         */\n        bounds: function () {\n            var uc = this.center.coords.usrCoords,\n                r = this.Radius();\n\n            return [uc[1] - r, uc[2] + r, uc[1] + r, uc[2] - r];\n        },\n\n        /**\n         * Get data to construct this element. Data consists of the parent elements\n         * and static data like radius.\n         * @returns {Array} data necessary to construct this element\n         */\n        getParents: function () {\n            if (this.parents.length === 1) {\n                // i.e. this.method === 'pointRadius'\n                return this.parents.concat(this.radius);\n            }\n            return this.parents;\n        }\n    }\n);\n\n/**\n * @class This element is used to provide a constructor for a circle.\n * @pseudo\n * @description  A circle consists of all points with a given distance from one point. This point is called center, the distance is called radius.\n * A circle can be constructed by providing a center and a point on the circle or a center and a radius (given as a number, function,\n * line, or circle).\n * @name Circle\n * @augments JXG.Circle\n * @constructor\n * @type JXG.Circle\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_number,JXG.Point,JXG.Line,JXG.Circle} center,radius The center must be given as a {@link JXG.Point}, see {@link JXG.providePoints}, but the radius can be given\n * as a number (which will create a circle with a fixed radius), another {@link JXG.Point}, a {@link JXG.Line} (the distance of start and end point of the\n * line will determine the radius), or another {@link JXG.Circle}.\n * @example\n * // Create a circle providing two points\n * var p1 = board.create('point', [2.0, 2.0]),\n *     p2 = board.create('point', [2.0, 0.0]),\n *     c1 = board.create('circle', [p1, p2]);\n *\n * // Create another circle using the above circle\n * var p3 = board.create('point', [3.0, 2.0]),\n *     c2 = board.create('circle', [p3, c1]);\n * </pre><div class=\"jxgbox\" id=\"JXG5f304d31-ef20-4a8e-9c0e-ea1a2b6c79e0\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function() {\n *   var cex1_board = JXG.JSXGraph.initBoard('JXG5f304d31-ef20-4a8e-9c0e-ea1a2b6c79e0', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *       cex1_p1 = cex1_board.create('point', [2.0, 2.0]),\n *       cex1_p2 = cex1_board.create('point', [2.0, 0.0]),\n *       cex1_c1 = cex1_board.create('circle', [cex1_p1, cex1_p2]),\n *       cex1_p3 = cex1_board.create('point', [3.0, 2.0]),\n *       cex1_c2 = cex1_board.create('circle', [cex1_p3, cex1_c1]);\n * })();\n * </script><pre>\n * @example\n * // Create a circle providing two points\n * var p1 = board.create('point', [2.0, 2.0]),\n *     c1 = board.create('circle', [p1, 3]);\n *\n * // Create another circle using the above circle\n * var c2 = board.create('circle', [function() { return [p1.X(), p1.Y() + 1];}, function() { return c1.Radius(); }]);\n * </pre><div class=\"jxgbox\" id=\"JXG54165f60-93b9-441d-8979-ac5d0f193020\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function() {\n * var board = JXG.JSXGraph.initBoard('JXG54165f60-93b9-441d-8979-ac5d0f193020', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n * var p1 = board.create('point', [2.0, 2.0]);\n * var c1 = board.create('circle', [p1, 3]);\n *\n * // Create another circle using the above circle\n * var c2 = board.create('circle', [function() { return [p1.X(), p1.Y() + 1];}, function() { return c1.Radius(); }]);\n * })();\n * </script><pre>\n * @example\n * var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n * var reflect = board.create('transform', [li], {type: 'reflect'});\n *\n * var c1 = board.create('circle', [[-2,-2], [-2, -1]], {center: {visible:true}});\n * var c2 = board.create('circle', [c1, reflect]);\n *      * </pre><div id=\"JXGa2a5a870-5dbb-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGa2a5a870-5dbb-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *             var reflect = board.create('transform', [li], {type: 'reflect'});\n *\n *             var c1 = board.create('circle', [[-2,-2], [-2, -1]], {center: {visible:true}});\n *             var c2 = board.create('circle', [c1, reflect]);\n *     })();\n *\n * </script><pre>\n *\n * @example\n * var t = board.create('transform', [2, 1.5], {type: 'scale'});\n * var c1 = board.create('circle', [[1.3, 1.3], [0, 1.3]], {strokeColor: 'black', center: {visible:true}});\n * var c2 = board.create('circle', [c1, t], {strokeColor: 'black'});\n *\n * </pre><div id=\"JXG0686a222-6339-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG0686a222-6339-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var t = board.create('transform', [2, 1.5], {type: 'scale'});\n *     var c1 = board.create('circle', [[1.3, 1.3], [0, 1.3]], {strokeColor: 'black', center: {visible:true}});\n *     var c2 = board.create('circle', [c1, t], {strokeColor: 'black'});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createCircle = function (board, parents, attributes) {\n    var el,\n        p,\n        i,\n        attr,\n        obj,\n        isDraggable = true,\n        point_style = [\"center\", \"point2\"];\n\n    p = [];\n    obj = board.select(parents[0]);\n    if (\n        Type.isObject(obj) &&\n        obj.elementClass === Const.OBJECT_CLASS_CIRCLE &&\n        Type.isTransformationOrArray(parents[1])\n    ) {\n        attr = Type.copyAttributes(attributes, board.options, \"circle\");\n        // if (!Type.exists(attr.type) || attr.type.toLowerCase() !== 'euclidean') {\n        //     // Create a circle element from a circle and a Euclidean transformation\n        //     el = JXG.createCircle(board, [obj.center, function() { return obj.Radius(); }], attr);\n        // } else {\n        // Create a conic element from a circle and a projective transformation\n        el = Conic.createEllipse(\n            board,\n            [\n                obj.center,\n                obj.center,\n                function () {\n                    return 2 * obj.Radius();\n                }\n            ],\n            attr\n        );\n        // }\n        el.addTransform(parents[1]);\n        return el;\n    }\n    // Circle defined by points\n    for (i = 0; i < parents.length; i++) {\n        if (Type.isPointType(board, parents[i])) {\n            p = p.concat(\n                Type.providePoints(board, [parents[i]], attributes, \"circle\", [point_style[i]])\n            );\n            if (p[p.length - 1] === false) {\n                throw new Error(\n                    \"JSXGraph: Can't create circle from this type. Please provide a point type.\"\n                );\n            }\n        } else {\n            p.push(parents[i]);\n        }\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"circle\");\n\n    if (p.length === 2 && Type.isPoint(p[0]) && Type.isPoint(p[1])) {\n        // Point/Point\n        el = new JXG.Circle(board, \"twoPoints\", p[0], p[1], attr);\n    } else if (\n        (Type.isNumber(p[0]) || Type.isFunction(p[0]) || Type.isString(p[0])) &&\n        Type.isPoint(p[1])\n    ) {\n        // Number/Point\n        el = new JXG.Circle(board, \"pointRadius\", p[1], p[0], attr);\n    } else if (\n        (Type.isNumber(p[1]) || Type.isFunction(p[1]) || Type.isString(p[1])) &&\n        Type.isPoint(p[0])\n    ) {\n        // Point/Number\n        el = new JXG.Circle(board, \"pointRadius\", p[0], p[1], attr);\n    } else if (p[0].elementClass === Const.OBJECT_CLASS_CIRCLE && Type.isPoint(p[1])) {\n        // Circle/Point\n        el = new JXG.Circle(board, \"pointCircle\", p[1], p[0], attr);\n    } else if (p[1].elementClass === Const.OBJECT_CLASS_CIRCLE && Type.isPoint(p[0])) {\n        // Point/Circle\n        el = new JXG.Circle(board, \"pointCircle\", p[0], p[1], attr);\n    } else if (p[0].elementClass === Const.OBJECT_CLASS_LINE && Type.isPoint(p[1])) {\n        // Line/Point\n        el = new JXG.Circle(board, \"pointLine\", p[1], p[0], attr);\n    } else if (p[1].elementClass === Const.OBJECT_CLASS_LINE && Type.isPoint(p[0])) {\n        // Point/Line\n        el = new JXG.Circle(board, \"pointLine\", p[0], p[1], attr);\n    } else if (\n        parents.length === 3 &&\n        Type.isPoint(p[0]) &&\n        Type.isPoint(p[1]) &&\n        Type.isPoint(p[2])\n    ) {\n        // Circle through three points\n        // Check if circumcircle element is available\n        if (JXG.elements.circumcircle) {\n            el = JXG.elements.circumcircle(board, p, attr);\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create circle with three points. Please include the circumcircle element (element/composition).\"\n            );\n        }\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create circle with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point], [point,number], [point,function], [point,circle], [point,point,point], [circle,transformation]\"\n        );\n    }\n\n    el.isDraggable = isDraggable;\n    el.setParents(p);\n    el.elType = \"circle\";\n    for (i = 0; i < p.length; i++) {\n        if (Type.isPoint(p[i])) {\n            el.inherits.push(p[i]);\n        }\n    }\n    return el;\n};\n\nJXG.registerElement(\"circle\", JXG.createCircle);\n\nexport default {\n    Circle: JXG.Circle,\n    createCircle: JXG.createCircle\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG:true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport Coords from \"./coords\";\nimport Statistics from \"../math/statistics\";\nimport Geometry from \"../math/geometry\";\nimport Type from \"../utils/type\";\nimport GeometryElement from \"./element\";\n\n/**\n * Creates a new instance of JXG.Polygon.\n * @class Polygon stores all style and functional properties that are required\n * to draw and to interactact with a polygon.\n * @param {JXG.Board} board Reference to the board the polygon is to be drawn on.\n * @param {Array} vertices Unique identifiers for the points defining the polygon.\n * Last point must be first point. Otherwise, the first point will be added at the list.\n * @param {Object} attributes An object which contains properties as given in {@link JXG.Options.elements}\n * and {@link JXG.Options.polygon}.\n * @constructor\n * @extends JXG.GeometryElement\n */\n\nJXG.Polygon = function (board, vertices, attributes) {\n    this.constructor(board, attributes, Const.OBJECT_TYPE_POLYGON, Const.OBJECT_CLASS_AREA);\n\n    var i,\n        l,\n        len,\n        j,\n        p,\n        attr_line = Type.copyAttributes(attributes, board.options, \"polygon\", \"borders\");\n\n    this.withLines = attributes.withlines;\n    this.attr_line = attr_line;\n\n    /**\n     * References to the points defining the polygon. The last vertex is the same as the first vertex.\n     * @type Array\n     */\n    this.vertices = [];\n    for (i = 0; i < vertices.length; i++) {\n        this.vertices[i] = this.board.select(vertices[i]);\n\n        // The _is_new flag is replaced by _is_new_pol.\n        // Otherwise, the polygon would disappear if the last border element\n        // is removed (and the point has been provided by coordinates)\n        if (this.vertices[i]._is_new) {\n            delete this.vertices[i]._is_new;\n            this.vertices[i]._is_new_pol = true;\n        }\n    }\n\n    // Close the polygon\n    if (\n        this.vertices.length > 0 &&\n        this.vertices[this.vertices.length - 1].id !== this.vertices[0].id\n    ) {\n        this.vertices.push(this.vertices[0]);\n    }\n\n    /**\n     * References to the border lines of the polygon.\n     * @type Array\n     */\n    this.borders = [];\n\n    if (this.withLines) {\n        len = this.vertices.length - 1;\n        for (j = 0; j < len; j++) {\n            // This sets the \"correct\" labels for the first triangle of a construction.\n            i = (j + 1) % len;\n            attr_line.id = attr_line.ids && attr_line.ids[i];\n            attr_line.name = attr_line.names && attr_line.names[i];\n            attr_line.strokecolor =\n                (Type.isArray(attr_line.colors) &&\n                    attr_line.colors[i % attr_line.colors.length]) ||\n                attr_line.strokecolor;\n            attr_line.visible = Type.exists(attributes.borders.visible)\n                ? attributes.borders.visible\n                : attributes.visible;\n\n            if (attr_line.strokecolor === false) {\n                attr_line.strokecolor = \"none\";\n            }\n\n            l = board.create(\"segment\", [this.vertices[i], this.vertices[i + 1]], attr_line);\n            l.dump = false;\n            this.borders[i] = l;\n            l.parentPolygon = this;\n        }\n    }\n\n    this.inherits.push(this.vertices, this.borders);\n\n    // Register polygon at board\n    // This needs to be done BEFORE the points get this polygon added in their descendants list\n    this.id = this.board.setId(this, \"Py\");\n\n    // Add dependencies: either\n    // - add polygon as child to an existing point\n    // or\n    // - add  points (supplied as coordinate arrays by the user and created by Type.providePoints) as children to the polygon\n    for (i = 0; i < this.vertices.length - 1; i++) {\n        p = this.board.select(this.vertices[i]);\n        if (Type.exists(p._is_new_pol)) {\n            this.addChild(p);\n            delete p._is_new_pol;\n        } else {\n            p.addChild(this);\n        }\n    }\n\n    this.board.renderer.drawPolygon(this);\n    this.board.finalizeAdding(this);\n\n    this.createGradient();\n    this.elType = \"polygon\";\n\n    // create label\n    this.createLabel();\n\n    this.methodMap = JXG.deepCopy(this.methodMap, {\n        borders: \"borders\",\n        vertices: \"vertices\",\n        A: \"Area\",\n        Area: \"Area\",\n        Perimeter: \"Perimeter\",\n        L: \"Perimeter\",\n        Length: \"Perimeter\",\n        boundingBox: \"boundingBox\",\n        bounds: \"bounds\",\n        addPoints: \"addPoints\",\n        insertPoints: \"insertPoints\",\n        removePoints: \"removePoints\"\n    });\n};\n\nJXG.Polygon.prototype = new GeometryElement();\n\nJXG.extend(\n    JXG.Polygon.prototype,\n    /** @lends JXG.Polygon.prototype */ {\n        /**\n         * Wrapper for JXG.Math.Geometry.pnpoly.\n         *\n         * @param {Number} x_in x-coordinate (screen or user coordinates)\n         * @param {Number} y_in y-coordinate (screen or user coordinates)\n         * @param {Number} coord_type (Optional) the type of coordinates used here.\n         *   Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.\n         *   Default value is JXG.COORDS_BY_SCREEN\n         *\n         * @returns {Boolean} if (x_in, y_in) is inside of the polygon.\n         * @see JXG.Math.Geometry#pnpoly\n         *\n         * @example\n         * var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);\n         * var p = board.create('point', [4, 3]);\n         * var txt = board.create('text', [-1, 0.5, function() {\n         *   return 'Point A is inside of the polygon = ' +\n         *     pol.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER);\n         * }]);\n         *\n         * </pre><div id=\"JXG7f96aec7-4e3d-4ffc-a3f5-d3f967b6691c\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG7f96aec7-4e3d-4ffc-a3f5-d3f967b6691c',\n         *             {boundingbox: [-2, 5, 5,-2], axis: true, showcopyright: false, shownavigation: false});\n         *     var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);\n         *     var p = board.create('point', [4, 3]);\n         *     var txt = board.create('text', [-1, 0.5, function() {\n         *     \t\treturn 'Point A is inside of the polygon = ' + pol.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER);\n         *     }]);\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        pnpoly: function (x_in, y_in, coord_type) {\n            return Geometry.pnpoly(x_in, y_in, this.vertices, coord_type);\n        },\n\n        /**\n         * Checks whether (x,y) is near the polygon.\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} Returns true, if (x,y) is inside or at the boundary the polygon, otherwise false.\n         */\n        hasPoint: function (x, y) {\n            var i, len;\n\n            if (Type.evaluate(this.visProp.hasinnerpoints)) {\n                // All points of the polygon trigger hasPoint: inner and boundary points\n                if (this.pnpoly(x, y)) {\n                    return true;\n                }\n            }\n\n            // Only boundary points trigger hasPoint\n            // We additionally test the boundary also in case hasInnerPoints.\n            // Since even if the above test has failed, the strokewidth may be large and (x, y) may\n            // be inside of hasPoint() of a vertices.\n            len = this.borders.length;\n            for (i = 0; i < len; i++) {\n                if (this.borders[i].hasPoint(x, y)) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Uses the boards renderer to update the polygon.\n         */\n        updateRenderer: function () {\n            var i, len; // wasReal,\n\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            if (this.visPropCalc.visible) {\n                // wasReal = this.isReal;\n\n                len = this.vertices.length;\n                this.isReal = true;\n                for (i = 0; i < len; ++i) {\n                    if (!this.vertices[i].isReal) {\n                        this.isReal = false;\n                        break;\n                    }\n                }\n\n                if (\n                    //wasReal &&\n                    !this.isReal\n                ) {\n                    this.updateVisibility(false);\n                }\n            }\n\n            if (this.visPropCalc.visible) {\n                this.board.renderer.updatePolygon(this);\n            }\n\n            /* Update the label if visible. */\n            if (\n                this.hasLabel &&\n                this.visPropCalc.visible &&\n                this.label &&\n                this.label.visPropCalc.visible &&\n                this.isReal\n            ) {\n                this.label.update();\n                this.board.renderer.updateText(this.label);\n            }\n\n            // Update rendNode display\n            this.setDisplayRendNode();\n            // if (this.visPropCalc.visible !== this.visPropOld.visible) {\n            //     this.board.renderer.display(this, this.visPropCalc.visible);\n            //     this.visPropOld.visible = this.visPropCalc.visible;\n            //\n            //     if (this.hasLabel) {\n            //         this.board.renderer.display(this.label, this.label.visPropCalc.visible);\n            //     }\n            // }\n\n            this.needsUpdate = false;\n            return this;\n        },\n\n        /**\n         * return TextAnchor\n         */\n        getTextAnchor: function () {\n            var a, b, x, y, i;\n\n            if (this.vertices.length === 0) {\n                return new Coords(Const.COORDS_BY_USER, [1, 0, 0], this.board);\n            }\n\n            a = this.vertices[0].X();\n            b = this.vertices[0].Y();\n            x = a;\n            y = b;\n            for (i = 0; i < this.vertices.length; i++) {\n                if (this.vertices[i].X() < a) {\n                    a = this.vertices[i].X();\n                }\n\n                if (this.vertices[i].X() > x) {\n                    x = this.vertices[i].X();\n                }\n\n                if (this.vertices[i].Y() > b) {\n                    b = this.vertices[i].Y();\n                }\n\n                if (this.vertices[i].Y() < y) {\n                    y = this.vertices[i].Y();\n                }\n            }\n\n            return new Coords(Const.COORDS_BY_USER, [(a + x) * 0.5, (b + y) * 0.5], this.board);\n        },\n\n        getLabelAnchor: JXG.shortcut(JXG.Polygon.prototype, \"getTextAnchor\"),\n\n        // documented in geometry element\n        cloneToBackground: function () {\n            var copy = {},\n                er;\n\n            copy.id = this.id + \"T\" + this.numTraces;\n            this.numTraces++;\n            copy.vertices = this.vertices;\n            copy.visProp = Type.deepCopy(this.visProp, this.visProp.traceattributes, true);\n            copy.visProp.layer = this.board.options.layer.trace;\n            copy.board = this.board;\n            Type.clearVisPropOld(copy);\n\n            copy.visPropCalc = {\n                visible: Type.evaluate(copy.visProp.visible)\n            };\n\n            er = this.board.renderer.enhancedRendering;\n            this.board.renderer.enhancedRendering = true;\n            this.board.renderer.drawPolygon(copy);\n            this.board.renderer.enhancedRendering = er;\n            this.traces[copy.id] = copy.rendNode;\n\n            return this;\n        },\n\n        /**\n         * Hide the polygon including its border lines. It will still exist but not visible on the board.\n         * @param {Boolean} [borderless=false] If set to true, the polygon is treated as a polygon without\n         * borders, i.e. the borders will not be hidden.\n         */\n        hideElement: function (borderless) {\n            var i;\n\n            JXG.deprecated(\"Element.hideElement()\", \"Element.setDisplayRendNode()\");\n\n            this.visPropCalc.visible = false;\n            this.board.renderer.display(this, false);\n\n            if (!borderless) {\n                for (i = 0; i < this.borders.length; i++) {\n                    this.borders[i].hideElement();\n                }\n            }\n\n            if (this.hasLabel && Type.exists(this.label)) {\n                this.label.hiddenByParent = true;\n                if (this.label.visPropCalc.visible) {\n                    this.label.hideElement();\n                }\n            }\n        },\n\n        /**\n         * Make the element visible.\n         * @param {Boolean} [borderless=false] If set to true, the polygon is treated as a polygon without\n         * borders, i.e. the borders will not be shown.\n         */\n        showElement: function (borderless) {\n            var i;\n\n            JXG.deprecated(\"Element.showElement()\", \"Element.setDisplayRendNode()\");\n\n            this.visPropCalc.visible = true;\n            this.board.renderer.display(this, true);\n\n            if (!borderless) {\n                for (i = 0; i < this.borders.length; i++) {\n                    this.borders[i].showElement().updateRenderer();\n                }\n            }\n\n            if (Type.exists(this.label) && this.hasLabel && this.label.hiddenByParent) {\n                this.label.hiddenByParent = false;\n                if (!this.label.visPropCalc.visible) {\n                    this.label.showElement().updateRenderer();\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Area of (not self-intersecting) polygon\n         * @returns {Number} Area of (not self-intersecting) polygon\n         */\n        Area: function () {\n            return Math.abs(Geometry.signedPolygon(this.vertices, true));\n        },\n\n        /**\n         * Perimeter of polygon.\n         * @returns {Number} Perimeter of polygon in user units.\n         *\n         * @example\n         * var p = [[0.0, 2.0], [2.0, 1.0], [4.0, 6.0], [1.0, 3.0]];\n         *\n         * var pol = board.create('polygon', p, {hasInnerPoints: true});\n         * var t = board.create('text', [5, 5, function() { return pol.Perimeter(); }]);\n         * </pre><div class=\"jxgbox\" id=\"JXGb10b734d-89fc-4b9d-b4a7-e3f0c1c6bf77\" style=\"width: 400px; height: 400px;\"></div>\n         * <script type=\"text/javascript\">\n         *  (function () {\n         *   var board = JXG.JSXGraph.initBoard('JXGb10b734d-89fc-4b9d-b4a7-e3f0c1c6bf77', {boundingbox: [-1, 9, 9, -1], axis: false, showcopyright: false, shownavigation: false}),\n         *       p = [[0.0, 2.0], [2.0, 1.0], [4.0, 6.0], [1.0, 4.0]],\n         *       cc1 = board.create('polygon', p, {hasInnerPoints: true}),\n         *       t = board.create('text', [5, 5, function() { return cc1.Perimeter(); }]);\n         *  })();\n         * </script><pre>\n         *\n         */\n        Perimeter: function () {\n            var i,\n                len = this.vertices.length,\n                val = 0.0;\n\n            for (i = 1; i < len; ++i) {\n                val += this.vertices[i].Dist(this.vertices[i - 1]);\n            }\n\n            return val;\n        },\n\n        /**\n         * Bounding box of a polygon. The bounding box is an array of four numbers: the first two numbers\n         * determine the upper left corner, the last two number determine the lower right corner of the bounding box.\n         *\n         * The width and height of a polygon can then determined like this:\n         * @example\n         * var box = polygon.boundingBox();\n         * var width = box[2] - box[0];\n         * var height = box[1] - box[3];\n         *\n         * @returns {Array} Array containing four numbers: [minX, maxY, maxX, minY]\n         */\n        boundingBox: function () {\n            var box = [0, 0, 0, 0],\n                i,\n                v,\n                le = this.vertices.length - 1;\n\n            if (le === 0) {\n                return box;\n            }\n            box[0] = this.vertices[0].X();\n            box[2] = box[0];\n            box[1] = this.vertices[0].Y();\n            box[3] = box[1];\n\n            for (i = 1; i < le; ++i) {\n                v = this.vertices[i].X();\n                if (v < box[0]) {\n                    box[0] = v;\n                } else if (v > box[2]) {\n                    box[2] = v;\n                }\n\n                v = this.vertices[i].Y();\n                if (v > box[1]) {\n                    box[1] = v;\n                } else if (v < box[3]) {\n                    box[3] = v;\n                }\n            }\n\n            return box;\n        },\n\n        // Already documented in GeometryElement\n        bounds: function () {\n            return this.boundingBox();\n        },\n\n        /**\n         * This method removes the SVG or VML nodes of the lines and the filled area from the renderer, to remove\n         * the object completely you should use {@link JXG.Board#removeObject}.\n         *\n         * @private\n         */\n        remove: function () {\n            var i;\n\n            for (i = 0; i < this.borders.length; i++) {\n                this.board.removeObject(this.borders[i]);\n            }\n\n            GeometryElement.prototype.remove.call(this);\n        },\n\n        /**\n         * Finds the index to a given point reference.\n         * @param {JXG.Point} p Reference to an element of type {@link JXG.Point}\n         * @returns {Number} Index of the point or -1.\n         */\n        findPoint: function (p) {\n            var i;\n\n            if (!Type.isPoint(p)) {\n                return -1;\n            }\n\n            for (i = 0; i < this.vertices.length; i++) {\n                if (this.vertices[i].id === p.id) {\n                    return i;\n                }\n            }\n\n            return -1;\n        },\n\n        /**\n         * Add more points to the polygon. The new points will be inserted at the end.\n         * The attributes of new border segments are set to the same values\n         * as those used when the polygon was created.\n         * If new vertices are supplied by coordinates, the default attributes of polygon\n         * vertices are taken as their attributes. Therefore, the visual attributes of\n         * new vertices and borders may have to be adapted afterwards.\n         * @param {JXG.Point} p Arbitrary number of points or coordinate arrays\n         * @returns {JXG.Polygon} Reference to the polygon\n         * @example\n         * const board = JXG.JSXGraph.initBoard('jxgbox', {axis:true});\n         * var pg = board.create('polygon', [[1,2], [3,4], [-3,1]], {hasInnerPoints: true});\n         * var newPoint = board.create('point', [-1, -1]);\n         * var newPoint2 = board.create('point', [-1, -2]);\n         * pg.addPoints(newPoint, newPoint2, [1, -2]);\n         *\n         * </pre><div id=\"JXG70eb0fd2-d20f-4ba9-9ab6-0eac92aabfa5\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG70eb0fd2-d20f-4ba9-9ab6-0eac92aabfa5',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     const board = JXG.JSXGraph.initBoard('jxgbox', {axis:true});\n         *     var pg = board.create('polygon', [[1,2], [3,4], [-3,1]], {hasInnerPoints: true});\n         *     var newPoint = board.create('point', [-1, -1]);\n         *     var newPoint2 = board.create('point', [-1, -2]);\n         *     pg.addPoints(newPoint, newPoint2, [1, -2]);\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        addPoints: function (p) {\n            var idx,\n                args = Array.prototype.slice.call(arguments);\n\n            if (this.elType === \"polygonalchain\") {\n                idx = this.vertices.length - 1;\n            } else {\n                idx = this.vertices.length - 2;\n            }\n            return this.insertPoints.apply(this, [idx].concat(args));\n        },\n\n        /**\n         * Insert points to the vertex list of the polygon after index <tt><idx</tt>.\n         * The attributes of new border segments are set to the same values\n         * as those used when the polygon was created.\n         * If new vertices are supplied by coordinates, the default attributes of polygon\n         * vertices are taken as their attributes. Therefore, the visual attributes of\n         * new vertices and borders may have to be adapted afterwards.\n         *\n         * @param {Number} idx The position after which the new vertices are inserted.\n         * Setting idx to -1 inserts the new points at the front, i.e. at position 0.\n         * @param {JXG.Point} p Arbitrary number of points or coordinate arrays to insert.\n         * @returns {JXG.Polygon} Reference to the polygon object\n         *\n         * @example\n         * const board = JXG.JSXGraph.initBoard('jxgbox', {axis:true});\n         * var pg = board.create('polygon', [[1,2], [3,4], [-3,1]], {hasInnerPoints: true});\n         * var newPoint = board.create('point', [-1, -1]);\n         * pg.insertPoints(0, newPoint, newPoint, [1, -2]);\n         *\n         * </pre><div id=\"JXG17b84b2a-a851-4e3f-824f-7f6a60f166ca\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG17b84b2a-a851-4e3f-824f-7f6a60f166ca',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     const board = JXG.JSXGraph.initBoard('jxgbox', {axis:true});\n         *     var pg = board.create('polygon', [[1,2], [3,4], [-3,1]], {hasInnerPoints: true});\n         *     var newPoint = board.create('point', [-1, -1]);\n         *     pg.insertPoints(0, newPoint, newPoint, [1, -2]);\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        insertPoints: function (idx, p) {\n            var i, le, last, start, q;\n\n            if (arguments.length === 0) {\n                return this;\n            }\n\n            last = this.vertices.length - 1;\n            if (this.elType === \"polygon\") {\n                last--;\n            }\n\n            // Wrong insertion index, get out of here\n            if (idx < -1 || idx > last) {\n                return this;\n            }\n\n            le = arguments.length - 1;\n            for (i = 1; i < le + 1; i++) {\n                q = Type.providePoints(this.board, [arguments[i]], {}, \"polygon\", [\n                    \"vertices\"\n                ])[0];\n                if (q._is_new) {\n                    // Add the point as child of the polygon, but not of the borders.\n                    this.addChild(q);\n                    delete q._is_new;\n                }\n                this.vertices.splice(idx + i, 0, q);\n            }\n\n            if (this.withLines) {\n                start = idx + 1;\n                if (this.elType === \"polygon\") {\n                    if (idx < 0) {\n                        // Add point(s) in the front\n                        this.vertices[this.vertices.length - 1] = this.vertices[0];\n                        this.borders[this.borders.length - 1].point2 =\n                            this.vertices[this.vertices.length - 1];\n                    } else {\n                        // Insert point(s) (middle or end)\n                        this.borders[idx].point2 = this.vertices[start];\n                    }\n                } else {\n                    // Add point(s) in the front: do nothing\n                    // Else:\n                    if (idx >= 0) {\n                        if (idx < this.borders.length) {\n                            // Insert point(s) in the middle\n                            this.borders[idx].point2 = this.vertices[start];\n                        } else {\n                            // Add point at the end\n                            start = idx;\n                        }\n                    }\n                }\n                for (i = start; i < start + le; i++) {\n                    this.borders.splice(\n                        i,\n                        0,\n                        this.board.create(\n                            \"segment\",\n                            [this.vertices[i], this.vertices[i + 1]],\n                            this.attr_line\n                        )\n                    );\n                }\n            }\n            this.inherits = [];\n            this.inherits.push(this.vertices, this.borders);\n            this.board.update();\n\n            return this;\n        },\n\n        /**\n         * Removes given set of vertices from the polygon\n         * @param {JXG.Point} p Arbitrary number of vertices as {@link JXG.Point} elements or index numbers\n         * @returns {JXG.Polygon} Reference to the polygon\n         */\n        removePoints: function (p) {\n            var i,\n                j,\n                j0,\n                idx,\n                firstPoint,\n                nvertices = [],\n                nborders = [],\n                nidx = [],\n                partition = [];\n\n            // Partition:\n            // in order to keep the borders which could be recycled, we have to partition\n            // the set of removed points. I.e. if the points 1, 2, 5, 6, 7, 10 are removed,\n            // the partitions are\n            //       1-2, 5-7, 10-10\n            // this gives us the borders, that can be removed and the borders we have to create.\n\n            // In case of polygon: remove the last vertex from the list of vertices since\n            // it is identical to the first\n            if (this.elType === \"polygon\") {\n                firstPoint = this.vertices.pop();\n            }\n\n            // Collect all valid parameters as indices in nidx\n            for (i = 0; i < arguments.length; i++) {\n                idx = arguments[i];\n                if (Type.isPoint(idx)) {\n                    idx = this.findPoint(idx);\n                }\n                if (\n                    Type.isNumber(idx) &&\n                    idx > -1 &&\n                    idx < this.vertices.length &&\n                    Type.indexOf(nidx, idx) === -1\n                ) {\n                    nidx.push(idx);\n                }\n            }\n\n            if (nidx.length === 0) {\n                // Wrong index, get out of here\n                if (this.elType === \"polygon\") {\n                    this.vertices.push(firstPoint);\n                }\n                return this;\n            }\n\n            // Remove the polygon from each removed point's children\n            for (i = 0; i < nidx.length; i++) {\n                this.vertices[nidx[i]].removeChild(this);\n            }\n\n            // Sort the elements to be eliminated\n            nidx = nidx.sort();\n            nvertices = this.vertices.slice();\n            nborders = this.borders.slice();\n\n            // Initialize the partition with an array containing the last point to be removed\n            if (this.withLines) {\n                partition.push([nidx[nidx.length - 1]]);\n            }\n\n            // Run through all existing vertices and copy all remaining ones to nvertices,\n            // compute the partition\n            for (i = nidx.length - 1; i > -1; i--) {\n                nvertices[nidx[i]] = -1;\n\n                // Find gaps between the list of points to be removed.\n                // In this case a new partition is added.\n                if (this.withLines && nidx.length > 1 && nidx[i] - 1 > nidx[i - 1]) {\n                    partition[partition.length - 1][1] = nidx[i];\n                    partition.push([nidx[i - 1]]);\n                }\n            }\n\n            // Finalize the partition computation\n            if (this.withLines) {\n                partition[partition.length - 1][1] = nidx[0];\n            }\n\n            // Update vertices\n            this.vertices = [];\n            for (i = 0; i < nvertices.length; i++) {\n                if (Type.isPoint(nvertices[i])) {\n                    this.vertices.push(nvertices[i]);\n                }\n            }\n\n            // Close the polygon again\n            if (\n                this.elType === \"polygon\" &&\n                this.vertices.length > 1 &&\n                this.vertices[this.vertices.length - 1].id !== this.vertices[0].id\n            ) {\n                this.vertices.push(this.vertices[0]);\n            }\n\n            // Delete obsolete and create missing borders\n            if (this.withLines) {\n                for (i = 0; i < partition.length; i++) {\n                    for (j = partition[i][1] - 1; j < partition[i][0] + 1; j++) {\n                        // special cases\n                        if (j < 0) {\n                            if (this.elType === \"polygon\") {\n                                // First vertex is removed, so the last border has to be removed, too\n                                this.board.removeObject(this.borders[nborders.length - 1]);\n                                nborders[nborders.length - 1] = -1;\n                            }\n                        } else if (j < nborders.length) {\n                            this.board.removeObject(this.borders[j]);\n                            nborders[j] = -1;\n                        }\n                    }\n\n                    // Only create the new segment if it's not the closing border.\n                    // The closing border is getting a special treatment at the end.\n                    if (partition[i][1] !== 0 && partition[i][0] !== nvertices.length - 1) {\n                        // nborders[partition[i][0] - 1] = this.board.create('segment', [\n                        //             nvertices[Math.max(partition[i][1] - 1, 0)],\n                        //             nvertices[Math.min(partition[i][0] + 1, this.vertices.length - 1)]\n                        //         ], this.attr_line);\n                        nborders[partition[i][0] - 1] = this.board.create(\n                            \"segment\",\n                            [nvertices[partition[i][1] - 1], nvertices[partition[i][0] + 1]],\n                            this.attr_line\n                        );\n                    }\n                }\n\n                this.borders = [];\n                for (i = 0; i < nborders.length; i++) {\n                    if (nborders[i] !== -1) {\n                        this.borders.push(nborders[i]);\n                    }\n                }\n\n                // if the first and/or the last vertex is removed, the closing border is created at the end.\n                if (\n                    this.elType === \"polygon\" &&\n                    this.vertices.length > 2 && // Avoid trivial case of polygon with 1 vertex\n                    (partition[0][1] === this.vertices.length - 1 ||\n                        partition[partition.length - 1][1] === 0)\n                ) {\n                    this.borders.push(\n                        this.board.create(\n                            \"segment\",\n                            [this.vertices[0], this.vertices[this.vertices.length - 2]],\n                            this.attr_line\n                        )\n                    );\n                }\n            }\n            this.inherits = [];\n            this.inherits.push(this.vertices, this.borders);\n\n            this.board.update();\n\n            return this;\n        },\n\n        // documented in element.js\n        getParents: function () {\n            this.setParents(this.vertices);\n            return this.parents;\n        },\n\n        getAttributes: function () {\n            var attr = GeometryElement.prototype.getAttributes.call(this),\n                i;\n\n            if (this.withLines) {\n                attr.lines = attr.lines || {};\n                attr.lines.ids = [];\n                attr.lines.colors = [];\n\n                for (i = 0; i < this.borders.length; i++) {\n                    attr.lines.ids.push(this.borders[i].id);\n                    attr.lines.colors.push(this.borders[i].visProp.strokecolor);\n                }\n            }\n\n            return attr;\n        },\n\n        snapToGrid: function () {\n            var i, force;\n\n            if (Type.evaluate(this.visProp.snaptogrid)) {\n                force = true;\n            } else {\n                force = false;\n            }\n\n            for (i = 0; i < this.vertices.length; i++) {\n                this.vertices[i].handleSnapToGrid(force, true);\n            }\n        },\n\n        /**\n         * Moves the polygon by the difference of two coordinates.\n         * @param {Number} method The type of coordinates used here. Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.\n         * @param {Array} coords coordinates in screen/user units\n         * @param {Array} oldcoords previous coordinates in screen/user units\n         * @returns {JXG.Polygon} this element\n         */\n        setPositionDirectly: function (method, coords, oldcoords) {\n            var dc,\n                t,\n                i,\n                len,\n                c = new Coords(method, coords, this.board),\n                oldc = new Coords(method, oldcoords, this.board);\n\n            len = this.vertices.length - 1;\n            for (i = 0; i < len; i++) {\n                if (!this.vertices[i].draggable()) {\n                    return this;\n                }\n            }\n\n            dc = Statistics.subtract(c.usrCoords, oldc.usrCoords);\n            t = this.board.create(\"transform\", dc.slice(1), { type: \"translate\" });\n            t.applyOnce(this.vertices.slice(0, -1));\n\n            return this;\n        },\n\n        /**\n         * Algorithm by Sutherland and Hodgman to compute the intersection of two convex polygons.\n         * The polygon itself is the clipping polygon, it expects as parameter a polygon to be clipped.\n         * See <a href=\"https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\">wikipedia entry</a>.\n         * Called by {@link JXG.Polygon#intersect}.\n         *\n         * @private\n         *\n         * @param {JXG.Polygon} polygon Polygon which will be clipped.\n         *\n         * @returns {Array} of (normalized homogeneous user) coordinates (i.e. [z, x, y], where z==1 in most cases,\n         *   representing the vertices of the intersection polygon.\n         *\n         */\n        sutherlandHodgman: function (polygon) {\n            // First the two polygons are sorted counter clockwise\n            var clip = JXG.Math.Geometry.sortVertices(this.vertices), // \"this\" is the clipping polygon\n                subject = JXG.Math.Geometry.sortVertices(polygon.vertices), // \"polygon\" is the subject polygon\n                lenClip = clip.length - 1,\n                lenSubject = subject.length - 1,\n                lenIn,\n                outputList = [],\n                inputList,\n                i,\n                j,\n                S,\n                E,\n                cross,\n                // Determines if the point c3 is right of the line through c1 and c2.\n                // Since the polygons are sorted counter clockwise, \"right of\" and therefore >= is needed here\n                isInside = function (c1, c2, c3) {\n                    return (\n                        (c2[1] - c1[1]) * (c3[2] - c1[2]) - (c2[2] - c1[2]) * (c3[1] - c1[1]) >=\n                        0\n                    );\n                };\n\n            for (i = 0; i < lenSubject; i++) {\n                outputList.push(subject[i]);\n            }\n\n            for (i = 0; i < lenClip; i++) {\n                inputList = outputList.slice(0);\n                lenIn = inputList.length;\n                outputList = [];\n\n                S = inputList[lenIn - 1];\n\n                for (j = 0; j < lenIn; j++) {\n                    E = inputList[j];\n                    if (isInside(clip[i], clip[i + 1], E)) {\n                        if (!isInside(clip[i], clip[i + 1], S)) {\n                            cross = JXG.Math.Geometry.meetSegmentSegment(\n                                S,\n                                E,\n                                clip[i],\n                                clip[i + 1]\n                            );\n                            cross[0][1] /= cross[0][0];\n                            cross[0][2] /= cross[0][0];\n                            cross[0][0] = 1;\n                            outputList.push(cross[0]);\n                        }\n                        outputList.push(E);\n                    } else if (isInside(clip[i], clip[i + 1], S)) {\n                        cross = JXG.Math.Geometry.meetSegmentSegment(\n                            S,\n                            E,\n                            clip[i],\n                            clip[i + 1]\n                        );\n                        cross[0][1] /= cross[0][0];\n                        cross[0][2] /= cross[0][0];\n                        cross[0][0] = 1;\n                        outputList.push(cross[0]);\n                    }\n                    S = E;\n                }\n            }\n\n            return outputList;\n        },\n\n        /**\n         * Generic method for the intersection of this polygon with another polygon.\n         * The parent object is the clipping polygon, it expects as parameter a polygon to be clipped.\n         * Both polygons have to be convex.\n         * Calls the algorithm by Sutherland, Hodgman, {@link JXG.Polygon#sutherlandHodgman}.\n         * <p>\n         * An alternative is to use the methods from {@link JXG.Math.Clip}, where the algorithm by Greiner and Hormann\n         * is used.\n         *\n         * @param {JXG.Polygon} polygon Polygon which will be clipped.\n         *\n         * @returns {Array} of (normalized homogeneous user) coordinates (i.e. [z, x, y], where z==1 in most cases,\n         *   representing the vertices of the intersection polygon.\n         *\n         * @example\n         *  // Static intersection of two polygons pol1 and pol2\n         *  var pol1 = board.create('polygon', [[-2, 3], [-4, -3], [2, 0], [4, 4]], {\n         *                name:'pol1', withLabel: true,\n         *                fillColor: 'yellow'\n         *             });\n         *  var pol2 = board.create('polygon', [[-2, -3], [-4, 1], [0, 4], [5, 1]], {\n         *                name:'pol2', withLabel: true\n         *             });\n         *\n         *  // Static version:\n         *  // the intersection polygon does not adapt to changes of pol1 or pol2.\n         *  var pol3 = board.create('polygon', pol1.intersect(pol2), {fillColor: 'blue'});\n         * </pre><div class=\"jxgbox\" id=\"JXGd1fe5ea9-309f-494a-af07-ee3d033acb7c\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *   (function() {\n         *       var board = JXG.JSXGraph.initBoard('JXGd1fe5ea9-309f-494a-af07-ee3d033acb7c', {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *       // Intersect two polygons pol1 and pol2\n         *       var pol1 = board.create('polygon', [[-2, 3], [-4, -3], [2, 0], [4, 4]], {\n         *                name:'pol1', withLabel: true,\n         *                fillColor: 'yellow'\n         *             });\n         *       var pol2 = board.create('polygon', [[-2, -3], [-4, 1], [0, 4], [5, 1]], {\n         *                name:'pol2', withLabel: true\n         *             });\n         *\n         *       // Static version: the intersection polygon does not adapt to changes of pol1 or pol2.\n         *       var pol3 = board.create('polygon', pol1.intersect(pol2), {fillColor: 'blue'});\n         *   })();\n         * </script><pre>\n         *\n         * @example\n         *  // Dynamic intersection of two polygons pol1 and pol2\n         *  var pol1 = board.create('polygon', [[-2, 3], [-4, -3], [2, 0], [4, 4]], {\n         *                name:'pol1', withLabel: true,\n         *                fillColor: 'yellow'\n         *             });\n         *  var pol2 = board.create('polygon', [[-2, -3], [-4, 1], [0, 4], [5, 1]], {\n         *                name:'pol2', withLabel: true\n         *             });\n         *\n         *  // Dynamic version:\n         *  // the intersection polygon does adapt to changes of pol1 or pol2.\n         *  // For this a curve element is used.\n         *  var curve = board.create('curve', [[],[]], {fillColor: 'blue', fillOpacity: 0.4});\n         *  curve.updateDataArray = function() {\n         *      var mat = JXG.Math.transpose(pol1.intersect(pol2));\n         *\n         *      if (mat.length == 3) {\n         *          this.dataX = mat[1];\n         *          this.dataY = mat[2];\n         *      } else {\n         *          this.dataX = [];\n         *          this.dataY = [];\n         *      }\n         *  };\n         *  board.update();\n         * </pre><div class=\"jxgbox\" id=\"JXGf870d516-ca1a-4140-8fe3-5d64fb42e5f2\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *   (function() {\n         *       var board = JXG.JSXGraph.initBoard('JXGf870d516-ca1a-4140-8fe3-5d64fb42e5f2', {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *       // Intersect two polygons pol1 and pol2\n         *       var pol1 = board.create('polygon', [[-2, 3], [-4, -3], [2, 0], [4, 4]], {\n         *                name:'pol1', withLabel: true,\n         *                fillColor: 'yellow'\n         *             });\n         *       var pol2 = board.create('polygon', [[-2, -3], [-4, 1], [0, 4], [5, 1]], {\n         *                name:'pol2', withLabel: true\n         *             });\n         *\n         *  // Dynamic version:\n         *  // the intersection polygon does  adapt to changes of pol1 or pol2.\n         *  // For this a curve element is used.\n         *    var curve = board.create('curve', [[],[]], {fillColor: 'blue', fillOpacity: 0.4});\n         *    curve.updateDataArray = function() {\n         *        var mat = JXG.Math.transpose(pol1.intersect(pol2));\n         *\n         *        if (mat.length == 3) {\n         *            this.dataX = mat[1];\n         *            this.dataY = mat[2];\n         *        } else {\n         *            this.dataX = [];\n         *            this.dataY = [];\n         *        }\n         *    };\n         *    board.update();\n         *   })();\n         * </script><pre>\n         *\n         */\n        intersect: function (polygon) {\n            return this.sutherlandHodgman(polygon);\n        }\n    }\n);\n\n/**\n * @class A polygon is an area enclosed by a set of border lines which are determined by\n * <ul>\n *    <li> a list of points or\n *    <li> a list of coordinate arrays or\n *    <li> a function returning a list of coordinate arrays.\n * </ul>\n * Each two consecutive points of the list define a line.\n * @pseudo\n * @constructor\n * @name Polygon\n * @type Polygon\n * @augments JXG.Polygon\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Array} vertices The polygon's vertices. If the first and the last vertex don't match the first one will be\n * added to the array by the creator. Here, two points match if they have the same 'id' attribute.\n *\n * Additionally, a polygon can be created by providing a polygon and a transformation (or an array of transformations).\n * The result is a polygon which is the transformation of the supplied polygon.\n *\n * @example\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var p3 = board.create('point', [4.0, 6.0]);\n * var p4 = board.create('point', [1.0, 4.0]);\n *\n * var pol = board.create('polygon', [p1, p2, p3, p4]);\n * </pre><div class=\"jxgbox\" id=\"JXG682069e9-9e2c-4f63-9b73-e26f8a2b2bb1\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG682069e9-9e2c-4f63-9b73-e26f8a2b2bb1', {boundingbox: [-1, 9, 9, -1], axis: false, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [0.0, 2.0]),\n *       p2 = board.create('point', [2.0, 1.0]),\n *       p3 = board.create('point', [4.0, 6.0]),\n *       p4 = board.create('point', [1.0, 4.0]),\n *       cc1 = board.create('polygon', [p1, p2, p3, p4]);\n *  })();\n * </script><pre>\n *\n * @example\n * var p = [[0.0, 2.0], [2.0, 1.0], [4.0, 6.0], [1.0, 3.0]];\n *\n * var pol = board.create('polygon', p, {hasInnerPoints: true});\n * </pre><div class=\"jxgbox\" id=\"JXG9f9a5946-112a-4768-99ca-f30792bcdefb\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG9f9a5946-112a-4768-99ca-f30792bcdefb', {boundingbox: [-1, 9, 9, -1], axis: false, showcopyright: false, shownavigation: false}),\n *       p = [[0.0, 2.0], [2.0, 1.0], [4.0, 6.0], [1.0, 4.0]],\n *       cc1 = board.create('polygon', p, {hasInnerPoints: true});\n *  })();\n * </script><pre>\n *\n * @example\n *   var f1 = function() { return [0.0, 2.0]; },\n *       f2 = function() { return [2.0, 1.0]; },\n *       f3 = function() { return [4.0, 6.0]; },\n *       f4 = function() { return [1.0, 4.0]; },\n *       cc1 = board.create('polygon', [f1, f2, f3, f4]);\n *       board.update();\n *\n * </pre><div class=\"jxgbox\" id=\"JXGceb09915-b783-44db-adff-7877ae3534c8\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *   var board = JXG.JSXGraph.initBoard('JXGceb09915-b783-44db-adff-7877ae3534c8', {boundingbox: [-1, 9, 9, -1], axis: false, showcopyright: false, shownavigation: false}),\n *       f1 = function() { return [0.0, 2.0]; },\n *       f2 = function() { return [2.0, 1.0]; },\n *       f3 = function() { return [4.0, 6.0]; },\n *       f4 = function() { return [1.0, 4.0]; },\n *       cc1 = board.create('polygon', [f1, f2, f3, f4]);\n *       board.update();\n *  })();\n * </script><pre>\n *\n * @example\n * var t = board.create('transform', [2, 1.5], {type: 'scale'});\n * var a = board.create('point', [-3,-2], {name: 'a'});\n * var b = board.create('point', [-1,-4], {name: 'b'});\n * var c = board.create('point', [-2,-0.5], {name: 'c'});\n * var pol1 = board.create('polygon', [a,b,c], {vertices: {withLabel: false}});\n * var pol2 = board.create('polygon', [pol1, t], {vertices: {withLabel: true}});\n *\n * </pre><div id=\"JXG6530a69c-6339-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG6530a69c-6339-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var t = board.create('transform', [2, 1.5], {type: 'scale'});\n *     var a = board.create('point', [-3,-2], {name: 'a'});\n *     var b = board.create('point', [-1,-4], {name: 'b'});\n *     var c = board.create('point', [-2,-0.5], {name: 'c'});\n *     var pol1 = board.create('polygon', [a,b,c], {vertices: {withLabel: false}});\n *     var pol2 = board.create('polygon', [pol1, t], {vertices: {withLabel: true}});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createPolygon = function (board, parents, attributes) {\n    var el,\n        i,\n        le,\n        obj,\n        points = [],\n        attr,\n        attr_points,\n        is_transform = false;\n\n    attr = Type.copyAttributes(attributes, board.options, \"polygon\");\n    obj = board.select(parents[0]);\n    if (obj === null) {\n        // This is necessary if the original polygon is defined in another board.\n        obj = parents[0];\n    }\n    if (\n        Type.isObject(obj) &&\n        obj.type === Const.OBJECT_TYPE_POLYGON &&\n        Type.isTransformationOrArray(parents[1])\n    ) {\n        is_transform = true;\n        le = obj.vertices.length - 1;\n        attr_points = Type.copyAttributes(attributes, board.options, \"polygon\", \"vertices\");\n        for (i = 0; i < le; i++) {\n            if (attr_points.withlabel) {\n                attr_points.name =\n                    obj.vertices[i].name === \"\" ? \"\" : obj.vertices[i].name + \"'\";\n            }\n            points.push(board.create(\"point\", [obj.vertices[i], parents[1]], attr_points));\n        }\n    } else {\n        points = Type.providePoints(board, parents, attributes, \"polygon\", [\"vertices\"]);\n        if (points === false) {\n            throw new Error(\n                \"JSXGraph: Can't create polygon / polygonalchain with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates. Alternatively, a polygon and a transformation can be supplied\"\n            );\n        }\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"polygon\");\n    el = new JXG.Polygon(board, points, attr);\n    el.isDraggable = true;\n\n    // Put the points to their position\n    if (is_transform) {\n        el.prepareUpdate().update().updateVisibility().updateRenderer();\n        le = obj.vertices.length - 1;\n        for (i = 0; i < le; i++) {\n            points[i].prepareUpdate().update().updateVisibility().updateRenderer();\n        }\n    }\n\n    return el;\n};\n\n/**\n * @class Constructs a regular polygon. It needs two points which define the base line and the number of vertices.\n * @pseudo\n * @description Constructs a regular polygon. It needs two points which define the base line and the number of vertices, or a set of points.\n * @constructor\n * @name RegularPolygon\n * @type Polygon\n * @augments Polygon\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_Number} p1,p2,n The constructed regular polygon has n vertices and the base line defined by p1 and p2.\n * @example\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n *\n * var pol = board.create('regularpolygon', [p1, p2, 5]);\n * </pre><div class=\"jxgbox\" id=\"JXG682069e9-9e2c-4f63-9b73-e26f8a2b2bb1\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *  (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG682069e9-9e2c-4f63-9b73-e26f8a2b2bb1', {boundingbox: [-1, 9, 9, -1], axis: false, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [0.0, 2.0]),\n *       p2 = board.create('point', [2.0, 1.0]),\n *       cc1 = board.create('regularpolygon', [p1, p2, 5]);\n *  })();\n * </script><pre>\n * @example\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [4.0,4.0]);\n * var p3 = board.create('point', [2.0,0.0]);\n *\n * var pol = board.create('regularpolygon', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG096a78b3-bd50-4bac-b958-3be5e7df17ed\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG096a78b3-bd50-4bac-b958-3be5e7df17ed', {boundingbox: [-1, 9, 9, -1], axis: false, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [0.0, 2.0]),\n *       p2 = board.create('point', [4.0, 4.0]),\n *       p3 = board.create('point', [2.0,0.0]),\n *       cc1 = board.create('regularpolygon', [p1, p2, p3]);\n * })();\n * </script><pre>\n *\n * @example\n *         // Line of reflection\n *         var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *         var reflect = board.create('transform', [li], {type: 'reflect'});\n *         var pol1 = board.create('polygon', [[-3,-2], [-1,-4], [-2,-0.5]]);\n *         var pol2 = board.create('polygon', [pol1, reflect]);\n *\n * </pre><div id=\"JXG58fc3078-d8d1-11e7-93b3-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG58fc3078-d8d1-11e7-93b3-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *             var reflect = board.create('transform', [li], {type: 'reflect'});\n *             var pol1 = board.create('polygon', [[-3,-2], [-1,-4], [-2,-0.5]]);\n *             var pol2 = board.create('polygon', [pol1, reflect]);\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createRegularPolygon = function (board, parents, attributes) {\n    var el,\n        i,\n        n,\n        p = [],\n        rot,\n        len,\n        pointsExist,\n        attr;\n\n    len = parents.length;\n    n = parents[len - 1];\n\n    if (Type.isNumber(n) && (parents.length !== 3 || n < 3)) {\n        throw new Error(\n            \"JSXGraph: A regular polygon needs two point types and a number > 2 as input.\"\n        );\n    }\n\n    if (Type.isNumber(board.select(n))) {\n        // Regular polygon given by 2 points and a number\n        len--;\n        pointsExist = false;\n    } else {\n        // Regular polygon given by n points\n        n = len;\n        pointsExist = true;\n    }\n\n    p = Type.providePoints(board, parents.slice(0, len), attributes, \"regularpolygon\", [\n        \"vertices\"\n    ]);\n    if (p === false) {\n        throw new Error(\n            \"JSXGraph: Can't create regular polygon with parent types other than 'point' and 'coordinate arrays' or a function returning an array of coordinates\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"regularpolygon\", \"vertices\");\n    for (i = 2; i < n; i++) {\n        rot = board.create(\"transform\", [Math.PI * (2 - (n - 2) / n), p[i - 1]], {\n            type: \"rotate\"\n        });\n        if (pointsExist) {\n            p[i].addTransform(p[i - 2], rot);\n            p[i].fullUpdate();\n        } else {\n            if (Type.isArray(attr.ids) && attr.ids.length >= n - 2) {\n                attr.id = attr.ids[i - 2];\n            }\n            p[i] = board.create(\"point\", [p[i - 2], rot], attr);\n            p[i].type = Const.OBJECT_TYPE_CAS;\n\n            // The next two lines of code are needed to make regular polygones draggable\n            // The new helper points are set to be draggable.\n            p[i].isDraggable = true;\n            p[i].visProp.fixed = false;\n        }\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"regularpolygon\");\n    el = board.create(\"polygon\", p, attr);\n    el.elType = \"regularpolygon\";\n\n    return el;\n};\n\n/**\n * @class  A polygonal chain is a connected series of line segments determined by\n * <ul>\n *    <li> a list of points or\n *    <li> a list of coordinate arrays or\n *    <li> a function returning a list of coordinate arrays.\n * </ul>\n * Each two consecutive points of the list define a line.\n * In JSXGraph, a polygonal chain is simply realized as polygon without the last - closing - point.\n * This may lead to unexpected results. Polygonal chains can be distinguished from polygons by the attribute 'elType' which\n * is 'polygonalchain' for the first and 'polygon' for the latter.\n * @pseudo\n * @constructor\n * @name PolygonalChain\n * @type Polygon\n * @augments JXG.Polygon\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Array} vertices The polygon's vertices.\n *\n * Additionally, a polygonal chain can be created by providing a polygonal chain and a transformation (or an array of transformations).\n * The result is a polygonal chain which is the transformation of the supplied polygona chain.\n *\n * @example\n *     var attr = {\n *             snapToGrid: true\n *         },\n *         p = [];\n *\n * \tp.push(board.create('point', [-4, 0], attr));\n * \tp.push(board.create('point', [-1, -3], attr));\n * \tp.push(board.create('point', [0, 2], attr));\n * \tp.push(board.create('point', [2, 1], attr));\n * \tp.push(board.create('point', [4, -2], attr));\n *\n *  var chain = board.create('polygonalchain', p, {borders: {strokeWidth: 3}});\n *\n * </pre><div id=\"JXG878f93d8-3e49-46cf-aca2-d3bb7d60c5ae\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG878f93d8-3e49-46cf-aca2-d3bb7d60c5ae',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *         var attr = {\n *                 snapToGrid: true\n *             },\n *             p = [];\n *\n *     \tp.push(board.create('point', [-4, 0], attr));\n *     \tp.push(board.create('point', [-1, -3], attr));\n *     \tp.push(board.create('point', [0, 2], attr));\n *     \tp.push(board.create('point', [2, 1], attr));\n *     \tp.push(board.create('point', [4, -2], attr));\n *\n *         var chain = board.create('polygonalchain', p, {borders: {strokeWidth: 3}});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createPolygonalChain = function (board, parents, attributes) {\n    var attr, el;\n\n    attr = Type.copyAttributes(attributes, board.options, \"polygonalchain\");\n    el = board.create(\"polygon\", parents, attr);\n    el.elType = \"polygonalchain\";\n\n    // A polygonal chain is not necessarily closed.\n    el.vertices.pop();\n    board.removeObject(el.borders[el.borders.length - 1]);\n    el.borders.pop();\n\n    return el;\n};\n\nJXG.registerElement(\"polygon\", JXG.createPolygon);\nJXG.registerElement(\"regularpolygon\", JXG.createRegularPolygon);\nJXG.registerElement(\"polygonalchain\", JXG.createPolygonalChain);\n\nexport default {\n    Polygon: JXG.Polygon,\n    createPolygon: JXG.createPolygon,\n    createRegularPolygon: JXG.createRegularPolygon\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the geometry element Curve is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport Coords from \"./coords\";\nimport GeometryElement from \"./element\";\nimport Mat from \"../math/math\";\nimport Numerics from \"../math/numerics\";\nimport Plot from \"../math/plot\";\nimport Geometry from \"../math/geometry\";\nimport GeonextParser from \"../parser/geonext\";\nimport Type from \"../utils/type\";\nimport QDT from \"../math/qdt\";\n\n/**\n * Curves are the common object for function graphs, parametric curves, polar curves, and data plots.\n * @class Creates a new curve object. Do not use this constructor to create a curve. Use {@link JXG.Board#create} with\n * type {@link Curve}, or {@link Functiongraph} instead.\n * @augments JXG.GeometryElement\n * @param {String|JXG.Board} board The board the new curve is drawn on.\n * @param {Array} parents defining terms An array with the functon terms or the data points of the curve.\n * @param {Object} attributes Defines the visual appearance of the curve.\n * @see JXG.Board#generateName\n * @see JXG.Board#addCurve\n */\nJXG.Curve = function (board, parents, attributes) {\n    this.constructor(board, attributes, Const.OBJECT_TYPE_CURVE, Const.OBJECT_CLASS_CURVE);\n\n    this.points = [];\n    /**\n     * Number of points on curves. This value changes\n     * between numberPointsLow and numberPointsHigh.\n     * It is set in {@link JXG.Curve#updateCurve}.\n     */\n    this.numberPoints = Type.evaluate(this.visProp.numberpointshigh);\n\n    this.bezierDegree = 1;\n\n    /**\n     * Array holding the x-coordinates of a data plot.\n     * This array can be updated during run time by overwriting\n     * the method {@link JXG.Curve#updateDataArray}.\n     * @type array\n     */\n    this.dataX = null;\n\n    /**\n     * Array holding the y-coordinates of a data plot.\n     * This array can be updated during run time by overwriting\n     * the method {@link JXG.Curve#updateDataArray}.\n     * @type array\n     */\n    this.dataY = null;\n\n    /**\n     * Array of ticks storing all the ticks on this curve. Do not set this field directly and use\n     * {@link JXG.Curve#addTicks} and {@link JXG.Curve#removeTicks} to add and remove ticks to and\n     * from the curve.\n     * @type Array\n     * @see JXG.Ticks\n     */\n    this.ticks = [];\n\n    /**\n     * Stores a quad tree if it is required. The quad tree is generated in the curve\n     * updates and can be used to speed up the hasPoint method.\n     * @type JXG.Math.Quadtree\n     */\n    this.qdt = null;\n\n    if (Type.exists(parents[0])) {\n        this.varname = parents[0];\n    } else {\n        this.varname = \"x\";\n    }\n\n    // function graphs: \"x\"\n    this.xterm = parents[1];\n    // function graphs: e.g. \"x^2\"\n    this.yterm = parents[2];\n\n    // Converts GEONExT syntax into JavaScript syntax\n    this.generateTerm(this.varname, this.xterm, this.yterm, parents[3], parents[4]);\n    // First evaluation of the curve\n    this.updateCurve();\n\n    this.id = this.board.setId(this, \"G\");\n    this.board.renderer.drawCurve(this);\n\n    this.board.finalizeAdding(this);\n\n    this.createGradient();\n    this.elType = \"curve\";\n    this.createLabel();\n\n    if (Type.isString(this.xterm)) {\n        this.notifyParents(this.xterm);\n    }\n    if (Type.isString(this.yterm)) {\n        this.notifyParents(this.yterm);\n    }\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        generateTerm: \"generateTerm\",\n        setTerm: \"generateTerm\",\n        move: \"moveTo\",\n        moveTo: \"moveTo\"\n    });\n};\n\nJXG.Curve.prototype = new GeometryElement();\n\nJXG.extend(\n    JXG.Curve.prototype,\n    /** @lends JXG.Curve.prototype */ {\n        /**\n         * Gives the default value of the left bound for the curve.\n         * May be overwritten in {@link JXG.Curve#generateTerm}.\n         * @returns {Number} Left bound for the curve.\n         */\n        minX: function () {\n            var leftCoords;\n\n            if (Type.evaluate(this.visProp.curvetype) === \"polar\") {\n                return 0;\n            }\n\n            leftCoords = new Coords(\n                Const.COORDS_BY_SCREEN,\n                [-this.board.canvasWidth * 0.1, 0],\n                this.board,\n                false\n            );\n            return leftCoords.usrCoords[1];\n        },\n\n        /**\n         * Gives the default value of the right bound for the curve.\n         * May be overwritten in {@link JXG.Curve#generateTerm}.\n         * @returns {Number} Right bound for the curve.\n         */\n        maxX: function () {\n            var rightCoords;\n\n            if (Type.evaluate(this.visProp.curvetype) === \"polar\") {\n                return 2 * Math.PI;\n            }\n            rightCoords = new Coords(\n                Const.COORDS_BY_SCREEN,\n                [this.board.canvasWidth * 1.1, 0],\n                this.board,\n                false\n            );\n\n            return rightCoords.usrCoords[1];\n        },\n\n        /**\n         * The parametric function which defines the x-coordinate of the curve.\n         * @param {Number} t A number between {@link JXG.Curve#minX} and {@link JXG.Curve#maxX}.\n         * @param {Boolean} suspendUpdate A boolean flag which is false for the\n         * first call of the function during a fresh plot of the curve and true\n         * for all subsequent calls of the function. This may be used to speed up the\n         * plotting of the curve, if the e.g. the curve depends on some input elements.\n         * @returns {Number} x-coordinate of the curve at t.\n         */\n        X: function (t) {\n            return NaN;\n        },\n\n        /**\n         * The parametric function which defines the y-coordinate of the curve.\n         * @param {Number} t A number between {@link JXG.Curve#minX} and {@link JXG.Curve#maxX}.\n         * @param {Boolean} suspendUpdate A boolean flag which is false for the\n         * first call of the function during a fresh plot of the curve and true\n         * for all subsequent calls of the function. This may be used to speed up the\n         * plotting of the curve, if the e.g. the curve depends on some input elements.\n         * @returns {Number} y-coordinate of the curve at t.\n         */\n        Y: function (t) {\n            return NaN;\n        },\n\n        /**\n         * Treat the curve as curve with homogeneous coordinates.\n         * @param {Number} t A number between {@link JXG.Curve#minX} and {@link JXG.Curve#maxX}.\n         * @returns {Number} Always 1.0\n         */\n        Z: function (t) {\n            return 1;\n        },\n\n        /**\n         * Checks whether (x,y) is near the curve.\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @param {Number} start Optional start index for search on data plots.\n         * @returns {Boolean} True if (x,y) is near the curve, False otherwise.\n         */\n        hasPoint: function (x, y, start) {\n            var t,\n                checkPoint,\n                len,\n                invMat,\n                c,\n                i,\n                tX,\n                tY,\n                isIn,\n                res = [],\n                points,\n                qdt,\n                steps = Type.evaluate(this.visProp.numberpointslow),\n                d = (this.maxX() - this.minX()) / steps,\n                prec,\n                type,\n                dist = Infinity,\n                ux2,\n                uy2,\n                ev_ct,\n                mi,\n                ma,\n                suspendUpdate = true;\n\n            if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n                type = this.board._inputDevice;\n                prec = Type.evaluate(this.visProp.precision[type]);\n            } else {\n                // 'inherit'\n                prec = this.board.options.precision.hasPoint;\n            }\n\n            // From now on, x,y are usrCoords\n            checkPoint = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board, false);\n            x = checkPoint.usrCoords[1];\n            y = checkPoint.usrCoords[2];\n\n            // Handle inner points of the curve\n            if (this.bezierDegree === 1 && Type.evaluate(this.visProp.hasinnerpoints)) {\n                isIn = Geometry.windingNumber([1, x, y], this.points, true);\n                if (isIn !== 0) {\n                    return true;\n                }\n            }\n\n            // We use usrCoords. Only in the final distance calculation\n            // screen coords are used\n            prec += Type.evaluate(this.visProp.strokewidth) * 0.5;\n            prec *= prec; // We do not want to take sqrt\n            ux2 = this.board.unitX * this.board.unitX;\n            uy2 = this.board.unitY * this.board.unitY;\n\n            mi = this.minX();\n            ma = this.maxX();\n            if (Type.exists(this._visibleArea)) {\n                mi = this._visibleArea[0];\n                ma = this._visibleArea[1];\n                d = (ma - mi) / steps;\n            }\n\n            ev_ct = Type.evaluate(this.visProp.curvetype);\n            if (ev_ct === \"parameter\" || ev_ct === \"polar\") {\n                // Transform the mouse/touch coordinates\n                // back to the original position of the curve.\n                // This is needed, because we work with the function terms, not the points.\n                if (this.transformations.length > 0) {\n                    this.updateTransformMatrix();\n                    invMat = Mat.inverse(this.transformMat);\n                    c = Mat.matVecMult(invMat, [1, x, y]);\n                    x = c[1];\n                    y = c[2];\n                }\n\n                // Brute force search for a point on the curve close to the mouse pointer\n                for (i = 0, t = mi; i < steps; i++) {\n                    tX = this.X(t, suspendUpdate);\n                    tY = this.Y(t, suspendUpdate);\n\n                    dist = (x - tX) * (x - tX) * ux2 + (y - tY) * (y - tY) * uy2;\n\n                    if (dist <= prec) {\n                        return true;\n                    }\n\n                    t += d;\n                }\n            } else if (ev_ct === \"plot\" || ev_ct === \"functiongraph\") {\n                // Here, we can ignore transformations of the curve,\n                // since we are working directly with the points.\n\n                if (!Type.exists(start) || start < 0) {\n                    start = 0;\n                }\n\n                if (\n                    Type.exists(this.qdt) &&\n                    Type.evaluate(this.visProp.useqdt) &&\n                    this.bezierDegree !== 3\n                ) {\n                    qdt = this.qdt.query(new Coords(Const.COORDS_BY_USER, [x, y], this.board));\n                    points = qdt.points;\n                    len = points.length;\n                } else {\n                    points = this.points;\n                    len = this.numberPoints - 1;\n                }\n\n                for (i = start; i < len; i++) {\n                    if (this.bezierDegree === 3) {\n                        res.push(Geometry.projectCoordsToBeziersegment([1, x, y], this, i));\n                    } else {\n                        if (qdt) {\n                            if (points[i].prev) {\n                                res = Geometry.projectCoordsToSegment(\n                                    [1, x, y],\n                                    points[i].prev.usrCoords,\n                                    points[i].usrCoords\n                                );\n                            }\n\n                            // If the next point in the array is the same as the current points\n                            // next neighbor we don't have to project it onto that segment because\n                            // that will already be done in the next iteration of this loop.\n                            if (points[i].next && points[i + 1] !== points[i].next) {\n                                res = Geometry.projectCoordsToSegment(\n                                    [1, x, y],\n                                    points[i].usrCoords,\n                                    points[i].next.usrCoords\n                                );\n                            }\n                        } else {\n                            res = Geometry.projectCoordsToSegment(\n                                [1, x, y],\n                                points[i].usrCoords,\n                                points[i + 1].usrCoords\n                            );\n                        }\n                    }\n\n                    if (\n                        res[1] >= 0 &&\n                        res[1] <= 1 &&\n                        (x - res[0][1]) * (x - res[0][1]) * ux2 +\n                            (y - res[0][2]) * (y - res[0][2]) * uy2 <=\n                            prec\n                    ) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            return dist < prec;\n        },\n\n        /**\n         * Allocate points in the Coords array this.points\n         */\n        allocatePoints: function () {\n            var i, len;\n\n            len = this.numberPoints;\n\n            if (this.points.length < this.numberPoints) {\n                for (i = this.points.length; i < len; i++) {\n                    this.points[i] = new Coords(\n                        Const.COORDS_BY_USER,\n                        [0, 0],\n                        this.board,\n                        false\n                    );\n                }\n            }\n        },\n\n        /**\n         * Computes for equidistant points on the x-axis the values of the function\n         * @returns {JXG.Curve} Reference to the curve object.\n         * @see JXG.Curve#updateCurve\n         */\n        update: function () {\n            if (this.needsUpdate) {\n                if (Type.evaluate(this.visProp.trace)) {\n                    this.cloneToBackground(true);\n                }\n                this.updateCurve();\n            }\n\n            return this;\n        },\n\n        /**\n         * Updates the visual contents of the curve.\n         * @returns {JXG.Curve} Reference to the curve object.\n         */\n        updateRenderer: function () {\n            //var wasReal;\n\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            if (this.visPropCalc.visible) {\n                // wasReal = this.isReal;\n\n                this.isReal = Plot.checkReal(this.points);\n\n                if (\n                    //wasReal &&\n                    !this.isReal\n                ) {\n                    this.updateVisibility(false);\n                }\n            }\n\n            if (this.visPropCalc.visible) {\n                this.board.renderer.updateCurve(this);\n            }\n\n            /* Update the label if visible. */\n            if (\n                this.hasLabel &&\n                this.visPropCalc.visible &&\n                this.label &&\n                this.label.visPropCalc.visible &&\n                this.isReal\n            ) {\n                this.label.update();\n                this.board.renderer.updateText(this.label);\n            }\n\n            // Update rendNode display\n            this.setDisplayRendNode();\n            // if (this.visPropCalc.visible !== this.visPropOld.visible) {\n            //     this.board.renderer.display(this, this.visPropCalc.visible);\n            //     this.visPropOld.visible = this.visPropCalc.visible;\n            //\n            //     if (this.hasLabel) {\n            //         this.board.renderer.display(this.label, this.label.visPropCalc.visible);\n            //     }\n            // }\n\n            this.needsUpdate = false;\n            return this;\n        },\n\n        /**\n         * For dynamic dataplots updateCurve can be used to compute new entries\n         * for the arrays {@link JXG.Curve#dataX} and {@link JXG.Curve#dataY}. It\n         * is used in {@link JXG.Curve#updateCurve}. Default is an empty method, can\n         * be overwritten by the user.\n         *\n         *\n         * @example\n         * // This example overwrites the updateDataArray method.\n         * // There, new values for the arrays JXG.Curve.dataX and JXG.Curve.dataY\n         * // are computed from the value of the slider N\n         *\n         * var N = board.create('slider', [[0,1.5],[3,1.5],[1,3,40]], {name:'n',snapWidth:1});\n         * var circ = board.create('circle',[[4,-1.5],1],{strokeWidth:1, strokecolor:'black', strokeWidth:2,\n         * \t\tfillColor:'#0055ff13'});\n         *\n         * var c = board.create('curve', [[0],[0]],{strokecolor:'red', strokeWidth:2});\n         * c.updateDataArray = function() {\n         *         var r = 1, n = Math.floor(N.Value()),\n         *             x = [0], y = [0],\n         *             phi = Math.PI/n,\n         *             h = r*Math.cos(phi),\n         *             s = r*Math.sin(phi),\n         *             i, j,\n         *             px = 0, py = 0, sgn = 1,\n         *             d = 16,\n         *             dt = phi/d,\n         *             pt;\n         *\n         *         for (i = 0; i < n; i++) {\n         *             for (j = -d; j <= d; j++) {\n         *                 pt = dt*j;\n         *                 x.push(px + r*Math.sin(pt));\n         *                 y.push(sgn*r*Math.cos(pt) - (sgn-1)*h*0.5);\n         *             }\n         *             px += s;\n         *             sgn *= (-1);\n         *         }\n         *         x.push((n - 1)*s);\n         *         y.push(h + (sgn - 1)*h*0.5);\n         *         this.dataX = x;\n         *         this.dataY = y;\n         *     }\n         *\n         * var c2 = board.create('curve', [[0],[0]],{strokecolor:'red', strokeWidth:1});\n         * c2.updateDataArray = function() {\n         *         var r = 1, n = Math.floor(N.Value()),\n         *             px = circ.midpoint.X(), py = circ.midpoint.Y(),\n         *             x = [px], y = [py],\n         *             phi = Math.PI/n,\n         *             s = r*Math.sin(phi),\n         *             i, j,\n         *             d = 16,\n         *             dt = phi/d,\n         *             pt = Math.PI*0.5+phi;\n         *\n         *         for (i = 0; i < n; i++) {\n         *             for (j= -d; j <= d; j++) {\n         *                 x.push(px + r*Math.cos(pt));\n         *                 y.push(py + r*Math.sin(pt));\n         *                 pt -= dt;\n         *             }\n         *             x.push(px);\n         *             y.push(py);\n         *             pt += dt;\n         *         }\n         *         this.dataX = x;\n         *         this.dataY = y;\n         *     }\n         *     board.update();\n         *\n         * </pre><div id=\"JXG20bc7802-e69e-11e5-b1bf-901b0e1b8723\" class=\"jxgbox\" style=\"width: 600px; height: 400px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG20bc7802-e69e-11e5-b1bf-901b0e1b8723',\n         *             {boundingbox: [-1.5,2,8,-3], keepaspectratio: true, axis: true, showcopyright: false, shownavigation: false});\n         *             var N = board.create('slider', [[0,1.5],[3,1.5],[1,3,40]], {name:'n',snapWidth:1});\n         *             var circ = board.create('circle',[[4,-1.5],1],{strokeWidth:1, strokecolor:'black',\n         *             strokeWidth:2, fillColor:'#0055ff13'});\n         *\n         *             var c = board.create('curve', [[0],[0]],{strokecolor:'red', strokeWidth:2});\n         *             c.updateDataArray = function() {\n         *                     var r = 1, n = Math.floor(N.Value()),\n         *                         x = [0], y = [0],\n         *                         phi = Math.PI/n,\n         *                         h = r*Math.cos(phi),\n         *                         s = r*Math.sin(phi),\n         *                         i, j,\n         *                         px = 0, py = 0, sgn = 1,\n         *                         d = 16,\n         *                         dt = phi/d,\n         *                         pt;\n         *\n         *                     for (i=0;i<n;i++) {\n         *                         for (j=-d;j<=d;j++) {\n         *                             pt = dt*j;\n         *                             x.push(px+r*Math.sin(pt));\n         *                             y.push(sgn*r*Math.cos(pt)-(sgn-1)*h*0.5);\n         *                         }\n         *                         px += s;\n         *                         sgn *= (-1);\n         *                     }\n         *                     x.push((n-1)*s);\n         *                     y.push(h+(sgn-1)*h*0.5);\n         *                     this.dataX = x;\n         *                     this.dataY = y;\n         *                 }\n         *\n         *             var c2 = board.create('curve', [[0],[0]],{strokecolor:'red', strokeWidth:1});\n         *             c2.updateDataArray = function() {\n         *                     var r = 1, n = Math.floor(N.Value()),\n         *                         px = circ.midpoint.X(), py = circ.midpoint.Y(),\n         *                         x = [px], y = [py],\n         *                         phi = Math.PI/n,\n         *                         s = r*Math.sin(phi),\n         *                         i, j,\n         *                         d = 16,\n         *                         dt = phi/d,\n         *                         pt = Math.PI*0.5+phi;\n         *\n         *                     for (i=0;i<n;i++) {\n         *                         for (j=-d;j<=d;j++) {\n         *                             x.push(px+r*Math.cos(pt));\n         *                             y.push(py+r*Math.sin(pt));\n         *                             pt -= dt;\n         *                         }\n         *                         x.push(px);\n         *                         y.push(py);\n         *                         pt += dt;\n         *                     }\n         *                     this.dataX = x;\n         *                     this.dataY = y;\n         *                 }\n         *                 board.update();\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         * @example\n         * // This is an example which overwrites updateDataArray and produces\n         * // a Bezier curve of degree three.\n         * var A = board.create('point', [-3,3]);\n         * var B = board.create('point', [3,-2]);\n         * var line = board.create('segment', [A,B]);\n         *\n         * var height = 0.5; // height of the curly brace\n         *\n         * // Curly brace\n         * var crl = board.create('curve', [[0],[0]], {strokeWidth:1, strokeColor:'black'});\n         * crl.bezierDegree = 3;\n         * crl.updateDataArray = function() {\n         *     var d = [B.X()-A.X(), B.Y()-A.Y()],\n         *         dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),\n         *         mid = [(A.X()+B.X())*0.5, (A.Y()+B.Y())*0.5];\n         *\n         *     d[0] *= height/dl;\n         *     d[1] *= height/dl;\n         *\n         *     this.dataX = [ A.X(), A.X()-d[1], mid[0], mid[0]-d[1], mid[0], B.X()-d[1], B.X() ];\n         *     this.dataY = [ A.Y(), A.Y()+d[0], mid[1], mid[1]+d[0], mid[1], B.Y()+d[0], B.Y() ];\n         * };\n         *\n         * // Text\n         * var txt = board.create('text', [\n         *                     function() {\n         *                         var d = [B.X()-A.X(), B.Y()-A.Y()],\n         *                             dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),\n         *                             mid = (A.X()+B.X())*0.5;\n         *\n         *                         d[1] *= height/dl;\n         *                         return mid-d[1]+0.1;\n         *                     },\n         *                     function() {\n         *                         var d = [B.X()-A.X(), B.Y()-A.Y()],\n         *                             dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),\n         *                             mid = (A.Y()+B.Y())*0.5;\n         *\n         *                         d[0] *= height/dl;\n         *                         return mid+d[0]+0.1;\n         *                     },\n         *                     function() { return \"length=\" + JXG.toFixed(B.Dist(A), 2); }\n         *                 ]);\n         *\n         *\n         * board.update(); // This update is necessary to call updateDataArray the first time.\n         *\n         * </pre><div id=\"JXGa61a4d66-e69f-11e5-b1bf-901b0e1b8723\"  class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *      var board = JXG.JSXGraph.initBoard('JXGa61a4d66-e69f-11e5-b1bf-901b0e1b8723',\n         *             {boundingbox: [-4, 4, 4,-4], axis: true, showcopyright: false, shownavigation: false});\n         *     var A = board.create('point', [-3,3]);\n         *     var B = board.create('point', [3,-2]);\n         *     var line = board.create('segment', [A,B]);\n         *\n         *     var height = 0.5; // height of the curly brace\n         *\n         *     // Curly brace\n         *     var crl = board.create('curve', [[0],[0]], {strokeWidth:1, strokeColor:'black'});\n         *     crl.bezierDegree = 3;\n         *     crl.updateDataArray = function() {\n         *         var d = [B.X()-A.X(), B.Y()-A.Y()],\n         *             dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),\n         *             mid = [(A.X()+B.X())*0.5, (A.Y()+B.Y())*0.5];\n         *\n         *         d[0] *= height/dl;\n         *         d[1] *= height/dl;\n         *\n         *         this.dataX = [ A.X(), A.X()-d[1], mid[0], mid[0]-d[1], mid[0], B.X()-d[1], B.X() ];\n         *         this.dataY = [ A.Y(), A.Y()+d[0], mid[1], mid[1]+d[0], mid[1], B.Y()+d[0], B.Y() ];\n         *     };\n         *\n         *     // Text\n         *     var txt = board.create('text', [\n         *                         function() {\n         *                             var d = [B.X()-A.X(), B.Y()-A.Y()],\n         *                                 dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),\n         *                                 mid = (A.X()+B.X())*0.5;\n         *\n         *                             d[1] *= height/dl;\n         *                             return mid-d[1]+0.1;\n         *                         },\n         *                         function() {\n         *                             var d = [B.X()-A.X(), B.Y()-A.Y()],\n         *                                 dl = Math.sqrt(d[0]*d[0]+d[1]*d[1]),\n         *                                 mid = (A.Y()+B.Y())*0.5;\n         *\n         *                             d[0] *= height/dl;\n         *                             return mid+d[0]+0.1;\n         *                         },\n         *                         function() { return \"length=\"+JXG.toFixed(B.Dist(A), 2); }\n         *                     ]);\n         *\n         *\n         *     board.update(); // This update is necessary to call updateDataArray the first time.\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         *\n         */\n        updateDataArray: function () {\n            // this used to return this, but we shouldn't rely on the user to implement it.\n        },\n\n        /**\n         * Computes the curve path\n         * @see JXG.Curve#update\n         * @returns {JXG.Curve} Reference to the curve object.\n         */\n        updateCurve: function () {\n            var len,\n                mi,\n                ma,\n                x,\n                y,\n                i,\n                version = this.visProp.plotversion,\n                //t1, t2, l1,\n                suspendUpdate = false;\n\n            this.updateTransformMatrix();\n            this.updateDataArray();\n            mi = this.minX();\n            ma = this.maxX();\n\n            // Discrete data points\n            // x-coordinates are in an array\n            if (Type.exists(this.dataX)) {\n                this.numberPoints = this.dataX.length;\n                len = this.numberPoints;\n\n                // It is possible, that the array length has increased.\n                this.allocatePoints();\n\n                for (i = 0; i < len; i++) {\n                    x = i;\n\n                    // y-coordinates are in an array\n                    if (Type.exists(this.dataY)) {\n                        y = i;\n                        // The last parameter prevents rounding in usr2screen().\n                        this.points[i].setCoordinates(\n                            Const.COORDS_BY_USER,\n                            [this.dataX[i], this.dataY[i]],\n                            false\n                        );\n                    } else {\n                        // discrete x data, continuous y data\n                        y = this.X(x);\n                        // The last parameter prevents rounding in usr2screen().\n                        this.points[i].setCoordinates(\n                            Const.COORDS_BY_USER,\n                            [this.dataX[i], this.Y(y, suspendUpdate)],\n                            false\n                        );\n                    }\n                    this.points[i]._t = i;\n\n                    // this.updateTransform(this.points[i]);\n                    suspendUpdate = true;\n                }\n                // continuous x data\n            } else {\n                if (Type.evaluate(this.visProp.doadvancedplot)) {\n                    // console.time(\"plot\");\n\n                    if (version === 1 || Type.evaluate(this.visProp.doadvancedplotold)) {\n                        Plot.updateParametricCurveOld(this, mi, ma);\n                    } else if (version === 2) {\n                        Plot.updateParametricCurve_v2(this, mi, ma);\n                    } else if (version === 3) {\n                        Plot.updateParametricCurve_v3(this, mi, ma);\n                    } else if (version === 4) {\n                        Plot.updateParametricCurve_v4(this, mi, ma);\n                    } else {\n                        Plot.updateParametricCurve_v2(this, mi, ma);\n                    }\n                    // console.timeEnd(\"plot\");\n                } else {\n                    if (this.board.updateQuality === this.board.BOARD_QUALITY_HIGH) {\n                        this.numberPoints = Type.evaluate(this.visProp.numberpointshigh);\n                    } else {\n                        this.numberPoints = Type.evaluate(this.visProp.numberpointslow);\n                    }\n\n                    // It is possible, that the array length has increased.\n                    this.allocatePoints();\n                    Plot.updateParametricCurveNaive(this, mi, ma, this.numberPoints);\n                }\n                len = this.numberPoints;\n\n                if (\n                    Type.evaluate(this.visProp.useqdt) &&\n                    this.board.updateQuality === this.board.BOARD_QUALITY_HIGH\n                ) {\n                    this.qdt = new QDT(this.board.getBoundingBox());\n                    for (i = 0; i < this.points.length; i++) {\n                        this.qdt.insert(this.points[i]);\n\n                        if (i > 0) {\n                            this.points[i].prev = this.points[i - 1];\n                        }\n\n                        if (i < len - 1) {\n                            this.points[i].next = this.points[i + 1];\n                        }\n                    }\n                }\n\n                // for (i = 0; i < len; i++) {\n                //     this.updateTransform(this.points[i]);\n                // }\n            }\n\n            if (\n                Type.evaluate(this.visProp.curvetype) !== \"plot\" &&\n                Type.evaluate(this.visProp.rdpsmoothing)\n            ) {\n                // console.time(\"rdp\");\n                this.points = Numerics.RamerDouglasPeucker(this.points, 0.2);\n                this.numberPoints = this.points.length;\n                // console.timeEnd(\"rdp\");\n                // console.log(this.numberPoints);\n            }\n\n            len = this.numberPoints;\n            for (i = 0; i < len; i++) {\n                this.updateTransform(this.points[i]);\n            }\n\n            return this;\n        },\n\n        updateTransformMatrix: function () {\n            var t,\n                i,\n                len = this.transformations.length;\n\n            this.transformMat = [\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1]\n            ];\n\n            for (i = 0; i < len; i++) {\n                t = this.transformations[i];\n                t.update();\n                this.transformMat = Mat.matMatMult(t.matrix, this.transformMat);\n            }\n\n            return this;\n        },\n\n        /**\n         * Applies the transformations of the curve to the given point <tt>p</tt>.\n         * Before using it, {@link JXG.Curve#updateTransformMatrix} has to be called.\n         * @param {JXG.Point} p\n         * @returns {JXG.Point} The given point.\n         */\n        updateTransform: function (p) {\n            var c,\n                len = this.transformations.length;\n\n            if (len > 0) {\n                c = Mat.matVecMult(this.transformMat, p.usrCoords);\n                p.setCoordinates(Const.COORDS_BY_USER, c, false, true);\n            }\n\n            return p;\n        },\n\n        /**\n         * Add transformations to this curve.\n         * @param {JXG.Transformation|Array} transform Either one {@link JXG.Transformation} or an array of {@link JXG.Transformation}s.\n         * @returns {JXG.Curve} Reference to the curve object.\n         */\n        addTransform: function (transform) {\n            var i,\n                list = Type.isArray(transform) ? transform : [transform],\n                len = list.length;\n\n            for (i = 0; i < len; i++) {\n                this.transformations.push(list[i]);\n            }\n\n            return this;\n        },\n\n        /**\n         * Generate the method curve.X() in case curve.dataX is an array\n         * and generate the method curve.Y() in case curve.dataY is an array.\n         * @private\n         * @param {String} which Either 'X' or 'Y'\n         * @returns {function}\n         **/\n        interpolationFunctionFromArray: function (which) {\n            var data = \"data\" + which,\n                that = this;\n\n            return function (t, suspendedUpdate) {\n                var i,\n                    j,\n                    t0,\n                    t1,\n                    arr = that[data],\n                    len = arr.length,\n                    last,\n                    f = [];\n\n                if (isNaN(t)) {\n                    return NaN;\n                }\n\n                if (t < 0) {\n                    if (Type.isFunction(arr[0])) {\n                        return arr[0]();\n                    }\n\n                    return arr[0];\n                }\n\n                if (that.bezierDegree === 3) {\n                    last = (len - 1) / 3;\n\n                    if (t >= last) {\n                        if (Type.isFunction(arr[arr.length - 1])) {\n                            return arr[arr.length - 1]();\n                        }\n\n                        return arr[arr.length - 1];\n                    }\n\n                    i = Math.floor(t) * 3;\n                    t0 = t % 1;\n                    t1 = 1 - t0;\n\n                    for (j = 0; j < 4; j++) {\n                        if (Type.isFunction(arr[i + j])) {\n                            f[j] = arr[i + j]();\n                        } else {\n                            f[j] = arr[i + j];\n                        }\n                    }\n\n                    return (\n                        t1 * t1 * (t1 * f[0] + 3 * t0 * f[1]) +\n                        (3 * t1 * f[2] + t0 * f[3]) * t0 * t0\n                    );\n                }\n\n                if (t > len - 2) {\n                    i = len - 2;\n                } else {\n                    i = parseInt(Math.floor(t), 10);\n                }\n\n                if (i === t) {\n                    if (Type.isFunction(arr[i])) {\n                        return arr[i]();\n                    }\n                    return arr[i];\n                }\n\n                for (j = 0; j < 2; j++) {\n                    if (Type.isFunction(arr[i + j])) {\n                        f[j] = arr[i + j]();\n                    } else {\n                        f[j] = arr[i + j];\n                    }\n                }\n                return f[0] + (f[1] - f[0]) * (t - i);\n            };\n        },\n\n        /**\n         * Converts the JavaScript/JessieCode/GEONExT syntax of the defining function term into JavaScript.\n         * New methods X() and Y() for the Curve object are generated, further\n         * new methods for minX() and maxX().\n         * @see JXG.GeonextParser.geonext2JS.\n         */\n        generateTerm: function (varname, xterm, yterm, mi, ma) {\n            var fx, fy;\n\n            // Generate the methods X() and Y()\n            if (Type.isArray(xterm)) {\n                // Discrete data\n                this.dataX = xterm;\n\n                this.numberPoints = this.dataX.length;\n                this.X = this.interpolationFunctionFromArray.apply(this, [\"X\"]);\n                this.visProp.curvetype = \"plot\";\n                this.isDraggable = true;\n            } else {\n                // Continuous data\n                this.X = Type.createFunction(xterm, this.board, varname);\n                if (Type.isString(xterm)) {\n                    this.visProp.curvetype = \"functiongraph\";\n                } else if (Type.isFunction(xterm) || Type.isNumber(xterm)) {\n                    this.visProp.curvetype = \"parameter\";\n                }\n\n                this.isDraggable = true;\n            }\n\n            if (Type.isArray(yterm)) {\n                this.dataY = yterm;\n                this.Y = this.interpolationFunctionFromArray.apply(this, [\"Y\"]);\n            } else {\n                this.Y = Type.createFunction(yterm, this.board, varname);\n            }\n\n            /**\n             * Polar form\n             * Input data is function xterm() and offset coordinates yterm\n             */\n            if (Type.isFunction(xterm) && Type.isArray(yterm)) {\n                // Xoffset, Yoffset\n                fx = Type.createFunction(yterm[0], this.board, \"\");\n                fy = Type.createFunction(yterm[1], this.board, \"\");\n\n                this.X = function (phi) {\n                    return xterm(phi) * Math.cos(phi) + fx();\n                };\n\n                this.Y = function (phi) {\n                    return xterm(phi) * Math.sin(phi) + fy();\n                };\n\n                this.visProp.curvetype = \"polar\";\n            }\n\n            // Set the bounds lower bound\n            if (Type.exists(mi)) {\n                this.minX = Type.createFunction(mi, this.board, \"\");\n            }\n            if (Type.exists(ma)) {\n                this.maxX = Type.createFunction(ma, this.board, \"\");\n            }\n        },\n\n        /**\n         * Finds dependencies in a given term and notifies the parents by adding the\n         * dependent object to the found objects child elements.\n         * @param {String} contentStr String containing dependencies for the given object.\n         */\n        notifyParents: function (contentStr) {\n            var fstr,\n                dep,\n                isJessieCode = false,\n                obj;\n\n            // Read dependencies found by the JessieCode parser\n            obj = { xterm: 1, yterm: 1 };\n            for (fstr in obj) {\n                if (\n                    obj.hasOwnProperty(fstr) &&\n                    this.hasOwnProperty(fstr) &&\n                    this[fstr].origin\n                ) {\n                    isJessieCode = true;\n                    for (dep in this[fstr].origin.deps) {\n                        if (this[fstr].origin.deps.hasOwnProperty(dep)) {\n                            this[fstr].origin.deps[dep].addChild(this);\n                        }\n                    }\n                }\n            }\n\n            if (!isJessieCode) {\n                GeonextParser.findDependencies(this, contentStr, this.board);\n            }\n        },\n\n        // documented in geometry element\n        getLabelAnchor: function () {\n            var c,\n                x,\n                y,\n                ax = 0.05 * this.board.canvasWidth,\n                ay = 0.05 * this.board.canvasHeight,\n                bx = 0.95 * this.board.canvasWidth,\n                by = 0.95 * this.board.canvasHeight;\n\n            switch (Type.evaluate(this.visProp.label.position)) {\n                case \"ulft\":\n                    x = ax;\n                    y = ay;\n                    break;\n                case \"llft\":\n                    x = ax;\n                    y = by;\n                    break;\n                case \"rt\":\n                    x = bx;\n                    y = 0.5 * by;\n                    break;\n                case \"lrt\":\n                    x = bx;\n                    y = by;\n                    break;\n                case \"urt\":\n                    x = bx;\n                    y = ay;\n                    break;\n                case \"top\":\n                    x = 0.5 * bx;\n                    y = ay;\n                    break;\n                case \"bot\":\n                    x = 0.5 * bx;\n                    y = by;\n                    break;\n                default:\n                    // includes case 'lft'\n                    x = ax;\n                    y = 0.5 * by;\n            }\n\n            c = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board, false);\n            return Geometry.projectCoordsToCurve(\n                c.usrCoords[1],\n                c.usrCoords[2],\n                0,\n                this,\n                this.board\n            )[0];\n        },\n\n        // documented in geometry element\n        cloneToBackground: function () {\n            var er,\n                copy = {\n                    id: this.id + \"T\" + this.numTraces,\n                    elementClass: Const.OBJECT_CLASS_CURVE,\n\n                    points: this.points.slice(0),\n                    bezierDegree: this.bezierDegree,\n                    numberPoints: this.numberPoints,\n                    board: this.board,\n                    visProp: Type.deepCopy(this.visProp, this.visProp.traceattributes, true)\n                };\n\n            copy.visProp.layer = this.board.options.layer.trace;\n            copy.visProp.curvetype = this.visProp.curvetype;\n            this.numTraces++;\n\n            Type.clearVisPropOld(copy);\n            copy.visPropCalc = {\n                visible: Type.evaluate(copy.visProp.visible)\n            };\n            er = this.board.renderer.enhancedRendering;\n            this.board.renderer.enhancedRendering = true;\n            this.board.renderer.drawCurve(copy);\n            this.board.renderer.enhancedRendering = er;\n            this.traces[copy.id] = copy.rendNode;\n\n            return this;\n        },\n\n        // Already documented in GeometryElement\n        bounds: function () {\n            var minX = Infinity,\n                maxX = -Infinity,\n                minY = Infinity,\n                maxY = -Infinity,\n                l = this.points.length,\n                i,\n                bezier,\n                up;\n\n            if (this.bezierDegree === 3) {\n                // Add methods X(), Y()\n                for (i = 0; i < l; i++) {\n                    this.points[i].X = Type.bind(function () {\n                        return this.usrCoords[1];\n                    }, this.points[i]);\n                    this.points[i].Y = Type.bind(function () {\n                        return this.usrCoords[2];\n                    }, this.points[i]);\n                }\n                bezier = Numerics.bezier(this.points);\n                up = bezier[3]();\n                minX = Numerics.fminbr(\n                    function (t) {\n                        return bezier[0](t);\n                    },\n                    [0, up]\n                );\n                maxX = Numerics.fminbr(\n                    function (t) {\n                        return -bezier[0](t);\n                    },\n                    [0, up]\n                );\n                minY = Numerics.fminbr(\n                    function (t) {\n                        return bezier[1](t);\n                    },\n                    [0, up]\n                );\n                maxY = Numerics.fminbr(\n                    function (t) {\n                        return -bezier[1](t);\n                    },\n                    [0, up]\n                );\n\n                minX = bezier[0](minX);\n                maxX = bezier[0](maxX);\n                minY = bezier[1](minY);\n                maxY = bezier[1](maxY);\n                return [minX, maxY, maxX, minY];\n            }\n\n            // Linear segments\n            for (i = 0; i < l; i++) {\n                if (minX > this.points[i].usrCoords[1]) {\n                    minX = this.points[i].usrCoords[1];\n                }\n\n                if (maxX < this.points[i].usrCoords[1]) {\n                    maxX = this.points[i].usrCoords[1];\n                }\n\n                if (minY > this.points[i].usrCoords[2]) {\n                    minY = this.points[i].usrCoords[2];\n                }\n\n                if (maxY < this.points[i].usrCoords[2]) {\n                    maxY = this.points[i].usrCoords[2];\n                }\n            }\n\n            return [minX, maxY, maxX, minY];\n        },\n\n        // documented in element.js\n        getParents: function () {\n            var p = [this.xterm, this.yterm, this.minX(), this.maxX()];\n\n            if (this.parents.length !== 0) {\n                p = this.parents;\n            }\n\n            return p;\n        },\n\n        /**\n         * Shift the curve by the vector 'where'.\n         *\n         * @param {Array} where Array containing the x and y coordinate of the target location.\n         * @returns {JXG.Curve} Reference to itself.\n         */\n        moveTo: function (where) {\n            // TODO add animation\n            var delta = [],\n                p;\n            if (this.points.length > 0 && !Type.evaluate(this.visProp.fixed)) {\n                p = this.points[0];\n                if (where.length === 3) {\n                    delta = [\n                        where[0] - p.usrCoords[0],\n                        where[1] - p.usrCoords[1],\n                        where[2] - p.usrCoords[2]\n                    ];\n                } else {\n                    delta = [where[0] - p.usrCoords[1], where[1] - p.usrCoords[2]];\n                }\n                this.setPosition(Const.COORDS_BY_USER, delta);\n            }\n            return this;\n        },\n\n        /**\n         * If the curve is the result of a transformation applied\n         * to a continuous curve, the glider projection has to be done\n         * on the original curve. Otherwise there will be problems\n         * when changing between high and low precision plotting,\n         * since there number of points changes.\n         *\n         * @private\n         * @returns {Array} [Boolean, curve]: Array contining 'true' if curve is result of a transformation,\n         *   and the source curve of the transformation.\n         */\n        getTransformationSource: function () {\n            var isTransformed, curve_org;\n            if (Type.exists(this._transformationSource)) {\n                curve_org = this._transformationSource;\n                if (\n                    curve_org.elementClass === Const.OBJECT_CLASS_CURVE //&&\n                    //Type.evaluate(curve_org.visProp.curvetype) !== 'plot'\n                ) {\n                    isTransformed = true;\n                }\n            }\n            return [isTransformed, curve_org];\n        },\n\n        pnpoly: function (x_in, y_in, coord_type) {\n            var i,\n                j,\n                len,\n                x,\n                y,\n                crds,\n                v = this.points,\n                isIn = false;\n\n            if (coord_type === Const.COORDS_BY_USER) {\n                crds = new Coords(Const.COORDS_BY_USER, [x_in, y_in], this.board);\n                x = crds.scrCoords[1];\n                y = crds.scrCoords[2];\n            } else {\n                x = x_in;\n                y = y_in;\n            }\n\n            len = this.points.length;\n            for (i = 0, j = len - 2; i < len - 1; j = i++) {\n                if (\n                    v[i].scrCoords[2] > y !== v[j].scrCoords[2] > y &&\n                    x <\n                        ((v[j].scrCoords[1] - v[i].scrCoords[1]) * (y - v[i].scrCoords[2])) /\n                            (v[j].scrCoords[2] - v[i].scrCoords[2]) +\n                            v[i].scrCoords[1]\n                ) {\n                    isIn = !isIn;\n                }\n            }\n\n            return isIn;\n        }\n    }\n);\n\n/**\n * @class This element is used to provide a constructor for curve, which is just a wrapper for element {@link Curve}.\n * A curve is a mapping from R to R^2. t mapsto (x(t),y(t)). The graph is drawn for t in the interval [a,b].\n * <p>\n * The following types of curves can be plotted:\n * <ul>\n *  <li> parametric curves: t mapsto (x(t),y(t)), where x() and y() are univariate functions.\n *  <li> polar curves: curves commonly written with polar equations like spirals and cardioids.\n *  <li> data plots: plot line segments through a given list of coordinates.\n * </ul>\n * @pseudo\n * @description\n * @name Curve\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n *\n * @param {function,number_function,number_function,number_function,number} x,y,a_,b_ Parent elements for Parametric Curves.\n *                     <p>\n *                     x describes the x-coordinate of the curve. It may be a function term in one variable, e.g. x(t).\n *                     In case of x being of type number, x(t) is set to  a constant function.\n *                     this function at the values of the array.\n *                     </p>\n *                     <p>\n *                     y describes the y-coordinate of the curve. In case of a number, y(t) is set to the constant function\n *                     returning this number.\n *                     </p>\n *                     <p>\n *                     Further parameters are an optional number or function for the left interval border a,\n *                     and an optional number or function for the right interval border b.\n *                     </p>\n *                     <p>\n *                     Default values are a=-10 and b=10.\n *                     </p>\n * @param {array_array,function,number} x,y Parent elements for Data Plots.\n *                     <p>\n *                     x and y are arrays contining the x and y coordinates of the data points which are connected by\n *                     line segments. The individual entries of x and y may also be functions.\n *                     In case of x being an array the curve type is data plot, regardless of the second parameter and\n *                     if additionally the second parameter y is a function term the data plot evaluates.\n *                     </p>\n * @param {function_array,function,number_function,number_function,number} r,offset_,a_,b_ Parent elements for Polar Curves.\n *                     <p>\n *                     The first parameter is a function term r(phi) describing the polar curve.\n *                     </p>\n *                     <p>\n *                     The second parameter is the offset of the curve. It has to be\n *                     an array containing numbers or functions describing the offset. Default value is the origin [0,0].\n *                     </p>\n *                     <p>\n *                     Further parameters are an optional number or function for the left interval border a,\n *                     and an optional number or function for the right interval border b.\n *                     </p>\n *                     <p>\n *                     Default values are a=-10 and b=10.\n *                     </p>\n * <p>\n * Additionally, a curve can be created by providing a curve and a transformation (or an array of transformations).\n * The result is a curve which is the transformation of the supplied curve.\n *\n * @see JXG.Curve\n * @example\n * // Parametric curve\n * // Create a curve of the form (t-sin(t), 1-cos(t), i.e.\n * // the cycloid curve.\n *   var graph = board.create('curve',\n *                        [function(t){ return t-Math.sin(t);},\n *                         function(t){ return 1-Math.cos(t);},\n *                         0, 2*Math.PI]\n *                     );\n * </pre><div class=\"jxgbox\" id=\"JXGaf9f818b-f3b6-4c4d-8c4c-e4a4078b726d\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var c1_board = JXG.JSXGraph.initBoard('JXGaf9f818b-f3b6-4c4d-8c4c-e4a4078b726d', {boundingbox: [-1, 5, 7, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var graph1 = c1_board.create('curve', [function(t){ return t-Math.sin(t);},function(t){ return 1-Math.cos(t);},0, 2*Math.PI]);\n * </script><pre>\n * @example\n * // Data plots\n * // Connect a set of points given by coordinates with dashed line segments.\n * // The x- and y-coordinates of the points are given in two separate\n * // arrays.\n *   var x = [0,1,2,3,4,5,6,7,8,9];\n *   var y = [9.2,1.3,7.2,-1.2,4.0,5.3,0.2,6.5,1.1,0.0];\n *   var graph = board.create('curve', [x,y], {dash:2});\n * </pre><div class=\"jxgbox\" id=\"JXG7dcbb00e-b6ff-481d-b4a8-887f5d8c6a83\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var c3_board = JXG.JSXGraph.initBoard('JXG7dcbb00e-b6ff-481d-b4a8-887f5d8c6a83', {boundingbox: [-1,10,10,-1], axis: true, showcopyright: false, shownavigation: false});\n *   var x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n *   var y = [9.2, 1.3, 7.2, -1.2, 4.0, 5.3, 0.2, 6.5, 1.1, 0.0];\n *   var graph3 = c3_board.create('curve', [x,y], {dash:2});\n * </script><pre>\n * @example\n * // Polar plot\n * // Create a curve with the equation r(phi)= a*(1+phi), i.e.\n * // a cardioid.\n *   var a = board.create('slider',[[0,2],[2,2],[0,1,2]]);\n *   var graph = board.create('curve',\n *                        [function(phi){ return a.Value()*(1-Math.cos(phi));},\n *                         [1,0],\n *                         0, 2*Math.PI],\n *                         {curveType: 'polar'}\n *                     );\n * </pre><div class=\"jxgbox\" id=\"JXGd0bc7a2a-8124-45ca-a6e7-142321a8f8c2\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var c2_board = JXG.JSXGraph.initBoard('JXGd0bc7a2a-8124-45ca-a6e7-142321a8f8c2', {boundingbox: [-3,3,3,-3], axis: true, showcopyright: false, shownavigation: false});\n *   var a = c2_board.create('slider',[[0,2],[2,2],[0,1,2]]);\n *   var graph2 = c2_board.create('curve', [function(phi){ return a.Value()*(1-Math.cos(phi));}, [1,0], 0, 2*Math.PI], {curveType: 'polar'});\n * </script><pre>\n *\n * @example\n *  // Draggable Bezier curve\n *  var col, p, c;\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[1, 2.5 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[-1, -2.5 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -2], {size: 5, strokeColor:col, fillColor:col}));\n *\n *  c = board.create('curve', JXG.Math.Numerics.bezier(p),\n *              {strokeColor:'red', name:\"curve\", strokeWidth:5, fixed: false}); // Draggable curve\n *  c.addParents(p);\n * </pre><div class=\"jxgbox\" id=\"JXG7bcc6280-f6eb-433e-8281-c837c3387849\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function(){\n *  var board, col, p, c;\n *  board = JXG.JSXGraph.initBoard('JXG7bcc6280-f6eb-433e-8281-c837c3387849', {boundingbox: [-3,3,3,-3], axis: true, showcopyright: false, shownavigation: false});\n *  col = 'blue';\n *  p = [];\n *  p.push(board.create('point',[-2, -1 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[1, 2.5 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[-1, -2.5 ], {size: 5, strokeColor:col, fillColor:col}));\n *  p.push(board.create('point',[2, -2], {size: 5, strokeColor:col, fillColor:col}));\n *\n *  c = board.create('curve', JXG.Math.Numerics.bezier(p),\n *              {strokeColor:'red', name:\"curve\", strokeWidth:5, fixed: false}); // Draggable curve\n *  c.addParents(p);\n * })();\n * </script><pre>\n *\n * @example\n *         // The curve cu2 is the reflection of cu1 against line li\n *         var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *         var reflect = board.create('transform', [li], {type: 'reflect'});\n *         var cu1 = board.create('curve', [[-1, -1, -0.5, -1, -1, -0.5], [-3, -2, -2, -2, -2.5, -2.5]]);\n *         var cu2 = board.create('curve', [cu1, reflect], {strokeColor: 'red'});\n *\n * </pre><div id=\"JXG866dc7a2-d448-11e7-93b3-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG866dc7a2-d448-11e7-93b3-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *             var reflect = board.create('transform', [li], {type: 'reflect'});\n *             var cu1 = board.create('curve', [[-1, -1, -0.5, -1, -1, -0.5], [-3, -2, -2, -2, -2.5, -2.5]]);\n *             var cu2 = board.create('curve', [cu1, reflect], {strokeColor: 'red'});\n *\n *     })();\n *\n * </script><pre>\n */\nJXG.createCurve = function (board, parents, attributes) {\n    var obj,\n        cu,\n        attr = Type.copyAttributes(attributes, board.options, \"curve\");\n\n    obj = board.select(parents[0], true);\n    if (\n        Type.isTransformationOrArray(parents[1]) &&\n        Type.isObject(obj) &&\n        (obj.type === Const.OBJECT_TYPE_CURVE ||\n            obj.type === Const.OBJECT_TYPE_ANGLE ||\n            obj.type === Const.OBJECT_TYPE_ARC ||\n            obj.type === Const.OBJECT_TYPE_CONIC ||\n            obj.type === Const.OBJECT_TYPE_SECTOR)\n    ) {\n        if (obj.type === Const.OBJECT_TYPE_SECTOR) {\n            attr = Type.copyAttributes(attributes, board.options, \"sector\");\n        } else if (obj.type === Const.OBJECT_TYPE_ARC) {\n            attr = Type.copyAttributes(attributes, board.options, \"arc\");\n        } else if (obj.type === Const.OBJECT_TYPE_ANGLE) {\n            if (!Type.exists(attributes.withLabel)) {\n                attributes.withLabel = false;\n            }\n            attr = Type.copyAttributes(attributes, board.options, \"angle\");\n        } else {\n            attr = Type.copyAttributes(attributes, board.options, \"curve\");\n        }\n        attr = Type.copyAttributes(attr, board.options, \"curve\");\n\n        cu = new JXG.Curve(board, [\"x\", [], []], attr);\n        cu.updateDataArray = function () {\n            var i,\n                le = obj.numberPoints;\n            this.bezierDegree = obj.bezierDegree;\n            this.dataX = [];\n            this.dataY = [];\n            for (i = 0; i < le; i++) {\n                this.dataX.push(obj.points[i].usrCoords[1]);\n                this.dataY.push(obj.points[i].usrCoords[2]);\n            }\n            return this;\n        };\n        cu.addTransform(parents[1]);\n        obj.addChild(cu);\n        cu.setParents([obj]);\n        cu._transformationSource = obj;\n\n        return cu;\n    }\n    attr = Type.copyAttributes(attributes, board.options, \"curve\");\n    return new JXG.Curve(board, [\"x\"].concat(parents), attr);\n};\n\nJXG.registerElement(\"curve\", JXG.createCurve);\n\n/**\n * @class This element is used to provide a constructor for functiongraph,\n * which is just a wrapper for element {@link Curve} with {@link JXG.Curve#X}()\n * set to x. The graph is drawn for x in the interval [a,b].\n * @pseudo\n * @description\n * @name Functiongraph\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @param {function_number,function_number,function} f,a_,b_ Parent elements are a function term f(x) describing the function graph.\n *         <p>\n *         Further, an optional number or function for the left interval border a,\n *         and an optional number or function for the right interval border b.\n *         <p>\n *         Default values are a=-10 and b=10.\n * @see JXG.Curve\n * @example\n * // Create a function graph for f(x) = 0.5*x*x-2*x\n *   var graph = board.create('functiongraph',\n *                        [function(x){ return 0.5*x*x-2*x;}, -2, 4]\n *                     );\n * </pre><div class=\"jxgbox\" id=\"JXGefd432b5-23a3-4846-ac5b-b471e668b437\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var alex1_board = JXG.JSXGraph.initBoard('JXGefd432b5-23a3-4846-ac5b-b471e668b437', {boundingbox: [-3, 7, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *   var graph = alex1_board.create('functiongraph', [function(x){ return 0.5*x*x-2*x;}, -2, 4]);\n * </script><pre>\n * @example\n * // Create a function graph for f(x) = 0.5*x*x-2*x with variable interval\n *   var s = board.create('slider',[[0,4],[3,4],[-2,4,5]]);\n *   var graph = board.create('functiongraph',\n *                        [function(x){ return 0.5*x*x-2*x;},\n *                         -2,\n *                         function(){return s.Value();}]\n *                     );\n * </pre><div class=\"jxgbox\" id=\"JXG4a203a84-bde5-4371-ad56-44619690bb50\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var alex2_board = JXG.JSXGraph.initBoard('JXG4a203a84-bde5-4371-ad56-44619690bb50', {boundingbox: [-3, 7, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *   var s = alex2_board.create('slider',[[0,4],[3,4],[-2,4,5]]);\n *   var graph = alex2_board.create('functiongraph', [function(x){ return 0.5*x*x-2*x;}, -2, function(){return s.Value();}]);\n * </script><pre>\n */\nJXG.createFunctiongraph = function (board, parents, attributes) {\n    var attr,\n        par = [\"x\", \"x\"].concat(parents);\n\n    attr = Type.copyAttributes(attributes, board.options, \"curve\");\n    attr.curvetype = \"functiongraph\";\n    return new JXG.Curve(board, par, attr);\n};\n\nJXG.registerElement(\"functiongraph\", JXG.createFunctiongraph);\nJXG.registerElement(\"plot\", JXG.createFunctiongraph);\n\n/**\n * @class This element is used to provide a constructor for (natural) cubic spline curves.\n * Create a dynamic spline interpolated curve given by sample points p_1 to p_n.\n * @pseudo\n * @description\n * @name Spline\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @param {JXG.Board} board Reference to the board the spline is drawn on.\n * @param {Array} parents Array of points the spline interpolates. This can be\n *   <ul>\n *   <li> an array of JXGGraph points</li>\n *   <li> an array of coordinate pairs</li>\n *   <li> an array of functions returning coordinate pairs</li>\n *   <li> an array consisting of an array with x-coordinates and an array of y-coordinates</li>\n *   </ul>\n *   All individual entries of coordinates arrays may be numbers or functions returning numbers.\n * @param {Object} attributes Define color, width, ... of the spline\n * @returns {JXG.Curve} Returns reference to an object of type JXG.Curve.\n * @see JXG.Curve\n * @example\n *\n * var p = [];\n * p[0] = board.create('point', [-2,2], {size: 4, face: 'o'});\n * p[1] = board.create('point', [0,-1], {size: 4, face: 'o'});\n * p[2] = board.create('point', [2,0], {size: 4, face: 'o'});\n * p[3] = board.create('point', [4,1], {size: 4, face: 'o'});\n *\n * var c = board.create('spline', p, {strokeWidth:3});\n * </pre><div id=\"JXG6c197afc-e482-11e5-b1bf-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG6c197afc-e482-11e5-b1bf-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *\n *     var p = [];\n *     p[0] = board.create('point', [-2,2], {size: 4, face: 'o'});\n *     p[1] = board.create('point', [0,-1], {size: 4, face: 'o'});\n *     p[2] = board.create('point', [2,0], {size: 4, face: 'o'});\n *     p[3] = board.create('point', [4,1], {size: 4, face: 'o'});\n *\n *     var c = board.create('spline', p, {strokeWidth:3});\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createSpline = function (board, parents, attributes) {\n    var el, funcs, ret;\n\n    funcs = function () {\n        var D,\n            x = [],\n            y = [];\n\n        return [\n            function (t, suspended) {\n                // Function term\n                var i, j, c;\n\n                if (!suspended) {\n                    x = [];\n                    y = [];\n\n                    // given as [x[], y[]]\n                    if (\n                        parents.length === 2 &&\n                        Type.isArray(parents[0]) &&\n                        Type.isArray(parents[1]) &&\n                        parents[0].length === parents[1].length\n                    ) {\n                        for (i = 0; i < parents[0].length; i++) {\n                            if (Type.isFunction(parents[0][i])) {\n                                x.push(parents[0][i]());\n                            } else {\n                                x.push(parents[0][i]);\n                            }\n\n                            if (Type.isFunction(parents[1][i])) {\n                                y.push(parents[1][i]());\n                            } else {\n                                y.push(parents[1][i]);\n                            }\n                        }\n                    } else {\n                        for (i = 0; i < parents.length; i++) {\n                            if (Type.isPoint(parents[i])) {\n                                x.push(parents[i].X());\n                                y.push(parents[i].Y());\n                                // given as [[x1,y1], [x2, y2], ...]\n                            } else if (Type.isArray(parents[i]) && parents[i].length === 2) {\n                                for (j = 0; j < parents.length; j++) {\n                                    if (Type.isFunction(parents[j][0])) {\n                                        x.push(parents[j][0]());\n                                    } else {\n                                        x.push(parents[j][0]);\n                                    }\n\n                                    if (Type.isFunction(parents[j][1])) {\n                                        y.push(parents[j][1]());\n                                    } else {\n                                        y.push(parents[j][1]);\n                                    }\n                                }\n                            } else if (\n                                Type.isFunction(parents[i]) &&\n                                parents[i]().length === 2\n                            ) {\n                                c = parents[i]();\n                                x.push(c[0]);\n                                y.push(c[1]);\n                            }\n                        }\n                    }\n\n                    // The array D has only to be calculated when the position of one or more sample points\n                    // changes. Otherwise D is always the same for all points on the spline.\n                    D = Numerics.splineDef(x, y);\n                }\n\n                return Numerics.splineEval(t, x, y, D);\n            },\n            // minX()\n            function () {\n                return x[0];\n            },\n            //maxX()\n            function () {\n                return x[x.length - 1];\n            }\n        ];\n    };\n\n    attributes = Type.copyAttributes(attributes, board.options, \"curve\");\n    attributes.curvetype = \"functiongraph\";\n    ret = funcs();\n    el = new JXG.Curve(board, [\"x\", \"x\", ret[0], ret[1], ret[2]], attributes);\n    el.setParents(parents);\n    el.elType = \"spline\";\n\n    return el;\n};\n\n/**\n * Register the element type spline at JSXGraph\n * @private\n */\nJXG.registerElement(\"spline\", JXG.createSpline);\n\n/**\n * @class This element is used to provide a constructor for cardinal spline curves.\n * Create a dynamic cardinal spline interpolated curve given by sample points p_1 to p_n.\n * @pseudo\n * @description\n * @name Cardinalspline\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @param {JXG.Board} board Reference to the board the cardinal spline is drawn on.\n * @param {Array} parents Array with three entries.\n * <p>\n *   First entry: Array of points the spline interpolates. This can be\n *   <ul>\n *   <li> an array of JXGGraph points</li>\n *   <li> an array of coordinate pairs</li>\n *   <li> an array of functions returning coordinate pairs</li>\n *   <li> an array consisting of an array with x-coordinates and an array of y-coordinates</li>\n *   </ul>\n *   All individual entries of coordinates arrays may be numbers or functions returning numbers.\n *   <p>\n *   Second entry: tau number or function\n *   <p>\n *   Third entry: type string containing 'uniform' (default) or 'centripetal'.\n * @param {Object} attributes Define color, width, ... of the cardinal spline\n * @returns {JXG.Curve} Returns reference to an object of type JXG.Curve.\n * @see JXG.Curve\n * @example\n * //create a cardinal spline out of an array of JXG points with adjustable tension\n * //create array of points\n * var p1 = board.create('point',[0,0])\n * var p2 = board.create('point',[1,4])\n * var p3 = board.create('point',[4,5])\n * var p4 = board.create('point',[2,3])\n * var p5 = board.create('point',[3,0])\n * var p = [p1,p2,p3,p4,p5]\n *\n * // tension\n * tau = board.create('slider', [[4,3],[9,3],[0.001,0.5,1]], {name:'tau'});\n * c = board.create('curve', JXG.Math.Numerics.CardinalSpline(p, function(){ return tau.Value();}), {strokeWidth:3});\n * </pre><div id=\"JXG6c197afc-e482-11e5-b2af-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG6c197afc-e482-11e5-b2af-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *\n *     var p = [];\n *     p[0] = board.create('point', [-2,2], {size: 4, face: 'o'});\n *     p[1] = board.create('point', [0,-1], {size: 4, face: 'o'});\n *     p[2] = board.create('point', [2,0], {size: 4, face: 'o'});\n *     p[3] = board.create('point', [4,1], {size: 4, face: 'o'});\n *\n *     var c = board.create('spline', p, {strokeWidth:3});\n *     })();\n *\n * </script><pre>\n */\nJXG.createCardinalSpline = function (board, parents, attributes) {\n    var el,\n        getPointLike,\n        points,\n        tau,\n        type,\n        p,\n        q,\n        i,\n        le,\n        splineArr,\n        errStr = \"\\nPossible parent types: [points:array, tau:number|function, type:string]\";\n\n    if (!Type.exists(parents[0]) || !Type.isArray(parents[0])) {\n        throw new Error(\n            \"JSXGraph: JXG.createCardinalSpline: argument 1 'points' has to be array of points or coordinate pairs\" +\n                errStr\n        );\n    }\n    if (\n        !Type.exists(parents[1]) ||\n        (!Type.isNumber(parents[1]) && !Type.isFunction(parents[1]))\n    ) {\n        throw new Error(\n            \"JSXGraph: JXG.createCardinalSpline: argument 2 'tau' has to be number between [0,1] or function'\" +\n                errStr\n        );\n    }\n    if (!Type.exists(parents[2]) || !Type.isString(parents[2])) {\n        throw new Error(\n            \"JSXGraph: JXG.createCardinalSpline: argument 3 'type' has to be string 'uniform' or 'centripetal'\" +\n                errStr\n        );\n    }\n\n    attributes = Type.copyAttributes(attributes, board.options, \"curve\");\n    attributes = Type.copyAttributes(attributes, board.options, \"cardinalspline\");\n    attributes.curvetype = \"parameter\";\n\n    p = parents[0];\n    q = [];\n\n    // given as [x[], y[]]\n    if (\n        !attributes.isarrayofcoordinates &&\n        p.length === 2 &&\n        Type.isArray(p[0]) &&\n        Type.isArray(p[1]) &&\n        p[0].length === p[1].length\n    ) {\n        for (i = 0; i < p[0].length; i++) {\n            q[i] = [];\n            if (Type.isFunction(p[0][i])) {\n                q[i].push(p[0][i]());\n            } else {\n                q[i].push(p[0][i]);\n            }\n\n            if (Type.isFunction(p[1][i])) {\n                q[i].push(p[1][i]());\n            } else {\n                q[i].push(p[1][i]);\n            }\n        }\n    } else {\n        // given as [[x0, y0], [x1, y1], point, ...]\n        for (i = 0; i < p.length; i++) {\n            if (Type.isString(p[i])) {\n                q.push(board.select(p[i]));\n            } else if (Type.isPoint(p[i])) {\n                q.push(p[i]);\n                // given as [[x0,y0], [x1, y2], ...]\n            } else if (Type.isArray(p[i]) && p[i].length === 2) {\n                q[i] = [];\n                if (Type.isFunction(p[i][0])) {\n                    q[i].push(p[i][0]());\n                } else {\n                    q[i].push(p[i][0]);\n                }\n\n                if (Type.isFunction(p[i][1])) {\n                    q[i].push(p[i][1]());\n                } else {\n                    q[i].push(p[i][1]);\n                }\n            } else if (Type.isFunction(p[i]) && p[i]().length === 2) {\n                q.push(parents[i]());\n            }\n        }\n    }\n\n    if (attributes.createpoints === true) {\n        points = Type.providePoints(board, q, attributes, \"cardinalspline\", [\"points\"]);\n    } else {\n        points = [];\n\n        /**\n         * @ignore\n         */\n        getPointLike = function (ii) {\n            return {\n                X: function () {\n                    return q[ii][0];\n                },\n                Y: function () {\n                    return q[ii][1];\n                },\n                Dist: function (p) {\n                    var dx = this.X() - p.X(),\n                        dy = this.Y() - p.Y();\n                    return Math.sqrt(dx * dx + dy * dy);\n                }\n            };\n        };\n\n        for (i = 0; i < q.length; i++) {\n            if (Type.isPoint(q[i])) {\n                points.push(q[i]);\n            } else {\n                points.push(getPointLike(i));\n            }\n        }\n    }\n\n    tau = parents[1];\n    type = parents[2];\n\n    splineArr = [\"x\"].concat(Numerics.CardinalSpline(points, tau, type));\n\n    el = new JXG.Curve(board, splineArr, attributes);\n    le = points.length;\n    el.setParents(points);\n    for (i = 0; i < le; i++) {\n        p = points[i];\n        if (Type.isPoint(p)) {\n            if (Type.exists(p._is_new)) {\n                el.addChild(p);\n                delete p._is_new;\n            } else {\n                p.addChild(el);\n            }\n        }\n    }\n    el.elType = \"cardinalspline\";\n\n    return el;\n};\n\n/**\n * Register the element type cardinalspline at JSXGraph\n * @private\n */\nJXG.registerElement(\"cardinalspline\", JXG.createCardinalSpline);\n\n/**\n * @class This element is used to provide a constructor for metapost spline curves.\n * Create a dynamic metapost spline interpolated curve given by sample points p_1 to p_n.\n * @pseudo\n * @description\n * @name Metapostspline\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @param {JXG.Board} board Reference to the board the metapost spline is drawn on.\n * @param {Array} parents Array with two entries.\n * <p>\n *   First entry: Array of points the spline interpolates. This can be\n *   <ul>\n *   <li> an array of JXGGraph points</li>\n *   <li> an object of coordinate pairs</li>\n *   <li> an array of functions returning coordinate pairs</li>\n *   <li> an array consisting of an array with x-coordinates and an array of y-coordinates</li>\n *   </ul>\n *   All individual entries of coordinates arrays may be numbers or functions returning numbers.\n *   <p>\n *   Second entry: JavaScript object containing the control values like tension, direction, curl.\n * @param {Object} attributes Define color, width, ... of the metapost spline\n * @returns {JXG.Curve} Returns reference to an object of type JXG.Curve.\n * @see JXG.Curve\n * @example\n *     var po = [],\n *         attr = {\n *             size: 5,\n *             color: 'red'\n *         },\n *         controls;\n *\n *     var tension = board.create('slider', [[-3, 6], [3, 6], [0, 1, 20]], {name: 'tension'});\n *     var curl = board.create('slider', [[-3, 5], [3, 5], [0, 1, 30]], {name: 'curl A, D'});\n *     var dir = board.create('slider', [[-3, 4], [3, 4], [-180, 0, 180]], {name: 'direction B'});\n *\n *     po.push(board.create('point', [-3, -3]));\n *     po.push(board.create('point', [0, -3]));\n *     po.push(board.create('point', [4, -5]));\n *     po.push(board.create('point', [6, -2]));\n *\n *     var controls = {\n *         tension: function() {return tension.Value(); },\n *         direction: { 1: function() {return dir.Value(); } },\n *         curl: { 0: function() {return curl.Value(); },\n *                 3: function() {return curl.Value(); }\n *             },\n *         isClosed: false\n *     };\n *\n *     // Plot a metapost curve\n *     var cu = board.create('metapostspline', [po, controls], {strokeColor: 'blue', strokeWidth: 2});\n *\n *\n * </pre><div id=\"JXGb8c6ffed-7419-41a3-9e55-3754b2327ae9\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGb8c6ffed-7419-41a3-9e55-3754b2327ae9',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *         var po = [],\n *             attr = {\n *                 size: 5,\n *                 color: 'red'\n *             },\n *             controls;\n *\n *         var tension = board.create('slider', [[-3, 6], [3, 6], [0, 1, 20]], {name: 'tension'});\n *         var curl = board.create('slider', [[-3, 5], [3, 5], [0, 1, 30]], {name: 'curl A, D'});\n *         var dir = board.create('slider', [[-3, 4], [3, 4], [-180, 0, 180]], {name: 'direction B'});\n *\n *         po.push(board.create('point', [-3, -3]));\n *         po.push(board.create('point', [0, -3]));\n *         po.push(board.create('point', [4, -5]));\n *         po.push(board.create('point', [6, -2]));\n *\n *         var controls = {\n *             tension: function() {return tension.Value(); },\n *             direction: { 1: function() {return dir.Value(); } },\n *             curl: { 0: function() {return curl.Value(); },\n *                     3: function() {return curl.Value(); }\n *                 },\n *             isClosed: false\n *         };\n *\n *         // Plot a metapost curve\n *         var cu = board.create('metapostspline', [po, controls], {strokeColor: 'blue', strokeWidth: 2});\n *\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createMetapostSpline = function (board, parents, attributes) {\n    var el,\n        getPointLike,\n        points,\n        controls,\n        p,\n        q,\n        i,\n        le,\n        errStr = \"\\nPossible parent types: [points:array, controls:object\";\n\n    if (!Type.exists(parents[0]) || !Type.isArray(parents[0])) {\n        throw new Error(\n            \"JSXGraph: JXG.createMetapostSpline: argument 1 'points' has to be array of points or coordinate pairs\" +\n                errStr\n        );\n    }\n    if (!Type.exists(parents[1]) || !Type.isObject(parents[1])) {\n        throw new Error(\n            \"JSXGraph: JXG.createMetapostSpline: argument 2 'controls' has to be a JavaScript object'\" +\n                errStr\n        );\n    }\n\n    attributes = Type.copyAttributes(attributes, board.options, \"curve\");\n    attributes = Type.copyAttributes(attributes, board.options, \"metapostspline\");\n    attributes.curvetype = \"parameter\";\n\n    p = parents[0];\n    q = [];\n\n    // given as [x[], y[]]\n    if (\n        !attributes.isarrayofcoordinates &&\n        p.length === 2 &&\n        Type.isArray(p[0]) &&\n        Type.isArray(p[1]) &&\n        p[0].length === p[1].length\n    ) {\n        for (i = 0; i < p[0].length; i++) {\n            q[i] = [];\n            if (Type.isFunction(p[0][i])) {\n                q[i].push(p[0][i]());\n            } else {\n                q[i].push(p[0][i]);\n            }\n\n            if (Type.isFunction(p[1][i])) {\n                q[i].push(p[1][i]());\n            } else {\n                q[i].push(p[1][i]);\n            }\n        }\n    } else {\n        // given as [[x0, y0], [x1, y1], point, ...]\n        for (i = 0; i < p.length; i++) {\n            if (Type.isString(p[i])) {\n                q.push(board.select(p[i]));\n            } else if (Type.isPoint(p[i])) {\n                q.push(p[i]);\n                // given as [[x0,y0], [x1, y2], ...]\n            } else if (Type.isArray(p[i]) && p[i].length === 2) {\n                q[i] = [];\n                if (Type.isFunction(p[i][0])) {\n                    q[i].push(p[i][0]());\n                } else {\n                    q[i].push(p[i][0]);\n                }\n\n                if (Type.isFunction(p[i][1])) {\n                    q[i].push(p[i][1]());\n                } else {\n                    q[i].push(p[i][1]);\n                }\n            } else if (Type.isFunction(p[i]) && p[i]().length === 2) {\n                q.push(parents[i]());\n            }\n        }\n    }\n\n    if (attributes.createpoints === true) {\n        points = Type.providePoints(board, q, attributes, \"metapostspline\", [\"points\"]);\n    } else {\n        points = [];\n\n        /**\n         * @ignore\n         */\n        getPointLike = function (ii) {\n            return {\n                X: function () {\n                    return q[ii][0];\n                },\n                Y: function () {\n                    return q[ii][1];\n                }\n            };\n        };\n\n        for (i = 0; i < q.length; i++) {\n            if (Type.isPoint(q[i])) {\n                points.push(q[i]);\n            } else {\n                points.push(getPointLike);\n            }\n        }\n    }\n\n    controls = parents[1];\n\n    el = new JXG.Curve(board, [\"t\", [], [], 0, p.length - 1], attributes);\n    el.updateDataArray = function () {\n        var res,\n            i,\n            len = points.length,\n            p = [];\n\n        for (i = 0; i < len; i++) {\n            p.push([points[i].X(), points[i].Y()]);\n        }\n\n        res = JXG.Math.Metapost.curve(p, controls);\n        this.dataX = res[0];\n        this.dataY = res[1];\n    };\n    el.bezierDegree = 3;\n\n    le = points.length;\n    el.setParents(points);\n    for (i = 0; i < le; i++) {\n        if (Type.isPoint(points[i])) {\n            points[i].addChild(el);\n        }\n    }\n    el.elType = \"metapostspline\";\n\n    return el;\n};\n\nJXG.registerElement(\"metapostspline\", JXG.createMetapostSpline);\n\n/**\n * @class This element is used to provide a constructor for Riemann sums, which is realized as a special curve.\n * The returned element has the method Value() which returns the sum of the areas of the bars.\n * @pseudo\n * @description\n * @name Riemannsum\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @param {function,array_number,function_string,function_function,number_function,number} f,n,type_,a_,b_ Parent elements of Riemannsum are a\n *         Either a function term f(x) describing the function graph which is filled by the Riemann bars, or\n *         an array consisting of two functions and the area between is filled by the Riemann bars.\n *         <p>\n *         n determines the number of bars, it is either a fixed number or a function.\n *         <p>\n *         type is a string or function returning one of the values:  'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson', or 'trapezoidal'.\n *         Default value is 'left'.\n *         <p>\n *         Further parameters are an optional number or function for the left interval border a,\n *         and an optional number or function for the right interval border b.\n *         <p>\n *         Default values are a=-10 and b=10.\n * @see JXG.Curve\n * @example\n * // Create Riemann sums for f(x) = 0.5*x*x-2*x.\n *   var s = board.create('slider',[[0,4],[3,4],[0,4,10]],{snapWidth:1});\n *   var f = function(x) { return 0.5*x*x-2*x; };\n *   var r = board.create('riemannsum',\n *               [f, function(){return s.Value();}, 'upper', -2, 5],\n *               {fillOpacity:0.4}\n *               );\n *   var g = board.create('functiongraph',[f, -2, 5]);\n *   var t = board.create('text',[-2,-2, function(){ return 'Sum=' + JXG.toFixed(r.Value(), 4); }]);\n * </pre><div class=\"jxgbox\" id=\"JXG940f40cc-2015-420d-9191-c5d83de988cf\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function(){\n *   var board = JXG.JSXGraph.initBoard('JXG940f40cc-2015-420d-9191-c5d83de988cf', {boundingbox: [-3, 7, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *   var f = function(x) { return 0.5*x*x-2*x; };\n *   var s = board.create('slider',[[0,4],[3,4],[0,4,10]],{snapWidth:1});\n *   var r = board.create('riemannsum', [f, function(){return s.Value();}, 'upper', -2, 5], {fillOpacity:0.4});\n *   var g = board.create('functiongraph', [f, -2, 5]);\n *   var t = board.create('text',[-2,-2, function(){ return 'Sum=' + JXG.toFixed(r.Value(), 4); }]);\n * })();\n * </script><pre>\n *\n * @example\n *   // Riemann sum between two functions\n *   var s = board.create('slider',[[0,4],[3,4],[0,4,10]],{snapWidth:1});\n *   var g = function(x) { return 0.5*x*x-2*x; };\n *   var f = function(x) { return -x*(x-4); };\n *   var r = board.create('riemannsum',\n *               [[g,f], function(){return s.Value();}, 'lower', 0, 4],\n *               {fillOpacity:0.4}\n *               );\n *   var f = board.create('functiongraph',[f, -2, 5]);\n *   var g = board.create('functiongraph',[g, -2, 5]);\n *   var t = board.create('text',[-2,-2, function(){ return 'Sum=' + JXG.toFixed(r.Value(), 4); }]);\n * </pre><div class=\"jxgbox\" id=\"JXGf9a7ba38-b50f-4a32-a873-2f3bf9caee79\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function(){\n *   var board = JXG.JSXGraph.initBoard('JXGf9a7ba38-b50f-4a32-a873-2f3bf9caee79', {boundingbox: [-3, 7, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *   var s = board.create('slider',[[0,4],[3,4],[0,4,10]],{snapWidth:1});\n *   var g = function(x) { return 0.5*x*x-2*x; };\n *   var f = function(x) { return -x*(x-4); };\n *   var r = board.create('riemannsum',\n *               [[g,f], function(){return s.Value();}, 'lower', 0, 4],\n *               {fillOpacity:0.4}\n *               );\n *   var f = board.create('functiongraph',[f, -2, 5]);\n *   var g = board.create('functiongraph',[g, -2, 5]);\n *   var t = board.create('text',[-2,-2, function(){ return 'Sum=' + JXG.toFixed(r.Value(), 4); }]);\n * })();\n * </script><pre>\n */\nJXG.createRiemannsum = function (board, parents, attributes) {\n    var n, type, f, par, c, attr;\n\n    attr = Type.copyAttributes(attributes, board.options, \"riemannsum\");\n    attr.curvetype = \"plot\";\n\n    f = parents[0];\n    n = Type.createFunction(parents[1], board, \"\");\n\n    if (!Type.exists(n)) {\n        throw new Error(\n            \"JSXGraph: JXG.createRiemannsum: argument '2' n has to be number or function.\" +\n                \"\\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]\"\n        );\n    }\n\n    type = Type.createFunction(parents[2], board, \"\", false);\n    if (!Type.exists(type)) {\n        throw new Error(\n            \"JSXGraph: JXG.createRiemannsum: argument 3 'type' has to be string or function.\" +\n                \"\\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]\"\n        );\n    }\n\n    par = [[0], [0]].concat(parents.slice(3));\n\n    c = board.create(\"curve\", par, attr);\n\n    c.sum = 0.0;\n    /**\n     * Returns the value of the Riemann sum, i.e. the sum of the (signed) areas of the rectangles.\n     * @name Value\n     * @memberOf Riemann.prototype\n     * @function\n     * @returns {Number} value of Riemann sum.\n     */\n    c.Value = function () {\n        return this.sum;\n    };\n\n    /**\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var u = Numerics.riemann(f, n(), type(), this.minX(), this.maxX());\n        this.dataX = u[0];\n        this.dataY = u[1];\n\n        // Update \"Riemann sum\"\n        this.sum = u[2];\n    };\n\n    return c;\n};\n\nJXG.registerElement(\"riemannsum\", JXG.createRiemannsum);\n\n/**\n * @class This element is used to provide a constructor for trace curve (simple locus curve), which is realized as a special curve.\n * @pseudo\n * @description\n * @name Tracecurve\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @param {Point,Point} Parent elements of Tracecurve are a\n *         glider point and a point whose locus is traced.\n * @see JXG.Curve\n * @example\n * // Create trace curve.\n * var c1 = board.create('circle',[[0, 0], [2, 0]]),\n * p1 = board.create('point',[-3, 1]),\n * g1 = board.create('glider',[2, 1, c1]),\n * s1 = board.create('segment',[g1, p1]),\n * p2 = board.create('midpoint',[s1]),\n * curve = board.create('tracecurve', [g1, p2]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXG5749fb7d-04fc-44d2-973e-45c1951e29ad\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var tc1_board = JXG.JSXGraph.initBoard('JXG5749fb7d-04fc-44d2-973e-45c1951e29ad', {boundingbox: [-4, 4, 4, -4], axis: false, showcopyright: false, shownavigation: false});\n *   var c1 = tc1_board.create('circle',[[0, 0], [2, 0]]),\n *       p1 = tc1_board.create('point',[-3, 1]),\n *       g1 = tc1_board.create('glider',[2, 1, c1]),\n *       s1 = tc1_board.create('segment',[g1, p1]),\n *       p2 = tc1_board.create('midpoint',[s1]),\n *       curve = tc1_board.create('tracecurve', [g1, p2]);\n * </script><pre>\n */\nJXG.createTracecurve = function (board, parents, attributes) {\n    var c, glider, tracepoint, attr;\n\n    if (parents.length !== 2) {\n        throw new Error(\n            \"JSXGraph: Can't create trace curve with given parent'\" +\n                \"\\nPossible parent types: [glider, point]\"\n        );\n    }\n\n    glider = board.select(parents[0]);\n    tracepoint = board.select(parents[1]);\n\n    if (glider.type !== Const.OBJECT_TYPE_GLIDER || !Type.isPoint(tracepoint)) {\n        throw new Error(\n            \"JSXGraph: Can't create trace curve with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [glider, point]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"tracecurve\");\n    attr.curvetype = \"plot\";\n    c = board.create(\"curve\", [[0], [0]], attr);\n\n    /**\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var i,\n            step,\n            t,\n            el,\n            pEl,\n            x,\n            y,\n            from,\n            savetrace,\n            le = attr.numberpoints,\n            savePos = glider.position,\n            slideObj = glider.slideObject,\n            mi = slideObj.minX(),\n            ma = slideObj.maxX();\n\n        // set step width\n        step = (ma - mi) / le;\n        this.dataX = [];\n        this.dataY = [];\n\n        /*\n         * For gliders on circles and lines a closed curve is computed.\n         * For gliders on curves the curve is not closed.\n         */\n        if (slideObj.elementClass !== Const.OBJECT_CLASS_CURVE) {\n            le++;\n        }\n\n        // Loop over all steps\n        for (i = 0; i < le; i++) {\n            t = mi + i * step;\n            x = slideObj.X(t) / slideObj.Z(t);\n            y = slideObj.Y(t) / slideObj.Z(t);\n\n            // Position the glider\n            glider.setPositionDirectly(Const.COORDS_BY_USER, [x, y]);\n            from = false;\n\n            // Update all elements from the glider up to the trace element\n            for (el in this.board.objects) {\n                if (this.board.objects.hasOwnProperty(el)) {\n                    pEl = this.board.objects[el];\n\n                    if (pEl === glider) {\n                        from = true;\n                    }\n\n                    if (from && pEl.needsRegularUpdate) {\n                        // Save the trace mode of the element\n                        savetrace = pEl.visProp.trace;\n                        pEl.visProp.trace = false;\n                        pEl.needsUpdate = true;\n                        pEl.update(true);\n\n                        // Restore the trace mode\n                        pEl.visProp.trace = savetrace;\n                        if (pEl === tracepoint) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Store the position of the trace point\n            this.dataX[i] = tracepoint.X();\n            this.dataY[i] = tracepoint.Y();\n        }\n\n        // Restore the original position of the glider\n        glider.position = savePos;\n        from = false;\n\n        // Update all elements from the glider to the trace point\n        for (el in this.board.objects) {\n            if (this.board.objects.hasOwnProperty(el)) {\n                pEl = this.board.objects[el];\n                if (pEl === glider) {\n                    from = true;\n                }\n\n                if (from && pEl.needsRegularUpdate) {\n                    savetrace = pEl.visProp.trace;\n                    pEl.visProp.trace = false;\n                    pEl.needsUpdate = true;\n                    pEl.update(true);\n                    pEl.visProp.trace = savetrace;\n\n                    if (pEl === tracepoint) {\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n    return c;\n};\n\nJXG.registerElement(\"tracecurve\", JXG.createTracecurve);\n\n/**\n     * @class This element is used to provide a constructor for step function, which is realized as a special curve.\n     *\n     * In case the data points should be updated after creation time, they can be accessed by curve.xterm and curve.yterm.\n     * @pseudo\n     * @description\n     * @name Stepfunction\n     * @augments JXG.Curve\n     * @constructor\n     * @type JXG.Curve\n     * @param {Array,Array|Function} Parent elements of Stepfunction are two arrays containing the coordinates.\n     * @see JXG.Curve\n     * @example\n     * // Create step function.\n     var curve = board.create('stepfunction', [[0,1,2,3,4,5], [1,3,0,2,2,1]]);\n\n     * </pre><div class=\"jxgbox\" id=\"JXG32342ec9-ad17-4339-8a97-ff23dc34f51a\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *   var sf1_board = JXG.JSXGraph.initBoard('JXG32342ec9-ad17-4339-8a97-ff23dc34f51a', {boundingbox: [-1, 5, 6, -2], axis: true, showcopyright: false, shownavigation: false});\n     *   var curve = sf1_board.create('stepfunction', [[0,1,2,3,4,5], [1,3,0,2,2,1]]);\n     * </script><pre>\n     */\nJXG.createStepfunction = function (board, parents, attributes) {\n    var c, attr;\n    if (parents.length !== 2) {\n        throw new Error(\n            \"JSXGraph: Can't create step function with given parent'\" +\n                \"\\nPossible parent types: [array, array|function]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"stepfunction\");\n    c = board.create(\"curve\", parents, attr);\n    /**\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var i,\n            j = 0,\n            len = this.xterm.length;\n\n        this.dataX = [];\n        this.dataY = [];\n\n        if (len === 0) {\n            return;\n        }\n\n        this.dataX[j] = this.xterm[0];\n        this.dataY[j] = this.yterm[0];\n        ++j;\n\n        for (i = 1; i < len; ++i) {\n            this.dataX[j] = this.xterm[i];\n            this.dataY[j] = this.dataY[j - 1];\n            ++j;\n            this.dataX[j] = this.xterm[i];\n            this.dataY[j] = this.yterm[i];\n            ++j;\n        }\n    };\n\n    return c;\n};\n\nJXG.registerElement(\"stepfunction\", JXG.createStepfunction);\n\n/**\n * @class This element is used to provide a constructor for the graph showing\n * the (numerical) derivative of a given curve.\n *\n * @pseudo\n * @description\n * @name Derivative\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @param {JXG.Curve} Parent Curve for which the derivative is generated.\n * @see JXG.Curve\n * @example\n * var cu = board.create('cardinalspline', [[[-3,0], [-1,2], [0,1], [2,0], [3,1]], 0.5, 'centripetal'], {createPoints: false});\n * var d = board.create('derivative', [cu], {dash: 2});\n *\n * </pre><div id=\"JXGb9600738-1656-11e8-8184-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGb9600738-1656-11e8-8184-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var cu = board.create('cardinalspline', [[[-3,0], [-1,2], [0,1], [2,0], [3,1]], 0.5, 'centripetal'], {createPoints: false});\n *     var d = board.create('derivative', [cu], {dash: 2});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createDerivative = function (board, parents, attributes) {\n    var c, curve, dx, dy, attr;\n\n    if (parents.length !== 1 && parents[0].class !== Const.OBJECT_CLASS_CURVE) {\n        throw new Error(\n            \"JSXGraph: Can't create derivative curve with given parent'\" +\n                \"\\nPossible parent types: [curve]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"curve\");\n\n    curve = parents[0];\n    dx = Numerics.D(curve.X);\n    dy = Numerics.D(curve.Y);\n\n    c = board.create(\n        \"curve\",\n        [\n            function (t) {\n                return curve.X(t);\n            },\n            function (t) {\n                return dy(t) / dx(t);\n            },\n            curve.minX(),\n            curve.maxX()\n        ],\n        attr\n    );\n\n    c.setParents(curve);\n\n    return c;\n};\n\nJXG.registerElement(\"derivative\", JXG.createDerivative);\n\n/**\n * @class Intersection of two closed path elements. The elements may be of type curve, circle, polygon, inequality.\n * If one element is a curve, it has to be closed.\n * The resulting element is of type curve.\n * @pseudo\n * @description\n * @name CurveIntersection\n * @param {JXG.Curve|JXG.Polygon|JXG.Circle} curve1 First element which is intersected\n * @param {JXG.Curve|JXG.Polygon|JXG.Circle} curve2 Second element which is intersected\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n *\n * @example\n * var f = board.create('functiongraph', ['cos(x)']);\n * var ineq = board.create('inequality', [f], {inverse: true, fillOpacity: 0.1});\n * var circ = board.create('circle', [[0,0], 4]);\n * var clip = board.create('curveintersection', [ineq, circ], {fillColor: 'yellow', fillOpacity: 0.6});\n *\n * </pre><div id=\"JXGe2948257-8835-4276-9164-8acccb48e8d4\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGe2948257-8835-4276-9164-8acccb48e8d4',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var f = board.create('functiongraph', ['cos(x)']);\n *     var ineq = board.create('inequality', [f], {inverse: true, fillOpacity: 0.1});\n *     var circ = board.create('circle', [[0,0], 4]);\n *     var clip = board.create('curveintersection', [ineq, circ], {fillColor: 'yellow', fillOpacity: 0.6});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createCurveIntersection = function (board, parents, attributes) {\n    var c;\n\n    if (parents.length !== 2) {\n        throw new Error(\n            \"JSXGraph: Can't create curve intersection with given parent'\" +\n                \"\\nPossible parent types: [array, array|function]\"\n        );\n    }\n\n    c = board.create(\"curve\", [[], []], attributes);\n    /**\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var a = JXG.Math.Clip.intersection(parents[0], parents[1], this.board);\n        this.dataX = a[0];\n        this.dataY = a[1];\n    };\n    return c;\n};\n\n/**\n * @class Union of two closed path elements. The elements may be of type curve, circle, polygon, inequality.\n * If one element is a curve, it has to be closed.\n * The resulting element is of type curve.\n * @pseudo\n * @description\n * @name CurveUnion\n * @param {JXG.Curve|JXG.Polygon|JXG.Circle} curve1 First element defining the union\n * @param {JXG.Curve|JXG.Polygon|JXG.Circle} curve2 Second element defining the union\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n *\n * @example\n * var f = board.create('functiongraph', ['cos(x)']);\n * var ineq = board.create('inequality', [f], {inverse: true, fillOpacity: 0.1});\n * var circ = board.create('circle', [[0,0], 4]);\n * var clip = board.create('curveunion', [ineq, circ], {fillColor: 'yellow', fillOpacity: 0.6});\n *\n * </pre><div id=\"JXGe2948257-8835-4276-9164-8acccb48e8d4\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGe2948257-8835-4276-9164-8acccb48e8d4',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var f = board.create('functiongraph', ['cos(x)']);\n *     var ineq = board.create('inequality', [f], {inverse: true, fillOpacity: 0.1});\n *     var circ = board.create('circle', [[0,0], 4]);\n *     var clip = board.create('curveunion', [ineq, circ], {fillColor: 'yellow', fillOpacity: 0.6});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createCurveUnion = function (board, parents, attributes) {\n    var c;\n\n    if (parents.length !== 2) {\n        throw new Error(\n            \"JSXGraph: Can't create curve union with given parent'\" +\n                \"\\nPossible parent types: [array, array|function]\"\n        );\n    }\n\n    c = board.create(\"curve\", [[], []], attributes);\n    /**\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var a = JXG.Math.Clip.union(parents[0], parents[1], this.board);\n        this.dataX = a[0];\n        this.dataY = a[1];\n    };\n    return c;\n};\n\n/**\n * @class Difference of two closed path elements. The elements may be of type curve, circle, polygon, inequality.\n * If one element is a curve, it has to be closed.\n * The resulting element is of type curve.\n * @pseudo\n * @description\n * @name CurveDifference\n * @param {JXG.Curve|JXG.Polygon|JXG.Circle} curve1 First element from which the second element is \"subtracted\"\n * @param {JXG.Curve|JXG.Polygon|JXG.Circle} curve2 Second element which is subtracted from the first element\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n *\n * @example\n * var f = board.create('functiongraph', ['cos(x)']);\n * var ineq = board.create('inequality', [f], {inverse: true, fillOpacity: 0.1});\n * var circ = board.create('circle', [[0,0], 4]);\n * var clip = board.create('curvedifference', [ineq, circ], {fillColor: 'yellow', fillOpacity: 0.6});\n *\n * </pre><div id=\"JXGe2948257-8835-4276-9164-8acccb48e8d4\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGe2948257-8835-4276-9164-8acccb48e8d4',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var f = board.create('functiongraph', ['cos(x)']);\n *     var ineq = board.create('inequality', [f], {inverse: true, fillOpacity: 0.1});\n *     var circ = board.create('circle', [[0,0], 4]);\n *     var clip = board.create('curvedifference', [ineq, circ], {fillColor: 'yellow', fillOpacity: 0.6});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createCurveDifference = function (board, parents, attributes) {\n    var c;\n\n    if (parents.length !== 2) {\n        throw new Error(\n            \"JSXGraph: Can't create curve difference with given parent'\" +\n                \"\\nPossible parent types: [array, array|function]\"\n        );\n    }\n\n    c = board.create(\"curve\", [[], []], attributes);\n    /**\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var a = JXG.Math.Clip.difference(parents[0], parents[1], this.board);\n        this.dataX = a[0];\n        this.dataY = a[1];\n    };\n    return c;\n};\n\nJXG.registerElement(\"curvedifference\", JXG.createCurveDifference);\nJXG.registerElement(\"curveintersection\", JXG.createCurveIntersection);\nJXG.registerElement(\"curveunion\", JXG.createCurveUnion);\n\n/**\n * @class Box plot curve. The direction of the box plot can be either vertical or horizontal which\n * is controlled by the attribute \"dir\".\n * @pseudo\n * @description\n * @name Boxplot\n * @param {Array} quantiles Array conatining at least five quantiles. The elements can be of type number, function or string.\n * @param {Number|Function} axis Axis position of the box plot\n * @param {Number|Function} width Width of the rectangle part of the box plot. The width of the first and 4th quantile\n * is relative to this width and can be controlled by the attribute \"smallWidth\".\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n *\n * @example\n * var Q = [ -1, 2, 3, 3.5, 5 ];\n *\n * var b = board.create('boxplot', [Q, 2, 4], {strokeWidth: 3});\n *\n * </pre><div id=\"JXG13eb23a1-a641-41a2-be11-8e03e400a947\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG13eb23a1-a641-41a2-be11-8e03e400a947',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var Q = [ -1, 2, 3, 3.5, 5 ];\n *     var b = board.create('boxplot', [Q, 2, 4], {strokeWidth: 3});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * var Q = [ -1, 2, 3, 3.5, 5 ];\n * var b = board.create('boxplot', [Q, 3, 4], {dir: 'horizontal', smallWidth: 0.25, color:'red'});\n *\n * </pre><div id=\"JXG0deb9cb2-84bc-470d-a6db-8be9a5694813\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG0deb9cb2-84bc-470d-a6db-8be9a5694813',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var Q = [ -1, 2, 3, 3.5, 5 ];\n *     var b = board.create('boxplot', [Q, 3, 4], {dir: 'horizontal', smallWidth: 0.25, color:'red'});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * var data = [57, 57, 57, 58, 63, 66, 66, 67, 67, 68, 69, 70, 70, 70, 70, 72, 73, 75, 75, 76, 76, 78, 79, 81];\n * var Q = [];\n *\n * Q[0] = JXG.Math.Statistics.min(data);\n * Q = Q.concat(JXG.Math.Statistics.percentile(data, [25, 50, 75]));\n * Q[4] = JXG.Math.Statistics.max(data);\n *\n * var b = board.create('boxplot', [Q, 0, 3]);\n *\n * </pre><div id=\"JXGef079e76-ae99-41e4-af29-1d07d83bf85a\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGef079e76-ae99-41e4-af29-1d07d83bf85a',\n *             {boundingbox: [-5,90,5,30], axis: true, showcopyright: false, shownavigation: false});\n *     var data = [57, 57, 57, 58, 63, 66, 66, 67, 67, 68, 69, 70, 70, 70, 70, 72, 73, 75, 75, 76, 76, 78, 79, 81];\n *     var Q = [];\n *\n *     Q[0] = JXG.Math.Statistics.min(data);\n *     Q = Q.concat(JXG.Math.Statistics.percentile(data, [25, 50, 75]));\n *     Q[4] = JXG.Math.Statistics.max(data);\n *\n *     var b = board.create('boxplot', [Q, 0, 3]);\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * var mi = board.create('glider', [0, -1, board.defaultAxes.y]);\n * var ma = board.create('glider', [0, 5, board.defaultAxes.y]);\n * var Q = [function() { return mi.Y(); }, 2, 3, 3.5, function() { return ma.Y(); }];\n *\n * var b = board.create('boxplot', [Q, 0, 2]);\n *\n * </pre><div id=\"JXG3b3225da-52f0-42fe-8396-be9016bf289b\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG3b3225da-52f0-42fe-8396-be9016bf289b',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var mi = board.create('glider', [0, -1, board.defaultAxes.y]);\n *     var ma = board.create('glider', [0, 5, board.defaultAxes.y]);\n *     var Q = [function() { return mi.Y(); }, 2, 3, 3.5, function() { return ma.Y(); }];\n *\n *     var b = board.create('boxplot', [Q, 0, 2]);\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createBoxPlot = function (board, parents, attributes) {\n    var box,\n        i,\n        len,\n        w2,\n        attr = Type.copyAttributes(attributes, board.options, \"boxplot\");\n\n    if (parents.length !== 3) {\n        throw new Error(\n            \"JSXGraph: Can't create box plot with given parent'\" +\n                \"\\nPossible parent types: [array, number|function, number|function] containing quantiles, axis, width\"\n        );\n    }\n    if (parents[0].length < 5) {\n        throw new Error(\n            \"JSXGraph: Can't create box plot with given parent[0]'\" +\n                \"\\nparent[0] has to conatin at least 5 quantiles.\"\n        );\n    }\n    box = board.create(\"curve\", [[], []], attr);\n\n    len = parents[0].length; // Quantiles\n    box.Q = [];\n    for (i = 0; i < len; i++) {\n        box.Q[i] = Type.createFunction(parents[0][i], board, null, true);\n    }\n    box.x = Type.createFunction(parents[1], board, null, true);\n    box.w = Type.createFunction(parents[2], board, null, true);\n\n    box.updateDataArray = function () {\n        var v1, v2, l1, l2, r1, r2, w2, dir, x;\n\n        w2 = Type.evaluate(this.visProp.smallwidth);\n        dir = Type.evaluate(this.visProp.dir);\n        x = this.x();\n        l1 = x - this.w() * 0.5;\n        l2 = x - this.w() * 0.5 * w2;\n        r1 = x + this.w() * 0.5;\n        r2 = x + this.w() * 0.5 * w2;\n        v1 = [x, l2, r2, x, x, l1, l1, r1, r1, x, NaN, l1, r1, NaN, x, x, l2, r2, x];\n        v2 = [\n            this.Q[0](),\n            this.Q[0](),\n            this.Q[0](),\n            this.Q[0](),\n            this.Q[1](),\n            this.Q[1](),\n            this.Q[3](),\n            this.Q[3](),\n            this.Q[1](),\n            this.Q[1](),\n            NaN,\n            this.Q[2](),\n            this.Q[2](),\n            NaN,\n            this.Q[3](),\n            this.Q[4](),\n            this.Q[4](),\n            this.Q[4](),\n            this.Q[4]()\n        ];\n        if (dir === \"vertical\") {\n            this.dataX = v1;\n            this.dataY = v2;\n        } else {\n            this.dataX = v2;\n            this.dataY = v1;\n        }\n    };\n    return box;\n};\n\nJXG.registerElement(\"boxplot\", JXG.createBoxPlot);\n\nexport default {\n    Curve: JXG.Curve,\n    createCardinalSpline: JXG.createCardinalSpline,\n    createCurve: JXG.createCurve,\n    createCurveDifference: JXG.createCurveDifference,\n    createCurveIntersection: JXG.createCurveIntersection,\n    createCurveUnion: JXG.createCurveUnion,\n    createDerivative: JXG.createDerivative,\n    createFunctiongraph: JXG.createFunctiongraph,\n    createMetapostSpline: JXG.createMetapostSpline,\n    createPlot: JXG.createFunctiongraph,\n    createSpline: JXG.createSpline,\n    createRiemannsum: JXG.createRiemannsum,\n    createStepfunction: JXG.createStepfunction,\n    createTracecurve: JXG.createTracecurve\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the geometry object Arc is defined. Arc stores all\n * style and functional properties that are required to draw an arc on a board.\n */\n\nimport JXG from \"../jxg\";\nimport Geometry from \"../math/geometry\";\nimport Mat from \"../math/math\";\nimport Coords from \"../base/coords\";\nimport Circle from \"../base/circle\";\nimport Type from \"../utils/type\";\nimport Const from \"../base/constants\";\n\n/**\n * @class An arc is a segment of the circumference of a circle. It is defined by a center, one point that\n * defines the radius, and a third point that defines the angle of the arc.\n *\n * @pseudo\n * @name Arc\n * @augments Curve\n * @constructor\n * @type JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The result will be an arc of a circle around p1 through p2. The arc is drawn\n * counter-clockwise from p2 to p3.\n * @example\n * // Create an arc out of three free points\n * var p1 = board.create('point', [2.0, 2.0]);\n * var p2 = board.create('point', [1.0, 0.5]);\n * var p3 = board.create('point', [3.5, 1.0]);\n *\n * var a = board.create('arc', [p1, p2, p3]);\n * board.create('text',[1,6,function(){return 'arclength: '+Math.round(a.Value()*100)/100}])\n * </pre><div class=\"jxgbox\" id=\"JXG114ef584-4a5e-4686-8392-c97501befb5b\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG114ef584-4a5e-4686-8392-c97501befb5b', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [2.0, 2.0]),\n *       p2 = board.create('point', [1.0, 0.5]),\n *       p3 = board.create('point', [3.5, 1.0]),\n *\n *       a = board.create('arc', [p1, p2, p3]);\n *       board.create('text',[1,6,function(){return 'arclength: '+Math.round(a.Value()*100)/100}])\n * })();\n * </script><pre>\n *\n * @example\n * var t = board.create('transform', [2, 1.5], {type: 'scale'});\n * var a1 = board.create('arc', [[1, 1], [0, 1], [1, 0]], {strokeColor: 'red'});\n * var a2 = board.create('curve', [a1, t], {strokeColor: 'red'});\n *\n * </pre><div id=\"JXG1949da46-6339-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG1949da46-6339-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var t = board.create('transform', [2, 1.5], {type: 'scale'});\n *     var a1 = board.create('arc', [[1, 1], [0, 1], [1, 0]], {strokeColor: 'red'});\n *     var a2 = board.create('curve', [a1, t], {strokeColor: 'red'});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createArc = function (board, parents, attributes) {\n    var el, attr, points;\n\n    points = Type.providePoints(board, parents, attributes, \"arc\", [\n        \"center\",\n        \"radiusPoint\",\n        \"anglePoint\"\n    ]);\n    if (points === false || points.length < 3) {\n        throw new Error(\n            \"JSXGraph: Can't create Arc with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point,point], [arc, transformation]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"arc\");\n    el = board.create(\"curve\", [[0], [0]], attr);\n\n    el.elType = \"arc\";\n    el.setParents(points);\n\n    /**\n     * documented in JXG.GeometryElement\n     * @ignore\n     */\n    el.type = Const.OBJECT_TYPE_ARC;\n\n    /**\n     * Center of the arc.\n     * @memberOf Arc.prototype\n     * @name center\n     * @type JXG.Point\n     */\n    el.center = points[0];\n\n    /**\n     * Point defining the arc's radius.\n     * @memberOf Arc.prototype\n     * @name radiuspoint\n     * @type JXG.Point\n     */\n    el.radiuspoint = points[1];\n    el.point2 = el.radiuspoint;\n\n    /**\n     * The point defining the arc's angle.\n     * @memberOf Arc.prototype\n     * @name anglepoint\n     * @type JXG.Point\n     */\n    el.anglepoint = points[2];\n    el.point3 = el.anglepoint;\n\n    // Add arc as child to defining points\n    // or vice versa if the points are provided as coordinates\n    if (Type.exists(el.center._is_new)) {\n        el.addChild(el.center);\n        delete el.center._is_new;\n    } else {\n        el.center.addChild(el);\n    }\n    if (Type.exists(el.radiuspoint._is_new)) {\n        el.addChild(el.radiuspoint);\n        delete el.radiuspoint._is_new;\n    } else {\n        el.radiuspoint.addChild(el);\n    }\n    if (Type.exists(el.anglepoint._is_new)) {\n        el.addChild(el.anglepoint);\n        delete el.anglepoint._is_new;\n    } else {\n        el.anglepoint.addChild(el);\n    }\n\n    // should be documented in options\n    el.useDirection = attr.usedirection;\n\n    // documented in JXG.Curve\n    el.updateDataArray = function () {\n        var ar,\n            phi,\n            det,\n            p0c,\n            p1c,\n            p2c,\n            sgn = 1,\n            A = this.radiuspoint,\n            B = this.center,\n            C = this.anglepoint,\n            ev_s = Type.evaluate(this.visProp.selection);\n\n        phi = Geometry.rad(A, B, C);\n        if ((ev_s === \"minor\" && phi > Math.PI) || (ev_s === \"major\" && phi < Math.PI)) {\n            sgn = -1;\n        }\n\n        // This is true for circumCircleArcs. In that case there is\n        // a fourth parent element: [center, point1, point3, point2]\n        if (this.useDirection) {\n            p0c = points[1].coords.usrCoords;\n            p1c = points[3].coords.usrCoords;\n            p2c = points[2].coords.usrCoords;\n            det = (p0c[1] - p2c[1]) * (p0c[2] - p1c[2]) - (p0c[2] - p2c[2]) * (p0c[1] - p1c[1]);\n\n            if (det < 0) {\n                this.radiuspoint = points[1];\n                this.anglepoint = points[2];\n            } else {\n                this.radiuspoint = points[2];\n                this.anglepoint = points[1];\n            }\n        }\n\n        A = A.coords.usrCoords;\n        B = B.coords.usrCoords;\n        C = C.coords.usrCoords;\n\n        ar = Geometry.bezierArc(A, B, C, false, sgn);\n\n        this.dataX = ar[0];\n        this.dataY = ar[1];\n\n        this.bezierDegree = 3;\n\n        this.updateStdform();\n        this.updateQuadraticform();\n    };\n\n    /**\n     * Determines the arc's current radius. I.e. the distance between {@link Arc#center} and {@link Arc#radiuspoint}.\n     * @memberOf Arc.prototype\n     * @name Radius\n     * @function\n     * @returns {Number} The arc's radius\n     */\n    el.Radius = function () {\n        return this.radiuspoint.Dist(this.center);\n    };\n\n    /**\n     * @deprecated Use {@link Arc#Radius}\n     * @memberOf Arc.prototype\n     * @name getRadius\n     * @function\n     * @returns {Number}\n     */\n    el.getRadius = function () {\n        JXG.deprecated(\"Arc.getRadius()\", \"Arc.Radius()\");\n        return this.Radius();\n    };\n\n    /**\n     * Returns the length of the arc.\n     * @memberOf Arc.prototype\n     * @name Value\n     * @function\n     * @returns {Number} The arc length\n     */\n    el.Value = function () {\n        return this.Radius() * Geometry.rad(this.radiuspoint, this.center, this.anglepoint);\n    };\n\n    // documented in geometry element\n    el.hasPoint = function (x, y) {\n        var dist,\n            checkPoint,\n            has,\n            invMat,\n            c,\n            prec,\n            type,\n            r = this.Radius();\n\n        if (Type.evaluate(this.visProp.hasinnerpoints)) {\n            return this.hasPointSector(x, y);\n        }\n\n        if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n            type = this.board._inputDevice;\n            prec = Type.evaluate(this.visProp.precision[type]);\n        } else {\n            // 'inherit'\n            prec = this.board.options.precision.hasPoint;\n        }\n        prec /= Math.min(this.board.unitX, this.board.unitY);\n        checkPoint = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board);\n\n        if (this.transformations.length > 0) {\n            // Transform the mouse/touch coordinates\n            // back to the original position of the curve.\n            this.updateTransformMatrix();\n            invMat = Mat.inverse(this.transformMat);\n            c = Mat.matVecMult(invMat, checkPoint.usrCoords);\n            checkPoint = new Coords(Const.COORDS_BY_USER, c, this.board);\n        }\n\n        dist = this.center.coords.distance(Const.COORDS_BY_USER, checkPoint);\n        has = Math.abs(dist - r) < prec;\n\n        /**\n         * At that point we know that the user has touched the circle line.\n         * Now, we have to check, if the user has hit the arc path.\n         */\n        if (has) {\n            has = Geometry.coordsOnArc(this, checkPoint);\n        }\n        return has;\n    };\n\n    /**\n     * Checks whether (x,y) is within the sector defined by the arc.\n     * @memberOf Arc.prototype\n     * @name hasPointSector\n     * @function\n     * @param {Number} x Coordinate in x direction, screen coordinates.\n     * @param {Number} y Coordinate in y direction, screen coordinates.\n     * @returns {Boolean} True if (x,y) is within the sector defined by the arc, False otherwise.\n     */\n    el.hasPointSector = function (x, y) {\n        var checkPoint = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board),\n            r = this.Radius(),\n            dist = this.center.coords.distance(Const.COORDS_BY_USER, checkPoint),\n            has = dist < r;\n\n        if (has) {\n            has = Geometry.coordsOnArc(this, checkPoint);\n        }\n        return has;\n    };\n\n    // documented in geometry element\n    el.getTextAnchor = function () {\n        return this.center.coords;\n    };\n\n    // documented in geometry element\n    el.getLabelAnchor = function () {\n        var coords,\n            vec,\n            vecx,\n            vecy,\n            len,\n            angle = Geometry.rad(this.radiuspoint, this.center, this.anglepoint),\n            dx = 10 / this.board.unitX,\n            dy = 10 / this.board.unitY,\n            p2c = this.point2.coords.usrCoords,\n            pmc = this.center.coords.usrCoords,\n            bxminusax = p2c[1] - pmc[1],\n            byminusay = p2c[2] - pmc[2],\n            ev_s = Type.evaluate(this.visProp.selection),\n            l_vp = this.label ? this.label.visProp : this.visProp.label;\n\n        // If this is uncommented, the angle label can not be dragged\n        //if (Type.exists(this.label)) {\n        //    this.label.relativeCoords = new Coords(Const.COORDS_BY_SCREEN, [0, 0], this.board);\n        //}\n\n        if ((ev_s === \"minor\" && angle > Math.PI) || (ev_s === \"major\" && angle < Math.PI)) {\n            angle = -(2 * Math.PI - angle);\n        }\n\n        coords = new Coords(\n            Const.COORDS_BY_USER,\n            [\n                pmc[1] + Math.cos(angle * 0.5) * bxminusax - Math.sin(angle * 0.5) * byminusay,\n                pmc[2] + Math.sin(angle * 0.5) * bxminusax + Math.cos(angle * 0.5) * byminusay\n            ],\n            this.board\n        );\n\n        vecx = coords.usrCoords[1] - pmc[1];\n        vecy = coords.usrCoords[2] - pmc[2];\n\n        len = Math.sqrt(vecx * vecx + vecy * vecy);\n        vecx = (vecx * (len + dx)) / len;\n        vecy = (vecy * (len + dy)) / len;\n        vec = [pmc[1] + vecx, pmc[2] + vecy];\n\n        l_vp.position = Geometry.calcLabelQuadrant(Geometry.rad([1, 0], [0, 0], vec));\n\n        return new Coords(Const.COORDS_BY_USER, vec, this.board);\n    };\n\n    // documentation in jxg.circle\n    el.updateQuadraticform = Circle.Circle.prototype.updateQuadraticform;\n\n    // documentation in jxg.circle\n    el.updateStdform = Circle.Circle.prototype.updateStdform;\n\n    el.methodMap = JXG.deepCopy(el.methodMap, {\n        getRadius: \"getRadius\",\n        radius: \"Radius\",\n        center: \"center\",\n        radiuspoint: \"radiuspoint\",\n        anglepoint: \"anglepoint\",\n        Value: \"Value\"\n    });\n\n    el.prepareUpdate().update();\n    return el;\n};\n\nJXG.registerElement(\"arc\", JXG.createArc);\n\n/**\n * @class A semicircle is a special arc defined by two points. The arc hits both points.\n * @pseudo\n * @name Semicircle\n * @augments Arc\n * @constructor\n * @type Arc\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point} p1,p2 The result will be a composition of an arc drawn clockwise from <tt>p1</tt> and\n * <tt>p2</tt> and the midpoint of <tt>p1</tt> and <tt>p2</tt>.\n * @example\n * // Create an arc out of three free points\n * var p1 = board.create('point', [4.5, 2.0]);\n * var p2 = board.create('point', [1.0, 0.5]);\n *\n * var a = board.create('semicircle', [p1, p2]);\n * </pre><div class=\"jxgbox\" id=\"JXG5385d349-75d7-4078-b732-9ae808db1b0e\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG5385d349-75d7-4078-b732-9ae808db1b0e', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [4.5, 2.0]),\n *       p2 = board.create('point', [1.0, 0.5]),\n *\n *       sc = board.create('semicircle', [p1, p2]);\n * })();\n * </script><pre>\n */\nJXG.createSemicircle = function (board, parents, attributes) {\n    var el, mp, attr, points;\n\n    // we need 2 points\n    points = Type.providePoints(board, parents, attributes, \"point\");\n    if (points === false || points.length !== 2) {\n        throw new Error(\n            \"JSXGraph: Can't create Semicircle with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"semicircle\", \"center\");\n    mp = board.create(\"midpoint\", points, attr);\n    mp.dump = false;\n\n    attr = Type.copyAttributes(attributes, board.options, \"semicircle\");\n    el = board.create(\"arc\", [mp, points[1], points[0]], attr);\n    el.elType = \"semicircle\";\n    el.setParents([points[0].id, points[1].id]);\n    el.subs = {\n        midpoint: mp\n    };\n    el.inherits.push(mp);\n\n    /**\n     * The midpoint of the two defining points.\n     * @memberOf Semicircle.prototype\n     * @name midpoint\n     * @type Midpoint\n     */\n    el.midpoint = el.center = mp;\n\n    return el;\n};\n\nJXG.registerElement(\"semicircle\", JXG.createSemicircle);\n\n/**\n * @class A circumcircle arc is an {@link Arc} defined by three points. All three points lie on the arc.\n * @pseudo\n * @name CircumcircleArc\n * @augments Arc\n * @constructor\n * @type Arc\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The result will be a composition of an arc of the circumcircle of\n * <tt>p1</tt>, <tt>p2</tt>, and <tt>p3</tt> and the midpoint of the circumcircle of the three points. The arc is drawn\n * counter-clockwise from <tt>p1</tt> over <tt>p2</tt> to <tt>p3</tt>.\n * @example\n * // Create a circum circle arc out of three free points\n * var p1 = board.create('point', [2.0, 2.0]);\n * var p2 = board.create('point', [1.0, 0.5]);\n * var p3 = board.create('point', [3.5, 1.0]);\n *\n * var a = board.create('circumcirclearc', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG87125fd4-823a-41c1-88ef-d1a1369504e3\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG87125fd4-823a-41c1-88ef-d1a1369504e3', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [2.0, 2.0]),\n *       p2 = board.create('point', [1.0, 0.5]),\n *       p3 = board.create('point', [3.5, 1.0]),\n *\n *       cca = board.create('circumcirclearc', [p1, p2, p3]);\n * })();\n * </script><pre>\n */\nJXG.createCircumcircleArc = function (board, parents, attributes) {\n    var el, mp, attr, points;\n\n    // We need three points\n    points = Type.providePoints(board, parents, attributes, \"point\");\n    if (points === false || points.length !== 3) {\n        throw new Error(\n            \"JSXGraph: create Circumcircle Arc with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point,point]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"circumcirclearc\", \"center\");\n    mp = board.create(\"circumcenter\", points, attr);\n    mp.dump = false;\n\n    attr = Type.copyAttributes(attributes, board.options, \"circumcirclearc\");\n    attr.usedirection = true;\n    el = board.create(\"arc\", [mp, points[0], points[2], points[1]], attr);\n\n    el.elType = \"circumcirclearc\";\n    el.setParents([points[0].id, points[1].id, points[2].id]);\n    el.subs = {\n        center: mp\n    };\n    el.inherits.push(mp);\n\n    /**\n     * The midpoint of the circumcircle of the three points defining the circumcircle arc.\n     * @memberOf CircumcircleArc.prototype\n     * @name center\n     * @type Circumcenter\n     */\n    el.center = mp;\n\n    return el;\n};\n\nJXG.registerElement(\"circumcirclearc\", JXG.createCircumcircleArc);\n\n/**\n * @class A minor arc is a segment of the circumference of a circle having measure less than or equal to\n * 180 degrees (pi radians). It is defined by a center, one point that\n * defines the radius, and a third point that defines the angle of the arc.\n * @pseudo\n * @name MinorArc\n * @augments Curve\n * @constructor\n * @type JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 . Minor arc is an arc of a circle around p1 having measure less than or equal to\n * 180 degrees (pi radians) and starts at p2. The radius is determined by p2, the angle by p3.\n * @example\n * // Create an arc out of three free points\n * var p1 = board.create('point', [2.0, 2.0]);\n * var p2 = board.create('point', [1.0, 0.5]);\n * var p3 = board.create('point', [3.5, 1.0]);\n *\n * var a = board.create('arc', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG64ba7ca2-8728-45f3-96e5-3c7a4414de2f\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG64ba7ca2-8728-45f3-96e5-3c7a4414de2f', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [2.0, 2.0]),\n *       p2 = board.create('point', [1.0, 0.5]),\n *       p3 = board.create('point', [3.5, 1.0]),\n *\n *       a = board.create('minorarc', [p1, p2, p3]);\n * })();\n * </script><pre>\n */\n\nJXG.createMinorArc = function (board, parents, attributes) {\n    attributes.selection = \"minor\";\n    return JXG.createArc(board, parents, attributes);\n};\n\nJXG.registerElement(\"minorarc\", JXG.createMinorArc);\n\n/**\n * @class A major arc is a segment of the circumference of a circle having measure greater than or equal to\n * 180 degrees (pi radians). It is defined by a center, one point that\n * defines the radius, and a third point that defines the angle of the arc.\n * @pseudo\n * @name MajorArc\n * @augments Curve\n * @constructor\n * @type JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 . Major arc is an arc of a circle around p1 having measure greater than or equal to\n * 180 degrees (pi radians) and starts at p2. The radius is determined by p2, the angle by p3.\n * @example\n * // Create an arc out of three free points\n * var p1 = board.create('point', [2.0, 2.0]);\n * var p2 = board.create('point', [1.0, 0.5]);\n * var p3 = board.create('point', [3.5, 1.0]);\n *\n * var a = board.create('minorarc', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG17a10d38-5629-40a4-b150-f41806edee9f\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG17a10d38-5629-40a4-b150-f41806edee9f', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [2.0, 2.0]),\n *       p2 = board.create('point', [1.0, 0.5]),\n *       p3 = board.create('point', [3.5, 1.0]),\n *\n *       a = board.create('majorarc', [p1, p2, p3]);\n * })();\n * </script><pre>\n */\nJXG.createMajorArc = function (board, parents, attributes) {\n    attributes.selection = \"major\";\n    return JXG.createArc(board, parents, attributes);\n};\n\nJXG.registerElement(\"majorarc\", JXG.createMajorArc);\n\nexport default {\n    createArc: JXG.createArc,\n    createSemicircle: JXG.createSemicircle,\n    createCircumcircleArc: JXG.createCircumcircleArc,\n    createMinorArc: JXG.createMinorArc,\n    createMajorArc: JXG.createMajorArc\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Geometry from \"../math/geometry\";\nimport Mat from \"../math/math\";\nimport Statistics from \"../math/statistics\";\nimport Coords from \"../base/coords\";\nimport Const from \"../base/constants\";\nimport Type from \"../utils/type\";\n\n/**\n * @class A circular sector is a subarea of the area enclosed by a circle. It is enclosed by two radii and an arc.\n * @pseudo\n * @name Sector\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n *\n * First possiblity of input parameters are:\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 A sector is defined by three points: The sector's center <tt>p1</tt>,\n * a second point <tt>p2</tt> defining the radius and a third point <tt>p3</tt> defining the angle of the sector. The\n * Sector is always drawn counter clockwise from <tt>p2</tt> to <tt>p3</tt>\n * <p>\n * Second possibility of input parameters are:\n * @param {JXG.Line_JXG.Line_array,number_array,number_number,function} line, line2, coords1 or direction1, coords2 or direction2, radius The sector is defined by two lines.\n * The two legs which define the sector are given by two coordinates arrays which are project initially two the two lines or by two directions (+/- 1).\n * The last parameter is the radius of the sector.\n *\n *\n * @example\n * // Create a sector out of three free points\n * var p1 = board.create('point', [1.5, 5.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [5.0, 3.0]),\n *\n *     a = board.create('sector', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG49f59123-f013-4681-bfd9-338b89893156\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG49f59123-f013-4681-bfd9-338b89893156', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *     p1 = board.create('point', [1.5, 5.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [5.0, 3.0]),\n *\n *     a = board.create('sector', [p1, p2, p3]);\n * })();\n * </script><pre>\n *\n * @example\n * // Create a sector out of two lines, two directions and a radius\n * var p1 = board.create('point', [-1, 4]),\n *  p2 = board.create('point', [4, 1]),\n *  q1 = board.create('point', [-2, -3]),\n *  q2 = board.create('point', [4,3]),\n *\n *  li1 = board.create('line', [p1,p2], {strokeColor:'black', lastArrow:true}),\n *  li2 = board.create('line', [q1,q2], {lastArrow:true}),\n *\n *  sec1 = board.create('sector', [li1, li2, [5.5, 0], [4, 3], 3]),\n *  sec2 = board.create('sector', [li1, li2, 1, -1, 4]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXGbb9e2809-9895-4ff1-adfa-c9c71d50aa53\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXGbb9e2809-9895-4ff1-adfa-c9c71d50aa53', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *     p1 = board.create('point', [-1, 4]),\n *     p2 = board.create('point', [4, 1]),\n *     q1 = board.create('point', [-2, -3]),\n *     q2 = board.create('point', [4,3]),\n *\n *     li1 = board.create('line', [p1,p2], {strokeColor:'black', lastArrow:true}),\n *     li2 = board.create('line', [q1,q2], {lastArrow:true}),\n *\n *     sec1 = board.create('sector', [li1, li2, [5.5, 0], [4, 3], 3]),\n *     sec2 = board.create('sector', [li1, li2, 1, -1, 4]);\n * })();\n * </script><pre>\n *\n * @example\n * var t = board.create('transform', [2, 1.5], {type: 'scale'});\n * var s1 = board.create('sector', [[-3.5,-3], [-3.5, -2], [-3.5,-4]], {\n *                 anglePoint: {visible:true}, center: {visible: true}, radiusPoint: {visible: true},\n *                 fillColor: 'yellow', strokeColor: 'black'});\n * var s2 = board.create('curve', [s1, t], {fillColor: 'yellow', strokeColor: 'black'});\n *\n * </pre><div id=\"JXG2e70ee14-6339-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG2e70ee14-6339-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var t = board.create('transform', [2, 1.5], {type: 'scale'});\n *     var s1 = board.create('sector', [[-3.5,-3], [-3.5, -2], [-3.5,-4]], {\n *                     anglePoint: {visible:true}, center: {visible: true}, radiusPoint: {visible: true},\n *                     fillColor: 'yellow', strokeColor: 'black'});\n *     var s2 = board.create('curve', [s1, t], {fillColor: 'yellow', strokeColor: 'black'});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * var A = board.create('point', [3, -2]),\n *     B = board.create('point', [-2, -2]),\n *     C = board.create('point', [0, 4]);\n * \n * var angle = board.create('sector', [B, A, C], {\n *         strokeWidth: 0,\n *         arc: {\n *         \tvisible: true,\n *         \tstrokeWidth: 3,\n *           lastArrow: {size: 4},\n *           firstArrow: {size: 4}\n *         }\n *       });\n * //angle.arc.setAttribute({firstArrow: false});\n * angle.arc.setAttribute({lastArrow: false});\n * \n * </pre><div id=\"JXGca37b99e-1510-49fa-ac9e-efd60e956104\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGca37b99e-1510-49fa-ac9e-efd60e956104',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var A = board.create('point', [3, -2]),\n *         B = board.create('point', [-2, -2]),\n *         C = board.create('point', [0, 4]);\n *     \n *     var angle = board.create('sector', [B, A, C], {\n *             strokeWidth: 0,\n *             arc: {\n *             \tvisible: true,\n *             \tstrokeWidth: 3,\n *               lastArrow: {size: 4},\n *               firstArrow: {size: 4}\n *             }\n *           });\n *     //angle.arc.setAttribute({firstArrow: false});\n *     angle.arc.setAttribute({lastArrow: false});\n * \n *     })();\n * \n * </script><pre>\n * \n * \n */\nJXG.createSector = function (board, parents, attributes) {\n    var el,\n        attr,\n        i,\n        type = \"invalid\",\n        s,\n        v,\n        attrPoints = [\"center\", \"radiusPoint\", \"anglePoint\"],\n        points;\n\n    // Three points?\n    if (\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE &&\n        parents[1].elementClass === Const.OBJECT_CLASS_LINE &&\n        (Type.isArray(parents[2]) || Type.isNumber(parents[2])) &&\n        (Type.isArray(parents[3]) || Type.isNumber(parents[3])) &&\n        (Type.isNumber(parents[4]) || Type.isFunction(parents[4]) || Type.isString(parents[4]))\n    ) {\n        type = \"2lines\";\n    } else {\n        points = Type.providePoints(board, parents, attributes, \"sector\", attrPoints);\n        if (points === false) {\n            throw new Error(\n                \"JSXGraph: Can't create Sector with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"' and '\" +\n                    typeof parents[2] +\n                    \"'.\"\n            );\n        }\n        type = \"3points\";\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"sector\");\n    el = board.create(\"curve\", [[0], [0]], attr);\n    el.type = Const.OBJECT_TYPE_SECTOR;\n    el.elType = \"sector\";\n\n    /**\n     * Set a radius if the attribute `radius` has value 'auto'.\n     * Sets a radius between 20 and 50 points, depending on the distance\n     * between the center and the radius point.\n     * This function is used in {@link Angle}.\n     *\n     * @returns {Number} returns a radius value in user coordinates.\n     */\n    el.autoRadius = function () {\n        var r1 = 20 / el.board.unitX, // 20px\n            r2 = Infinity,\n            r3 = 50 / el.board.unitX; // 50px\n\n        if (Type.isPoint(el.center)) {\n            // This does not work for 2-lines sectors / angles\n            r2 = el.center.Dist(el.point2) * 0.3333;\n        }\n\n        return Math.max(r1, Math.min(r2, r3));\n    };\n\n    if (type === \"2lines\") {\n        /**\n         * @ignore\n         */\n        el.Radius = function () {\n            var r = Type.evaluate(parents[4]);\n            if (r === \"auto\") {\n                return this.autoRadius();\n            }\n            return r;\n        };\n\n        el.line1 = board.select(parents[0]);\n        el.line2 = board.select(parents[1]);\n\n        el.line1.addChild(el);\n        el.line2.addChild(el);\n        el.setParents(parents);\n\n        el.point1 = { visProp: {} };\n        el.point2 = { visProp: {} };\n        el.point3 = { visProp: {} };\n\n        /* Intersection point */\n        s = Geometry.meetLineLine(el.line1.stdform, el.line2.stdform, 0, board);\n\n        if (Type.isArray(parents[2])) {\n            /* project p1 to l1 */\n            if (parents[2].length === 2) {\n                parents[2] = [1].concat(parents[2]);\n            }\n            /*\n                v = [0, el.line1.stdform[1], el.line1.stdform[2]];\n                v = Mat.crossProduct(v, parents[2]);\n                v = Geometry.meetLineLine(v, el.line1.stdform, 0, board);\n                */\n            v = Geometry.projectPointToLine(\n                { coords: { usrCoords: parents[2] } },\n                el.line1,\n                board\n            );\n            v = Statistics.subtract(v.usrCoords, s.usrCoords);\n            el.direction1 =\n                Mat.innerProduct(v, [0, el.line1.stdform[2], -el.line1.stdform[1]], 3) >= 0\n                    ? +1\n                    : -1;\n        } else {\n            el.direction1 = parents[2] >= 0 ? 1 : -1;\n        }\n\n        if (Type.isArray(parents[3])) {\n            /* project p2 to l2 */\n            if (parents[3].length === 2) {\n                parents[3] = [1].concat(parents[3]);\n            }\n            /*\n                v = [0, el.line2.stdform[1], el.line2.stdform[2]];\n                v = Mat.crossProduct(v, parents[3]);\n                v = Geometry.meetLineLine(v, el.line2.stdform, 0, board);\n                */\n            v = Geometry.projectPointToLine(\n                { coords: { usrCoords: parents[3] } },\n                el.line2,\n                board\n            );\n            v = Statistics.subtract(v.usrCoords, s.usrCoords);\n            el.direction2 =\n                Mat.innerProduct(v, [0, el.line2.stdform[2], -el.line2.stdform[1]], 3) >= 0\n                    ? +1\n                    : -1;\n        } else {\n            el.direction2 = parents[3] >= 0 ? 1 : -1;\n        }\n\n        el.updateDataArray = function () {\n            var r,\n                l1,\n                l2,\n                A = [0, 0, 0],\n                B = [0, 0, 0],\n                C = [0, 0, 0],\n                ar;\n\n            l1 = this.line1;\n            l2 = this.line2;\n\n            // Intersection point of the lines\n            B = Mat.crossProduct(l1.stdform, l2.stdform);\n\n            if (Math.abs(B[0]) > Mat.eps * Mat.eps) {\n                B[1] /= B[0];\n                B[2] /= B[0];\n                B[0] /= B[0];\n            }\n            // First point\n            r = this.direction1 * this.Radius();\n            A = Statistics.add(B, [0, r * l1.stdform[2], -r * l1.stdform[1]]);\n\n            // Second point\n            r = this.direction2 * this.Radius();\n            C = Statistics.add(B, [0, r * l2.stdform[2], -r * l2.stdform[1]]);\n\n            this.point2.coords = new Coords(Const.COORDS_BY_USER, A, el.board);\n            this.point1.coords = new Coords(Const.COORDS_BY_USER, B, el.board);\n            this.point3.coords = new Coords(Const.COORDS_BY_USER, C, el.board);\n\n            if (\n                Math.abs(A[0]) < Mat.eps ||\n                Math.abs(B[0]) < Mat.eps ||\n                Math.abs(C[0]) < Mat.eps\n            ) {\n                this.dataX = [NaN];\n                this.dataY = [NaN];\n                return;\n            }\n\n            ar = Geometry.bezierArc(A, B, C, true, 1);\n\n            this.dataX = ar[0];\n            this.dataY = ar[1];\n\n            this.bezierDegree = 3;\n        };\n\n        el.methodMap = JXG.deepCopy(el.methodMap, {\n            radius: \"Radius\",\n            getRadius: \"Radius\",\n            setRadius: \"setRadius\"\n        });\n\n        //    el.prepareUpdate().update();\n\n        // end '2lines'\n    } else if (type === \"3points\") {\n        /**\n         * Midpoint of the sector.\n         * @memberOf Sector.prototype\n         * @name point1\n         * @type JXG.Point\n         */\n        el.point1 = points[0];\n\n        /**\n         * This point together with {@link Sector#point1} defines the radius..\n         * @memberOf Sector.prototype\n         * @name point2\n         * @type JXG.Point\n         */\n        el.point2 = points[1];\n\n        /**\n         * Defines the sector's angle.\n         * @memberOf Sector.prototype\n         * @name point3\n         * @type JXG.Point\n         */\n        el.point3 = points[2];\n\n        /* Add arc as child to defining points */\n        for (i = 0; i < 3; i++) {\n            if (Type.exists(points[i]._is_new)) {\n                el.addChild(points[i]);\n                delete points[i]._is_new;\n            } else {\n                points[i].addChild(el);\n            }\n        }\n\n        // useDirection is necessary for circumCircleSectors\n        el.useDirection = attributes.usedirection;\n        el.setParents(points);\n\n        /**\n         * Defines the sectors orientation in case of circumCircleSectors.\n         * @memberOf Sector.prototype\n         * @name point4\n         * @type JXG.Point\n         */\n        if (Type.exists(points[3])) {\n            el.point4 = points[3];\n            el.point4.addChild(el);\n        }\n\n        el.methodMap = JXG.deepCopy(el.methodMap, {\n            arc: \"arc\",\n            center: \"center\",\n            radiuspoint: \"radiuspoint\",\n            anglepoint: \"anglepoint\",\n            radius: \"Radius\",\n            getRadius: \"Radius\",\n            setRadius: \"setRadius\"\n        });\n\n        /**\n         * documented in JXG.Curve\n         * @ignore\n         */\n        el.updateDataArray = function () {\n            var ar,\n                det,\n                p0c,\n                p1c,\n                p2c,\n                A = this.point2,\n                B = this.point1,\n                C = this.point3,\n                phi,\n                sgn = 1,\n                vp_s = Type.evaluate(this.visProp.selection);\n\n            if (!A.isReal || !B.isReal || !C.isReal) {\n                this.dataX = [NaN];\n                this.dataY = [NaN];\n                return;\n            }\n\n            phi = Geometry.rad(A, B, C);\n            if ((vp_s === \"minor\" && phi > Math.PI) || (vp_s === \"major\" && phi < Math.PI)) {\n                sgn = -1;\n            }\n\n            // This is true for circumCircleSectors. In that case there is\n            // a fourth parent element: [midpoint, point1, point3, point2]\n            if (this.useDirection && Type.exists(this.point4)) {\n                p0c = this.point2.coords.usrCoords;\n                p1c = this.point4.coords.usrCoords;\n                p2c = this.point3.coords.usrCoords;\n                det =\n                    (p0c[1] - p2c[1]) * (p0c[2] - p1c[2]) -\n                    (p0c[2] - p2c[2]) * (p0c[1] - p1c[1]);\n\n                if (det >= 0.0) {\n                    C = this.point2;\n                    A = this.point3;\n                }\n            }\n\n            A = A.coords.usrCoords;\n            B = B.coords.usrCoords;\n            C = C.coords.usrCoords;\n\n            ar = Geometry.bezierArc(A, B, C, true, sgn);\n\n            this.dataX = ar[0];\n            this.dataY = ar[1];\n            this.bezierDegree = 3;\n        };\n\n        /**\n         * Returns the radius of the sector.\n         * @memberOf Sector.prototype\n         * @name Radius\n         * @function\n         * @returns {Number} The distance between {@link Sector#point1} and {@link Sector#point2}.\n         */\n        el.Radius = function () {\n            return this.point2.Dist(this.point1);\n        };\n\n        attr = Type.copyAttributes(attributes, board.options, \"sector\", \"arc\");\n        attr.withLabel = false;\n        attr.name += \"_arc\";\n        el.arc = board.create(\"arc\", [el.point1, el.point2, el.point3], attr);\n        el.addChild(el.arc);\n    } // end '3points'\n\n    el.center = el.point1;\n    el.radiuspoint = el.point2;\n    el.anglepoint = el.point3;\n\n    // Default hasPoint method. Documented in geometry element\n    el.hasPointCurve = function (x, y) {\n        var angle,\n            alpha,\n            beta,\n            prec,\n            type,\n            checkPoint = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board),\n            r = this.Radius(),\n            dist = this.center.coords.distance(Const.COORDS_BY_USER, checkPoint),\n            has,\n            vp_s = Type.evaluate(this.visProp.selection);\n\n        if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n            type = this.board._inputDevice;\n            prec = Type.evaluate(this.visProp.precision[type]);\n        } else {\n            // 'inherit'\n            prec = this.board.options.precision.hasPoint;\n        }\n        prec /= Math.min(this.board.unitX, this.board.unitY);\n        has = Math.abs(dist - r) < prec;\n        if (has) {\n            angle = Geometry.rad(this.point2, this.center, checkPoint.usrCoords.slice(1));\n            alpha = 0;\n            beta = Geometry.rad(this.point2, this.center, this.point3);\n\n            if ((vp_s === \"minor\" && beta > Math.PI) || (vp_s === \"major\" && beta < Math.PI)) {\n                alpha = beta;\n                beta = 2 * Math.PI;\n            }\n\n            if (angle < alpha || angle > beta) {\n                has = false;\n            }\n        }\n\n        return has;\n    };\n\n    /**\n     * Checks whether (x,y) is within the area defined by the sector.\n     * @memberOf Sector.prototype\n     * @name hasPointSector\n     * @function\n     * @param {Number} x Coordinate in x direction, screen coordinates.\n     * @param {Number} y Coordinate in y direction, screen coordinates.\n     * @returns {Boolean} True if (x,y) is within the sector defined by the arc, False otherwise.\n     */\n    el.hasPointSector = function (x, y) {\n        var angle,\n            checkPoint = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board),\n            r = this.Radius(),\n            dist = this.point1.coords.distance(Const.COORDS_BY_USER, checkPoint),\n            alpha,\n            beta,\n            has = dist < r,\n            vp_s = Type.evaluate(this.visProp.selection);\n\n        if (has) {\n            angle = Geometry.rad(this.radiuspoint, this.center, checkPoint.usrCoords.slice(1));\n            alpha = 0.0;\n            beta = Geometry.rad(this.radiuspoint, this.center, this.anglepoint);\n\n            if ((vp_s === \"minor\" && beta > Math.PI) || (vp_s === \"major\" && beta < Math.PI)) {\n                alpha = beta;\n                beta = 2 * Math.PI;\n            }\n            //if (angle > Geometry.rad(this.point2, this.point1, this.point3)) {\n            if (angle < alpha || angle > beta) {\n                has = false;\n            }\n        }\n        return has;\n    };\n\n    el.hasPoint = function (x, y) {\n        if (\n            Type.evaluate(this.visProp.highlightonsector) ||\n            Type.evaluate(this.visProp.hasinnerpoints)\n        ) {\n            return this.hasPointSector(x, y);\n        }\n\n        return this.hasPointCurve(x, y);\n    };\n\n    // documented in GeometryElement\n    el.getTextAnchor = function () {\n        return this.point1.coords;\n    };\n\n    // documented in GeometryElement\n    // this method is very similar to arc.getLabelAnchor()\n    // there are some additions in the arc version though, mainly concerning\n    // \"major\" and \"minor\" arcs. but maybe these methods can be merged.\n    el.getLabelAnchor = function () {\n        var coords,\n            vec,\n            vecx,\n            vecy,\n            len,\n            angle = Geometry.rad(this.point2, this.point1, this.point3),\n            dx = 13 / this.board.unitX,\n            dy = 13 / this.board.unitY,\n            p2c = this.point2.coords.usrCoords,\n            pmc = this.point1.coords.usrCoords,\n            bxminusax = p2c[1] - pmc[1],\n            byminusay = p2c[2] - pmc[2],\n            vp_s = Type.evaluate(this.visProp.selection),\n            l_vp = this.label ? this.label.visProp : this.visProp.label;\n\n        // If this is uncommented, the angle label can not be dragged\n        //if (Type.exists(this.label)) {\n        //    this.label.relativeCoords = new Coords(Const.COORDS_BY_SCREEN, [0, 0], this.board);\n        //}\n\n        if ((vp_s === \"minor\" && angle > Math.PI) || (vp_s === \"major\" && angle < Math.PI)) {\n            angle = -(2 * Math.PI - angle);\n        }\n\n        coords = new Coords(\n            Const.COORDS_BY_USER,\n            [\n                pmc[1] + Math.cos(angle * 0.5) * bxminusax - Math.sin(angle * 0.5) * byminusay,\n                pmc[2] + Math.sin(angle * 0.5) * bxminusax + Math.cos(angle * 0.5) * byminusay\n            ],\n            this.board\n        );\n\n        vecx = coords.usrCoords[1] - pmc[1];\n        vecy = coords.usrCoords[2] - pmc[2];\n\n        len = Math.sqrt(vecx * vecx + vecy * vecy);\n        vecx = (vecx * (len + dx)) / len;\n        vecy = (vecy * (len + dy)) / len;\n        vec = [pmc[1] + vecx, pmc[2] + vecy];\n\n        l_vp.position = Geometry.calcLabelQuadrant(Geometry.rad([1, 0], [0, 0], vec));\n\n        return new Coords(Const.COORDS_BY_USER, vec, this.board);\n    };\n\n    /**\n     * Overwrite the Radius method of the sector.\n     * Used in {@link GeometryElement#setAttribute}.\n     * @param {Number, Function} value New radius.\n     */\n    el.setRadius = function (val) {\n        /**\n         * @ignore\n         */\n        el.Radius = function () {\n            var r = Type.evaluate(val);\n            if (r === \"auto\") {\n                return this.autoRadius();\n            }\n            return r;\n        };\n    };\n\n    /**\n     * @deprecated\n     * @ignore\n     */\n    el.getRadius = function () {\n        JXG.deprecated(\"Sector.getRadius()\", \"Sector.Radius()\");\n        return this.Radius();\n    };\n\n    /**\n     * Moves the sector by the difference of two coordinates.\n     * @param {Number} method The type of coordinates used here. Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.\n     * @param {Array} coords coordinates in screen/user units\n     * @param {Array} oldcoords previous coordinates in screen/user units\n     * @returns {JXG.Curve} this element\n     */\n    if (type === \"3points\") {\n        el.setPositionDirectly = function (method, coords, oldcoords) {\n            var dc,\n                t,\n                i,\n                c = new Coords(method, coords, this.board),\n                oldc = new Coords(method, oldcoords, this.board);\n\n            if (!el.point1.draggable() || !el.point2.draggable() || !el.point3.draggable()) {\n                return this;\n            }\n\n            dc = Statistics.subtract(c.usrCoords, oldc.usrCoords);\n            t = this.board.create(\"transform\", dc.slice(1), { type: \"translate\" });\n            t.applyOnce([el.point1, el.point2, el.point3]);\n\n            return this;\n        };\n    }\n\n    el.prepareUpdate().update();\n\n    return el;\n};\n\nJXG.registerElement(\"sector\", JXG.createSector);\n\n/**\n * @class A circumcircle sector is different from a {@link Sector} mostly in the way the parent elements are interpreted.\n * At first, the circum centre is determined from the three given points. Then the sector is drawn from <tt>p1</tt> through\n * <tt>p2</tt> to <tt>p3</tt>.\n * @pseudo\n * @name CircumcircleSector\n * @augments Sector\n * @constructor\n * @type Sector\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p1 A circumcircle sector is defined by the circumcircle which is determined\n * by these three given points. The circumcircle sector is always drawn from <tt>p1</tt> through <tt>p2</tt> to <tt>p3</tt>.\n * @example\n * // Create an arc out of three free points\n * var p1 = board.create('point', [1.5, 5.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [5.0, 3.0]),\n *\n *     a = board.create('circumcirclesector', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG695cf0d6-6d7a-4d4d-bfc9-34c6aa28cd04\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG695cf0d6-6d7a-4d4d-bfc9-34c6aa28cd04', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *     p1 = board.create('point', [1.5, 5.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [5.0, 3.0]),\n *\n *     a = board.create('circumcirclesector', [p1, p2, p3]);\n * })();\n * </script><pre>\n */\nJXG.createCircumcircleSector = function (board, parents, attributes) {\n    var el, mp, attr, points, i;\n\n    points = Type.providePoints(board, parents, attributes, \"point\");\n    if (points === false) {\n        throw new Error(\n            \"JSXGraph: Can't create circumcircle sector with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\"\n        );\n    }\n\n    mp = board.create(\"circumcenter\", points.slice(0, 3), attr);\n    mp.dump = false;\n\n    attr = Type.copyAttributes(attributes, board.options, \"circumcirclesector\");\n    el = board.create(\"sector\", [mp, points[0], points[2], points[1]], attr);\n\n    el.elType = \"circumcirclesector\";\n    el.setParents(points);\n\n    /**\n     * Center of the circumcirclesector\n     * @memberOf CircumcircleSector.prototype\n     * @name center\n     * @type Circumcenter\n     */\n    el.center = mp;\n    el.subs = {\n        center: mp\n    };\n\n    return el;\n};\n\nJXG.registerElement(\"circumcirclesector\", JXG.createCircumcircleSector);\n\n/**\n * @class A minor sector is a sector of a circle having measure less than or equal to\n * 180 degrees (pi radians). It is defined by a center, one point that\n * defines the radius, and a third point that defines the angle of the sector.\n * @pseudo\n * @name MinorSector\n * @augments Curve\n * @constructor\n * @type JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 . Minor sector is a sector of a circle around p1 having measure less than or equal to\n * 180 degrees (pi radians) and starts at p2. The radius is determined by p2, the angle by p3.\n * @example\n * // Create sector out of three free points\n * var p1 = board.create('point', [2.0, 2.0]);\n * var p2 = board.create('point', [1.0, 0.5]);\n * var p3 = board.create('point', [3.5, 1.0]);\n *\n * var a = board.create('minorsector', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXGaf27ddcc-265f-428f-90dd-d31ace945800\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXGaf27ddcc-265f-428f-90dd-d31ace945800', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [2.0, 2.0]),\n *       p2 = board.create('point', [1.0, 0.5]),\n *       p3 = board.create('point', [3.5, 1.0]),\n *\n *       a = board.create('minorsector', [p1, p2, p3]);\n * })();\n * </script><pre>\n * \n * @example\n * var A = board.create('point', [3, -2]),\n *     B = board.create('point', [-2, -2]),\n *     C = board.create('point', [0, 4]);\n * \n * var angle = board.create('minorsector', [B, A, C], {\n *         strokeWidth: 0,\n *         arc: {\n *         \tvisible: true,\n *         \tstrokeWidth: 3,\n *           lastArrow: {size: 4},\n *           firstArrow: {size: 4}\n *         }\n *       });\n * //angle.arc.setAttribute({firstArrow: false});\n * angle.arc.setAttribute({lastArrow: false});\n * \n * \n * </pre><div id=\"JXGdddf3c8f-4b0c-4268-8171-8fcd30e71f60\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGdddf3c8f-4b0c-4268-8171-8fcd30e71f60',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var A = board.create('point', [3, -2]),\n *         B = board.create('point', [-2, -2]),\n *         C = board.create('point', [0, 4]);\n *     \n *     var angle = board.create('minorsector', [B, A, C], {\n *             strokeWidth: 0,\n *             arc: {\n *             \tvisible: true,\n *             \tstrokeWidth: 3,\n *               lastArrow: {size: 4},\n *               firstArrow: {size: 4}\n *             }\n *           });\n *     //angle.arc.setAttribute({firstArrow: false});\n *     angle.arc.setAttribute({lastArrow: false});\n *     \n * \n *     })();\n * \n * </script><pre>\n * \n */\nJXG.createMinorSector = function (board, parents, attributes) {\n    attributes.selection = \"minor\";\n    return JXG.createSector(board, parents, attributes);\n};\n\nJXG.registerElement(\"minorsector\", JXG.createMinorSector);\n\n/**\n * @class A major sector is a sector of a circle having measure greater than or equal to\n * 180 degrees (pi radians). It is defined by a center, one point that\n * defines the radius, and a third point that defines the angle of the sector.\n * @pseudo\n * @name MajorSector\n * @augments Curve\n * @constructor\n * @type JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 . Major sector is a sector of a circle around p1 having measure greater than or equal to\n * 180 degrees (pi radians) and starts at p2. The radius is determined by p2, the angle by p3.\n * @example\n * // Create an arc out of three free points\n * var p1 = board.create('point', [2.0, 2.0]);\n * var p2 = board.create('point', [1.0, 0.5]);\n * var p3 = board.create('point', [3.5, 1.0]);\n *\n * var a = board.create('majorsector', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG83c6561f-7561-4047-b98d-036248a00932\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG83c6561f-7561-4047-b98d-036248a00932', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *       p1 = board.create('point', [2.0, 2.0]),\n *       p2 = board.create('point', [1.0, 0.5]),\n *       p3 = board.create('point', [3.5, 1.0]),\n *\n *       a = board.create('majorsector', [p1, p2, p3]);\n * })();\n * </script><pre>\n */\nJXG.createMajorSector = function (board, parents, attributes) {\n    attributes.selection = \"major\";\n    return JXG.createSector(board, parents, attributes);\n};\n\nJXG.registerElement(\"majorsector\", JXG.createMajorSector);\n\n/**\n * @class The angle element is used to denote an angle defined by three points. Visually it is just a {@link Sector}\n * element with a radius not defined by the parent elements but by an attribute <tt>radius</tt>. As opposed to the sector,\n * an angle has two angle points and no radius point.\n * Sector is displayed if type==\"sector\".\n * If type==\"square\", instead of a sector a parallelogram is displayed.\n * In case of type==\"auto\", a square is displayed if the angle is near orthogonal.\n * If no name is provided the angle label is automatically set to a lower greek letter.\n * @pseudo\n * @name Angle\n * @augments Sector\n * @constructor\n * @type Sector\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * First possibility of input parameters are:\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p1 An angle is always drawn counterclockwise from <tt>p1</tt> to\n * <tt>p3</tt> around <tt>p2</tt>.\n *\n * Second possibility of input parameters are:\n * @param {JXG.Line_JXG.Line_array|number_array|number} line, line2, coords1 or direction1, coords2 or direction2, radius The angle is defined by two lines.\n * The two legs which define the angle are given by two coordinate arrays.\n * The points given by these coordinate arrays are projected initially (i.e. only once) onto the two lines.\n * The other possibility is to supply directions (+/- 1).\n *\n * @example\n * // Create an angle out of three free points\n * var p1 = board.create('point', [5.0, 3.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [1.5, 5.0]),\n *\n *     a = board.create('angle', [p1, p2, p3]),\n *     t = board.create('text', [4, 4, function() { return JXG.toFixed(a.Value(), 2); }]);\n * </pre><div class=\"jxgbox\" id=\"JXGa34151f9-bb26-480a-8d6e-9b8cbf789ae5\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXGa34151f9-bb26-480a-8d6e-9b8cbf789ae5', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *     p1 = board.create('point', [5.0, 3.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [1.5, 5.0]),\n *\n *     a = board.create('angle', [p1, p2, p3]),\n *     t = board.create('text', [4, 4, function() { return JXG.toFixed(a.Value(), 2); }]);\n * })();\n * </script><pre>\n *\n * @example\n * // Create an angle out of two lines and two directions\n * var p1 = board.create('point', [-1, 4]),\n *  p2 = board.create('point', [4, 1]),\n *  q1 = board.create('point', [-2, -3]),\n *  q2 = board.create('point', [4,3]),\n *\n *  li1 = board.create('line', [p1,p2], {strokeColor:'black', lastArrow:true}),\n *  li2 = board.create('line', [q1,q2], {lastArrow:true}),\n *\n *  a1 = board.create('angle', [li1, li2, [5.5, 0], [4, 3]], { radius:1 }),\n *  a2 = board.create('angle', [li1, li2, 1, -1], { radius:2 });\n *\n *\n * </pre><div class=\"jxgbox\" id=\"JXG3a667ddd-63dc-4594-b5f1-afac969b371f\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG3a667ddd-63dc-4594-b5f1-afac969b371f', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *     p1 = board.create('point', [-1, 4]),\n *     p2 = board.create('point', [4, 1]),\n *     q1 = board.create('point', [-2, -3]),\n *     q2 = board.create('point', [4,3]),\n *\n *     li1 = board.create('line', [p1,p2], {strokeColor:'black', lastArrow:true}),\n *     li2 = board.create('line', [q1,q2], {lastArrow:true}),\n *\n *     a1 = board.create('angle', [li1, li2, [5.5, 0], [4, 3]], { radius:1 }),\n *     a2 = board.create('angle', [li1, li2, 1, -1], { radius:2 });\n * })();\n * </script><pre>\n *\n *\n * @example\n * // Display the angle value instead of the name\n * var p1 = board.create('point', [0,2]);\n * var p2 = board.create('point', [0,0]);\n * var p3 = board.create('point', [-2,0.2]);\n *\n * var a = board.create('angle', [p1, p2, p3], {\n * \t radius: 1,\n *   name: function() {\n *   \treturn JXG.Math.Geometry.trueAngle(p1, p2, p3).toFixed(1) + '°';\n *   }});\n *\n * </pre><div id=\"JXGc813f601-8dd3-4030-9892-25c6d8671512\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGc813f601-8dd3-4030-9892-25c6d8671512',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *\n *     var p1 = board.create('point', [0,2]);\n *     var p2 = board.create('point', [0,0]);\n *     var p3 = board.create('point', [-2,0.2]);\n *\n *     var a = board.create('angle', [p1, p2, p3], {\n *     \tradius: 1,\n *       name: function() {\n *       \treturn JXG.Math.Geometry.trueAngle(p1, p2, p3).toFixed(1) + '°';\n *       }});\n *\n *     })();\n *\n * </script><pre>\n *\n *\n * @example\n * // Apply a transformation to an angle.\n * var t = board.create('transform', [2, 1.5], {type: 'scale'});\n * var an1 = board.create('angle', [[-4,3.9], [-3, 4], [-3, 3]]);\n * var an2 = board.create('curve', [an1, t]);\n *\n * </pre><div id=\"JXG4c8d9ed8-6339-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG4c8d9ed8-6339-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var t = board.create('transform', [2, 1.5], {type: 'scale'});\n *     var an1 = board.create('angle', [[-4,3.9], [-3, 4], [-3, 3]]);\n *     var an2 = board.create('curve', [an1, t]);\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createAngle = function (board, parents, attributes) {\n    var el,\n        radius,\n        attr,\n        attrsub,\n        i,\n        points,\n        type = \"invalid\";\n\n    // Two lines or three points?\n    if (\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE &&\n        parents[1].elementClass === Const.OBJECT_CLASS_LINE &&\n        (Type.isArray(parents[2]) || Type.isNumber(parents[2])) &&\n        (Type.isArray(parents[3]) || Type.isNumber(parents[3]))\n    ) {\n        type = \"2lines\";\n    } else {\n        points = Type.providePoints(board, parents, attributes, \"point\");\n        if (points === false) {\n            throw new Error(\n                \"JSXGraph: Can't create angle with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"' and '\" +\n                    typeof parents[2] +\n                    \"'.\"\n            );\n        }\n        type = \"3points\";\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"angle\");\n\n    //  If empty, create a new name\n    if (!Type.exists(attr.name) || attr.name === \"\") {\n        attr.name = board.generateName({ type: Const.OBJECT_TYPE_ANGLE });\n    }\n\n    if (Type.exists(attr.radius)) {\n        radius = attr.radius;\n    } else {\n        radius = 0;\n    }\n\n    if (type === \"2lines\") {\n        parents.push(radius);\n        el = board.create(\"sector\", parents, attr);\n        el.updateDataArraySector = el.updateDataArray;\n\n        // TODO\n        el.setAngle = function (val) {};\n        el.free = function (val) {};\n    } else {\n        el = board.create(\"sector\", [points[1], points[0], points[2]], attr);\n        el.arc.visProp.priv = true;\n\n        /**\n         * The point defining the radius of the angle element.\n         * Alias for {@link Sector#radiuspoint}.\n         * @type JXG.Point\n         * @name point\n         * @memberOf Angle.prototype\n         *\n         */\n        el.point = el.point2 = el.radiuspoint = points[0];\n\n        /**\n         * Helper point for angles of type 'square'.\n         * @type JXG.Point\n         * @name pointsquare\n         * @memberOf Angle.prototype\n         */\n        el.pointsquare = el.point3 = el.anglepoint = points[2];\n\n        /**\n         * @ignore\n         */\n        el.Radius = function () {\n            // Set the angle radius, also @see @link Sector#autoRadius\n            var r = Type.evaluate(radius);\n            if (r === \"auto\") {\n                return el.autoRadius();\n            }\n            return r;\n        };\n\n        el.updateDataArraySector = function () {\n            var A = this.point2,\n                B = this.point1,\n                C = this.point3,\n                r = this.Radius(),\n                d = B.Dist(A),\n                ar,\n                phi,\n                sgn = 1,\n                vp_s = Type.evaluate(this.visProp.selection);\n\n            phi = Geometry.rad(A, B, C);\n            if ((vp_s === \"minor\" && phi > Math.PI) || (vp_s === \"major\" && phi < Math.PI)) {\n                sgn = -1;\n            }\n\n            A = A.coords.usrCoords;\n            B = B.coords.usrCoords;\n            C = C.coords.usrCoords;\n\n            A = [1, B[1] + ((A[1] - B[1]) * r) / d, B[2] + ((A[2] - B[2]) * r) / d];\n            C = [1, B[1] + ((C[1] - B[1]) * r) / d, B[2] + ((C[2] - B[2]) * r) / d];\n\n            ar = Geometry.bezierArc(A, B, C, true, sgn);\n\n            this.dataX = ar[0];\n            this.dataY = ar[1];\n            this.bezierDegree = 3;\n        };\n\n        /**\n         * Set an angle to a prescribed value given in radians.\n         * This is only possible if the third point of the angle, i.e.\n         * the anglepoint is a free point.\n         * Removing the constraint again is done by calling \"angle.free()\".\n         *\n         * Changing the angle requires to call the method \"free()\":\n         *\n         * <pre>\n         * angle.setAngle(Math.PI / 6);\n         * // ...\n         * angle.free().setAngle(Math.PI / 4);\n         * </pre>\n         *\n         * @name setAngle\n         * @function\n         * @param {Number|Function} val Number or Function which returns the size of the angle in Radians\n         * @returns {Object} Pointer to the angle element..\n         * @memberOf Angle.prototype\n         * @see Angle#free\n         *\n         * @example\n         * var p1, p2, p3, c, a, s;\n         *\n         * p1 = board.create('point',[0,0]);\n         * p2 = board.create('point',[5,0]);\n         * p3 = board.create('point',[0,5]);\n         *\n         * c1 = board.create('circle',[p1, p2]);\n         *\n         * a = board.create('angle',[p2, p1, p3], {radius:3});\n         *\n         * a.setAngle(function() {\n         *     return Math.PI / 3;\n         * });\n         * board.update();\n         *\n         * </pre><div id=\"JXG987c-394f-11e6-af4a-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG987c-394f-11e6-af4a-901b0e1b8723',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     var p1, p2, p3, c, a, s;\n         *\n         *     p1 = board.create('point',[0,0]);\n         *     p2 = board.create('point',[5,0]);\n         *     p3 = board.create('point',[0,5]);\n         *\n         *     c1 = board.create('circle',[p1, p2]);\n         *\n         *     a = board.create('angle',[p2, p1, p3], {radius: 3});\n         *\n         *     a.setAngle(function() {\n         *         return Math.PI / 3;\n         *     });\n         *     board.update();\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         * @example\n         * var p1, p2, p3, c, a, s;\n         *\n         * p1 = board.create('point',[0,0]);\n         * p2 = board.create('point',[5,0]);\n         * p3 = board.create('point',[0,5]);\n         *\n         * c1 = board.create('circle',[p1, p2]);\n         *\n         * a = board.create('angle',[p2, p1, p3], {radius:3});\n         * s = board.create('slider',[[-2,1], [2,1], [0, Math.PI*0.5, 2*Math.PI]]);\n         *\n         * a.setAngle(function() {\n         *     return s.Value();\n         * });\n         * board.update();\n         *\n         * </pre><div id=\"JXG99957b1c-394f-11e6-af4a-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG99957b1c-394f-11e6-af4a-901b0e1b8723',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     var p1, p2, p3, c, a, s;\n         *\n         *     p1 = board.create('point',[0,0]);\n         *     p2 = board.create('point',[5,0]);\n         *     p3 = board.create('point',[0,5]);\n         *\n         *     c1 = board.create('circle',[p1, p2]);\n         *\n         *     a = board.create('angle',[p2, p1, p3], {radius: 3});\n         *     s = board.create('slider',[[-2,1], [2,1], [0, Math.PI*0.5, 2*Math.PI]]);\n         *\n         *     a.setAngle(function() {\n         *         return s.Value();\n         *     });\n         *     board.update();\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        el.setAngle = function (val) {\n            var t1,\n                t2,\n                val2,\n                p = this.anglepoint,\n                q = this.radiuspoint;\n\n            if (p.draggable()) {\n                t1 = this.board.create(\"transform\", [val, this.center], {\n                    type: \"rotate\"\n                });\n                p.addTransform(q, t1);\n                // Immediately apply the transformation.\n                // This prevents that jumping elements can be watched.\n                t1.update();\n                p.moveTo(Mat.matVecMult(t1.matrix, q.coords.usrCoords));\n\n                if (Type.isFunction(val)) {\n                    /**\n                     * @ignore\n                     */\n                    val2 = function () {\n                        return Math.PI * 2 - val();\n                    };\n                } else {\n                    /**\n                     * @ignore\n                     */\n                    val2 = function () {\n                        return Math.PI * 2 - val;\n                    };\n                }\n                t2 = this.board.create(\"transform\", [val2, this.center], {\n                    type: \"rotate\"\n                });\n                p.coords.on(\"update\", function () {\n                    t2.update();\n                    q.moveTo(Mat.matVecMult(t2.matrix, p.coords.usrCoords));\n                });\n\n                p.setParents(q);\n            }\n            return this;\n        };\n\n        /**\n         * Frees an angle from a prescribed value. This is only relevant if the angle size has been set by\n         * \"setAngle()\" previously. The anglepoint is set to a free point.\n         * @name free\n         * @function\n         * @returns {Object} Pointer to the angle element..\n         * @memberOf Angle.prototype\n         * @see Angle#setAngle\n         */\n        el.free = function () {\n            var p = this.anglepoint;\n\n            if (p.transformations.length > 0) {\n                p.transformations.pop();\n                p.isDraggable = true;\n                p.parents = [];\n\n                p.coords.off(\"update\");\n            }\n\n            return this;\n        };\n\n        el.setParents(points); // Important: This overwrites the parents order in underlying sector\n    } // end '3points'\n\n    // GEONExT compatible labels.\n    if (Type.exists(el.visProp.text)) {\n        el.label.setText(Type.evaluate(el.visProp.text));\n    }\n\n    el.elType = \"angle\";\n    el.type = Const.OBJECT_TYPE_ANGLE;\n    el.subs = {};\n\n    el.updateDataArraySquare = function () {\n        var A,\n            B,\n            C,\n            r = this.Radius(),\n            d1,\n            d2,\n            v,\n            l1,\n            l2;\n\n        if (type === \"2lines\") {\n            // This is necessary to update this.point1, this.point2, this.point3.\n            this.updateDataArraySector();\n        }\n\n        A = this.point2;\n        B = this.point1;\n        C = this.point3;\n\n        A = A.coords.usrCoords;\n        B = B.coords.usrCoords;\n        C = C.coords.usrCoords;\n\n        d1 = Geometry.distance(A, B, 3);\n        d2 = Geometry.distance(C, B, 3);\n\n        // In case of type=='2lines' this is redundant, because r == d1 == d2\n        A = [1, B[1] + ((A[1] - B[1]) * r) / d1, B[2] + ((A[2] - B[2]) * r) / d1];\n        C = [1, B[1] + ((C[1] - B[1]) * r) / d2, B[2] + ((C[2] - B[2]) * r) / d2];\n\n        v = Mat.crossProduct(C, B);\n        l1 = [-A[1] * v[1] - A[2] * v[2], A[0] * v[1], A[0] * v[2]];\n        v = Mat.crossProduct(A, B);\n        l2 = [-C[1] * v[1] - C[2] * v[2], C[0] * v[1], C[0] * v[2]];\n\n        v = Mat.crossProduct(l1, l2);\n        v[1] /= v[0];\n        v[2] /= v[0];\n\n        this.dataX = [B[1], A[1], v[1], C[1], B[1]];\n        this.dataY = [B[2], A[2], v[2], C[2], B[2]];\n\n        this.bezierDegree = 1;\n    };\n\n    el.updateDataArrayNone = function () {\n        this.dataX = [NaN];\n        this.dataY = [NaN];\n        this.bezierDegree = 1;\n    };\n\n    el.updateDataArray = function () {\n        var type = Type.evaluate(this.visProp.type),\n            deg = Geometry.trueAngle(this.point2, this.point1, this.point3),\n            vp_s = Type.evaluate(this.visProp.selection);\n\n        if ((vp_s === \"minor\" && deg > 180.0) || (vp_s === \"major\" && deg < 180.0)) {\n            deg = 360.0 - deg;\n        }\n\n        if (Math.abs(deg - 90.0) < Type.evaluate(this.visProp.orthosensitivity) + Mat.eps) {\n            type = Type.evaluate(this.visProp.orthotype);\n        }\n\n        if (type === \"none\") {\n            this.updateDataArrayNone();\n        } else if (type === \"square\") {\n            this.updateDataArraySquare();\n        } else if (type === \"sector\") {\n            this.updateDataArraySector();\n        } else if (type === \"sectordot\") {\n            this.updateDataArraySector();\n            if (!this.dot.visProp.visible) {\n                this.dot.setAttribute({ visible: true });\n            }\n        }\n\n        if (!this.visProp.visible || (type !== \"sectordot\" && this.dot.visProp.visible)) {\n            this.dot.setAttribute({ visible: false });\n        }\n    };\n\n    /**\n     * Indicates a right angle. Invisible by default, use <tt>dot.visible: true</tt> to show.\n     * Though this dot indicates a right angle, it can be visible even if the angle is not a right\n     * one.\n     * @type JXG.Point\n     * @name dot\n     * @memberOf Angle.prototype\n     */\n    attrsub = Type.copyAttributes(attributes, board.options, \"angle\", \"dot\");\n    el.dot = board.create(\n        \"point\",\n        [\n            function () {\n                var A, B, r, d, a2, co, si, mat, vp_s;\n\n                if (Type.exists(el.dot) && !el.dot.visProp.visible) {\n                    return [0, 0];\n                }\n\n                A = el.point2.coords.usrCoords;\n                B = el.point1.coords.usrCoords;\n                r = el.Radius();\n                d = Geometry.distance(A, B, 3);\n                a2 = Geometry.rad(el.point2, el.point1, el.point3);\n\n                vp_s = Type.evaluate(el.visProp.selection);\n                if ((vp_s === \"minor\" && a2 > Math.PI) || (vp_s === \"major\" && a2 < Math.PI)) {\n                    a2 = -(2 * Math.PI - a2);\n                }\n                a2 *= 0.5;\n\n                co = Math.cos(a2);\n                si = Math.sin(a2);\n\n                A = [1, B[1] + ((A[1] - B[1]) * r) / d, B[2] + ((A[2] - B[2]) * r) / d];\n\n                mat = [\n                    [1, 0, 0],\n                    [B[1] - 0.5 * B[1] * co + 0.5 * B[2] * si, co * 0.5, -si * 0.5],\n                    [B[2] - 0.5 * B[1] * si - 0.5 * B[2] * co, si * 0.5, co * 0.5]\n                ];\n                return Mat.matVecMult(mat, A);\n            }\n        ],\n        attrsub\n    );\n\n    el.dot.dump = false;\n    el.subs.dot = el.dot;\n\n    if (type === \"2lines\") {\n        for (i = 0; i < 2; i++) {\n            board.select(parents[i]).addChild(el.dot);\n        }\n    } else {\n        for (i = 0; i < 3; i++) {\n            board.select(points[i]).addChild(el.dot);\n        }\n    }\n\n    // documented in GeometryElement\n    el.getLabelAnchor = function () {\n        var vec,\n            dx = 12,\n            A,\n            B,\n            r,\n            d,\n            a2,\n            co,\n            si,\n            mat,\n            vp_s = Type.evaluate(el.visProp.selection),\n            l_vp = this.label ? this.label.visProp : this.visProp.label;\n\n        // If this is uncommented, the angle label can not be dragged\n        //if (Type.exists(this.label)) {\n        //    this.label.relativeCoords = new Coords(Const.COORDS_BY_SCREEN, [0, 0], this.board);\n        //}\n\n        if (Type.exists(this.label.visProp.fontSize)) {\n            dx = Type.evaluate(this.label.visProp.fontSize);\n        }\n        dx /= this.board.unitX;\n\n        A = el.point2.coords.usrCoords;\n        B = el.point1.coords.usrCoords;\n        r = el.Radius();\n        d = Geometry.distance(A, B, 3);\n        a2 = Geometry.rad(el.point2, el.point1, el.point3);\n        if ((vp_s === \"minor\" && a2 > Math.PI) || (vp_s === \"major\" && a2 < Math.PI)) {\n            a2 = -(2 * Math.PI - a2);\n        }\n        a2 *= 0.5;\n        co = Math.cos(a2);\n        si = Math.sin(a2);\n\n        A = [1, B[1] + ((A[1] - B[1]) * r) / d, B[2] + ((A[2] - B[2]) * r) / d];\n\n        mat = [\n            [1, 0, 0],\n            [B[1] - 0.5 * B[1] * co + 0.5 * B[2] * si, co * 0.5, -si * 0.5],\n            [B[2] - 0.5 * B[1] * si - 0.5 * B[2] * co, si * 0.5, co * 0.5]\n        ];\n        vec = Mat.matVecMult(mat, A);\n        vec[1] /= vec[0];\n        vec[2] /= vec[0];\n        vec[0] /= vec[0];\n\n        d = Geometry.distance(vec, B, 3);\n        vec = [\n            vec[0],\n            B[1] + ((vec[1] - B[1]) * (r + dx)) / d,\n            B[2] + ((vec[2] - B[2]) * (r + dx)) / d\n        ];\n\n        l_vp.position = Geometry.calcLabelQuadrant(Geometry.rad([1, 0], [0, 0], vec));\n\n        return new Coords(Const.COORDS_BY_USER, vec, this.board);\n    };\n\n    /**\n     * Returns the value of the angle in Radians.\n     * @memberOf Angle.prototype\n     * @name Value\n     * @function\n     * @returns {Number} The angle value in Radians\n     */\n    el.Value = function () {\n        return Geometry.rad(this.point2, this.point1, this.point3);\n    };\n\n    el.methodMap = Type.deepCopy(el.methodMap, {\n        Value: \"Value\",\n        setAngle: \"setAngle\",\n        free: \"free\"\n    });\n\n    return el;\n};\n\nJXG.registerElement(\"angle\", JXG.createAngle);\n\n/**\n * @class A non-reflex angle is the acute or obtuse instance of an angle.\n * It is defined by a center, one point that\n * defines the radius, and a third point that defines the angle of the sector.\n * @pseudo\n * @name NonReflexAngle\n * @augments Angle\n * @constructor\n * @type Sector\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 . Minor sector is a sector of a circle around p1 having measure less than or equal to\n * 180 degrees (pi radians) and starts at p2. The radius is determined by p2, the angle by p3.\n * @example\n * // Create a non-reflex angle out of three free points\n * var p1 = board.create('point', [5.0, 3.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [1.5, 5.0]),\n *\n *     a = board.create('nonreflexangle', [p1, p2, p3], {radius: 2}),\n *     t = board.create('text', [4, 4, function() { return JXG.toFixed(a.Value(), 2); }]);\n * </pre><div class=\"jxgbox\" id=\"JXGd0ab6d6b-63a7-48b2-8749-b02bb5e744f9\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXGd0ab6d6b-63a7-48b2-8749-b02bb5e744f9', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *     p1 = board.create('point', [5.0, 3.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [1.5, 5.0]),\n *\n *     a = board.create('nonreflexangle', [p1, p2, p3], {radius: 2}),\n *     t = board.create('text', [4, 4, function() { return JXG.toFixed(a.Value(), 2); }]);\n * })();\n * </script><pre>\n */\nJXG.createNonreflexAngle = function (board, parents, attributes) {\n    var el;\n\n    attributes.selection = \"minor\";\n    el = JXG.createAngle(board, parents, attributes);\n\n    // Documented in createAngle\n    el.Value = function () {\n        var v = Geometry.rad(this.point2, this.point1, this.point3);\n        return v < Math.PI ? v : 2.0 * Math.PI - v;\n    };\n    return el;\n};\n\nJXG.registerElement(\"nonreflexangle\", JXG.createNonreflexAngle);\n\n/**\n * @class A reflex angle is the neither acute nor obtuse instance of an angle.\n * It is defined by a center, one point that\n * defines the radius, and a third point that defines the angle of the sector.\n * @pseudo\n * @name ReflexAngle\n * @augments Angle\n * @constructor\n * @type Sector\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 . Minor sector is a sector of a circle around p1 having measure less than or equal to\n * 180 degrees (pi radians) and starts at p2. The radius is determined by p2, the angle by p3.\n * @example\n * // Create a non-reflex angle out of three free points\n * var p1 = board.create('point', [5.0, 3.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [1.5, 5.0]),\n *\n *     a = board.create('reflexangle', [p1, p2, p3], {radius: 2}),\n *     t = board.create('text', [4, 4, function() { return JXG.toFixed(a.Value(), 2); }]);\n * </pre><div class=\"jxgbox\" id=\"JXGf2a577f2-553d-4f9f-a895-2d6d4b8c60e8\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n * var board = JXG.JSXGraph.initBoard('JXGf2a577f2-553d-4f9f-a895-2d6d4b8c60e8', {boundingbox: [-1, 7, 7, -1], axis: true, showcopyright: false, shownavigation: false}),\n *     p1 = board.create('point', [5.0, 3.0]),\n *     p2 = board.create('point', [1.0, 0.5]),\n *     p3 = board.create('point', [1.5, 5.0]),\n *\n *     a = board.create('reflexangle', [p1, p2, p3], {radius: 2}),\n *     t = board.create('text', [4, 4, function() { return JXG.toFixed(a.Value(), 2); }]);\n * })();\n * </script><pre>\n */\nJXG.createReflexAngle = function (board, parents, attributes) {\n    var el;\n\n    attributes.selection = \"major\";\n    el = JXG.createAngle(board, parents, attributes);\n\n    // Documented in createAngle\n    el.Value = function () {\n        var v = Geometry.rad(this.point2, this.point1, this.point3);\n        return v >= Math.PI ? v : 2.0 * Math.PI - v;\n    };\n    return el;\n};\n\nJXG.registerElement(\"reflexangle\", JXG.createReflexAngle);\n\nexport default {\n    createSector: JXG.createSector,\n    createCircumcircleSector: JXG.createCircumcircleSector,\n    createMinorSector: JXG.createMinorSector,\n    createMajorSector: JXG.createMajorSector,\n    createAngle: JXG.createAngle,\n    createReflexAngle: JXG.createReflexAngle,\n    createNonreflexAngle: JXG.createNonreflexAngle\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains code for transformations of geometrical objects.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport Mat from \"../math/math\";\nimport Type from \"../utils/type\";\n\n/**\n * A transformation consists of a 3x3 matrix, i.e. it is a projective transformation.\n * @class Creates a new transformation object. Do not use this constructor to create a transformation.\n * Use {@link JXG.Board#create} with\n * type {@link Transformation} instead.\n * @constructor\n * @param {JXG.Board} board The board the new circle is drawn on.\n * @param {String} type Can be\n * <ul><li> 'translate'\n * <li> 'scale'\n * <li> 'reflect'\n * <li> 'rotate'\n * <li> 'shear'\n * <li> 'generic'\n * </ul>\n * @param {Object} params The parameters depend on the transformation type\n *\n * <p>\n * Translation matrix:\n * <pre>\n * ( 1  0  0)   ( z )\n * ( a  1  0) * ( x )\n * ( b  0  1)   ( y )\n * </pre>\n *\n * <p>\n * Scale matrix:\n * <pre>\n * ( 1  0  0)   ( z )\n * ( 0  a  0) * ( x )\n * ( 0  0  b)   ( y )\n * </pre>\n *\n * <p>\n * A rotation matrix with angle a (in Radians)\n * <pre>\n * ( 1    0        0      )   ( z )\n * ( 0    cos(a)   -sin(a)) * ( x )\n * ( 0    sin(a)   cos(a) )   ( y )\n * </pre>\n *\n * <p>\n * Shear matrix:\n * <pre>\n * ( 1  0  0)   ( z )\n * ( 0  1  a) * ( x )\n * ( 0  b  1)   ( y )\n * </pre>\n *\n * <p>Generic transformation:\n * <pre>\n * ( a  b  c )   ( z )\n * ( d  e  f ) * ( x )\n * ( g  h  i )   ( y )\n * </pre>\n *\n */\nJXG.Transformation = function (board, type, params) {\n    this.elementClass = Const.OBJECT_CLASS_OTHER;\n    this.type = Const.OBJECT_TYPE_TRANSFORMATION;\n    this.matrix = [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ];\n    this.board = board;\n    this.isNumericMatrix = false;\n    this.setMatrix(board, type, params);\n\n    this.methodMap = {\n        apply: \"apply\",\n        applyOnce: \"applyOnce\",\n        bindTo: \"bindTo\",\n        bind: \"bindTo\",\n        melt: \"melt\"\n    };\n};\n\nJXG.Transformation.prototype = {};\n\nJXG.extend(\n    JXG.Transformation.prototype,\n    /** @lends JXG.Transformation.prototype */ {\n        /**\n         * Updates the numerical data for the transformation, i.e. the entry of the subobject matrix.\n         * @returns {JXG.Transform} returns pointer to itself\n         */\n        update: function () {\n            return this;\n        },\n\n        /**\n         * Set the transformation matrix for different types of standard transforms.\n         * @param {JXG.Board} board\n         * @param {String} type   Transformation type, possible values are\n         *                        'translate', 'scale', 'reflect', 'rotate',\n         *                        'shear', 'generic'.\n         * @param {Array} params Parameters for the various transformation types.\n         *\n         * <p>These are\n         * @param {Array} x,y Shift vector (number or function) in case of 'translate'.\n         * @param {Array} scale_x,scale_y Scale vector (number or function) in case of 'scale'.\n         * @param {Array} line|point_pair|\"four coordinates\" In case of 'reflect' the parameters could\n         *                be a line, a pair of points or four number (or functions) p_x, p_y, q_x, q_y,\n         *                determining a line through points (p_x, p_y) and (q_x, q_y).\n         * @param {Array} angle,x,y|angle,[x,y] In case of 'rotate' the parameters are an angle or angle function,\n         *                returning the angle in Radians and - optionally - a coordinate pair or a point defining the\n         *                rotation center. If the rotation center is not given, the transformation rotates around (0,0).\n         * @param {Array} shear_x,shear_y Shear vector (number or function) in case of 'shear'.\n         * @param {Array} a,b,c,d,e,f,g,h,i Nine matrix entries (numbers or functions) for a generic\n         *                projective transformation  in case of 'generic'.\n         *\n         * <p>A transformation with a generic matrix looks like:\n         * <pre>\n         * ( a  b  c )   ( z )\n         * ( d  e  f ) * ( x )\n         * ( g  h  i )   ( y )\n         * </pre>\n         *\n         */\n        setMatrix: function (board, type, params) {\n            var i;\n\n            this.isNumericMatrix = true;\n\n            for (i = 0; i < params.length; i++) {\n                if (typeof params[i] !== \"number\") {\n                    this.isNumericMatrix = false;\n                    break;\n                }\n            }\n\n            if (type === \"translate\") {\n                if (params.length !== 2) {\n                    throw new Error(\"JSXGraph: translate transformation needs 2 parameters.\");\n                }\n                this.evalParam = Type.createEvalFunction(board, params, 2);\n                this.update = function () {\n                    this.matrix[1][0] = this.evalParam(0);\n                    this.matrix[2][0] = this.evalParam(1);\n                };\n            } else if (type === \"scale\") {\n                if (params.length !== 2) {\n                    throw new Error(\"JSXGraph: scale transformation needs 2 parameters.\");\n                }\n                this.evalParam = Type.createEvalFunction(board, params, 2);\n                this.update = function () {\n                    this.matrix[1][1] = this.evalParam(0); // x\n                    this.matrix[2][2] = this.evalParam(1); // y\n                };\n                // Input: line or two points\n            } else if (type === \"reflect\") {\n                // line or two points\n                if (params.length < 4) {\n                    params[0] = board.select(params[0]);\n                }\n\n                // two points\n                if (params.length === 2) {\n                    params[1] = board.select(params[1]);\n                }\n\n                // 4 coordinates [px,py,qx,qy]\n                if (params.length === 4) {\n                    this.evalParam = Type.createEvalFunction(board, params, 4);\n                }\n\n                this.update = function () {\n                    var x, y, z, xoff, yoff, d, v, p;\n                    // Determine homogeneous coordinates of reflections axis\n                    // line\n                    if (params.length === 1) {\n                        v = params[0].stdform;\n                        // two points\n                    } else if (params.length === 2) {\n                        v = Mat.crossProduct(\n                            params[1].coords.usrCoords,\n                            params[0].coords.usrCoords\n                        );\n                        // two points coordinates [px,py,qx,qy]\n                    } else if (params.length === 4) {\n                        v = Mat.crossProduct(\n                            [1, this.evalParam(2), this.evalParam(3)],\n                            [1, this.evalParam(0), this.evalParam(1)]\n                        );\n                    }\n\n                    // Project origin to the line.  This gives a finite point p\n                    x = v[1];\n                    y = v[2];\n                    z = v[0];\n                    p = [-z * x, -z * y, x * x + y * y];\n                    d = p[2];\n\n                    // Normalize p\n                    xoff = p[0] / p[2];\n                    yoff = p[1] / p[2];\n\n                    // x, y is the direction of the line\n                    x = -v[2];\n                    y = v[1];\n\n                    this.matrix[1][1] = (x * x - y * y) / d;\n                    this.matrix[1][2] = (2 * x * y) / d;\n                    this.matrix[2][1] = this.matrix[1][2];\n                    this.matrix[2][2] = -this.matrix[1][1];\n                    this.matrix[1][0] =\n                        xoff * (1 - this.matrix[1][1]) - yoff * this.matrix[1][2];\n                    this.matrix[2][0] =\n                        yoff * (1 - this.matrix[2][2]) - xoff * this.matrix[2][1];\n                };\n            } else if (type === \"rotate\") {\n                // angle, x, y\n                if (params.length === 3) {\n                    this.evalParam = Type.createEvalFunction(board, params, 3);\n                    // angle, p or angle\n                } else if (params.length > 0 && params.length <= 2) {\n                    this.evalParam = Type.createEvalFunction(board, params, 1);\n\n                    if (params.length === 2 && !Type.isArray(params[1])) {\n                        params[1] = board.select(params[1]);\n                    }\n                }\n\n                this.update = function () {\n                    var x,\n                        y,\n                        beta = this.evalParam(0),\n                        co = Math.cos(beta),\n                        si = Math.sin(beta);\n\n                    this.matrix[1][1] = co;\n                    this.matrix[1][2] = -si;\n                    this.matrix[2][1] = si;\n                    this.matrix[2][2] = co;\n\n                    // rotate around [x,y] otherwise rotate around [0,0]\n                    if (params.length > 1) {\n                        if (params.length === 3) {\n                            x = this.evalParam(1);\n                            y = this.evalParam(2);\n                        } else {\n                            if (Type.isArray(params[1])) {\n                                x = params[1][0];\n                                y = params[1][1];\n                            } else {\n                                x = params[1].X();\n                                y = params[1].Y();\n                            }\n                        }\n                        this.matrix[1][0] = x * (1 - co) + y * si;\n                        this.matrix[2][0] = y * (1 - co) - x * si;\n                    }\n                };\n            } else if (type === \"shear\") {\n                if (params.length !== 2) {\n                    throw new Error(\"JSXGraph: shear transformation needs 2 parameters.\");\n                }\n\n                this.evalParam = Type.createEvalFunction(board, params, 2);\n                this.update = function () {\n                    this.matrix[1][2] = this.evalParam(0);\n                    this.matrix[2][1] = this.evalParam(1);\n                };\n            } else if (type === \"generic\") {\n                if (params.length !== 9) {\n                    throw new Error(\"JSXGraph: generic transformation needs 9 parameters.\");\n                }\n\n                this.evalParam = Type.createEvalFunction(board, params, 9);\n\n                this.update = function () {\n                    this.matrix[0][0] = this.evalParam(0);\n                    this.matrix[0][1] = this.evalParam(1);\n                    this.matrix[0][2] = this.evalParam(2);\n                    this.matrix[1][0] = this.evalParam(3);\n                    this.matrix[1][1] = this.evalParam(4);\n                    this.matrix[1][2] = this.evalParam(5);\n                    this.matrix[2][0] = this.evalParam(6);\n                    this.matrix[2][1] = this.evalParam(7);\n                    this.matrix[2][2] = this.evalParam(8);\n                };\n            }\n        },\n\n        /**\n         * Transform a GeometryElement:\n         * First, the transformation matrix is updated, then do the matrix-vector-multiplication.\n         * @private\n         * @param {JXG.GeometryElement} p element which is transformed\n         * @param {String} 'self' Apply the transformation to the initialCoords instead of the coords if this is set.\n         * @returns {Array}\n         */\n        apply: function (p, self) {\n            this.update();\n\n            if (Type.exists(self)) {\n                return Mat.matVecMult(this.matrix, p.initialCoords.usrCoords);\n            }\n            return Mat.matVecMult(this.matrix, p.coords.usrCoords);\n        },\n\n        /**\n         * Applies a transformation once to a GeometryElement or an array of elements.\n         * If it is a free point, then it can be dragged around later\n         * and will overwrite the transformed coordinates.\n         * @param {JXG.Point,Array} p\n         */\n        applyOnce: function (p) {\n            var c, len, i;\n\n            if (!Type.isArray(p)) {\n                p = [p];\n            }\n\n            len = p.length;\n\n            for (i = 0; i < len; i++) {\n                this.update();\n                c = Mat.matVecMult(this.matrix, p[i].coords.usrCoords);\n                p[i].coords.setCoordinates(Const.COORDS_BY_USER, c);\n            }\n        },\n\n        /**\n         * Binds a transformation to a GeometryElement or an array of elements. In every update of the\n         * GeometryElement(s), the transformation is executed. That means, in order to immediately\n         * apply the transformation, a call of board.update() has to follow.\n         * @param  {Array,JXG.Object} p JXG.Object or array of JXG.Object to\n         *                            which the transformation is bound to.\n         */\n        bindTo: function (p) {\n            var i, len;\n            if (Type.isArray(p)) {\n                len = p.length;\n\n                for (i = 0; i < len; i++) {\n                    p[i].transformations.push(this);\n                }\n            } else {\n                p.transformations.push(this);\n            }\n        },\n\n        /**\n         * Unused\n         * @deprecated Use setAttribute\n         * @param term\n         */\n        setProperty: function (term) {\n            JXG.deprecated(\"Transformation.setProperty()\", \"Transformation.setAttribute()\");\n        },\n\n        /**\n         * Empty method. Unused.\n         * @param {Object} term Key-value pairs of the attributes.\n         */\n        setAttribute: function (term) {},\n\n        /**\n         * Combine two transformations to one transformation. This only works if\n         * both of transformation matrices consist solely of numbers, and do not\n         * contain functions.\n         *\n         * Multiplies the transformation with a transformation t from the left.\n         * i.e. (this) = (t) join (this)\n         * @param  {JXG.Transform} t Transformation which is the left multiplicand\n         * @returns {JXG.Transform} the transformation object.\n         */\n        melt: function (t) {\n            var res = [],\n                i,\n                len,\n                len0,\n                k,\n                s,\n                j;\n\n            len = t.matrix.length;\n            len0 = this.matrix[0].length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = [];\n            }\n\n            this.update();\n            t.update();\n\n            for (i = 0; i < len; i++) {\n                for (j = 0; j < len0; j++) {\n                    s = 0;\n                    for (k = 0; k < len; k++) {\n                        s += t.matrix[i][k] * this.matrix[k][j];\n                    }\n                    res[i][j] = s;\n                }\n            }\n\n            this.update = function () {\n                var len = this.matrix.length,\n                    len0 = this.matrix[0].length;\n\n                for (i = 0; i < len; i++) {\n                    for (j = 0; j < len0; j++) {\n                        this.matrix[i][j] = res[i][j];\n                    }\n                }\n            };\n            return this;\n        },\n\n        // documented in element.js\n        // Not yet, since transformations are not listed in board.objects.\n        getParents: function () {\n            var p = [[].concat.apply([], this.matrix)];\n\n            if (this.parents.length !== 0) {\n                p = this.parents;\n            }\n\n            return p;\n        }\n    }\n);\n\n/**\n * @class This element is used to provide projective transformations.\n * @pseudo\n * @description A transformation consists of a 3x3 matrix, i.e. it is a projective transformation.\n * @name Transformation\n * @augments JXG.Transformation\n * @constructor\n * @type JXG.Transformation\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {numbers,functions} parameters The parameters depend on the transformation type, supplied as attribute 'type'.\n * Possible transformation types are\n * <ul><li> 'translate'\n * <li> 'scale'\n * <li> 'reflect'\n * <li> 'rotate'\n * <li> 'shear'\n * <li> 'generic'\n * </ul>\n * The transformation matrix then looks like:\n * <p>\n * Translation matrix:\n * <pre>\n * ( 1  0  0)   ( z )\n * ( a  1  0) * ( x )\n * ( b  0  1)   ( y )\n * </pre>\n *\n * <p>\n * Scale matrix:\n * <pre>\n * ( 1  0  0)   ( z )\n * ( 0  a  0) * ( x )\n * ( 0  0  b)   ( y )\n * </pre>\n *\n * <p>\n * A rotation matrix with angle a (in Radians)\n * <pre>\n * ( 1    0        0      )   ( z )\n * ( 0    cos(a)   -sin(a)) * ( x )\n * ( 0    sin(a)   cos(a) )   ( y )\n * </pre>\n *\n * <p>\n * Shear matrix:\n * <pre>\n * ( 1  0  0)   ( z )\n * ( 0  1  a) * ( x )\n * ( 0  b  1)   ( y )\n * </pre>\n *\n * <p>Generic transformation:\n * <pre>\n * ( a  b  c )   ( z )\n * ( d  e  f ) * ( x )\n * ( g  h  i )   ( y )\n * </pre>\n *\n * @see JXG.Transformation#setMatrix\n *\n * @example\n * // The point B is determined by taking twice the vector A from the origin\n *\n * var p0 = board.create('point', [0, 3], {name: 'A'}),\n *     t = board.create('transform', [function(){ return p0.X(); }, \"Y(A)\"], {type: 'translate'}),\n *     p1 = board.create('point', [p0, t], {color: 'blue'});\n *\n * </pre><div class=\"jxgbox\" id=\"JXG14167b0c-2ad3-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG14167b0c-2ad3-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p0 = board.create('point', [0, 3], {name: 'A'}),\n *         t = board.create('transform', [function(){ return p0.X(); }, \"Y(A)\"], {type:'translate'}),\n *         p1 = board.create('point', [p0, t], {color: 'blue'});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * // The point B is the result of scaling the point A with factor 2 in horizontal direction\n * // and with factor 0.5 in vertical direction.\n *\n * var p1 = board.create('point', [1, 1]),\n *     t = board.create('transform', [2, 0.5], {type: 'scale'}),\n *     p2 = board.create('point', [p1, t], {color: 'blue'});\n *\n * </pre><div class=\"jxgbox\" id=\"JXGa6827a72-2ad3-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGa6827a72-2ad3-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p1 = board.create('point', [1, 1]),\n *         t = board.create('transform', [2, 0.5], {type: 'scale'}),\n *         p2 = board.create('point', [p1, t], {color: 'blue'});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * // The point B is rotated around C which gives point D. The angle is determined\n * // by the vertical height of point A.\n *\n * var p0 = board.create('point', [0, 3], {name: 'A'}),\n *     p1 = board.create('point', [1, 1]),\n *     p2 = board.create('point', [2, 1], {name:'C', fixed: true}),\n *\n *     // angle, rotation center:\n *     t = board.create('transform', ['Y(A)', p2], {type: 'rotate'}),\n *     p3 = board.create('point', [p1, t], {color: 'blue'});\n *\n * </pre><div class=\"jxgbox\" id=\"JXG747cf11e-2ad4-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG747cf11e-2ad4-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p0 = board.create('point', [0, 3], {name: 'A'}),\n *         p1 = board.create('point', [1, 1]),\n *         p2 = board.create('point', [2, 1], {name:'C', fixed: true}),\n *\n *         // angle, rotation center:\n *         t = board.create('transform', ['Y(A)', p2], {type: 'rotate'}),\n *         p3 = board.create('point', [p1, t], {color: 'blue'});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * // A concatenation of several transformations.\n * var p1 = board.create('point', [1, 1]),\n *     t1 = board.create('transform', [-2, -1], {type: 'translate'}),\n *     t2 = board.create('transform', [Math.PI/4], {type: 'rotate'}),\n *     t3 = board.create('transform', [2, 1], {type: 'translate'}),\n *     p2 = board.create('point', [p1, [t1, t2, t3]], {color: 'blue'});\n *\n * </pre><div class=\"jxgbox\" id=\"JXGf516d3de-2ad5-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGf516d3de-2ad5-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p1 = board.create('point', [1, 1]),\n *         t1 = board.create('transform', [-2, -1], {type:'translate'}),\n *         t2 = board.create('transform', [Math.PI/4], {type:'rotate'}),\n *         t3 = board.create('transform', [2, 1], {type:'translate'}),\n *         p2 = board.create('point', [p1, [t1, t2, t3]], {color: 'blue'});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * // Reflection of point A\n * var p1 = board.create('point', [1, 1]),\n *     p2 = board.create('point', [1, 3]),\n *     p3 = board.create('point', [-2, 0]),\n *     l = board.create('line', [p2, p3]),\n *     t = board.create('transform', [l], {type: 'reflect'}),  // Possible are l, l.id, l.name\n *     p4 = board.create('point', [p1, t], {color: 'blue'});\n *\n * </pre><div class=\"jxgbox\" id=\"JXG6f374a04-2ad6-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG6f374a04-2ad6-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p1 = board.create('point', [1, 1]),\n *         p2 = board.create('point', [1, 3]),\n *         p3 = board.create('point', [-2, 0]),\n *         l = board.create('line', [p2, p3]),\n *         t = board.create('transform', [l], {type:'reflect'}),  // Possible are l, l.id, l.name\n *         p4 = board.create('point', [p1, t], {color: 'blue'});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * // One time application of a transform to points A, B\n * var p1 = board.create('point', [1, 1]),\n *     p2 = board.create('point', [1, 1]),\n *     t = board.create('transform', [3, 2], {type: 'shear'});\n * t.applyOnce([p1, p2]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXGb6cee1c4-2ad6-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGb6cee1c4-2ad6-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p1 = board.create('point', [1, 1]),\n *         p2 = board.create('point', [-1, -2]),\n *         t = board.create('transform', [3, 2], {type: 'shear'});\n *     t.applyOnce([p1, p2]);\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * // Construct a square of side length 2 with the\n * // help of transformations\n *     var sq = [],\n *         right = board.create('transform', [2, 0], {type: 'translate'}),\n *         up = board.create('transform', [0, 2], {type: 'translate'}),\n *         pol, rot, p0;\n *\n *     // The first point is free\n *     sq[0] = board.create('point', [0, 0], {name: 'Drag me'}),\n *\n *     // Construct the other free points by transformations\n *     sq[1] = board.create('point', [sq[0], right]),\n *     sq[2] = board.create('point', [sq[0], [right, up]]),\n *     sq[3] = board.create('point', [sq[0], up]),\n *\n *     // Polygon through these four points\n *     pol = board.create('polygon', sq, {\n *             fillColor:'blue',\n *             gradient:'radial',\n *             gradientsecondcolor:'white',\n *             gradientSecondOpacity:'0'\n *     }),\n *\n *     p0 = board.create('point', [0, 3], {name: 'angle'}),\n *     // Rotate the square around point sq[0] by dragging A\n *     rot = board.create('transform', ['Y(angle)', sq[0]], {type: 'rotate'});\n *\n *     // Apply the rotation to all but the first point of the square\n *     rot.bindTo(sq.slice(1));\n *\n * </pre><div class=\"jxgbox\" id=\"JXGc7f9097e-2ad7-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGc7f9097e-2ad7-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     // Construct a square of side length 2 with the\n *     // help of transformations\n *     var sq = [],\n *         right = board.create('transform', [2, 0], {type: 'translate'}),\n *         up = board.create('transform', [0, 2], {type: 'translate'}),\n *         pol, rot, p0;\n *\n *     // The first point is free\n *     sq[0] = board.create('point', [0, 0], {name: 'Drag me'}),\n *\n *     // Construct the other free points by transformations\n *     sq[1] = board.create('point', [sq[0], right]),\n *     sq[2] = board.create('point', [sq[0], [right, up]]),\n *     sq[3] = board.create('point', [sq[0], up]),\n *\n *     // Polygon through these four points\n *     pol = board.create('polygon', sq, {\n *             fillColor:'blue',\n *             gradient:'radial',\n *             gradientsecondcolor:'white',\n *             gradientSecondOpacity:'0'\n *     }),\n *\n *     p0 = board.create('point', [0, 3], {name: 'angle'}),\n *     // Rotate the square around point sq[0] by dragging A\n *     rot = board.create('transform', ['Y(angle)', sq[0]], {type: 'rotate'});\n *\n *     // Apply the rotation to all but the first point of the square\n *     rot.bindTo(sq.slice(1));\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createTransform = function (board, parents, attributes) {\n    return new JXG.Transformation(board, attributes.type, parents);\n};\n\nJXG.registerElement(\"transform\", JXG.createTransform);\n\nexport default {\n    Transformation: JXG.Transformation,\n    createTransform: JXG.createTransform\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains our composition elements, i.e. these elements are mostly put together\n * from one or more {@link JXG.GeometryElement} but with a special meaning. E.g. the midpoint element is contained here\n * and this is just a {@link JXG.Point} with coordinates dependent from two other points. Currently in this file the\n * following compositions can be found: <ul>\n *   <li>{@link Arrowparallel} (currently private)</li>\n *   <li>{@link Bisector}</li>\n *   <li>{@link Msector}</li>\n *   <li>{@link Circumcircle}</li>\n *   <li>{@link Circumcirclemidpoint}</li>\n *   <li>{@link Integral}</li>\n *   <li>{@link Midpoint}</li>\n *   <li>{@link Mirrorpoint}</li>\n *   <li>{@link Normal}</li>\n *   <li>{@link Orthogonalprojection}</li>\n *   <li>{@link Parallel}</li>\n *   <li>{@link Perpendicular}</li>\n *   <li>{@link Perpendicularpoint}</li>\n *   <li>{@link Perpendicularsegment}</li>\n *   <li>{@link Reflection}</li></ul>\n */\n\nimport JXG from \"../jxg\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Numerics from \"../math/numerics\";\nimport Coords from \"../base/coords\";\nimport Type from \"../utils/type\";\nimport Const from \"../base/constants\";\nimport Point from \"../base/point\";\nimport Line from \"../base/line\";\nimport Circle from \"../base/circle\";\nimport Transform from \"../base/transformation\";\nimport Composition from \"../base/composition\";\nimport Curve from \"../base/curve\";\nimport Polygon from \"../base/polygon\";\n\n/**\n * @class This is used to construct a point that is the orthogonal projection of a point to a line.\n * @pseudo\n * @description An orthogonal projection is given by a point and a line. It is determined by projecting the given point\n * orthogonal onto the given line.\n * @constructor\n * @name Orthogonalprojection\n * @type JXG.Point\n * @augments JXG.Point\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line_JXG.Point} p,l The constructed point is the orthogonal projection of p onto l.\n * @example\n * var p1 = board.create('point', [0.0, 4.0]);\n * var p2 = board.create('point', [6.0, 1.0]);\n * var l1 = board.create('line', [p1, p2]);\n * var p3 = board.create('point', [3.0, 3.0]);\n *\n * var pp1 = board.create('orthogonalprojection', [p3, l1]);\n * </pre><div class=\"jxgbox\" id=\"JXG7708b215-39fa-41b6-b972-19d73d77d791\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var ppex1_board = JXG.JSXGraph.initBoard('JXG7708b215-39fa-41b6-b972-19d73d77d791', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var ppex1_p1 = ppex1_board.create('point', [0.0, 4.0]);\n *   var ppex1_p2 = ppex1_board.create('point', [6.0, 1.0]);\n *   var ppex1_l1 = ppex1_board.create('line', [ppex1_p1, ppex1_p2]);\n *   var ppex1_p3 = ppex1_board.create('point', [3.0, 3.0]);\n *   var ppex1_pp1 = ppex1_board.create('orthogonalprojection', [ppex1_p3, ppex1_l1]);\n * </script><pre>\n */\nJXG.createOrthogonalProjection = function (board, parents, attributes) {\n    var l, p, t, attr;\n\n    parents[0] = board.select(parents[0]);\n    parents[1] = board.select(parents[1]);\n\n    if (\n        Type.isPointType(board, parents[0]) &&\n        parents[1].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        p = Type.providePoints(board, [parents[0]], attributes, \"point\")[0];\n        l = parents[1];\n    } else if (\n        Type.isPointType(board, parents[1]) &&\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        p = Type.providePoints(board, [parents[1]], attributes, \"point\")[0];\n        l = parents[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create perpendicular point with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,line]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"orthogonalprojection\");\n\n    t = board.create(\n        \"point\",\n        [\n            function () {\n                return Geometry.projectPointToLine(p, l, board);\n            }\n        ],\n        attr\n    );\n\n    if (Type.exists(p._is_new)) {\n        t.addChild(p);\n        delete p._is_new;\n    } else {\n        p.addChild(t);\n    }\n    l.addChild(t);\n\n    t.elType = \"orthogonalprojection\";\n    t.setParents([p.id, t.id]);\n\n    t.update();\n\n    /**\n     * Used to generate a polynomial for the orthogonal projection\n     * @name Orthogonalprojection#generatePolynomial\n     * @returns {Array} An array containing the generated polynomial.\n     * @private\n     */\n    t.generatePolynomial = function () {\n        /*\n         *  Perpendicular takes point P and line L and creates point T and line M:\n         *\n         *                          | M\n         *                          |\n         *                          x P (p1,p2)\n         *                          |\n         *                          |\n         *  L                       |\n         *  ----------x-------------x------------------------x--------\n         *            A (a1,a2)     |T (t1,t2)               B (b1,b2)\n         *                          |\n         *                          |\n         *\n         * So we have two conditions:\n         *\n         *   (a)  AT  || TB          (collinearity condition)\n         *   (b)  PT _|_ AB          (orthogonality condition)\n         *\n         *      a2-t2       t2-b2\n         *     -------  =  -------           (1)\n         *      a1-t1       t1-b1\n         *\n         *      p2-t2         a1-b1\n         *     -------  =  - -------         (2)\n         *      p1-t1         a2-b2\n         *\n         * Multiplying (1) and (2) with denominators and simplifying gives\n         *\n         *    a2t1 - a2b1 + t2b1 - a1t2 + a1b2 - t1b2 = 0                  (1')\n         *\n         *    p2a2 - p2b2 - t2a2 + t2b2 + p1a1 - p1b1 - t1a1 + t1b1 = 0    (2')\n         *\n         */\n\n        var a1 = l.point1.symbolic.x,\n            a2 = l.point1.symbolic.y,\n            b1 = l.point2.symbolic.x,\n            b2 = l.point2.symbolic.y,\n            p1 = p.symbolic.x,\n            p2 = p.symbolic.y,\n            t1 = t.symbolic.x,\n            t2 = t.symbolic.y,\n            poly1 =\n                \"(\" +\n                a2 +\n                \")*(\" +\n                t1 +\n                \")-(\" +\n                a2 +\n                \")*(\" +\n                b1 +\n                \")+(\" +\n                t2 +\n                \")*(\" +\n                b1 +\n                \")-(\" +\n                a1 +\n                \")*(\" +\n                t2 +\n                \")+(\" +\n                a1 +\n                \")*(\" +\n                b2 +\n                \")-(\" +\n                t1 +\n                \")*(\" +\n                b2 +\n                \")\",\n            poly2 =\n                \"(\" +\n                p2 +\n                \")*(\" +\n                a2 +\n                \")-(\" +\n                p2 +\n                \")*(\" +\n                b2 +\n                \")-(\" +\n                t2 +\n                \")*(\" +\n                a2 +\n                \")+(\" +\n                t2 +\n                \")*(\" +\n                b2 +\n                \")+(\" +\n                p1 +\n                \")*(\" +\n                a1 +\n                \")-(\" +\n                p1 +\n                \")*(\" +\n                b1 +\n                \")-(\" +\n                t1 +\n                \")*(\" +\n                a1 +\n                \")+(\" +\n                t1 +\n                \")*(\" +\n                b1 +\n                \")\";\n\n        return [poly1, poly2];\n    };\n\n    return t;\n};\n\n/**\n\n     * @class This element is used to provide a constructor for a perpendicular.\n     * @pseudo\n     * @description  A perpendicular is a composition of two elements: a line and a point. The line is orthogonal\n     * to a given line and contains a given point.\n     * @name Perpendicular\n     * @constructor\n     * @type JXG.Line\n     * @augments Segment\n     * @returns A {@link JXG.Line} object through the given point that is orthogonal to the given line.\n     * @throws {Error} If the elements cannot be constructed with the given parent objects an exception is thrown.\n     * @param {JXG.Line_JXG.Point} l,p The perpendicular line will be orthogonal to l and\n     * will contain p.\n     * @example\n     * // Create a perpendicular\n     * var p1 = board.create('point', [0.0, 2.0]);\n     * var p2 = board.create('point', [2.0, 1.0]);\n     * var l1 = board.create('line', [p1, p2]);\n     *\n     * var p3 = board.create('point', [3.0, 3.0]);\n     * var perp1 = board.create('perpendicular', [l1, p3]);\n     * </pre><div class=\"jxgbox\" id=\"JXGd5b78842-7b27-4d37-b608-d02519e6cd03\" style=\"width: 400px; height: 400px;\"></div>\n     * <script type=\"text/javascript\">\n     *   var pex1_board = JXG.JSXGraph.initBoard('JXGd5b78842-7b27-4d37-b608-d02519e6cd03', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n     *   var pex1_p1 = pex1_board.create('point', [0.0, 2.0]);\n     *   var pex1_p2 = pex1_board.create('point', [2.0, 1.0]);\n     *   var pex1_l1 = pex1_board.create('line', [pex1_p1, pex1_p2]);\n     *   var pex1_p3 = pex1_board.create('point', [3.0, 3.0]);\n     *   var pex1_perp1 = pex1_board.create('perpendicular', [pex1_l1, pex1_p3]);\n     * </script><pre>\n     */\nJXG.createPerpendicular = function (board, parents, attributes) {\n    var p, l, pd, attr;\n\n    parents[0] = board.select(parents[0]);\n    parents[1] = board.select(parents[1]);\n\n    if (\n        Type.isPointType(board, parents[0]) &&\n        parents[1].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        l = parents[1];\n        p = Type.providePoints(board, [parents[0]], attributes, \"point\")[0];\n    } else if (\n        Type.isPointType(board, parents[1]) &&\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        l = parents[0];\n        p = Type.providePoints(board, [parents[1]], attributes, \"point\")[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create perpendicular with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [line,point]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"perpendicular\");\n    pd = Line.createLine(\n        board,\n        [\n            function () {\n                return l.stdform[2] * p.X() - l.stdform[1] * p.Y();\n            },\n            function () {\n                return -l.stdform[2] * p.Z();\n            },\n            function () {\n                return l.stdform[1] * p.Z();\n            }\n        ],\n        attr\n    );\n\n    pd.elType = \"perpendicular\";\n    pd.setParents([l.id, p.id]);\n\n    if (Type.exists(p._is_new)) {\n        pd.addChild(p);\n        delete p._is_new;\n    } else {\n        p.addChild(pd);\n    }\n    l.addChild(pd);\n\n    return pd;\n};\n\n/**\n * @class This is used to construct a perpendicular point.\n * @pseudo\n * @description A perpendicular point is given by a point and a line. It is determined by projecting the given point\n * orthogonal onto the given line. This element should be used in GEONExTReader only. All other applications should\n * use orthogonal projection {@link Orthogonalprojection}.\n * @constructor\n * @name PerpendicularPoint\n * @type JXG.Point\n * @augments JXG.Point\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line_JXG.Point} p,l The constructed point is the orthogonal projection of p onto l.\n * @example\n * var p1 = board.create('point', [0.0, 4.0]);\n * var p2 = board.create('point', [6.0, 1.0]);\n * var l1 = board.create('line', [p1, p2]);\n * var p3 = board.create('point', [3.0, 3.0]);\n *\n * var pp1 = board.create('perpendicularpoint', [p3, l1]);\n * </pre><div class=\"jxgbox\" id=\"JXGded148c9-3536-44c0-ab81-1bb8fa48f3f4\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var ppex1_board = JXG.JSXGraph.initBoard('JXGded148c9-3536-44c0-ab81-1bb8fa48f3f4', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var ppex1_p1 = ppex1_board.create('point', [0.0, 4.0]);\n *   var ppex1_p2 = ppex1_board.create('point', [6.0, 1.0]);\n *   var ppex1_l1 = ppex1_board.create('line', [ppex1_p1, ppex1_p2]);\n *   var ppex1_p3 = ppex1_board.create('point', [3.0, 3.0]);\n *   var ppex1_pp1 = ppex1_board.create('perpendicularpoint', [ppex1_p3, ppex1_l1]);\n * </script><pre>\n */\nJXG.createPerpendicularPoint = function (board, parents, attributes) {\n    var l, p, t;\n\n    parents[0] = board.select(parents[0]);\n    parents[1] = board.select(parents[1]);\n    if (\n        Type.isPointType(board, parents[0]) &&\n        parents[1].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        p = Type.providePoints(board, [parents[0]], attributes, \"point\")[0];\n        l = parents[1];\n    } else if (\n        Type.isPointType(board, parents[1]) &&\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        p = Type.providePoints(board, [parents[1]], attributes, \"point\")[0];\n        l = parents[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create perpendicular point with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,line]\"\n        );\n    }\n\n    t = board.create(\n        \"point\",\n        [\n            function () {\n                return Geometry.perpendicular(l, p, board)[0];\n            }\n        ],\n        attributes\n    );\n\n    if (Type.exists(p._is_new)) {\n        t.addChild(p);\n        delete p._is_new;\n    } else {\n        p.addChild(t);\n    }\n    l.addChild(t);\n\n    t.elType = \"perpendicularpoint\";\n    t.setParents([p.id, l.id]);\n\n    t.update();\n\n    /**\n     * Used to generate a polynomial for the perpendicular point\n     * @name PerpendicularPoint#generatePolynomial\n     * @returns {Array} An array containing the generated polynomial.\n     * @private\n     */\n    t.generatePolynomial = function () {\n        /*\n         *  Perpendicular takes point P and line L and creates point T and line M:\n         *\n         *                          | M\n         *                          |\n         *                          x P (p1,p2)\n         *                          |\n         *                          |\n         *  L                       |\n         *  ----------x-------------x------------------------x--------\n         *            A (a1,a2)     |T (t1,t2)               B (b1,b2)\n         *                          |\n         *                          |\n         *\n         * So we have two conditions:\n         *\n         *   (a)  AT  || TB          (collinearity condition)\n         *   (b)  PT _|_ AB          (orthogonality condition)\n         *\n         *      a2-t2       t2-b2\n         *     -------  =  -------           (1)\n         *      a1-t1       t1-b1\n         *\n         *      p2-t2         a1-b1\n         *     -------  =  - -------         (2)\n         *      p1-t1         a2-b2\n         *\n         * Multiplying (1) and (2) with denominators and simplifying gives\n         *\n         *    a2t1 - a2b1 + t2b1 - a1t2 + a1b2 - t1b2 = 0                  (1')\n         *\n         *    p2a2 - p2b2 - t2a2 + t2b2 + p1a1 - p1b1 - t1a1 + t1b1 = 0    (2')\n         *\n         */\n        var a1 = l.point1.symbolic.x,\n            a2 = l.point1.symbolic.y,\n            b1 = l.point2.symbolic.x,\n            b2 = l.point2.symbolic.y,\n            p1 = p.symbolic.x,\n            p2 = p.symbolic.y,\n            t1 = t.symbolic.x,\n            t2 = t.symbolic.y,\n            poly1 =\n                \"(\" +\n                a2 +\n                \")*(\" +\n                t1 +\n                \")-(\" +\n                a2 +\n                \")*(\" +\n                b1 +\n                \")+(\" +\n                t2 +\n                \")*(\" +\n                b1 +\n                \")-(\" +\n                a1 +\n                \")*(\" +\n                t2 +\n                \")+(\" +\n                a1 +\n                \")*(\" +\n                b2 +\n                \")-(\" +\n                t1 +\n                \")*(\" +\n                b2 +\n                \")\",\n            poly2 =\n                \"(\" +\n                p2 +\n                \")*(\" +\n                a2 +\n                \")-(\" +\n                p2 +\n                \")*(\" +\n                b2 +\n                \")-(\" +\n                t2 +\n                \")*(\" +\n                a2 +\n                \")+(\" +\n                t2 +\n                \")*(\" +\n                b2 +\n                \")+(\" +\n                p1 +\n                \")*(\" +\n                a1 +\n                \")-(\" +\n                p1 +\n                \")*(\" +\n                b1 +\n                \")-(\" +\n                t1 +\n                \")*(\" +\n                a1 +\n                \")+(\" +\n                t1 +\n                \")*(\" +\n                b1 +\n                \")\";\n\n        return [poly1, poly2];\n    };\n\n    return t;\n};\n\n/**\n * @class This element is used to provide a constructor for a perpendicular segment.\n * @pseudo\n * @description  A perpendicular is a composition of two elements: a line segment and a point. The line segment is orthogonal\n * to a given line and contains a given point and meets the given line in the perpendicular point.\n * @name PerpendicularSegment\n * @constructor\n * @type JXG.Line\n * @augments Segment\n * @returns An array containing two elements: A {@link JXG.Line} object in the first component and a\n * {@link JXG.Point} element in the second component. The line segment is orthogonal to the given line and meets it\n * in the returned point.\n * @throws {Error} If the elements cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line_JXG.Point} l,p The perpendicular line will be orthogonal to l and\n * will contain p. The perpendicular point is the intersection point of the two lines.\n * @example\n * // Create a perpendicular\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var l1 = board.create('line', [p1, p2]);\n *\n * var p3 = board.create('point', [3.0, 3.0]);\n * var perp1 = board.create('perpendicularsegment', [l1, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG037a6eb2-781d-4b71-b286-763619a63f22\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var pex1_board = JXG.JSXGraph.initBoard('JXG037a6eb2-781d-4b71-b286-763619a63f22', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var pex1_p1 = pex1_board.create('point', [0.0, 2.0]);\n *   var pex1_p2 = pex1_board.create('point', [2.0, 1.0]);\n *   var pex1_l1 = pex1_board.create('line', [pex1_p1, pex1_p2]);\n *   var pex1_p3 = pex1_board.create('point', [3.0, 3.0]);\n *   var pex1_perp1 = pex1_board.create('perpendicularsegment', [pex1_l1, pex1_p3]);\n * </script><pre>\n */\nJXG.createPerpendicularSegment = function (board, parents, attributes) {\n    var p, l, pd, t, attr;\n\n    parents[0] = board.select(parents[0]);\n    parents[1] = board.select(parents[1]);\n    if (\n        Type.isPointType(board, parents[0]) &&\n        parents[1].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        l = parents[1];\n        p = Type.providePoints(board, [parents[0]], attributes, \"point\")[0];\n    } else if (\n        Type.isPointType(board, parents[1]) &&\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        l = parents[0];\n        p = Type.providePoints(board, [parents[1]], attributes, \"point\")[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create perpendicular with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [line,point]\"\n        );\n    }\n    attr = Type.copyAttributes(attributes, board.options, \"perpendicularsegment\", \"point\");\n    t = JXG.createPerpendicularPoint(board, [l, p], attr);\n    t.dump = false;\n\n    if (!Type.exists(attributes.layer)) {\n        attributes.layer = board.options.layer.line;\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"perpendicularsegment\");\n    pd = Line.createLine(\n        board,\n        [\n            function () {\n                return Geometry.perpendicular(l, p, board)[1] ? [t, p] : [p, t];\n            }\n        ],\n        attr\n    );\n\n    /**\n     * Helper point\n     * @memberOf PerpendicularSegment.prototype\n     * @type PerpendicularPoint\n     * @name point\n     */\n    pd.point = t;\n\n    if (Type.exists(p._is_new)) {\n        pd.addChild(p);\n        delete p._is_new;\n    } else {\n        p.addChild(pd);\n    }\n    l.addChild(pd);\n\n    pd.elType = \"perpendicularsegment\";\n    pd.setParents([p.id, l.id]);\n    pd.subs = {\n        point: t\n    };\n    pd.inherits.push(t);\n\n    return pd;\n};\n\n/**\n * @class The midpoint element constructs a point in the middle of two given points.\n * @pseudo\n * @description A midpoint is given by two points. It is collinear to the given points and the distance\n * is the same to each of the given points, i.e. it is in the middle of the given points.\n * @constructor\n * @name Midpoint\n * @type JXG.Point\n * @augments JXG.Point\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point} p1,p2 The constructed point will be in the middle of p1 and p2.\n * @param {JXG.Line} l The midpoint will be in the middle of {@link JXG.Line#point1} and {@link JXG.Line#point2} of\n * the given line l.\n * @example\n * // Create base elements: 2 points and 1 line\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var l1 = board.create('segment', [[0.0, 3.0], [3.0, 3.0]]);\n *\n * var mp1 = board.create('midpoint', [p1, p2]);\n * var mp2 = board.create('midpoint', [l1]);\n * </pre><div class=\"jxgbox\" id=\"JXG7927ef86-24ae-40cc-afb0-91ff61dd0de7\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var mpex1_board = JXG.JSXGraph.initBoard('JXG7927ef86-24ae-40cc-afb0-91ff61dd0de7', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var mpex1_p1 = mpex1_board.create('point', [0.0, 2.0]);\n *   var mpex1_p2 = mpex1_board.create('point', [2.0, 1.0]);\n *   var mpex1_l1 = mpex1_board.create('segment', [[0.0, 3.0], [3.0, 3.0]]);\n *   var mpex1_mp1 = mpex1_board.create('midpoint', [mpex1_p1, mpex1_p2]);\n *   var mpex1_mp2 = mpex1_board.create('midpoint', [mpex1_l1]);\n * </script><pre>\n */\nJXG.createMidpoint = function (board, parents, attributes) {\n    var a, b, t, i, attr;\n\n    for (i = 0; i < parents.length; ++i) {\n        parents[i] = board.select(parents[i]);\n    }\n    if (\n        parents.length === 2 &&\n        Type.isPointType(board, parents[0]) &&\n        Type.isPointType(board, parents[1])\n    ) {\n        parents = Type.providePoints(board, parents, attributes, \"point\");\n        a = parents[0];\n        b = parents[1];\n    } else if (parents.length === 1 && parents[0].elementClass === Const.OBJECT_CLASS_LINE) {\n        a = parents[0].point1;\n        b = parents[0].point2;\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create midpoint.\" +\n                \"\\nPossible parent types: [point,point], [line]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"midpoint\");\n    t = board.create(\n        \"point\",\n        [\n            function () {\n                var x = a.coords.usrCoords[1] + b.coords.usrCoords[1];\n                if (\n                    isNaN(x) ||\n                    Math.abs(a.coords.usrCoords[0]) < Mat.eps ||\n                    Math.abs(b.coords.usrCoords[0]) < Mat.eps\n                ) {\n                    return NaN;\n                }\n\n                return x * 0.5;\n            },\n            function () {\n                var y = a.coords.usrCoords[2] + b.coords.usrCoords[2];\n                if (\n                    isNaN(y) ||\n                    Math.abs(a.coords.usrCoords[0]) < Mat.eps ||\n                    Math.abs(b.coords.usrCoords[0]) < Mat.eps\n                ) {\n                    return NaN;\n                }\n\n                return y * 0.5;\n            }\n        ],\n        attr\n    );\n    if (Type.exists(a._is_new)) {\n        t.addChild(a);\n        delete a._is_new;\n    } else {\n        a.addChild(t);\n    }\n    if (Type.exists(b._is_new)) {\n        t.addChild(b);\n        delete b._is_new;\n    } else {\n        b.addChild(t);\n    }\n\n    t.elType = \"midpoint\";\n    t.setParents([a.id, b.id]);\n\n    t.prepareUpdate().update();\n\n    /**\n     * Used to generate a polynomial for the midpoint.\n     * @name Midpoint#generatePolynomial\n     * @returns {Array} An array containing the generated polynomial.\n     * @private\n     */\n    t.generatePolynomial = function () {\n        /*\n         *  Midpoint takes two point A and B or line L (with points P and Q) and creates point T:\n         *\n         *  L (not necessarily)\n         *  ----------x------------------x------------------x--------\n         *            A (a1,a2)          T (t1,t2)          B (b1,b2)\n         *\n         * So we have two conditions:\n         *\n         *   (a)   AT  ||  TB           (collinearity condition)\n         *   (b)  [AT] == [TB]          (equidistant condition)\n         *\n         *      a2-t2       t2-b2\n         *     -------  =  -------                                         (1)\n         *      a1-t1       t1-b1\n         *\n         *     (a1 - t1)^2 + (a2 - t2)^2 = (b1 - t1)^2 + (b2 - t2)^2       (2)\n         *\n         *\n         * Multiplying (1) with denominators and simplifying (1) and (2) gives\n         *\n         *    a2t1 - a2b1 + t2b1 - a1t2 + a1b2 - t1b2 = 0                      (1')\n         *\n         *    a1^2 - 2a1t1 + a2^2 - 2a2t2 - b1^2 + 2b1t1 - b2^2 + 2b2t2 = 0    (2')\n         *\n         */\n        var a1 = a.symbolic.x,\n            a2 = a.symbolic.y,\n            b1 = b.symbolic.x,\n            b2 = b.symbolic.y,\n            t1 = t.symbolic.x,\n            t2 = t.symbolic.y,\n            poly1 =\n                \"(\" +\n                a2 +\n                \")*(\" +\n                t1 +\n                \")-(\" +\n                a2 +\n                \")*(\" +\n                b1 +\n                \")+(\" +\n                t2 +\n                \")*(\" +\n                b1 +\n                \")-(\" +\n                a1 +\n                \")*(\" +\n                t2 +\n                \")+(\" +\n                a1 +\n                \")*(\" +\n                b2 +\n                \")-(\" +\n                t1 +\n                \")*(\" +\n                b2 +\n                \")\",\n            poly2 =\n                \"(\" +\n                a1 +\n                \")^2 - 2*(\" +\n                a1 +\n                \")*(\" +\n                t1 +\n                \")+(\" +\n                a2 +\n                \")^2-2*(\" +\n                a2 +\n                \")*(\" +\n                t2 +\n                \")-(\" +\n                b1 +\n                \")^2+2*(\" +\n                b1 +\n                \")*(\" +\n                t1 +\n                \")-(\" +\n                b2 +\n                \")^2+2*(\" +\n                b2 +\n                \")*(\" +\n                t2 +\n                \")\";\n\n        return [poly1, poly2];\n    };\n\n    return t;\n};\n\n/**\n * @class This element is used to construct a parallel point.\n * @pseudo\n * @description A parallel point is given by three points. Taking the Euclidean vector from the first to the\n * second point, the parallel point is determined by adding that vector to the third point.\n * The line determined by the first two points is parallel to the line determined by the third point and the constructed point.\n * @constructor\n * @name Parallelpoint\n * @type JXG.Point\n * @augments JXG.Point\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 Taking the Euclidean vector <tt>v=p2-p1</tt> the parallel point is determined by\n * <tt>p4 = p3+v</tt>\n * @param {JXG.Line_JXG.Point} l,p The resulting point will together with p specify a line which is parallel to l.\n * @example\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var p3 = board.create('point', [3.0, 3.0]);\n *\n * var pp1 = board.create('parallelpoint', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG488c4be9-274f-40f0-a469-c5f70abe1f0e\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var ppex1_board = JXG.JSXGraph.initBoard('JXG488c4be9-274f-40f0-a469-c5f70abe1f0e', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var ppex1_p1 = ppex1_board.create('point', [0.0, 2.0]);\n *   var ppex1_p2 = ppex1_board.create('point', [2.0, 1.0]);\n *   var ppex1_p3 = ppex1_board.create('point', [3.0, 3.0]);\n *   var ppex1_pp1 = ppex1_board.create('parallelpoint', [ppex1_p1, ppex1_p2, ppex1_p3]);\n * </script><pre>\n */\nJXG.createParallelPoint = function (board, parents, attributes) {\n    var a, b, c, p, i;\n\n    for (i = 0; i < parents.length; ++i) {\n        parents[i] = board.select(parents[i]);\n    }\n    if (\n        parents.length === 3 &&\n        Type.isPointType(board, parents[0]) &&\n        Type.isPointType(board, parents[1]) &&\n        Type.isPointType(board, parents[2])\n    ) {\n        parents = Type.providePoints(board, parents, attributes, \"point\");\n        a = parents[0];\n        b = parents[1];\n        c = parents[2];\n    } else if (\n        Type.isPointType(board, parents[0]) &&\n        parents[1].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        c = Type.providePoints(board, [parents[0]], attributes, \"point\")[0];\n        a = parents[1].point1;\n        b = parents[1].point2;\n    } else if (\n        Type.isPointType(board, parents[1]) &&\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE\n    ) {\n        c = Type.providePoints(board, [parents[1]], attributes, \"point\")[0];\n        a = parents[0].point1;\n        b = parents[0].point2;\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create parallel point with parent types '\" +\n                typeof parents[0] +\n                \"', '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [line,point], [point,point,point]\"\n        );\n    }\n\n    p = board.create(\n        \"point\",\n        [\n            function () {\n                return c.coords.usrCoords[1] + b.coords.usrCoords[1] - a.coords.usrCoords[1];\n            },\n            function () {\n                return c.coords.usrCoords[2] + b.coords.usrCoords[2] - a.coords.usrCoords[2];\n            }\n        ],\n        attributes\n    );\n\n    // required for algorithms requiring dependencies between elements\n    if (Type.exists(a._is_new)) {\n        p.addChild(a);\n        delete a._is_new;\n    } else {\n        a.addChild(p);\n    }\n    if (Type.exists(b._is_new)) {\n        p.addChild(b);\n        delete b._is_new;\n    } else {\n        b.addChild(p);\n    }\n    if (Type.exists(c._is_new)) {\n        p.addChild(c);\n        delete c._is_new;\n    } else {\n        c.addChild(p);\n    }\n\n    p.elType = \"parallelpoint\";\n    p.setParents([a.id, b.id, c.id]);\n\n    // required to set the coordinates because functions are considered as constraints. hence, the coordinates get set first after an update.\n    // can be removed if the above issue is resolved.\n    p.prepareUpdate().update();\n\n    p.generatePolynomial = function () {\n        /*\n         *  Parallelpoint takes three points A, B and C or line L (with points B and C) and creates point T:\n         *\n         *\n         *                     C (c1,c2)                             T (t1,t2)\n         *                      x                                     x\n         *                     /                                     /\n         *                    /                                     /\n         *                   /                                     /\n         *                  /                                     /\n         *                 /                                     /\n         *                /                                     /\n         *               /                                     /\n         *              /                                     /\n         *  L (opt)    /                                     /\n         *  ----------x-------------------------------------x--------\n         *            A (a1,a2)                             B (b1,b2)\n         *\n         * So we have two conditions:\n         *\n         *   (a)   CT  ||  AB           (collinearity condition I)\n         *   (b)   BT  ||  AC           (collinearity condition II)\n         *\n         * The corresponding equations are\n         *\n         *    (b2 - a2)(t1 - c1) - (t2 - c2)(b1 - a1) = 0         (1)\n         *    (t2 - b2)(a1 - c1) - (t1 - b1)(a2 - c2) = 0         (2)\n         *\n         * Simplifying (1) and (2) gives\n         *\n         *    b2t1 - b2c1 - a2t1 + a2c1 - t2b1 + t2a1 + c2b1 - c2a1 = 0      (1')\n         *    t2a1 - t2c1 - b2a1 + b2c1 - t1a2 + t1c2 + b1a2 - b1c2 = 0      (2')\n         *\n         */\n        var a1 = a.symbolic.x,\n            a2 = a.symbolic.y,\n            b1 = b.symbolic.x,\n            b2 = b.symbolic.y,\n            c1 = c.symbolic.x,\n            c2 = c.symbolic.y,\n            t1 = p.symbolic.x,\n            t2 = p.symbolic.y,\n            poly1 =\n                \"(\" +\n                b2 +\n                \")*(\" +\n                t1 +\n                \")-(\" +\n                b2 +\n                \")*(\" +\n                c1 +\n                \")-(\" +\n                a2 +\n                \")*(\" +\n                t1 +\n                \")+(\" +\n                a2 +\n                \")*(\" +\n                c1 +\n                \")-(\" +\n                t2 +\n                \")*(\" +\n                b1 +\n                \")+(\" +\n                t2 +\n                \")*(\" +\n                a1 +\n                \")+(\" +\n                c2 +\n                \")*(\" +\n                b1 +\n                \")-(\" +\n                c2 +\n                \")*(\" +\n                a1 +\n                \")\",\n            poly2 =\n                \"(\" +\n                t2 +\n                \")*(\" +\n                a1 +\n                \")-(\" +\n                t2 +\n                \")*(\" +\n                c1 +\n                \")-(\" +\n                b2 +\n                \")*(\" +\n                a1 +\n                \")+(\" +\n                b2 +\n                \")*(\" +\n                c1 +\n                \")-(\" +\n                t1 +\n                \")*(\" +\n                a2 +\n                \")+(\" +\n                t1 +\n                \")*(\" +\n                c2 +\n                \")+(\" +\n                b1 +\n                \")*(\" +\n                a2 +\n                \")-(\" +\n                b1 +\n                \")*(\" +\n                c2 +\n                \")\";\n\n        return [poly1, poly2];\n    };\n\n    return p;\n};\n\n/**\n * @class A parallel is a line through a given point with the same slope as a given line or\n * the line through two given point.\n * <p>\n * If original line is given as a JSXGraph line object, the resulting parallel line will be defined by the given point and an\n * infinitely far away point (an ideal point). That means, the line can not be shortened to a segment.\n * <p>\n * If the original line is given as two points, the resulting parallel line can be shortened to a a segment.\n * @pseudo\n * @name Parallel\n * @augments Line\n * @constructor\n * @type JXG.Line\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line_JXG.Point} l,p The constructed line contains p and has the same slope as l. Alternative parameters are p1, p2, p: The\n * constructed line contains p and has the same slope as the line through p1 and p2.\n * @example\n * // Create a parallel\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var l1 = board.create('line', [p1, p2]);\n *\n * var p3 = board.create('point', [3.0, 3.0]);\n * var pl1 = board.create('parallel', [l1, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG24e54f9e-5c4e-4afb-9228-0ef27a59d627\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var plex1_board = JXG.JSXGraph.initBoard('JXG24e54f9e-5c4e-4afb-9228-0ef27a59d627', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var plex1_p1 = plex1_board.create('point', [0.0, 2.0]);\n *   var plex1_p2 = plex1_board.create('point', [2.0, 1.0]);\n *   var plex1_l1 = plex1_board.create('line', [plex1_p1, plex1_p2]);\n *   var plex1_p3 = plex1_board.create('point', [3.0, 3.0]);\n *   var plex1_pl1 = plex1_board.create('parallel', [plex1_l1, plex1_p3]);\n * </script><pre>\n * @example\n * var p1, p2, p3, l1, pl1;\n *\n * p1 = board.create('point', [0.0, 2.0]);\n * p2 = board.create('point', [2.0, 1.0]);\n * l1 = board.create('line', [p1, p2]);\n *\n * p3 = board.create('point', [1.0, 3.0]);\n * pl1 = board.create('parallel', [p1, p2, p3], {straightFirst: false, straightLast: false});\n *\n * </pre><div id=\"JXGd643305d-20c3-4a88-91f9-8d0c4448594f\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGd643305d-20c3-4a88-91f9-8d0c4448594f',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p1, p2, p3, l1, pl1;\n *\n *     p1 = board.create('point', [0.0, 2.0]);\n *     p2 = board.create('point', [2.0, 1.0]);\n *     l1 = board.create('line', [p1, p2]);\n *\n *     p3 = board.create('point', [1.0, 3.0]);\n *     pl1 = board.create('parallel', [p1, p2, p3], {straightFirst: false, straightLast: false});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createParallel = function (board, parents, attributes) {\n    var p,\n        pp,\n        pl,\n        li,\n        i,\n        attr,\n        ty = 1;\n\n    for (i = 0; i < parents.length; ++i) {\n        parents[i] = board.select(parents[i]);\n    }\n    p = null;\n    if (parents.length === 3) {\n        // Line / segment through point parents[2] which is parallel to line through parents[0] and parents[1]\n        parents = Type.providePoints(board, parents, attributes, \"point\");\n        p = parents[2];\n        ty = 0;\n    } else if (Type.isPointType(board, parents[0])) {\n        // Parallel to line parents[1] through point parents[0]\n        p = Type.providePoints(board, [parents[0]], attributes, \"point\")[0];\n        /** @ignore */\n        li = function () {\n            return parents[1].stdform;\n        };\n    } else if (Type.isPointType(board, parents[1])) {\n        // Parallel to line parents[0] through point parents[1]\n        p = Type.providePoints(board, [parents[1]], attributes, \"point\")[0];\n        /** @ignore */\n        li = function () {\n            return parents[0].stdform;\n        };\n    }\n\n    if (!Type.exists(attributes.layer)) {\n        attributes.layer = board.options.layer.line;\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"parallel\", \"point\");\n    if (ty === 1) {\n        // Line is given by line element. The parallel line is\n        // constructed as line through an ideal point.\n        pp = board.create(\n            \"point\",\n            [\n                function () {\n                    return Mat.crossProduct([1, 0, 0], li());\n                }\n            ],\n            attr\n        );\n    } else {\n        // Line is given by two points. The parallel line is\n        // constructed as line through two finite point.\n        pp = board.create(\"parallelpoint\", parents, attr);\n    }\n    pp.isDraggable = true;\n\n    attr = Type.copyAttributes(attributes, board.options, \"parallel\");\n    // line creator also calls addChild\n    pl = board.create(\"line\", [p, pp], attr);\n\n    pl.elType = \"parallel\";\n    pl.subs = {\n        point: pp\n    };\n\n    pl.inherits.push(pp);\n    pl.setParents([parents[0].id, parents[1].id]);\n    if (parents.length === 3) {\n        pl.addParents(parents[2].id);\n    }\n\n    // p.addChild(pl);\n\n    /**\n     * Helper point used to create the parallel line. This point lies on the line at infinity, hence it's not visible,\n     * not even with visible set to <tt>true</tt>. Creating another line through this point would make that other line\n     * parallel to the create parallel.\n     * @memberOf Parallel.prototype\n     * @name point\n     * @type JXG.Point\n     */\n    pl.point = pp;\n\n    return pl;\n};\n\n/**\n * @class An arrow parallel is a segment with an arrow attached which is parallel through a given segment, given by its defining two points,\n * through a given point.\n * <p>\n * @pseudo\n * @constructor\n * @name Arrowparallel\n * @type Parallel\n * @augments Parallel\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param JXG.Point_JXG.Point_JXG.Point} p1, p2,p3 The constructed arrow contains p3 and has the same slope as the line through p1 and p2.\n * @example\n * // Create a parallel\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var l1 = board.create('segment', [p1, p2]);\n *\n * var p3 = board.create('point', [3.0, 3.0]);\n * var pl1 = board.create('arrowparallel', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXGeeacdf99-036f-4e83-aeb6-f7388423e369\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var plex1_board = JXG.JSXGraph.initBoard('JXGeeacdf99-036f-4e83-aeb6-f7388423e369', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var plex1_p1 = plex1_board.create('point', [0.0, 2.0]);\n *   var plex1_p2 = plex1_board.create('point', [2.0, 1.0]);\n *   var plex1_l1 = plex1_board.create('segment', [plex1_p1, plex1_p2]);\n *   var plex1_p3 = plex1_board.create('point', [3.0, 3.0]);\n *   var plex1_pl1 = plex1_board.create('arrowparallel', [plex1_p1, plex1_p2, plex1_p3]);\n * })();\n * </script><pre>\n */\nJXG.createArrowParallel = function (board, parents, attributes) {\n    var p;\n\n    /* parallel arrow point polynomials are done in createParallelPoint */\n    try {\n        attributes.firstArrow = false;\n        attributes.lastArrow = true;\n        p = JXG.createParallel(board, parents, attributes).setAttribute({\n            straightFirst: false,\n            straightLast: false\n        });\n        p.elType = \"arrowparallel\";\n\n        // parents are set in createParallel\n\n        return p;\n    } catch (e) {\n        throw new Error(\n            \"JSXGraph: Can't create arrowparallel with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [line,point], [point,point,point]\"\n        );\n    }\n};\n\n/**\n * @class Constructs a normal.\n * @pseudo\n * @description A normal is a line through a given point on a element of type line, circle, curve, or turtle and orthogonal to that object.\n * @constructor\n * @name Normal\n * @type JXG.Line\n * @augments JXG.Line\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line,JXG.Circle,JXG.Curve,JXG.Turtle_JXG.Point} o,p The constructed line contains p which lies on the object and is orthogonal\n * to the tangent to the object in the given point.\n * @param {Glider} p Works like above, however the object is given by {@link JXG.CoordsElement#slideObject}.\n * @example\n * // Create a normal to a circle.\n * var p1 = board.create('point', [2.0, 2.0]);\n * var p2 = board.create('point', [3.0, 2.0]);\n * var c1 = board.create('circle', [p1, p2]);\n *\n * var norm1 = board.create('normal', [c1, p2]);\n * </pre><div class=\"jxgbox\" id=\"JXG4154753d-3d29-40fb-a860-0b08aa4f3743\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var nlex1_board = JXG.JSXGraph.initBoard('JXG4154753d-3d29-40fb-a860-0b08aa4f3743', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var nlex1_p1 = nlex1_board.create('point', [2.0, 2.0]);\n *   var nlex1_p2 = nlex1_board.create('point', [3.0, 2.0]);\n *   var nlex1_c1 = nlex1_board.create('circle', [nlex1_p1, nlex1_p2]);\n *\n *   // var nlex1_p3 = nlex1_board.create('point', [1.0, 2.0]);\n *   var nlex1_norm1 = nlex1_board.create('normal', [nlex1_c1, nlex1_p2]);\n * </script><pre>\n */\nJXG.createNormal = function (board, parents, attributes) {\n    var p, c, l, i, g, f, attr, pp, attrp;\n\n    for (i = 0; i < parents.length; ++i) {\n        parents[i] = board.select(parents[i]);\n    }\n    // One arguments: glider on line, circle or curve\n    if (parents.length === 1) {\n        p = parents[0];\n        c = p.slideObject;\n        // Two arguments: (point,line), (point,circle), (line,point) or (circle,point)\n    } else if (parents.length === 2) {\n        if (Type.isPointType(board, parents[0])) {\n            p = Type.providePoints(board, [parents[0]], attributes, \"point\")[0];\n            c = parents[1];\n        } else if (Type.isPointType(board, parents[1])) {\n            c = parents[0];\n            p = Type.providePoints(board, [parents[1]], attributes, \"point\")[0];\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create normal with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,line], [point,circle], [glider]\"\n            );\n        }\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create normal with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,line], [point,circle], [glider]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"normal\");\n    if (c.elementClass === Const.OBJECT_CLASS_LINE) {\n        // Private point\n        attrp = Type.copyAttributes(attributes, board.options, \"normal\", \"point\");\n        pp = board.create(\n            \"point\",\n            [\n                function () {\n                    var p = Mat.crossProduct([1, 0, 0], c.stdform);\n                    return [p[0], -p[2], p[1]];\n                }\n            ],\n            attrp\n        );\n        pp.isDraggable = true;\n\n        l = board.create(\"line\", [p, pp], attr);\n\n        /**\n         * A helper point used to create a normal to a {@link JXG.Line} object. For normals to circles or curves this\n         * element is <tt>undefined</tt>.\n         * @type JXG.Point\n         * @name point\n         * @memberOf Normal.prototype\n         */\n        l.point = pp;\n        l.subs = {\n            point: pp\n        };\n        l.inherits.push(pp);\n    } else if (c.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n        l = board.create(\"line\", [c.midpoint, p], attr);\n    } else if (c.elementClass === Const.OBJECT_CLASS_CURVE) {\n        if (Type.evaluate(c.visProp.curvetype) !== \"plot\") {\n            g = c.X;\n            f = c.Y;\n            l = board.create(\n                \"line\",\n                [\n                    function () {\n                        return (\n                            -p.X() * Numerics.D(g)(p.position) -\n                            p.Y() * Numerics.D(f)(p.position)\n                        );\n                    },\n                    function () {\n                        return Numerics.D(g)(p.position);\n                    },\n                    function () {\n                        return Numerics.D(f)(p.position);\n                    }\n                ],\n                attr\n            );\n        } else {\n            // curveType 'plot'\n            l = board.create(\n                \"line\",\n                [\n                    function () {\n                        var i = Math.floor(p.position),\n                            lbda = p.position - i,\n                            p1,\n                            p2,\n                            t,\n                            A,\n                            B,\n                            C,\n                            D,\n                            dx,\n                            dy,\n                            d;\n\n                        if (c.bezierdegree === 1) {\n                            if (i === c.numberPoints - 1) {\n                                i -= 1;\n                                lbda = 1;\n                            }\n                        } else if (c.bezierDegree === 3) {\n                            // i is start of the Bezier segment\n                            // t is the position in the Bezier segment\n                            i = Math.floor((p.position * (c.numberPoints - 1)) / 3) * 3;\n                            t = (p.position * (c.numberPoints - 1) - i) / 3;\n                            if (i >= c.numberPoints - 1) {\n                                i = c.numberPoints - 4;\n                                t = 1;\n                            }\n                        } else {\n                            return 0;\n                        }\n\n                        if (i < 0) {\n                            return 1;\n                        }\n\n                        if (c.bezierDegree === 1) {\n                            return (\n                                (c.Y(i) + lbda * (c.Y(i + 1) - c.Y(i))) *\n                                    (c.Y(i) - c.Y(i + 1)) -\n                                (c.X(i) + lbda * (c.X(i + 1) - c.X(i))) * (c.X(i + 1) - c.X(i))\n                            );\n                        } else {\n                            A = c.points[i].usrCoords;\n                            B = c.points[i + 1].usrCoords;\n                            C = c.points[i + 2].usrCoords;\n                            D = c.points[i + 3].usrCoords;\n                            dx =\n                                (1 - t) * (1 - t) * (B[1] - A[1]) +\n                                2 * (1 - t) * t * (C[1] - B[1]) +\n                                t * t * (D[1] - C[1]);\n                            dy =\n                                (1 - t) * (1 - t) * (B[2] - A[2]) +\n                                2 * (1 - t) * t * (C[2] - B[2]) +\n                                t * t * (D[2] - C[2]);\n                            d = Math.sqrt(dx * dx + dy * dy);\n                            dx /= d;\n                            dy /= d;\n                            p1 = p.coords.usrCoords;\n                            p2 = [1, p1[1] - dy, p1[2] + dx];\n                            return p1[2] * p2[1] - p1[1] * p2[2];\n                        }\n                    },\n                    function () {\n                        var i = Math.floor(p.position),\n                            p1,\n                            p2,\n                            t,\n                            A,\n                            B,\n                            C,\n                            D,\n                            dx,\n                            dy,\n                            d;\n\n                        if (c.bezierdegree === 1) {\n                            if (i === c.numberPoints - 1) {\n                                i -= 1;\n                            }\n                        } else if (c.bezierDegree === 3) {\n                            // i is start of the Bezier segment\n                            // t is the position in the Bezier segment\n                            i = Math.floor((p.position * (c.numberPoints - 1)) / 3) * 3;\n                            t = (p.position * (c.numberPoints - 1) - i) / 3;\n                            if (i >= c.numberPoints - 1) {\n                                i = c.numberPoints - 4;\n                                t = 1;\n                            }\n                        } else {\n                            return 0;\n                        }\n\n                        if (i < 0) {\n                            return 0;\n                        }\n                        if (c.bezierDegree === 1) {\n                            return c.X(i + 1) - c.X(i);\n                        } else {\n                            A = c.points[i].usrCoords;\n                            B = c.points[i + 1].usrCoords;\n                            C = c.points[i + 2].usrCoords;\n                            D = c.points[i + 3].usrCoords;\n                            dx =\n                                (1 - t) * (1 - t) * (B[1] - A[1]) +\n                                2 * (1 - t) * t * (C[1] - B[1]) +\n                                t * t * (D[1] - C[1]);\n                            dy =\n                                (1 - t) * (1 - t) * (B[2] - A[2]) +\n                                2 * (1 - t) * t * (C[2] - B[2]) +\n                                t * t * (D[2] - C[2]);\n                            d = Math.sqrt(dx * dx + dy * dy);\n                            dx /= d;\n                            dy /= d;\n                            p1 = p.coords.usrCoords;\n                            p2 = [1, p1[1] - dy, p1[2] + dx];\n                            return p2[2] - p1[2];\n                        }\n                    },\n                    function () {\n                        var i = Math.floor(p.position),\n                            p1,\n                            p2,\n                            t,\n                            A,\n                            B,\n                            C,\n                            D,\n                            dx,\n                            dy,\n                            d;\n\n                        if (c.bezierdegree === 1) {\n                            if (i === c.numberPoints - 1) {\n                                i -= 1;\n                            }\n                        } else if (c.bezierDegree === 3) {\n                            // i is start of the Bezier segment\n                            // t is the position in the Bezier segment\n                            i = Math.floor((p.position * (c.numberPoints - 1)) / 3) * 3;\n                            t = (p.position * (c.numberPoints - 1) - i) / 3;\n                            if (i >= c.numberPoints - 1) {\n                                i = c.numberPoints - 4;\n                                t = 1;\n                            }\n                        } else {\n                            return 0;\n                        }\n\n                        if (i < 0) {\n                            return 0;\n                        }\n\n                        if (c.bezierDegree === 1) {\n                            return c.Y(i + 1) - c.Y(i);\n                        } else {\n                            A = c.points[i].usrCoords;\n                            B = c.points[i + 1].usrCoords;\n                            C = c.points[i + 2].usrCoords;\n                            D = c.points[i + 3].usrCoords;\n                            dx =\n                                (1 - t) * (1 - t) * (B[1] - A[1]) +\n                                2 * (1 - t) * t * (C[1] - B[1]) +\n                                t * t * (D[1] - C[1]);\n                            dy =\n                                (1 - t) * (1 - t) * (B[2] - A[2]) +\n                                2 * (1 - t) * t * (C[2] - B[2]) +\n                                t * t * (D[2] - C[2]);\n                            d = Math.sqrt(dx * dx + dy * dy);\n                            dx /= d;\n                            dy /= d;\n                            p1 = p.coords.usrCoords;\n                            p2 = [1, p1[1] - dy, p1[2] + dx];\n                            return p1[1] - p2[1];\n                        }\n                    }\n                ],\n                attr\n            );\n        }\n    } else if (c.type === Const.OBJECT_TYPE_TURTLE) {\n        l = board.create(\n            \"line\",\n            [\n                function () {\n                    var el,\n                        j,\n                        i = Math.floor(p.position),\n                        lbda = p.position - i;\n\n                    // run through all curves of this turtle\n                    for (j = 0; j < c.objects.length; j++) {\n                        el = c.objects[j];\n\n                        if (el.type === Const.OBJECT_TYPE_CURVE) {\n                            if (i < el.numberPoints) {\n                                break;\n                            }\n\n                            i -= el.numberPoints;\n                        }\n                    }\n\n                    if (i === el.numberPoints - 1) {\n                        i -= 1;\n                        lbda = 1;\n                    }\n\n                    if (i < 0) {\n                        return 1;\n                    }\n\n                    return (\n                        (el.Y(i) + lbda * (el.Y(i + 1) - el.Y(i))) * (el.Y(i) - el.Y(i + 1)) -\n                        (el.X(i) + lbda * (el.X(i + 1) - el.X(i))) * (el.X(i + 1) - el.X(i))\n                    );\n                },\n                function () {\n                    var el,\n                        j,\n                        i = Math.floor(p.position);\n\n                    // run through all curves of this turtle\n                    for (j = 0; j < c.objects.length; j++) {\n                        el = c.objects[j];\n                        if (el.type === Const.OBJECT_TYPE_CURVE) {\n                            if (i < el.numberPoints) {\n                                break;\n                            }\n\n                            i -= el.numberPoints;\n                        }\n                    }\n\n                    if (i === el.numberPoints - 1) {\n                        i -= 1;\n                    }\n\n                    if (i < 0) {\n                        return 0;\n                    }\n\n                    return el.X(i + 1) - el.X(i);\n                },\n                function () {\n                    var el,\n                        j,\n                        i = Math.floor(p.position);\n\n                    // run through all curves of this turtle\n                    for (j = 0; j < c.objects.length; j++) {\n                        el = c.objects[j];\n                        if (el.type === Const.OBJECT_TYPE_CURVE) {\n                            if (i < el.numberPoints) {\n                                break;\n                            }\n\n                            i -= el.numberPoints;\n                        }\n                    }\n\n                    if (i === el.numberPoints - 1) {\n                        i -= 1;\n                    }\n\n                    if (i < 0) {\n                        return 0;\n                    }\n\n                    return el.Y(i + 1) - el.Y(i);\n                }\n            ],\n            attr\n        );\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create normal with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,line], [point,circle], [glider]\"\n        );\n    }\n\n    l.elType = \"normal\";\n    l.setParents(parents);\n\n    if (Type.exists(p._is_new)) {\n        l.addChild(p);\n        delete p._is_new;\n    } else {\n        p.addChild(l);\n    }\n    c.addChild(l);\n\n    return l;\n};\n\n/**\n * @class A bisector is a line which divides an angle into two equal angles. It is given by three points A, B, and\n * C and divides the angle ABC into two equal sized parts.\n * @pseudo\n * @constructor\n * @name Bisector\n * @type JXG.Line\n * @augments JXG.Line\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The angle described by <tt>p1</tt>, <tt>p2</tt> and <tt>p3</tt> will\n * be divided into two equal angles.\n * @example\n * var p1 = board.create('point', [6.0, 4.0]);\n * var p2 = board.create('point', [3.0, 2.0]);\n * var p3 = board.create('point', [1.0, 7.0]);\n *\n * var bi1 = board.create('bisector', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXG0d58cea8-b06a-407c-b27c-0908f508f5a4\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG0d58cea8-b06a-407c-b27c-0908f508f5a4', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var p1 = board.create('point', [6.0, 4.0]);\n *   var p2 = board.create('point', [3.0, 2.0]);\n *   var p3 = board.create('point', [1.0, 7.0]);\n *   var bi1 = board.create('bisector', [p1, p2, p3]);\n * })();\n * </script><pre>\n */\nJXG.createBisector = function (board, parents, attributes) {\n    var p, l, i, attr;\n\n    parents = Type.providePoints(board, parents, attributes, \"point\");\n    if (Type.isPoint(parents[0]) && Type.isPoint(parents[1]) && Type.isPoint(parents[2])) {\n        // hidden and fixed helper\n        attr = Type.copyAttributes(attributes, board.options, \"bisector\", \"point\");\n        attr.snapToGrid = false;\n\n        p = board.create(\n            \"point\",\n            [\n                function () {\n                    return Geometry.angleBisector(parents[0], parents[1], parents[2], board);\n                }\n            ],\n            attr\n        );\n        p.dump = false;\n\n        for (i = 0; i < 3; i++) {\n            // required for algorithm requiring dependencies between elements\n            if (Type.exists(parents[i]._is_new)) {\n                p.addChild(parents[i]);\n                delete parents[i]._is_new;\n            } else {\n                parents[i].addChild(p);\n            }\n        }\n\n        if (!Type.exists(attributes.layer)) {\n            attributes.layer = board.options.layer.line;\n        }\n\n        attr = Type.copyAttributes(attributes, board.options, \"bisector\");\n        l = Line.createLine(board, [parents[1], p], attr);\n\n        /**\n         * Helper point\n         * @memberOf Bisector.prototype\n         * @type Point\n         * @name point\n         */\n        l.point = p;\n\n        l.elType = \"bisector\";\n        l.setParents(parents);\n        l.subs = {\n            point: p\n        };\n        l.inherits.push(p);\n\n        return l;\n    }\n\n    throw new Error(\n        \"JSXGraph: Can't create angle bisector with parent types '\" +\n            typeof parents[0] +\n            \"' and '\" +\n            typeof parents[1] +\n            \"'.\" +\n            \"\\nPossible parent types: [point,point,point]\"\n    );\n};\n\n/**\n * @class Bisector lines are similar to {@link Bisector} but take two lines as parent elements. The resulting element is\n * a composition of two lines.\n * @pseudo\n * @constructor\n * @name Bisectorlines\n * @type JXG.Composition\n * @augments JXG.Composition\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line_JXG.Line} l1,l2 The four angles described by the lines <tt>l1</tt> and <tt>l2</tt> will each\n * be divided into two equal angles.\n * @example\n * var p1 = board.create('point', [6.0, 4.0]);\n * var p2 = board.create('point', [3.0, 2.0]);\n * var p3 = board.create('point', [1.0, 7.0]);\n * var p4 = board.create('point', [3.0, 0.0]);\n * var l1 = board.create('line', [p1, p2]);\n * var l2 = board.create('line', [p3, p4]);\n *\n * var bi1 = board.create('bisectorlines', [l1, l2]);\n * </pre><div class=\"jxgbox\" id=\"JXG3121ff67-44f0-4dda-bb10-9cda0b80bf18\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG3121ff67-44f0-4dda-bb10-9cda0b80bf18', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var p1 = board.create('point', [6.0, 4.0]);\n *   var p2 = board.create('point', [3.0, 2.0]);\n *   var p3 = board.create('point', [1.0, 7.0]);\n *   var p4 = board.create('point', [3.0, 0.0]);\n *   var l1 = board.create('line', [p1, p2]);\n *   var l2 = board.create('line', [p3, p4]);\n *   var bi1 = board.create('bisectorlines', [l1, l2]);\n * })();\n * </script><pre>\n */\nJXG.createAngularBisectorsOfTwoLines = function (board, parents, attributes) {\n    // The angular bisectors of two line [c1,a1,b1] and [c2,a2,b2] are determined by the equation:\n    // (a1*x+b1*y+c1*z)/sqrt(a1^2+b1^2) = +/- (a2*x+b2*y+c2*z)/sqrt(a2^2+b2^2)\n\n    var g1,\n        g2,\n        attr,\n        ret,\n        l1 = board.select(parents[0]),\n        l2 = board.select(parents[1]);\n\n    if (\n        l1.elementClass !== Const.OBJECT_CLASS_LINE ||\n        l2.elementClass !== Const.OBJECT_CLASS_LINE\n    ) {\n        throw new Error(\n            \"JSXGraph: Can't create angle bisectors of two lines with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [line,line]\"\n        );\n    }\n\n    if (!Type.exists(attributes.layer)) {\n        attributes.layer = board.options.layer.line;\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"bisectorlines\", \"line1\");\n    g1 = board.create(\n        \"line\",\n        [\n            function () {\n                var d1 = Math.sqrt(\n                        l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]\n                    ),\n                    d2 = Math.sqrt(\n                        l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]\n                    );\n\n                return l1.stdform[0] / d1 - l2.stdform[0] / d2;\n            },\n            function () {\n                var d1 = Math.sqrt(\n                        l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]\n                    ),\n                    d2 = Math.sqrt(\n                        l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]\n                    );\n\n                return l1.stdform[1] / d1 - l2.stdform[1] / d2;\n            },\n            function () {\n                var d1 = Math.sqrt(\n                        l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]\n                    ),\n                    d2 = Math.sqrt(\n                        l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]\n                    );\n\n                return l1.stdform[2] / d1 - l2.stdform[2] / d2;\n            }\n        ],\n        attr\n    );\n\n    if (!Type.exists(attributes.layer)) {\n        attributes.layer = board.options.layer.line;\n    }\n    attr = Type.copyAttributes(attributes, board.options, \"bisectorlines\", \"line2\");\n    g2 = board.create(\n        \"line\",\n        [\n            function () {\n                var d1 = Math.sqrt(\n                        l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]\n                    ),\n                    d2 = Math.sqrt(\n                        l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]\n                    );\n\n                return l1.stdform[0] / d1 + l2.stdform[0] / d2;\n            },\n            function () {\n                var d1 = Math.sqrt(\n                        l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]\n                    ),\n                    d2 = Math.sqrt(\n                        l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]\n                    );\n\n                return l1.stdform[1] / d1 + l2.stdform[1] / d2;\n            },\n            function () {\n                var d1 = Math.sqrt(\n                        l1.stdform[1] * l1.stdform[1] + l1.stdform[2] * l1.stdform[2]\n                    ),\n                    d2 = Math.sqrt(\n                        l2.stdform[1] * l2.stdform[1] + l2.stdform[2] * l2.stdform[2]\n                    );\n\n                return l1.stdform[2] / d1 + l2.stdform[2] / d2;\n            }\n        ],\n        attr\n    );\n\n    // documentation\n    /**\n     * First line.\n     * @memberOf Bisectorlines.prototype\n     * @name line1\n     * @type Line\n     */\n\n    /**\n     * Second line.\n     * @memberOf Bisectorlines.prototype\n     * @name line2\n     * @type Line\n     */\n\n    ret = new Composition({ line1: g1, line2: g2 });\n\n    g1.dump = false;\n    g2.dump = false;\n\n    ret.elType = \"bisectorlines\";\n    ret.setParents([l1.id, l2.id]);\n    ret.subs = {\n        line1: g1,\n        line2: g2\n    };\n    // ret.inherits.push(g1, g2);\n\n    return ret;\n};\n\n// /**\n//  * @class An m-sector is a line which divides an angle into two angles. It is given by three points A, B, and\n//  * C and a real number m, and divides an angle into two angles, an angle with amplitude m and an angle with\n//  * amplitude (1-m)\n//  * @pseudo\n//  * @constructor\n//  * @name Msector\n//  * @type JXG.Line\n//  * @augments JXG.Line\n//  * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n//  * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The angle described by <tt>p1</tt>, <tt>p2</tt> and <tt>p3</tt> will\n//  * be divided into two angles according to the value of <tt>m</tt>.\n//  * @example\n//  * var p1 = board.create('point', [6.0, 4.0]);\n//  * var p2 = board.create('point', [3.0, 2.0]);\n//  * var p3 = board.create('point', [1.0, 7.0]);\n//  *\n//  * var bi1 = board.create('msector', [p1, p2, p3], 1/5);\n//  * </pre><div id=\"JXG0d58cea8-b06a-407c-b27c-0908f508f5a4\" style=\"width: 400px; height: 400px;\"></div>\n//  * <script type=\"text/javascript\">\n//  * (function () {\n//  *   var board = JXG.JSXGraph.initBoard('JXG0d58cea8-b06a-407c-b27c-0908f508f5a4', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n//  *   var p1 = board.create('point', [6.0, 4.0]);\n//  *   var p2 = board.create('point', [3.0, 2.0]);\n//  *   var p3 = board.create('point', [1.0, 7.0]);\n//  *   var bi1 = board.create('msector', [p1, p2, p3], 1/5);\n//  * })();\n//  * </script><pre>\n//  */\n// JXG.createMsector = function (board, parents, attributes) {\n//     var p, l, i, attr;\n\n//     if (parents[0].elementClass === Const.OBJECT_CLASS_POINT &&\n//             parents[1].elementClass === Const.OBJECT_CLASS_POINT &&\n//             parents[2].elementClass === Const.OBJECT_CLASS_POINT) {\n//         // hidden and fixed helper\n//         attr = Type.copyAttributes(attributes, board.options, 'msector', 'point');\n//         p = board.create('point', [\n//             function () {\n//                 return Geometry.angleMsector(parents[0], parents[1], parents[2], parents[3], board);\n//             }\n//         ], attr);\n//         p.dump = false;\n\n//         for (i = 0; i < 3; i++) {\n//             // required for algorithm requiring dependencies between elements\n//             parents[i].addChild(p);\n//         }\n\n//         if (!Type.exists(attributes.layer)) {\n//             attributes.layer = board.options.layer.line;\n//         }\n\n//         attr = Type.copyAttributes(attributes, board.options, 'msector');\n//         l = Line.createLine(board, [parents[1], p], attr);\n\n//         /**\n//          * Helper point\n//          * @memberOf Msector.prototype\n//          * @type Point\n//          * @name point\n//          */\n//         l.point = p;\n\n//         l.elType = 'msector';\n//         l.parents = [parents[0].id, parents[1].id, parents[2].id];\n//         l.subs = {\n//             point: p\n//         };\n//         l.inherits.push(p);\n\n//         return l;\n//     }\n\n//     throw new Error(\"JSXGraph: Can't create angle msector with parent types '\" +\n//         (typeof parents[0]) + \"' and '\" + (typeof parents[1]) + \"'.\" +\n//         \"\\nPossible parent types: [point,point,point,Number]\");\n// };\n\n/**\n * @class Constructs the midpoint of a {@link Circumcircle}. Like the circumcircle the circumcenter\n * is constructed by providing three points.\n * @pseudo\n * @description A circumcenter is given by three points which are all lying on the circle with the\n * constructed circumcenter as the midpoint.\n * @constructor\n * @name Circumcenter\n * @type JXG.Point\n * @augments JXG.Point\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The constructed point is the midpoint of the circle determined\n * by p1, p2, and p3.\n * @example\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var p3 = board.create('point', [3.0, 3.0]);\n *\n * var cc1 = board.create('circumcenter', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXGe8a40f95-bf30-4eb4-88a8-f4d5495261fd\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var ccmex1_board = JXG.JSXGraph.initBoard('JXGe8a40f95-bf30-4eb4-88a8-f4d5495261fd', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var ccmex1_p1 = ccmex1_board.create('point', [0.0, 2.0]);\n *   var ccmex1_p2 = ccmex1_board.create('point', [6.0, 1.0]);\n *   var ccmex1_p3 = ccmex1_board.create('point', [3.0, 7.0]);\n *   var ccmex1_cc1 = ccmex1_board.create('circumcenter', [ccmex1_p1, ccmex1_p2, ccmex1_p3]);\n * </script><pre>\n */\nJXG.createCircumcenter = function (board, parents, attributes) {\n    var p, i, a, b, c;\n\n    parents = Type.providePoints(board, parents, attributes, \"point\");\n    if (Type.isPoint(parents[0]) && Type.isPoint(parents[1]) && Type.isPoint(parents[2])) {\n        a = parents[0];\n        b = parents[1];\n        c = parents[2];\n\n        p = Point.createPoint(\n            board,\n            [\n                function () {\n                    return Geometry.circumcenter(a, b, c, board);\n                }\n            ],\n            attributes\n        );\n\n        for (i = 0; i < 3; i++) {\n            if (Type.exists(parents[i]._is_new)) {\n                p.addChild(parents[i]);\n                delete parents[i]._is_new;\n            } else {\n                parents[i].addChild(p);\n            }\n        }\n\n        p.elType = \"circumcenter\";\n        p.setParents(parents);\n\n        p.generatePolynomial = function () {\n            /*\n             *  CircumcircleMidpoint takes three points A, B and C  and creates point M, which is the circumcenter of A, B, and C.\n             *\n             *\n             * So we have two conditions:\n             *\n             *   (a)   CT  ==  AT           (distance condition I)\n             *   (b)   BT  ==  AT           (distance condition II)\n             *\n             */\n            var a1 = a.symbolic.x,\n                a2 = a.symbolic.y,\n                b1 = b.symbolic.x,\n                b2 = b.symbolic.y,\n                c1 = c.symbolic.x,\n                c2 = c.symbolic.y,\n                t1 = p.symbolic.x,\n                t2 = p.symbolic.y,\n                poly1 = [\n                    \"((\",\n                    t1,\n                    \")-(\",\n                    a1,\n                    \"))^2+((\",\n                    t2,\n                    \")-(\",\n                    a2,\n                    \"))^2-((\",\n                    t1,\n                    \")-(\",\n                    b1,\n                    \"))^2-((\",\n                    t2,\n                    \")-(\",\n                    b2,\n                    \"))^2\"\n                ].join(\"\"),\n                poly2 = [\n                    \"((\",\n                    t1,\n                    \")-(\",\n                    a1,\n                    \"))^2+((\",\n                    t2,\n                    \")-(\",\n                    a2,\n                    \"))^2-((\",\n                    t1,\n                    \")-(\",\n                    c1,\n                    \"))^2-((\",\n                    t2,\n                    \")-(\",\n                    c2,\n                    \"))^2\"\n                ].join(\"\");\n\n            return [poly1, poly2];\n        };\n\n        return p;\n    }\n\n    throw new Error(\n        \"JSXGraph: Can't create circumcircle midpoint with parent types '\" +\n            typeof parents[0] +\n            \"', '\" +\n            typeof parents[1] +\n            \"' and '\" +\n            typeof parents[2] +\n            \"'.\" +\n            \"\\nPossible parent types: [point,point,point]\"\n    );\n};\n\n/**\n * @class Constructs the incenter of the triangle described by the three given points.{@link http://mathworld.wolfram.com/Incenter.html}\n * @pseudo\n * @constructor\n * @name Incenter\n * @type JXG.Point\n * @augments JXG.Point\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The constructed point is the incenter of the triangle described\n * by p1, p2, and p3.\n * @example\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var p3 = board.create('point', [3.0, 3.0]);\n *\n * var ic1 = board.create('incenter', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXGe8a40f95-bf30-4eb4-88a8-a2d5495261fd\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var icmex1_board = JXG.JSXGraph.initBoard('JXGe8a40f95-bf30-4eb4-88a8-a2d5495261fd', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var icmex1_p1 = icmex1_board.create('point', [0.0, 2.0]);\n *   var icmex1_p2 = icmex1_board.create('point', [6.0, 1.0]);\n *   var icmex1_p3 = icmex1_board.create('point', [3.0, 7.0]);\n *   var icmex1_ic1 = icmex1_board.create('incenter', [icmex1_p1, icmex1_p2, icmex1_p3]);\n * </script><pre>\n */\nJXG.createIncenter = function (board, parents, attributes) {\n    var p, A, B, C, i;\n\n    parents = Type.providePoints(board, parents, attributes, \"point\");\n    if (\n        parents.length >= 3 &&\n        Type.isPoint(parents[0]) &&\n        Type.isPoint(parents[1]) &&\n        Type.isPoint(parents[2])\n    ) {\n        A = parents[0];\n        B = parents[1];\n        C = parents[2];\n\n        p = board.create(\n            \"point\",\n            [\n                function () {\n                    var a, b, c;\n\n                    a = Math.sqrt(\n                        (B.X() - C.X()) * (B.X() - C.X()) + (B.Y() - C.Y()) * (B.Y() - C.Y())\n                    );\n                    b = Math.sqrt(\n                        (A.X() - C.X()) * (A.X() - C.X()) + (A.Y() - C.Y()) * (A.Y() - C.Y())\n                    );\n                    c = Math.sqrt(\n                        (B.X() - A.X()) * (B.X() - A.X()) + (B.Y() - A.Y()) * (B.Y() - A.Y())\n                    );\n\n                    return new Coords(\n                        Const.COORDS_BY_USER,\n                        [\n                            (a * A.X() + b * B.X() + c * C.X()) / (a + b + c),\n                            (a * A.Y() + b * B.Y() + c * C.Y()) / (a + b + c)\n                        ],\n                        board\n                    );\n                }\n            ],\n            attributes\n        );\n\n        for (i = 0; i < 3; i++) {\n            if (Type.exists(parents[i]._is_new)) {\n                p.addChild(parents[i]);\n                delete parents[i]._is_new;\n            } else {\n                parents[i].addChild(p);\n            }\n        }\n\n        p.elType = \"incenter\";\n        p.setParents(parents);\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create incenter with parent types '\" +\n                typeof parents[0] +\n                \"', '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point,point]\"\n        );\n    }\n\n    return p;\n};\n\n/**\n * @class A circumcircle is given by three points which are all lying on the circle.\n * @pseudo\n * @constructor\n * @name Circumcircle\n * @type JXG.Circle\n * @augments JXG.Circle\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The constructed element is the circle determined by <tt>p1</tt>, <tt>p2</tt>, and <tt>p3</tt>.\n * @example\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var p3 = board.create('point', [3.0, 3.0]);\n *\n * var cc1 = board.create('circumcircle', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXGe65c9861-0bf0-402d-af57-3ab11962f5ac\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var ccex1_board = JXG.JSXGraph.initBoard('JXGe65c9861-0bf0-402d-af57-3ab11962f5ac', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var ccex1_p1 = ccex1_board.create('point', [0.0, 2.0]);\n *   var ccex1_p2 = ccex1_board.create('point', [6.0, 1.0]);\n *   var ccex1_p3 = ccex1_board.create('point', [3.0, 7.0]);\n *   var ccex1_cc1 = ccex1_board.create('circumcircle', [ccex1_p1, ccex1_p2, ccex1_p3]);\n * </script><pre>\n */\nJXG.createCircumcircle = function (board, parents, attributes) {\n    var p, c, attr, i;\n\n    parents = Type.providePoints(board, parents, attributes, \"point\");\n    if (parents === false) {\n        throw new Error(\n            \"JSXGraph: Can't create circumcircle with parent types '\" +\n                typeof parents[0] +\n                \"', '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point,point]\"\n        );\n    }\n\n    try {\n        attr = Type.copyAttributes(attributes, board.options, \"circumcircle\", \"center\");\n        p = JXG.createCircumcenter(board, parents, attr);\n\n        p.dump = false;\n\n        if (!Type.exists(attributes.layer)) {\n            attributes.layer = board.options.layer.circle;\n        }\n        attr = Type.copyAttributes(attributes, board.options, \"circumcircle\");\n        c = Circle.createCircle(board, [p, parents[0]], attr);\n\n        c.elType = \"circumcircle\";\n        c.setParents(parents);\n        c.subs = {\n            center: p\n        };\n        c.inherits.push(c);\n        for (i = 0; i < 3; i++) {\n            if (Type.exists(parents[i]._is_new)) {\n                c.addChild(parents[i]);\n                delete parents[i]._is_new;\n            } else {\n                parents[i].addChild(c);\n            }\n        }\n    } catch (e) {\n        throw new Error(\n            \"JSXGraph: Can't create circumcircle with parent types '\" +\n                typeof parents[0] +\n                \"', '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point,point]\"\n        );\n    }\n\n    // p is already stored as midpoint in c so there's no need to store it explicitly.\n\n    return c;\n};\n\n/**\n * @class An incircle is given by three points.\n * @pseudo\n * @constructor\n * @name Incircle\n * @type JXG.Circle\n * @augments JXG.Circle\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point_JXG.Point} p1,p2,p3 The constructed point is the midpoint of the incircle of\n * <tt>p1</tt>, <tt>p2</tt>, and <tt>p3</tt>.\n * @example\n * var p1 = board.create('point', [0.0, 2.0]);\n * var p2 = board.create('point', [2.0, 1.0]);\n * var p3 = board.create('point', [3.0, 3.0]);\n *\n * var ic1 = board.create('incircle', [p1, p2, p3]);\n * </pre><div class=\"jxgbox\" id=\"JXGe65c9861-0bf0-402d-af57-2ab12962f8ac\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var icex1_board = JXG.JSXGraph.initBoard('JXGe65c9861-0bf0-402d-af57-2ab12962f8ac', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var icex1_p1 = icex1_board.create('point', [0.0, 2.0]);\n *   var icex1_p2 = icex1_board.create('point', [6.0, 1.0]);\n *   var icex1_p3 = icex1_board.create('point', [3.0, 7.0]);\n *   var icex1_ic1 = icex1_board.create('incircle', [icex1_p1, icex1_p2, icex1_p3]);\n * </script><pre>\n */\nJXG.createIncircle = function (board, parents, attributes) {\n    var i, p, c, attr;\n\n    parents = Type.providePoints(board, parents, attributes, \"point\");\n    if (parents === false) {\n        throw new Error(\n            \"JSXGraph: Can't create circumcircle with parent types '\" +\n                typeof parents[0] +\n                \"', '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point,point]\"\n        );\n    }\n    try {\n        attr = Type.copyAttributes(attributes, board.options, \"incircle\", \"center\");\n        p = JXG.createIncenter(board, parents, attr);\n\n        p.dump = false;\n\n        if (!Type.exists(attributes.layer)) {\n            attributes.layer = board.options.layer.circle;\n        }\n        attr = Type.copyAttributes(attributes, board.options, \"incircle\");\n        c = Circle.createCircle(\n            board,\n            [\n                p,\n                function () {\n                    var a = Math.sqrt(\n                            (parents[1].X() - parents[2].X()) *\n                                (parents[1].X() - parents[2].X()) +\n                                (parents[1].Y() - parents[2].Y()) *\n                                    (parents[1].Y() - parents[2].Y())\n                        ),\n                        b = Math.sqrt(\n                            (parents[0].X() - parents[2].X()) *\n                                (parents[0].X() - parents[2].X()) +\n                                (parents[0].Y() - parents[2].Y()) *\n                                    (parents[0].Y() - parents[2].Y())\n                        ),\n                        c = Math.sqrt(\n                            (parents[1].X() - parents[0].X()) *\n                                (parents[1].X() - parents[0].X()) +\n                                (parents[1].Y() - parents[0].Y()) *\n                                    (parents[1].Y() - parents[0].Y())\n                        ),\n                        s = (a + b + c) / 2;\n\n                    return Math.sqrt(((s - a) * (s - b) * (s - c)) / s);\n                }\n            ],\n            attr\n        );\n\n        c.elType = \"incircle\";\n        c.setParents(parents);\n        for (i = 0; i < 3; i++) {\n            if (Type.exists(parents[i]._is_new)) {\n                c.addChild(parents[i]);\n                delete parents[i]._is_new;\n            } else {\n                parents[i].addChild(c);\n            }\n        }\n\n        /**\n         * The center of the incircle\n         * @memberOf Incircle.prototype\n         * @type Incenter\n         * @name center\n         */\n        c.center = p;\n\n        c.subs = {\n            center: c.center\n        };\n        c.inherits.push(p);\n    } catch (e) {\n        throw new Error(\n            \"JSXGraph: Can't create circumcircle with parent types '\" +\n                typeof parents[0] +\n                \"', '\" +\n                typeof parents[1] +\n                \"' and '\" +\n                typeof parents[2] +\n                \"'.\" +\n                \"\\nPossible parent types: [point,point,point]\"\n        );\n    }\n\n    // p is already stored as midpoint in c so there's no need to store it explicitly.\n\n    return c;\n};\n\n/**\n * @class This element is used to construct reflected elements (points, lines, circles, curves, polygons).\n * @pseudo\n * @description A reflected element (point, polygon, line or curve) is given by a given\n * object of the same type and a line of reflection.\n * It is determined by the reflection of the given element\n * across the given line.\n * @constructor\n * @name Reflection\n * @type JXG.GeometryElement\n * @augments JXG.GeometryElement\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point|JXG.Line|JXG.Curve|JXG.Polygon_JXG.Line} p,l The reflection element is the reflection of p across the line l.\n * @example\n * var p1 = board.create('point', [0.0, 4.0]);\n * var p2 = board.create('point', [6.0, 1.0]);\n * var l1 = board.create('line', [p1, p2]);\n * var p3 = board.create('point', [3.0, 3.0]);\n *\n * var rp1 = board.create('reflection', [p3, l1]);\n * </pre><div class=\"jxgbox\" id=\"JXG087a798e-a36a-4f52-a2b4-29a23a69393b\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var rpex1_board = JXG.JSXGraph.initBoard('JXG087a798e-a36a-4f52-a2b4-29a23a69393b', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var rpex1_p1 = rpex1_board.create('point', [0.0, 4.0]);\n *   var rpex1_p2 = rpex1_board.create('point', [6.0, 1.0]);\n *   var rpex1_l1 = rpex1_board.create('line', [rpex1_p1, rpex1_p2]);\n *   var rpex1_p3 = rpex1_board.create('point', [3.0, 3.0]);\n *   var rpex1_rp1 = rpex1_board.create('reflection', [rpex1_p3, rpex1_l1]);\n * </script><pre>\n * @example\n *         // Reflection of more elements\n *         // reflection line\n *         var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *\n *         var p1 = board.create('point', [-3,-1], {name: \"A\"});\n *         var q1 = board.create('reflection', [p1, li], {name: \"A'\"});\n *\n *         var l1 = board.create('line', [1,-5,1]);\n *         var l2 = board.create('reflection', [l1, li]);\n *\n *         var cu1 = board.create('curve', [[-3, -3, -2.5, -3, -3, -2.5], [-3, -2, -2, -2, -2.5, -2.5]], {strokeWidth:3});\n *         var cu2 = board.create('reflection', [cu1, li], {strokeColor: 'red', strokeWidth:3});\n *\n *         var pol1 = board.create('polygon', [[-6,-3], [-4,-5], [-5,-1.5]]);\n *         var pol2 = board.create('reflection', [pol1, li]);\n *\n *         var c1 = board.create('circle', [[-2,-2], [-2, -1]]);\n *         var c2 = board.create('reflection', [c1, li]);\n *\n *         var a1 = board.create('arc', [[1, 1], [0, 1], [1, 0]], {strokeColor: 'red'});\n *         var a2 = board.create('reflection', [a1, li], {strokeColor: 'red'});\n *\n *         var s1 = board.create('sector', [[-3.5,-3], [-3.5, -2], [-3.5,-4]], {\n *                           anglePoint: {visible:true}, center: {visible: true}, radiusPoint: {visible: true},\n *                           fillColor: 'yellow', strokeColor: 'black'});\n *         var s2 = board.create('reflection', [s1, li], {fillColor: 'yellow', strokeColor: 'black', fillOpacity: 0.5});\n *\n *         var an1 = board.create('angle', [[-4,3.9], [-3, 4], [-3, 3]]);\n *         var an2 = board.create('reflection', [an1, li]);\n *\n * </pre><div id=\"JXG8f763af4-d449-11e7-93b3-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG8f763af4-d449-11e7-93b3-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             // reflection line\n *             var li = board.create('line', [1,1,1], {strokeColor: '#aaaaaa'});\n *\n *             var p1 = board.create('point', [-3,-1], {name: \"A\"});\n *             var q1 = board.create('reflection', [p1, li], {name: \"A'\"});\n *\n *             var l1 = board.create('line', [1,-5,1]);\n *             var l2 = board.create('reflection', [l1, li]);\n *\n *             var cu1 = board.create('curve', [[-3, -3, -2.5, -3, -3, -2.5], [-3, -2, -2, -2, -2.5, -2.5]], {strokeWidth:3});\n *             var cu2 = board.create('reflection', [cu1, li], {strokeColor: 'red', strokeWidth:3});\n *\n *             var pol1 = board.create('polygon', [[-6,-3], [-4,-5], [-5,-1.5]]);\n *             var pol2 = board.create('reflection', [pol1, li]);\n *\n *             var c1 = board.create('circle', [[-2,-2], [-2, -1]]);\n *             var c2 = board.create('reflection', [c1, li]);\n *\n *         var a1 = board.create('arc', [[1, 1], [0, 1], [1, 0]], {strokeColor: 'red'});\n *         var a2 = board.create('reflection', [a1, li], {strokeColor: 'red'});\n *\n *         var s1 = board.create('sector', [[-3.5,-3], [-3.5, -2], [-3.5,-4]], {\n *                           anglePoint: {visible:true}, center: {visible: true}, radiusPoint: {visible: true},\n *                           fillColor: 'yellow', strokeColor: 'black'});\n *         var s2 = board.create('reflection', [s1, li], {fillColor: 'yellow', strokeColor: 'black', fillOpacity: 0.5});\n *\n *         var an1 = board.create('angle', [[-4,3.9], [-3, 4], [-3, 3]]);\n *         var an2 = board.create('reflection', [an1, li]);\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createReflection = function (board, parents, attributes) {\n    var l,\n        org,\n        r,\n        r_c,\n        t,\n        i,\n        attr,\n        attr2,\n        errStr = \"\\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, line]\";\n\n    for (i = 0; i < parents.length; ++i) {\n        parents[i] = board.select(parents[i]);\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"reflection\");\n\n    if (Type.isPoint(parents[0])) {\n        org = Type.providePoints(board, [parents[0]], attr2)[0];\n    } else if (\n        parents[0].elementClass === Const.OBJECT_CLASS_CURVE ||\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE ||\n        parents[0].type === Const.OBJECT_TYPE_POLYGON ||\n        parents[0].elementClass === Const.OBJECT_CLASS_CIRCLE\n    ) {\n        org = parents[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create reflection element with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                errStr\n        );\n    }\n\n    if (parents[1].elementClass === Const.OBJECT_CLASS_LINE) {\n        l = parents[1];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create reflected element with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                errStr\n        );\n    }\n    t = Transform.createTransform(board, [l], { type: \"reflect\" });\n\n    if (Type.isPoint(org)) {\n        r = Point.createPoint(board, [org, t], attr);\n\n        // Arcs and sectors are treated as curves\n    } else if (org.elementClass === Const.OBJECT_CLASS_CURVE) {\n        r = Curve.createCurve(board, [org, t], attr);\n    } else if (org.elementClass === Const.OBJECT_CLASS_LINE) {\n        r = Line.createLine(board, [org, t], attr);\n    } else if (org.type === Const.OBJECT_TYPE_POLYGON) {\n        r = Polygon.createPolygon(board, [org, t], attr);\n    } else if (org.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n        if (attr.type.toLowerCase() === \"euclidean\") {\n            // Create a circle element from a circle and a Euclidean transformation\n            attr2 = Type.copyAttributes(attributes, board.options, \"reflection\", \"center\");\n            r_c = Point.createPoint(board, [org.center, t], attr2);\n            r_c.prepareUpdate()\n                .update()\n                .updateVisibility(Type.evaluate(r_c.visProp.visible))\n                .updateRenderer();\n            r = Circle.createCircle(\n                board,\n                [\n                    r_c,\n                    function () {\n                        return org.Radius();\n                    }\n                ],\n                attr\n            );\n        } else {\n            // Create a conic element from a circle and a projective transformation\n            r = Circle.createCircle(board, [org, t], attr);\n        }\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create reflected element with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                errStr\n        );\n    }\n\n    if (Type.exists(org._is_new)) {\n        r.addChild(org);\n        delete org._is_new;\n    } else {\n        // org.addChild(r);\n    }\n    l.addChild(r);\n\n    r.elType = \"reflection\";\n    r.addParents(l);\n    r.prepareUpdate().update(); //.updateVisibility(Type.evaluate(r.visProp.visible)).updateRenderer();\n\n    if (Type.isPoint(r)) {\n        r.generatePolynomial = function () {\n            /*\n             *  Reflection takes a point R and a line L and creates point P, which is the reflection of R on L.\n             *  L is defined by two points A and B.\n             *\n             * So we have two conditions:\n             *\n             *   (a)   RP  _|_  AB            (orthogonality condition)\n             *   (b)   AR  ==   AP            (distance condition)\n             *\n             */\n            var a1 = l.point1.symbolic.x,\n                a2 = l.point1.symbolic.y,\n                b1 = l.point2.symbolic.x,\n                b2 = l.point2.symbolic.y,\n                p1 = org.symbolic.x,\n                p2 = org.symbolic.y,\n                r1 = r.symbolic.x,\n                r2 = r.symbolic.y,\n                poly1 = [\n                    \"((\",\n                    r2,\n                    \")-(\",\n                    p2,\n                    \"))*((\",\n                    a2,\n                    \")-(\",\n                    b2,\n                    \"))+((\",\n                    a1,\n                    \")-(\",\n                    b1,\n                    \"))*((\",\n                    r1,\n                    \")-(\",\n                    p1,\n                    \"))\"\n                ].join(\"\"),\n                poly2 = [\n                    \"((\",\n                    r1,\n                    \")-(\",\n                    a1,\n                    \"))^2+((\",\n                    r2,\n                    \")-(\",\n                    a2,\n                    \"))^2-((\",\n                    p1,\n                    \")-(\",\n                    a1,\n                    \"))^2-((\",\n                    p2,\n                    \")-(\",\n                    a2,\n                    \"))^2\"\n                ].join(\"\");\n\n            return [poly1, poly2];\n        };\n    }\n\n    return r;\n};\n\n/**\n * @class A mirror element of a point, line, circle, curve, polygon will be constructed.\n * @pseudo\n * @description A mirror element is determined by the reflection of a given point, line, circle, curve, polygon across another given point.\n * @constructor\n * @name Mirrorelement\n * @type JXG.GeometryElement\n * @augments JXG.GeometryElement\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point|JXG.Line|JXG.Curve|JXG.Ppolygon_JXG.Point} p1,p2 The constructed element is the mirror image of p2 across p1.\n * @example\n *         // point of reflection\n *         var mirr = board.create('point', [-1,-1], {color: '#aaaaaa'});\n *\n *         var p1 = board.create('point', [-3,-1], {name: \"A\"});\n *         var q1 = board.create('mirrorelement', [p1, mirr], {name: \"A'\"});\n *\n *         var l1 = board.create('line', [1, -5, 1]);\n *         var l2 = board.create('mirrorelement', [l1, mirr]);\n *\n *         var cu1 = board.create('curve', [[-3, -3, -2.5, -3, -3, -2.5], [-3, -2, -2, -2, -2.5, -2.5]], {strokeWidth:3});\n *         var cu2 = board.create('mirrorelement', [cu1, mirr], {strokeColor: 'red', strokeWidth:3});\n *\n *         var pol1 = board.create('polygon', [[-6,-2], [-4,-4], [-5,-0.5]]);\n *         var pol2 = board.create('mirrorelement', [pol1, mirr]);\n *\n *         var c1 = board.create('circle', [[-6,-6], [-6, -5]]);\n *         var c2 = board.create('mirrorelement', [c1, mirr]);\n *\n *         var a1 = board.create('arc', [[1, 1], [0, 1], [1, 0]], {strokeColor: 'red'});\n *         var a2 = board.create('mirrorelement', [a1, mirr], {strokeColor: 'red'});\n *\n *         var s1 = board.create('sector', [[-3.5,-3], [-3.5, -2], [-3.5,-4]], {\n *                           anglePoint: {visible:true}, center: {visible: true}, radiusPoint: {visible: true},\n *                           fillColor: 'yellow', strokeColor: 'black'});\n *         var s2 = board.create('mirrorelement', [s1, mirr], {fillColor: 'yellow', strokeColor: 'black', fillOpacity: 0.5});\n *\n *         var an1 = board.create('angle', [[-4,3.9], [-3, 4], [-3, 3]]);\n *         var an2 = board.create('mirrorelement', [an1, mirr]);\n *\n *\n * </pre><div id=\"JXG026c779c-d8d9-11e7-93b3-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG026c779c-d8d9-11e7-93b3-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             // point of reflection\n *             var mirr = board.create('point', [-1,-1], {color: '#aaaaaa'});\n *\n *             var p1 = board.create('point', [-3,-1], {name: \"A\"});\n *             var q1 = board.create('mirrorelement', [p1, mirr], {name: \"A'\"});\n *\n *             var l1 = board.create('line', [1,-5, 1]);\n *             var l2 = board.create('mirrorelement', [l1, mirr]);\n *\n *             var cu1 = board.create('curve', [[-3, -3, -2.5, -3, -3, -2.5], [-3, -2, -2, -2, -2.5, -2.5]], {strokeWidth:3});\n *             var cu2 = board.create('mirrorelement', [cu1, mirr], {strokeColor: 'red', strokeWidth:3});\n *\n *             var pol1 = board.create('polygon', [[-6,-2], [-4,-4], [-5,-0.5]]);\n *             var pol2 = board.create('mirrorelement', [pol1, mirr]);\n *\n *             var c1 = board.create('circle', [[-6,-6], [-6, -5]]);\n *             var c2 = board.create('mirrorelement', [c1, mirr]);\n *\n *         var a1 = board.create('arc', [[1, 1], [0, 1], [1, 0]], {strokeColor: 'red'});\n *         var a2 = board.create('mirrorelement', [a1, mirr], {strokeColor: 'red'});\n *\n *         var s1 = board.create('sector', [[-3.5,-3], [-3.5, -2], [-3.5,-4]], {\n *                           anglePoint: {visible:true}, center: {visible: true}, radiusPoint: {visible: true},\n *                           fillColor: 'yellow', strokeColor: 'black'});\n *         var s2 = board.create('mirrorelement', [s1, mirr], {fillColor: 'yellow', strokeColor: 'black', fillOpacity: 0.5});\n *\n *         var an1 = board.create('angle', [[-4,3.9], [-3, 4], [-3, 3]]);\n *         var an2 = board.create('mirrorelement', [an1, mirr]);\n *\n *     })();\n *\n * </script><pre>\n */\nJXG.createMirrorElement = function (board, parents, attributes) {\n    var org,\n        i,\n        m,\n        r,\n        r_c,\n        t,\n        attr,\n        attr2,\n        errStr = \"\\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, point]\";\n\n    for (i = 0; i < parents.length; ++i) {\n        parents[i] = board.select(parents[i]);\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"mirrorelement\");\n    if (Type.isPoint(parents[0])) {\n        // Create point to be mirrored if supplied by coords array.\n        org = Type.providePoints(board, [parents[0]], attr)[0];\n    } else if (\n        parents[0].elementClass === Const.OBJECT_CLASS_CURVE ||\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE ||\n        parents[0].type === Const.OBJECT_TYPE_POLYGON ||\n        parents[0].elementClass === Const.OBJECT_CLASS_CIRCLE\n    ) {\n        org = parents[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create mirror element with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                errStr\n        );\n    }\n\n    if (Type.isPoint(parents[1])) {\n        attr2 = Type.copyAttributes(attributes, board.options, \"mirrorelement\", \"point\");\n        // Create mirror point if supplied by coords array.\n        m = Type.providePoints(board, [parents[1]], attr2)[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create mirror element with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                errStr\n        );\n    }\n\n    t = Transform.createTransform(board, [Math.PI, m], { type: \"rotate\" });\n    if (Type.isPoint(org)) {\n        r = Point.createPoint(board, [org, t], attr);\n\n        // Arcs and sectors are treated as curves\n    } else if (org.elementClass === Const.OBJECT_CLASS_CURVE) {\n        r = Curve.createCurve(board, [org, t], attr);\n    } else if (org.elementClass === Const.OBJECT_CLASS_LINE) {\n        r = Line.createLine(board, [org, t], attr);\n    } else if (org.type === Const.OBJECT_TYPE_POLYGON) {\n        r = Polygon.createPolygon(board, [org, t], attr);\n    } else if (org.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n        if (attr.type.toLowerCase() === \"euclidean\") {\n            // Create a circle element from a circle and a Euclidean transformation\n            attr2 = Type.copyAttributes(attributes, board.options, \"mirrorelement\", \"center\");\n            r_c = Point.createPoint(board, [org.center, t], attr2);\n            r_c.prepareUpdate()\n                .update()\n                .updateVisibility(Type.evaluate(r_c.visProp.visible))\n                .updateRenderer();\n            r = Circle.createCircle(\n                board,\n                [\n                    r_c,\n                    function () {\n                        return org.Radius();\n                    }\n                ],\n                attr\n            );\n        } else {\n            // Create a conic element from a circle and a projective transformation\n            r = Circle.createCircle(board, [org, t], attr);\n        }\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create mirror element with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                errStr\n        );\n    }\n\n    if (Type.exists(org._is_new)) {\n        r.addChild(org);\n        delete org._is_new;\n    } else {\n        // org.addChild(r);\n    }\n    m.addChild(r);\n\n    r.elType = \"mirrorelement\";\n    r.addParents(m);\n    r.prepareUpdate().update();\n\n    return r;\n};\n\n/**\n * @class A mirror point will be constructed.\n * @pseudo\n * @description A mirror point is determined by the reflection of a given point against another given point.\n * @constructor\n * @name Mirrorpoint\n * @type JXG.Point\n * @augments JXG.Point\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point_JXG.Point} p1,p2 The constructed point is the reflection of p2 against p1.\n *\n * This method is superseeded by the more general {@link JXG.createMirrorElement}.\n * @example\n * var p1 = board.create('point', [3.0, 3.0]);\n * var p2 = board.create('point', [6.0, 1.0]);\n *\n * var mp1 = board.create('mirrorpoint', [p1, p2]);\n * </pre><div class=\"jxgbox\" id=\"JXG7eb2a814-6c4b-4caa-8cfa-4183a948d25b\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var mpex1_board = JXG.JSXGraph.initBoard('JXG7eb2a814-6c4b-4caa-8cfa-4183a948d25b', {boundingbox: [-1, 9, 9, -1], axis: true, showcopyright: false, shownavigation: false});\n *   var mpex1_p1 = mpex1_board.create('point', [3.0, 3.0]);\n *   var mpex1_p2 = mpex1_board.create('point', [6.0, 1.0]);\n *   var mpex1_mp1 = mpex1_board.create('mirrorpoint', [mpex1_p1, mpex1_p2]);\n * </script><pre>\n */\nJXG.createMirrorPoint = function (board, parents, attributes) {\n    var el = JXG.createMirrorElement(board, parents, attributes);\n    el.elType = \"mirrorpoint\";\n    return el;\n};\n\n/**\n * @class This element is used to visualize the integral of a given curve over a given interval.\n * @pseudo\n * @description The Integral element is used to visualize the area under a given curve over a given interval\n * and to calculate the area's value. For that a polygon and gliders are used. The polygon displays the area,\n * the gliders are used to change the interval dynamically.\n * @constructor\n * @name Integral\n * @type JXG.Curve\n * @augments JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Array_JXG.Curve} i,c The constructed element covers the area between the curve <tt>c</tt> and the x-axis\n * within the interval <tt>i</tt>.\n * @example\n * var c1 = board.create('functiongraph', [function (t) { return Math.cos(t)*t; }]);\n * var i1 = board.create('integral', [[-2.0, 2.0], c1]);\n * </pre><div class=\"jxgbox\" id=\"JXGd45d7188-6624-4d6e-bebb-1efa2a305c8a\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var intex1_board = JXG.JSXGraph.initBoard('JXGd45d7188-6624-4d6e-bebb-1efa2a305c8a', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false});\n *   var intex1_c1 = intex1_board.create('functiongraph', [function (t) { return Math.cos(t)*t; }]);\n *   var intex1_i1 = intex1_board.create('integral', [[-2.0, 2.0], intex1_c1]);\n * </script><pre>\n */\nJXG.createIntegral = function (board, parents, attributes) {\n    var interval,\n        curve,\n        attr,\n        start,\n        end,\n        startx,\n        starty,\n        endx,\n        endy,\n        pa_on_curve,\n        pa_on_axis,\n        pb_on_curve,\n        pb_on_axis,\n        t = null,\n        p;\n\n    if (Type.isArray(parents[0]) && parents[1].elementClass === Const.OBJECT_CLASS_CURVE) {\n        interval = parents[0];\n        curve = parents[1];\n    } else if (\n        Type.isArray(parents[1]) &&\n        parents[0].elementClass === Const.OBJECT_CLASS_CURVE\n    ) {\n        interval = parents[1];\n        curve = parents[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create integral with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [[number|function,number|function],curve]\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"integral\");\n    attr.withLabel = false; // There is a custom 'label' below.\n    p = board.create(\"curve\", [[0], [0]], attr);\n\n    // Correct the interval if necessary - NOT ANYMORE, GGB's fault\n    start = interval[0];\n    end = interval[1];\n\n    if (Type.isFunction(start)) {\n        startx = start;\n        starty = function () {\n            return curve.Y(startx());\n        };\n        start = startx();\n    } else {\n        startx = start;\n        starty = curve.Y(start);\n    }\n\n    if (Type.isFunction(end)) {\n        endx = end;\n        endy = function () {\n            return curve.Y(endx());\n        };\n        end = endx();\n    } else {\n        endx = end;\n        endy = curve.Y(end);\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"integral\", \"curveLeft\");\n    pa_on_curve = board.create(\"glider\", [startx, starty, curve], attr);\n    if (Type.isFunction(startx)) {\n        pa_on_curve.hideElement();\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"integral\", \"baseLeft\");\n    pa_on_axis = board.create(\n        \"point\",\n        [\n            function () {\n                if (Type.evaluate(p.visProp.axis) === \"y\") {\n                    return 0;\n                }\n\n                return pa_on_curve.X();\n            },\n            function () {\n                if (Type.evaluate(p.visProp.axis) === \"y\") {\n                    return pa_on_curve.Y();\n                }\n\n                return 0;\n            }\n        ],\n        attr\n    );\n\n    attr = Type.copyAttributes(attributes, board.options, \"integral\", \"curveRight\");\n    pb_on_curve = board.create(\"glider\", [endx, endy, curve], attr);\n    if (Type.isFunction(endx)) {\n        pb_on_curve.hideElement();\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"integral\", \"baseRight\");\n    pb_on_axis = board.create(\n        \"point\",\n        [\n            function () {\n                if (Type.evaluate(p.visProp.axis) === \"y\") {\n                    return 0;\n                }\n                return pb_on_curve.X();\n            },\n            function () {\n                if (Type.evaluate(p.visProp.axis) === \"y\") {\n                    return pb_on_curve.Y();\n                }\n\n                return 0;\n            }\n        ],\n        attr\n    );\n\n    attr = Type.copyAttributes(attributes, board.options, \"integral\");\n    if (attr.withlabel !== false && attr.axis !== \"y\") {\n        attr = Type.copyAttributes(attributes, board.options, \"integral\", \"label\");\n        attr = Type.copyAttributes(attr, board.options, \"label\");\n\n        t = board.create(\n            \"text\",\n            [\n                function () {\n                    var off = new Coords(\n                            Const.COORDS_BY_SCREEN,\n                            [\n                                Type.evaluate(this.visProp.offset[0]) +\n                                    this.board.origin.scrCoords[1],\n                                0\n                            ],\n                            this.board,\n                            false\n                        ),\n                        bb = this.board.getBoundingBox(),\n                        dx = (bb[2] - bb[0]) * 0.1,\n                        x = pb_on_curve.X();\n\n                    if (x < bb[0]) {\n                        x = bb[0] + dx;\n                    } else if (x > bb[2]) {\n                        x = bb[2] - dx;\n                    }\n\n                    return x + off.usrCoords[1];\n                },\n                function () {\n                    var off = new Coords(\n                            Const.COORDS_BY_SCREEN,\n                            [\n                                0,\n                                Type.evaluate(this.visProp.offset[1]) +\n                                    this.board.origin.scrCoords[2]\n                            ],\n                            this.board,\n                            false\n                        ),\n                        bb = this.board.getBoundingBox(),\n                        dy = (bb[1] - bb[3]) * 0.1,\n                        y = pb_on_curve.Y();\n\n                    if (y > bb[1]) {\n                        y = bb[1] - dy;\n                    } else if (y < bb[3]) {\n                        y = bb[3] + dy;\n                    }\n\n                    return y + off.usrCoords[2];\n                },\n                function () {\n                    var Int = Numerics.NewtonCotes([pa_on_axis.X(), pb_on_axis.X()], curve.Y);\n                    return \"&int; = \" + Type.toFixed(Int, 4);\n                }\n            ],\n            attr\n        );\n\n        t.dump = false;\n\n        pa_on_curve.addChild(t);\n        pb_on_curve.addChild(t);\n    }\n\n    // dump stuff\n    pa_on_curve.dump = false;\n    pa_on_axis.dump = false;\n\n    pb_on_curve.dump = false;\n    pb_on_axis.dump = false;\n\n    p.elType = \"integral\";\n    p.setParents([curve.id, interval]);\n    p.subs = {\n        curveLeft: pa_on_curve,\n        baseLeft: pa_on_axis,\n        curveRight: pb_on_curve,\n        baseRight: pb_on_axis\n    };\n    p.inherits.push(pa_on_curve, pa_on_axis, pb_on_curve, pb_on_axis);\n\n    if (attr.withLabel) {\n        p.subs.label = t;\n        p.inherits.push(t);\n    }\n\n    /**\n     * Returns the current value of the integral.\n     * @memberOf Integral\n     * @name Value\n     * @function\n     * @returns {Number}\n     */\n    p.Value = function () {\n        return Numerics.I([pa_on_axis.X(), pb_on_axis.X()], curve.Y);\n    };\n\n    /**\n     * documented in JXG.Curve\n     * @ignore\n     */\n    p.updateDataArray = function () {\n        var x, y, i, left, right, lowx, upx, lowy, upy;\n\n        if (Type.evaluate(this.visProp.axis) === \"y\") {\n            if (pa_on_curve.Y() < pb_on_curve.Y()) {\n                lowx = pa_on_curve.X();\n                lowy = pa_on_curve.Y();\n                upx = pb_on_curve.X();\n                upy = pb_on_curve.Y();\n            } else {\n                lowx = pb_on_curve.X();\n                lowy = pb_on_curve.Y();\n                upx = pa_on_curve.X();\n                upy = pa_on_curve.Y();\n            }\n            left = Math.min(lowx, upx);\n            right = Math.max(lowx, upx);\n\n            x = [0, lowx];\n            y = [lowy, lowy];\n\n            for (i = 0; i < curve.numberPoints; i++) {\n                if (\n                    lowy <= curve.points[i].usrCoords[2] &&\n                    left <= curve.points[i].usrCoords[1] &&\n                    curve.points[i].usrCoords[2] <= upy &&\n                    curve.points[i].usrCoords[1] <= right\n                ) {\n                    x.push(curve.points[i].usrCoords[1]);\n                    y.push(curve.points[i].usrCoords[2]);\n                }\n            }\n            x.push(upx);\n            y.push(upy);\n            x.push(0);\n            y.push(upy);\n\n            // close the curve\n            x.push(0);\n            y.push(lowy);\n        } else {\n            if (pa_on_axis.X() < pb_on_axis.X()) {\n                left = pa_on_axis.X();\n                right = pb_on_axis.X();\n            } else {\n                left = pb_on_axis.X();\n                right = pa_on_axis.X();\n            }\n\n            x = [left, left];\n            y = [0, curve.Y(left)];\n\n            for (i = 0; i < curve.numberPoints; i++) {\n                if (\n                    left <= curve.points[i].usrCoords[1] &&\n                    curve.points[i].usrCoords[1] <= right\n                ) {\n                    x.push(curve.points[i].usrCoords[1]);\n                    y.push(curve.points[i].usrCoords[2]);\n                }\n            }\n            x.push(right);\n            y.push(curve.Y(right));\n            x.push(right);\n            y.push(0);\n\n            // close the curve\n            x.push(left);\n            y.push(0);\n        }\n\n        this.dataX = x;\n        this.dataY = y;\n    };\n\n    pa_on_curve.addChild(p);\n    pb_on_curve.addChild(p);\n    pa_on_axis.addChild(p);\n    pb_on_axis.addChild(p);\n\n    /**\n     * The point on the axis initially corresponding to the lower value of the interval.\n     *\n     * @name baseLeft\n     * @memberOf Integral\n     * @type JXG.Point\n     */\n    p.baseLeft = pa_on_axis;\n\n    /**\n     * The point on the axis initially corresponding to the higher value of the interval.\n     *\n     * @name baseRight\n     * @memberOf Integral\n     * @type JXG.Point\n     */\n    p.baseRight = pb_on_axis;\n\n    /**\n     * The glider on the curve corresponding to the lower value of the interval.\n     *\n     * @name curveLeft\n     * @memberOf Integral\n     * @type Glider\n     */\n    p.curveLeft = pa_on_curve;\n\n    /**\n     * The glider on the axis corresponding to the higher value of the interval.\n     *\n     * @name curveRight\n     * @memberOf Integral\n     * @type Glider\n     */\n    p.curveRight = pb_on_curve;\n\n    p.methodMap = JXG.deepCopy(p.methodMap, {\n        curveLeft: \"curveLeft\",\n        baseLeft: \"baseLeft\",\n        curveRight: \"curveRight\",\n        baseRight: \"baseRight\",\n        Value: \"Value\"\n    });\n\n    /**\n     * documented in GeometryElement\n     * @ignore\n     */\n    p.label = t;\n\n    return p;\n};\n\n/**\n * @class Creates a grid to support the user with element placement.\n * @pseudo\n * @description A grid is a set of vertical and horizontal lines to support the user with element placement. This method\n * draws such a grid on the given board. This method does not\n * take any parent elements. It is usually instantiated on the board's creation via the attribute <tt>grid</tt> set\n * to true.\n * @parameter None.\n * @constructor\n * @name Grid\n * @type JXG.Curve\n * @augments JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @example\n * grid = board.create('grid', []);\n * </pre><div class=\"jxgbox\" id=\"JXGa9a0671f-7a51-4fa2-8697-241142c00940\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *  board = JXG.JSXGraph.initBoard('JXGa9a0671f-7a51-4fa2-8697-241142c00940', {boundingbox:[-4, 6, 10, -6], axis: false, grid: false, keepaspectratio: true});\n *  grid = board.create('grid', []);\n * })();\n * </script><pre>\n */\nJXG.createGrid = function (board, parents, attributes) {\n    var c, attr;\n\n    attr = Type.copyAttributes(attributes, board.options, \"grid\");\n    c = board.create(\"curve\", [[null], [null]], attr);\n\n    c.elType = \"grid\";\n    c.type = Const.OBJECT_TYPE_GRID;\n\n    /**\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var start,\n            end,\n            i,\n            topLeft,\n            bottomRight,\n            gridX = Type.evaluate(this.visProp.gridx),\n            gridY = Type.evaluate(this.visProp.gridy);\n\n        if (Type.isArray(this.visProp.topleft)) {\n            topLeft = new Coords(\n                Type.evaluate(this.visProp.tltype) || Const.COORDS_BY_USER,\n                this.visProp.topleft,\n                board\n            );\n        } else {\n            topLeft = new Coords(Const.COORDS_BY_SCREEN, [0, 0], board);\n        }\n\n        if (Type.isArray(this.visProp.bottomright)) {\n            bottomRight = new Coords(\n                Type.evaluate(this.visProp.brtype) || Const.COORDS_BY_USER,\n                this.visProp.bottomright,\n                board\n            );\n        } else {\n            bottomRight = new Coords(\n                Const.COORDS_BY_SCREEN,\n                [board.canvasWidth, board.canvasHeight],\n                board\n            );\n        }\n\n        //\n        //      |         |         |\n        //  ----+---------+---------+-----\n        //      |        /|         |\n        //      |    gridY|     <---+------   Grid Cell\n        //      |        \\|         |\n        //  ----+---------+---------+-----\n        //      |         |\\ gridX /|\n        //      |         |         |\n        //\n        // uc: usercoordinates\n        //\n        // currently one grid cell is 1/JXG.Options.grid.gridX uc wide and 1/JXG.Options.grid.gridY uc high.\n        // this may work perfectly with GeonextReader (#readGeonext, initialization of gridX and gridY) but it\n        // is absolutely not user friendly when it comes to use it as an API interface.\n        // i changed this to use gridX and gridY as the actual width and height of the grid cell. for this i\n        // had to refactor these methods:\n        //\n        //  DONE JXG.Board.calculateSnapSizes (init p1, p2)\n        //  DONE JXG.GeonextReader.readGeonext (init gridX, gridY)\n        //\n\n        board.options.grid.hasGrid = true;\n\n        // fix_grid: adding integer function to calculation of start and end values, and adding to calculation of start and end values below\n        // To allow this:\n        // (axes on the outside, min value of grid = 0.25)\n        //\n        //      |    |         |          |\n        // 1.5 -+----+---------+----------+-----\n        //      |    |         |          |\n        //      |    |         |          |\n        //      |    |         |          |\n        //   1 -+----+---------+----------+-----\n        //      |    |         |          |\n        //      |    |         |          |\n        //      |    |         |          |\n        // 0.5 -+----+---------+----------+-----\n        //      |    |         |          |\n        //      +----+---------+----------+-----\n        //           |         |          |\n        //          0.5        1         1.5\n        //\n        // fix_grid: these lines disabled:\n        // topLeft.setCoordinates(Const.COORDS_BY_USER, [Math.ceil(topLeft.usrCoords[1] / gridX) * gridX, Math.floor(topLeft.usrCoords[2] / gridY) * gridY]);\n        // bottomRight.setCoordinates(Const.COORDS_BY_USER, [Math.floor(bottomRight.usrCoords[1] / gridX) * gridX, Math.ceil(bottomRight.usrCoords[2] / gridY) * gridY]);\n\n        c.dataX = [];\n        c.dataY = [];\n\n        // Sometimes the bounding box is used to invert the axis. We have to take this into account here.\n        // fix_grid: adding integer function to calculation of start and end values\n        start = Math.floor(topLeft.usrCoords[2] / gridY) * gridY;\n        end = Math.ceil(bottomRight.usrCoords[2] / gridY) * gridY;\n\n        if (topLeft.usrCoords[2] < bottomRight.usrCoords[2]) {\n            start = Math.ceil(bottomRight.usrCoords[2] / gridY) * gridY; // bottomRight.usrCoords[2];\n            end = Math.floor(topLeft.usrCoords[2] / gridY) * gridY;\n        }\n\n        // start with the horizontal grid:\n        for (i = start; i > end - gridY; i -= gridY) {\n            c.dataX.push(topLeft.usrCoords[1], bottomRight.usrCoords[1], NaN);\n            c.dataY.push(i, i, NaN);\n        }\n\n        // fix_grid: adding integer function to calculation of start and end values\n        start = Math.ceil(topLeft.usrCoords[1] / gridX) * gridX;\n        end = Math.floor(bottomRight.usrCoords[1] / gridX) * gridX;\n\n        if (topLeft.usrCoords[1] > bottomRight.usrCoords[1]) {\n            start = Math.floor(bottomRight.usrCoords[1] / gridX) * gridX;\n            end = Math.ceil(topLeft.usrCoords[1] / gridX) * gridX;\n        }\n\n        // build vertical grid\n        for (i = start; i < end + gridX; i += gridX) {\n            c.dataX.push(i, i, NaN);\n            c.dataY.push(topLeft.usrCoords[2], bottomRight.usrCoords[2], NaN);\n        }\n    };\n\n    // we don't care about highlighting so we turn it off completely to save a lot of\n    // time on every mouse move\n    c.hasPoint = function () {\n        return false;\n    };\n\n    board.grids.push(c);\n\n    return c;\n};\n\n/**\n * @class Creates an area indicating the solution of a linear inequality or an inequality\n * of a function graph, i.e. an inequality of type y <= f(x).\n * @pseudo\n * @description Display the solution set of a linear inequality (less than or equal to).\n * To be precise, the solution set of the inequality <i>y <= b/a * x + c/a</i> is shown.\n * In case <i>a = 0</i>, that is if the equation of the line is <i>bx + c = 0</i>,\n * the area of the inequality <i>bx + c <= 0</i> is shown.\n * <p>\n * For function graphs the area below the function graph is filled, i.e. the\n * area of the inequality y <= f(x).\n * With the attribute inverse:true the area of the inequality y >= f(x) is filled.\n *\n * @param {JXG.Line} l The area drawn will be the area below this line. With the attribute\n * inverse:true, the inequality 'greater than or equal to' is shown.\n * @constructor\n * @name Inequality\n * @type JXG.Curve\n * @augments JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @example\n * var p = board.create('point', [1, 3]),\n *     q = board.create('point', [-2, -4]),\n *     l = board.create('line', [p, q]),\n *     ineq = board.create('inequality', [l]);\n * ineq = board.create('inequality', [l]);\n * </pre><div class=\"jxgbox\" id=\"JXG2b703006-fd98-11e1-b79e-ef9e591c002e\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *  var board = JXG.JSXGraph.initBoard('JXG2b703006-fd98-11e1-b79e-ef9e591c002e', {boundingbox:[-4, 6, 10, -6], axis: false, grid: false, keepaspectratio: true}),\n *      p = board.create('point', [1, 3]),\n *      q = board.create('point', [-2, -4]),\n *      l = board.create('line', [p, q]),\n *      ineq = board.create('inequality', [l]);\n * })();\n * </script><pre>\n *\n * @example\n * // Plot the inequality\n * //     y >= 2/3 x + 1\n * // or\n * //     0 >= -3y + 2x +1\n * var l = board.create('line', [1, 2, -3]),\n *     ineq = board.create('inequality', [l], {inverse:true});\n * </pre><div class=\"jxgbox\" id=\"JXG1ded3812-2da4-4323-abaf-1db4bad1bfbd\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *  var board = JXG.JSXGraph.initBoard('JXG1ded3812-2da4-4323-abaf-1db4bad1bfbd', {boundingbox:[-4, 6, 10, -6], axis: false, grid: false, keepaspectratio: true}),\n *      l = board.create('line', [1, 2, -3]),\n *      ineq = board.create('inequality', [l], {inverse:true});\n * })();\n * </script><pre>\n *\n * @example\n * var f = board.create('functiongraph', ['sin(x)', -2*Math.PI, 2*Math.PI]);\n *\n * var ineq_lower = board.create('inequality', [f]);\n * var ineq_greater = board.create('inequality', [f], {inverse: true, fillColor: 'yellow'});\n *\n *\n * </pre><div id=\"JXGdb68c574-414c-11e8-839a-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGdb68c574-414c-11e8-839a-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var f = board.create('functiongraph', ['sin(x)', -2*Math.PI, 2*Math.PI]);\n *\n *     var ineq_lower = board.create('inequality', [f]);\n *     var ineq_greater = board.create('inequality', [f], {inverse: true, fillColor: 'yellow'});\n *\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createInequality = function (board, parents, attributes) {\n    var f, a, attr;\n\n    attr = Type.copyAttributes(attributes, board.options, \"inequality\");\n    if (parents[0].elementClass === Const.OBJECT_CLASS_LINE) {\n        a = board.create(\"curve\", [[], []], attr);\n        a.hasPoint = function () {\n            return false;\n        };\n        a.updateDataArray = function () {\n            var i1,\n                i2,\n                // This will be the height of the area. We mustn't rely upon the board height because if we pan the view\n                // such that the line is not visible anymore, the borders of the area will get visible in some cases.\n                h,\n                bb = board.getBoundingBox(),\n                factor = attr.inverse ? -1 : 1,\n                expansion = 1.5,\n                w = expansion * Math.max(bb[2] - bb[0], bb[1] - bb[3]),\n                // Fake a point (for Math.Geometry.perpendicular)\n                // contains centroid of the board\n                dp = {\n                    coords: {\n                        usrCoords: [1, (bb[0] + bb[2]) / 2, attr.inverse ? bb[1] : bb[3]]\n                    }\n                },\n                slope1 = parents[0].stdform.slice(1),\n                slope2 = slope1;\n\n            // This is wrong. Example:\n            // var line = board.create('line', [0, -1, -1]);\n            // var ineq = board.create('inequality', [line]);\n            //\n            // if (slope1[1] > 0) {\n            //     slope1 = Statistics.multiply(slope1, -1);\n            //     slope2 = slope1;\n            // }\n\n            // Calculate the area height as\n            //  expansion times the distance of the line to the\n            // point in the middle of the top/bottom border.\n            h =\n                expansion *\n                Math.max(\n                    Geometry.perpendicular(parents[0], dp, board)[0].distance(\n                        Const.COORDS_BY_USER,\n                        dp.coords\n                    ),\n                    w\n                );\n            h *= factor;\n\n            // reuse dp\n            dp = {\n                coords: {\n                    usrCoords: [1, (bb[0] + bb[2]) / 2, (bb[1] + bb[3]) / 2]\n                }\n            };\n\n            // If dp is on the line, Geometry.perpendicular will return a point not on the line.\n            // Since this somewhat odd behavior of Geometry.perpendicular is needed in GEONExT,\n            // it is circumvented here.\n            if (\n                Math.abs(Mat.innerProduct(dp.coords.usrCoords, parents[0].stdform, 3)) >=\n                Mat.eps\n            ) {\n                dp = Geometry.perpendicular(parents[0], dp, board)[0].usrCoords;\n            } else {\n                dp = dp.coords.usrCoords;\n            }\n            i1 = [1, dp[1] + slope1[1] * w, dp[2] - slope1[0] * w];\n            i2 = [1, dp[1] - slope2[1] * w, dp[2] + slope2[0] * w];\n\n            // One of the vectors based in i1 and orthogonal to the parent line has the direction d1 = (slope1, -1)\n            // We will go from i1 to to i1 + h*d1, from there to i2 + h*d2 (with d2 calculated equivalent to d1) and\n            // end up in i2.\n            this.dataX = [i1[1], i1[1] + slope1[0] * h, i2[1] + slope2[0] * h, i2[1], i1[1]];\n            this.dataY = [i1[2], i1[2] + slope1[1] * h, i2[2] + slope2[1] * h, i2[2], i1[2]];\n        };\n    } else if (\n        parents[0].elementClass === Const.OBJECT_CLASS_CURVE &&\n        parents[0].visProp.curvetype === \"functiongraph\"\n    ) {\n        a = board.create(\"curve\", [[], []], attr);\n        a.updateDataArray = function () {\n            var bbox = this.board.getBoundingBox(),\n                points = [],\n                infty,\n                first,\n                last,\n                len,\n                i,\n                mi = parents[0].minX(),\n                ma = parents[0].maxX(),\n                curve_mi,\n                curve_ma,\n                firstx,\n                lastx,\n                enlarge = (bbox[1] - bbox[3]) * 0.3, // enlarge the bbox vertically by this amount\n                inverse = Type.evaluate(this.visProp.inverse);\n\n            // inverse == true <=> Fill area with y >= f(x)\n            infty = inverse ? 1 : 3; // we will use either bbox[1] or bbox[3] below\n\n            this.dataX = [];\n            this.dataY = [];\n            len = parents[0].points.length;\n            if (len === 0) {\n                return;\n            }\n\n            bbox[1] += enlarge;\n            bbox[3] -= enlarge;\n\n            last = -1;\n            while (last < len - 1) {\n                // Find the first point with real coordinates on this curve segment\n                for (i = last + 1, first = len; i < len; i++) {\n                    if (parents[0].points[i].isReal()) {\n                        first = i;\n                        break;\n                    }\n                }\n                // No real points found -> exit\n                if (first >= len) {\n                    break;\n                }\n\n                // Find the last point with real coordinates on this curve segment\n                for (i = first, last = len - 1; i < len - 1; i++) {\n                    if (!parents[0].points[i + 1].isReal()) {\n                        last = i;\n                        break;\n                    }\n                }\n\n                firstx = parents[0].points[first].usrCoords[1];\n                lastx = parents[0].points[last].usrCoords[1];\n\n                // Restrict the plot interval if the function ends inside of the board\n                curve_mi = bbox[0] < mi ? mi : bbox[0];\n                curve_ma = bbox[2] > ma ? ma : bbox[2];\n\n                // Found NaNs\n                curve_mi = first === 0 ? curve_mi : Math.max(curve_mi, firstx);\n                curve_ma = last === len - 1 ? curve_ma : Math.min(curve_ma, lastx);\n\n                // First and last relevant x-coordinate of the curve\n                curve_mi = first === 0 ? mi : firstx;\n                curve_ma = last === len - 1 ? ma : lastx;\n\n                // Copy the curve points\n                points = [];\n\n                points.push([1, curve_mi, bbox[infty]]);\n                points.push([1, curve_mi, parents[0].points[first].usrCoords[2]]);\n                for (i = first; i <= last; i++) {\n                    points.push(parents[0].points[i].usrCoords);\n                }\n                points.push([1, curve_ma, parents[0].points[last].usrCoords[2]]);\n                points.push([1, curve_ma, bbox[infty]]);\n                points.push(points[0]);\n\n                for (i = 0; i < points.length; i++) {\n                    this.dataX.push(points[i][1]);\n                    this.dataY.push(points[i][2]);\n                }\n\n                if (last < len - 1) {\n                    this.dataX.push(NaN);\n                    this.dataY.push(NaN);\n                }\n            }\n        };\n\n        // Previous code:\n        a.hasPoint = function () {\n            return false;\n        };\n    } else {\n        // Not yet practical?\n        f = Type.createFunction(parents[0]);\n        if (!Type.exists(f)) {\n            throw new Error(\n                \"JSXGraph: Can't create area with the given parents.\" +\n                    \"\\nPossible parent types: [line], [function]\"\n            );\n        }\n    }\n\n    a.addParents(parents[0]);\n    return a;\n};\n\nJXG.registerElement(\"arrowparallel\", JXG.createArrowParallel);\nJXG.registerElement(\"bisector\", JXG.createBisector);\nJXG.registerElement(\"bisectorlines\", JXG.createAngularBisectorsOfTwoLines);\nJXG.registerElement(\"msector\", JXG.createMsector);\nJXG.registerElement(\"circumcircle\", JXG.createCircumcircle);\nJXG.registerElement(\"circumcirclemidpoint\", JXG.createCircumcenter);\nJXG.registerElement(\"circumcenter\", JXG.createCircumcenter);\nJXG.registerElement(\"incenter\", JXG.createIncenter);\nJXG.registerElement(\"incircle\", JXG.createIncircle);\nJXG.registerElement(\"integral\", JXG.createIntegral);\nJXG.registerElement(\"midpoint\", JXG.createMidpoint);\nJXG.registerElement(\"mirrorelement\", JXG.createMirrorElement);\nJXG.registerElement(\"mirrorpoint\", JXG.createMirrorPoint);\nJXG.registerElement(\"normal\", JXG.createNormal);\nJXG.registerElement(\"orthogonalprojection\", JXG.createOrthogonalProjection);\nJXG.registerElement(\"parallel\", JXG.createParallel);\nJXG.registerElement(\"parallelpoint\", JXG.createParallelPoint);\nJXG.registerElement(\"perpendicular\", JXG.createPerpendicular);\nJXG.registerElement(\"perpendicularpoint\", JXG.createPerpendicularPoint);\nJXG.registerElement(\"perpendicularsegment\", JXG.createPerpendicularSegment);\nJXG.registerElement(\"reflection\", JXG.createReflection);\nJXG.registerElement(\"grid\", JXG.createGrid);\nJXG.registerElement(\"inequality\", JXG.createInequality);\n\nexport default {\n    createArrowParallel: JXG.createArrowParallel,\n    createBisector: JXG.createBisector,\n    createAngularBisectorOfTwoLines: JXG.createAngularBisectorsOfTwoLines,\n    createCircumcircle: JXG.createCircumcircle,\n    createCircumcenter: JXG.createCircumcenter,\n    createIncenter: JXG.createIncenter,\n    createIncircle: JXG.createIncircle,\n    createIntegral: JXG.createIntegral,\n    createMidpoint: JXG.createMidpoint,\n    createMirrorElement: JXG.createMirrorElement,\n    createMirrorPoint: JXG.createMirrorPoint,\n    createNormal: JXG.createNormal,\n    createOrthogonalProjection: JXG.createOrthogonalProjection,\n    createParallel: JXG.createParallel,\n    createParallelPoint: JXG.createParallelPoint,\n    createPerpendicular: JXG.createPerpendicular,\n    createPerpendicularPoint: JXG.createPerpendicularPoint,\n    createPerpendicularSegmen: JXG.createPerpendicularSegment,\n    createReflection: JXG.createReflection,\n    createGrid: JXG.createGrid,\n    createInequality: JXG.createInequality\n};\n","/*\n Copyright 2008-2022\n Matthias Ehmann,\n Michael Gerhaeuser,\n Carsten Miller,\n Bianca Valentin,\n Alfred Wassermann,\n Peter Wilfahrt\n\n This file is part of JSXGraph.\n\n JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n You can redistribute it and/or modify it under the terms of the\n\n * GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version\n OR\n * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n JSXGraph is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License and\n the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Symbolic from \"../math/symbolic\";\nimport Type from \"../utils/type\";\n\n/**\n * @class This element is used to visualize the locus of a given dependent point.\n * @pseudo\n * @description The locus element is used to visualize the curve a given point describes.\n * @constructor\n * @name Locus\n * @type JXG.Curve\n * @augments JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Point} p The constructed curve is the geometric locus of the given point.\n * @example\n *  // This examples needs JXG.Server up and running, otherwise it won't work.\n *  p1 = board.create('point', [0, 0]);\n *  p2 = board.create('point', [6, -1]);\n *  c1 = board.create('circle', [p1, 2]);\n *  c2 = board.create('circle', [p2, 1.5]);\n *  g1 = board.create('glider', [6, 3, c1]);\n *  c3 = board.create('circle', [g1, 4]);\n *  g2 = board.create('intersection', [c2,c3,0]);\n *  m1 = board.create('midpoint', [g1,g2]);\n *  loc = board.create('locus', [m1], {strokeColor: 'red'});\n * </pre><div class=\"jxgbox\" id=\"JXGd45d7188-6624-4d6e-bebb-1efa2a305c8a\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *  lcex_board = JXG.JSXGraph.initBoard('JXGd45d7188-6624-4d6e-bebb-1efa2a305c8a', {boundingbox:[-4, 6, 10, -6], axis: true, grid: false, keepaspectratio: true});\n *  lcex_p1 = lcex_board.create('point', [0, 0]);\n *  lcex_p2 = lcex_board.create('point', [6, -1]);\n *  lcex_c1 = lcex_board.create('circle', [lcex_p1, 2]);\n *  lcex_c2 = lcex_board.create('circle', [lcex_p2, 1.5]);\n *  lcex_g1 = lcex_board.create('glider', [6, 3, lcex_c1]);\n *  lcex_c3 = lcex_board.create('circle', [lcex_g1, 4]);\n *  lcex_g2 = lcex_board.create('intersection', [lcex_c2,lcex_c3,0]);\n *  lcex_m1 = lcex_board.create('midpoint', [lcex_g1,lcex_g2]);\n *  lcex_loc = board.create('locus', [lcex_m1], {strokeColor: 'red'});\n * </script><pre>\n */\nJXG.createLocus = function (board, parents, attributes) {\n    var c, p;\n\n    if (Type.isArray(parents) && parents.length === 1 && Type.isPoint(parents[0])) {\n        p = parents[0];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create locus with parent of type other than point.\" +\n                \"\\nPossible parent types: [point]\"\n        );\n    }\n\n    c = board.create(\"curve\", [[null], [null]], attributes);\n    c.dontCallServer = false;\n\n    c.elType = \"locus\";\n    c.setParents([p.id]);\n\n    /**\n     * Should be documented in JXG.Curve\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var spe, cb, data;\n\n        if (c.board.mode > 0) {\n            return;\n        }\n\n        spe = Symbolic.generatePolynomials(board, p, true).join(\"|\");\n        if (spe === c.spe) {\n            return;\n        }\n\n        c.spe = spe;\n\n        cb = function (x, y, eq, t) {\n            c.dataX = x;\n            c.dataY = y;\n\n            /**\n             * The implicit definition of the locus.\n             * @memberOf Locus.prototype\n             * @name eq\n             * @type String\n             */\n            c.eq = eq;\n\n            /**\n             * The time it took to calculate the locus\n             * @memberOf Locus.prototype\n             * @name ctime\n             * @type Number\n             */\n            c.ctime = t;\n\n            // convert equation and use it to build a generatePolynomial-method\n            c.generatePolynomial = (function (equations) {\n                return function (point) {\n                    var i,\n                        x = \"(\" + point.symbolic.x + \")\",\n                        y = \"(\" + point.symbolic.y + \")\",\n                        res = [];\n\n                    for (i = 0; i < equations.length; i++) {\n                        res[i] = equations[i]\n                            .replace(/\\*\\*/g, \"^\")\n                            .replace(/x/g, x)\n                            .replace(/y/g, y);\n                    }\n\n                    return res;\n                };\n            })(eq);\n        };\n        data = Symbolic.geometricLocusByGroebnerBase(board, p, cb);\n\n        cb(data.datax, data.datay, data.polynomial, data.exectime);\n    };\n    return c;\n};\n\nJXG.registerElement(\"locus\", JXG.createLocus);\n\nexport default {\n    createLocus: JXG.createLocus\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the geometry element Image is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport Coords from \"./coords\";\nimport GeometryElement from \"./element\";\nimport Mat from \"../math/math\";\nimport Type from \"../utils/type\";\nimport CoordsElement from \"./coordselement\";\n\n/**\n * Construct and handle images\n *\n * The image can be supplied as an URL or an base64 encoded inline image\n * like \"data:image/png;base64, /9j/4AAQSkZJRgA...\" or a function returning\n * an URL: function(){ return 'xxx.png; }.\n *\n * @class Creates a new image object. Do not use this constructor to create a image. Use {@link JXG.Board#create} with\n * type {@link Image} instead.\n * @augments JXG.GeometryElement\n * @augments JXG.CoordsElement\n * @param {string|JXG.Board} board The board the new image is drawn on.\n * @param {Array} coordinates An array with the user coordinates of the image.\n * @param {Object} attributes An object containing visual and - optionally - a name and an id.\n * @param {string|function} url An URL string or a function returning an URL string.\n * @param  {Array} size Array containing width and height of the image in user coordinates.\n *\n */\nJXG.Image = function (board, coords, attributes, url, size) {\n    this.constructor(board, attributes, Const.OBJECT_TYPE_IMAGE, Const.OBJECT_CLASS_OTHER);\n    this.element = this.board.select(attributes.anchor);\n    this.coordsConstructor(coords);\n\n    this.W = Type.createFunction(size[0], this.board, \"\");\n    this.H = Type.createFunction(size[1], this.board, \"\");\n\n    this.usrSize = [this.W(), this.H()];\n\n    /**\n     * Array of length two containing [width, height] of the image in pixel.\n     * @type array\n     */\n    this.size = [\n        Math.abs(this.usrSize[0] * board.unitX),\n        Math.abs(this.usrSize[1] * board.unitY)\n    ];\n\n    /**\n     * 'href' of the image. This might be an URL, but also a data-uri is allowed.\n     * @type string\n     */\n    this.url = url;\n\n    this.elType = \"image\";\n\n    // span contains the anchor point and the two vectors\n    // spanning the image rectangle.\n    this.span = [\n        this.coords.usrCoords.slice(0),\n        [this.coords.usrCoords[0], this.W(), 0],\n        [this.coords.usrCoords[0], 0, this.H()]\n    ];\n\n    //this.parent = board.select(attributes.anchor);\n    this.id = this.board.setId(this, \"Im\");\n\n    this.board.renderer.drawImage(this);\n    this.board.finalizeAdding(this);\n\n    this.methodMap = JXG.deepCopy(this.methodMap, {\n        addTransformation: \"addTransform\",\n        trans: \"addTransform\"\n    });\n};\n\nJXG.Image.prototype = new GeometryElement();\nType.copyPrototypeMethods(JXG.Image, CoordsElement, \"coordsConstructor\");\n\nJXG.extend(\n    JXG.Image.prototype,\n    /** @lends JXG.Image.prototype */ {\n        /**\n         * Checks whether (x,y) is over or near the image;\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} True if (x,y) is over the image, False otherwise.\n         */\n        hasPoint: function (x, y) {\n            var dx,\n                dy,\n                r,\n                type,\n                prec,\n                c,\n                v,\n                p,\n                dot,\n                len = this.transformations.length;\n\n            if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n                type = this.board._inputDevice;\n                prec = Type.evaluate(this.visProp.precision[type]);\n            } else {\n                // 'inherit'\n                prec = this.board.options.precision.hasPoint;\n            }\n\n            // Easy case: no transformation\n            if (len === 0) {\n                dx = x - this.coords.scrCoords[1];\n                dy = this.coords.scrCoords[2] - y;\n                r = prec;\n\n                return dx >= -r && dx - this.size[0] <= r && dy >= -r && dy - this.size[1] <= r;\n            }\n\n            // Image is transformed\n            c = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board);\n            // v is the vector from anchor point to the drag point\n            c = c.usrCoords;\n            v = [c[0] - this.span[0][0], c[1] - this.span[0][1], c[2] - this.span[0][2]];\n            dot = Mat.innerProduct; // shortcut\n\n            // Project the drag point to the sides.\n            p = dot(v, this.span[1]);\n            if (0 <= p && p <= dot(this.span[1], this.span[1])) {\n                p = dot(v, this.span[2]);\n\n                if (0 <= p && p <= dot(this.span[2], this.span[2])) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        /**\n         * Recalculate the coordinates of lower left corner and the width and height.\n         *\n         * @returns {JXG.GeometryElement} A reference to the element\n         * @private\n         */\n        update: function (fromParent) {\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            this.updateCoords(fromParent);\n            this.updateSize();\n            this.updateSpan();\n\n            return this;\n        },\n\n        /**\n         * Send an update request to the renderer.\n         * @private\n         */\n        updateRenderer: function () {\n            return this.updateRendererGeneric(\"updateImage\");\n        },\n\n        /**\n         * Updates the internal arrays containing size of the image.\n         * @returns {JXG.GeometryElement} A reference to the element\n         * @private\n         */\n        updateSize: function () {\n            this.usrSize = [this.W(), this.H()];\n            this.size = [\n                Math.abs(this.usrSize[0] * this.board.unitX),\n                Math.abs(this.usrSize[1] * this.board.unitY)\n            ];\n\n            return this;\n        },\n\n        /**\n         * Update the anchor point of the image, i.e. the lower left corner\n         * and the two vectors which span the rectangle.\n         * @returns {JXG.GeometryElement} A reference to the element\n         * @private\n         *\n         */\n        updateSpan: function () {\n            var i,\n                j,\n                len = this.transformations.length,\n                v = [];\n\n            if (len === 0) {\n                this.span = [\n                    [this.Z(), this.X(), this.Y()],\n                    [this.Z(), this.W(), 0],\n                    [this.Z(), 0, this.H()]\n                ];\n            } else {\n                // v contains the three defining corners of the rectangle/image\n                v[0] = [this.Z(), this.X(), this.Y()];\n                v[1] = [this.Z(), this.X() + this.W(), this.Y()];\n                v[2] = [this.Z(), this.X(), this.Y() + this.H()];\n\n                // Transform the three corners\n                for (i = 0; i < len; i++) {\n                    for (j = 0; j < 3; j++) {\n                        v[j] = Mat.matVecMult(this.transformations[i].matrix, v[j]);\n                    }\n                }\n                // Normalize the vectors\n                for (j = 0; j < 3; j++) {\n                    v[j][1] /= v[j][0];\n                    v[j][2] /= v[j][0];\n                    v[j][0] /= v[j][0];\n                }\n                // Compute the two vectors spanning the rectangle\n                // by subtracting the anchor point.\n                for (j = 1; j < 3; j++) {\n                    v[j][0] -= v[0][0];\n                    v[j][1] -= v[0][1];\n                    v[j][2] -= v[0][2];\n                }\n                this.span = v;\n            }\n\n            return this;\n        },\n\n        addTransform: function (transform) {\n            var i;\n\n            if (Type.isArray(transform)) {\n                for (i = 0; i < transform.length; i++) {\n                    this.transformations.push(transform[i]);\n                }\n            } else {\n                this.transformations.push(transform);\n            }\n\n            return this;\n        },\n\n        // Documented in element.js\n        getParents: function () {\n            var p = [this.url, [this.Z(), this.X(), this.Y()], this.usrSize];\n\n            if (this.parents.length !== 0) {\n                p = this.parents;\n            }\n\n            return p;\n        },\n\n        /**\n         * Set the width and height of the image. After setting a new size,\n         * board.update() or image.fullUpdate()\n         * has to be called to make the change visible.\n         * @param  {number, function, string} width  Number, function or string\n         *                            that determines the new width of the image\n         * @param  {number, function, string} height Number, function or string\n         *                            that determines the new height of the image\n         * @returns {JXG.GeometryElement} A reference to the element\n         *\n         * @example\n         * var im = board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg',\n         *                                [-3,-2], [3,3]]);\n         * im.setSize(4, 4);\n         * board.update();\n         *\n         * </pre><div id=\"JXG8411e60c-f009-11e5-b1bf-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG8411e60c-f009-11e5-b1bf-901b0e1b8723',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     var im = board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg', [-3,-2],    [3,3]]);\n         *     //im.setSize(4, 4);\n         *     //board.update();\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         * @example\n         * var p0 = board.create('point', [-3, -2]),\n         *     im = board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg',\n         *                     [function(){ return p0.X(); }, function(){ return p0.Y(); }],\n         *                     [3,3]]),\n         *     p1 = board.create('point', [1, 2]);\n         *\n         * im.setSize(function(){ return p1.X() - p0.X(); }, function(){ return p1.Y() - p0.Y(); });\n         * board.update();\n         *\n         * </pre><div id=\"JXG4ce706c0-f00a-11e5-b1bf-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG4ce706c0-f00a-11e5-b1bf-901b0e1b8723',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     var p0 = board.create('point', [-3, -2]),\n         *         im = board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg',\n         *                         [function(){ return p0.X(); }, function(){ return p0.Y(); }],\n         *                         [3,3]]),\n         *         p1 = board.create('point', [1, 2]);\n         *\n         *     im.setSize(function(){ return p1.X() - p0.X(); }, function(){ return p1.Y() - p0.Y(); });\n         *     board.update();\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        setSize: function (width, height) {\n            this.W = Type.createFunction(width, this.board, \"\");\n            this.H = Type.createFunction(height, this.board, \"\");\n\n            // this.fullUpdate();\n\n            return this;\n        },\n\n        /**\n         * Returns the width of the image in user coordinates.\n         * @returns {number} width of the image in user coordinates\n         */\n        W: function () {}, // Needed for docs, defined in constructor\n\n        /**\n         * Returns the height of the image in user coordinates.\n         * @returns {number} height of the image in user coordinates\n         */\n        H: function () {} // Needed for docs, defined in constructor\n    }\n);\n\n/**\n * @class Displays an image.\n * @pseudo\n * @description\n * @name Image\n * @type JXG.Image\n * @augments JXG.Image\n * @constructor\n * @constructor\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {string,function_Array_Array} url,coords,size url defines the location of the image data. The array coords contains the user coordinates\n * of the lower left corner of the image.\n *   It can consist of two or three elements of type number, a string containing a GEONE<sub>x</sub>T\n *   constraint, or a function which takes no parameter and returns a number. Every element determines one coordinate. If a coordinate is\n *   given by a number, the number determines the initial position of a free image. If given by a string or a function that coordinate will be constrained\n *   that means the user won't be able to change the image's position directly by mouse because it will be calculated automatically depending on the string\n *   or the function's return value. If two parent elements are given the coordinates will be interpreted as 2D affine Euclidean coordinates, if three such\n *   parent elements are given they will be interpreted as homogeneous coordinates.\n * <p>\n * The array size defines the image's width and height in user coordinates.\n * @example\n * var im = board.create('image', ['https://jsxgraph.org/jsxgraph/distrib/images/uccellino.jpg', [-3,-2], [3,3]]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXG9850cda0-7ea0-4750-981c-68bacf9cca57\" style=\"width: 400px; height: 400px;\"></div>\n * <script type=\"text/javascript\">\n *   var image_board = JXG.JSXGraph.initBoard('JXG9850cda0-7ea0-4750-981c-68bacf9cca57', {boundingbox: [-4, 4, 4, -4], axis: true, showcopyright: false, shownavigation: false});\n *   var image_im = image_board.create('image', ['https://jsxgraph.org/distrib/images/uccellino.jpg', [-3,-2],[3,3]]);\n * </script><pre>\n */\nJXG.createImage = function (board, parents, attributes) {\n    var attr,\n        im,\n        url = parents[0],\n        coords = parents[1],\n        size = parents[2];\n\n    attr = Type.copyAttributes(attributes, board.options, \"image\");\n    im = CoordsElement.create(JXG.Image, board, coords, attr, url, size);\n    if (!im) {\n        throw new Error(\n            \"JSXGraph: Can't create image with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [x,y], [z,x,y], [element,transformation]\"\n        );\n    }\n\n    if (attr.rotate !== 0) {\n        // This is the default value, i.e. no rotation\n        im.addRotation(attr.rotate);\n    }\n\n    return im;\n};\n\nJXG.registerElement(\"image\", JXG.createImage);\n\nexport default {\n    Image: JXG.Image,\n    createImage: JXG.createImage\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The geometry object slider is defined in this file. Slider stores all\n * style and functional properties that are required to draw and use a slider on\n * a board.\n */\n\nimport JXG from \"../jxg\";\nimport Mat from \"../math/math\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Type from \"../utils/type\";\nimport Point from \"../base/point\";\n\n/**\n * @class A slider can be used to choose values from a given range of numbers.\n * @pseudo\n * @description\n * @name Slider\n * @augments Glider\n * @constructor\n * @type JXG.Point\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Array_Array_Array} start,end,data The first two arrays give the start and the end where the slider is drawn\n * on the board. The third array gives the start and the end of the range the slider operates as the first resp. the\n * third component of the array. The second component of the third array gives its start value.\n * @example\n * // Create a slider with values between 1 and 10, initial position is 5.\n * var s = board.create('slider', [[1, 2], [3, 2], [1, 5, 10]]);\n * </pre><div class=\"jxgbox\" id=\"JXGcfb51cde-2603-4f18-9cc4-1afb452b374d\" style=\"width: 200px; height: 200px;\"></div>\n * <script type=\"text/javascript\">\n *   (function () {\n *     var board = JXG.JSXGraph.initBoard('JXGcfb51cde-2603-4f18-9cc4-1afb452b374d', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});\n *     var s = board.create('slider', [[1, 2], [3, 2], [1, 5, 10]]);\n *   })();\n * </script><pre>\n * @example\n * // Create a slider taking integer values between 1 and 50. Initial value is 50.\n * var s = board.create('slider', [[1, 3], [3, 1], [0, 10, 50]], {snapWidth: 1, ticks: { drawLabels: true }});\n * </pre><div class=\"jxgbox\" id=\"JXGe17128e6-a25d-462a-9074-49460b0d66f4\" style=\"width: 200px; height: 200px;\"></div>\n * <script type=\"text/javascript\">\n *   (function () {\n *     var board = JXG.JSXGraph.initBoard('JXGe17128e6-a25d-462a-9074-49460b0d66f4', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});\n *     var s = board.create('slider', [[1, 3], [3, 1], [1, 10, 50]], {snapWidth: 1, ticks: { drawLabels: true }});\n *   })();\n * </script><pre>\n * @example\n *     // Draggable slider\n *     var s1 = board.create('slider', [[-3,1], [2,1],[-10,1,10]], {\n *         visible: true,\n *         snapWidth: 2,\n *         point1: {fixed: false},\n *         point2: {fixed: false},\n *         baseline: {fixed: false, needsRegularUpdate: true}\n *     });\n *\n * </pre><div id=\"JXGbfc67817-2827-44a1-bc22-40bf312e76f8\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGbfc67817-2827-44a1-bc22-40bf312e76f8',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *         var s1 = board.create('slider', [[-3,1], [2,1],[-10,1,10]], {\n *             visible: true,\n *             snapWidth: 2,\n *             point1: {fixed: false},\n *             point2: {fixed: false},\n *             baseline: {fixed: false, needsRegularUpdate: true}\n *         });\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n *     // Set the slider by clicking on the base line: attribute 'moveOnUp'\n *     var s1 = board.create('slider', [[-3,1], [2,1],[-10,1,10]], {\n *         snapWidth: 2,\n *         moveOnUp: true // default value\n *     });\n *\n * </pre><div id=\"JXGc0477c8a-b1a7-4111-992e-4ceb366fbccc\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGc0477c8a-b1a7-4111-992e-4ceb366fbccc',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *         var s1 = board.create('slider', [[-3,1], [2,1],[-10,1,10]], {\n *             snapWidth: 2,\n *             moveOnUp: true // default value\n *         });\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * // Set colors\n * var sl = board.create('slider', [[-3, 1], [1, 1], [-10, 1, 10]], {\n *\n *   baseline: { strokeColor: 'blue'},\n *   highline: { strokeColor: 'red'},\n *   fillColor: 'yellow',\n *   label: {fontSize: 24, strokeColor: 'orange'},\n *   name: 'xyz', // Not shown, if suffixLabel is set\n *   suffixLabel: 'x = ',\n *   postLabel: ' u'\n *\n * });\n *\n * </pre><div id=\"JXGd96c9e2c-2c25-4131-b6cf-9dbb80819401\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGd96c9e2c-2c25-4131-b6cf-9dbb80819401',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var sl = board.create('slider', [[-3, 1], [1, 1], [-10, 1, 10]], {\n *\n *       baseline: { strokeColor: 'blue'},\n *       highline: { strokeColor: 'red'},\n *       fillColor: 'yellow',\n *       label: {fontSize: 24, strokeColor: 'orange'},\n *       name: 'xyz', // Not shown, if suffixLabel is set\n *       suffixLabel: 'x = ',\n *       postLabel: ' u'\n *\n *     });\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createSlider = function (board, parents, attributes) {\n    var pos0,\n        pos1,\n        smin,\n        start,\n        smax,\n        sdiff,\n        p1,\n        p2,\n        l1,\n        ticks,\n        ti,\n        startx,\n        starty,\n        p3,\n        l2,\n        t,\n        withText,\n        withTicks,\n        snapWidth,\n        sw,\n        s,\n        attr,\n        digits;\n\n    attr = Type.copyAttributes(attributes, board.options, \"slider\");\n    withTicks = attr.withticks;\n    withText = attr.withlabel;\n    snapWidth = attr.snapwidth;\n\n    // start point\n    attr = Type.copyAttributes(attributes, board.options, \"slider\", \"point1\");\n    p1 = board.create(\"point\", parents[0], attr);\n\n    // end point\n    attr = Type.copyAttributes(attributes, board.options, \"slider\", \"point2\");\n    p2 = board.create(\"point\", parents[1], attr);\n    //g = board.create('group', [p1, p2]);\n\n    // Base line\n    attr = Type.copyAttributes(attributes, board.options, \"slider\", \"baseline\");\n    l1 = board.create(\"segment\", [p1, p2], attr);\n\n    // This is required for a correct projection of the glider onto the segment below\n    l1.updateStdform();\n\n    pos0 = p1.coords.usrCoords.slice(1);\n    pos1 = p2.coords.usrCoords.slice(1);\n    smin = parents[2][0];\n    start = parents[2][1];\n    smax = parents[2][2];\n    sdiff = smax - smin;\n\n    sw = Type.evaluate(snapWidth);\n    s = sw === -1 ? start : Math.round(start / sw) * sw;\n    startx = pos0[0] + ((pos1[0] - pos0[0]) * (s - smin)) / (smax - smin);\n    starty = pos0[1] + ((pos1[1] - pos0[1]) * (s - smin)) / (smax - smin);\n\n    // glider point\n    attr = Type.copyAttributes(attributes, board.options, \"slider\");\n    // overwrite this in any case; the sliders label is a special text element, not the gliders label.\n    // this will be set back to true after the text was created (and only if withlabel was true initially).\n    attr.withLabel = false;\n    // gliders set snapwidth=-1 by default (i.e. deactivate them)\n    p3 = board.create(\"glider\", [startx, starty, l1], attr);\n    p3.setAttribute({ snapwidth: snapWidth });\n\n    // Segment from start point to glider point: highline\n    attr = Type.copyAttributes(attributes, board.options, \"slider\", \"highline\");\n    l2 = board.create(\"segment\", [p1, p3], attr);\n\n    /**\n     * Returns the current slider value.\n     * @memberOf Slider.prototype\n     * @name Value\n     * @function\n     * @returns {Number}\n     */\n    p3.Value = function () {\n        var sdiff = this._smax - this._smin,\n            ev_sw = Type.evaluate(this.visProp.snapwidth);\n\n        return ev_sw === -1\n            ? this.position * sdiff + this._smin\n            : Math.round((this.position * sdiff + this._smin) / ev_sw) * ev_sw;\n    };\n\n    p3.methodMap = Type.deepCopy(p3.methodMap, {\n        Value: \"Value\",\n        setValue: \"setValue\",\n        smax: \"_smax\",\n        smin: \"_smin\",\n        setMax: \"setMax\",\n        setMin: \"setMin\"\n    });\n\n    /**\n     * End value of the slider range.\n     * @memberOf Slider.prototype\n     * @name _smax\n     * @type Number\n     */\n    p3._smax = smax;\n\n    /**\n     * Start value of the slider range.\n     * @memberOf Slider.prototype\n     * @name _smin\n     * @type Number\n     */\n    p3._smin = smin;\n\n    /**\n     * Sets the maximum value of the slider.\n     * @memberOf Slider.prototype\n     * @name setMax\n     * @param {Number} val New maximum value\n     * @returns {Object} this object\n     */\n    p3.setMax = function (val) {\n        this._smax = val;\n        return this;\n    };\n\n    /**\n     * Sets the value of the slider. This call must be followed\n     * by a board update call.\n     * @memberOf Slider.prototype\n     * @name setValue\n     * @param {Number} val New value\n     * @returns {Object} this object\n     */\n    p3.setValue = function (val) {\n        var sdiff = this._smax - this._smin;\n\n        if (Math.abs(sdiff) > Mat.eps) {\n            this.position = (val - this._smin) / sdiff;\n        } else {\n            this.position = 0.0; //this._smin;\n        }\n        this.position = Math.max(0.0, Math.min(1.0, this.position));\n        return this;\n    };\n\n    /**\n     * Sets the minimum value of the slider.\n     * @memberOf Slider.prototype\n     * @name setMin\n     * @param {Number} val New minimum value\n     * @returns {Object} this object\n     */\n    p3.setMin = function (val) {\n        this._smin = val;\n        return this;\n    };\n\n    if (withText) {\n        attr = Type.copyAttributes(attributes, board.options, \"slider\", \"label\");\n        t = board.create(\n            \"text\",\n            [\n                function () {\n                    return (p2.X() - p1.X()) * 0.05 + p2.X();\n                },\n                function () {\n                    return (p2.Y() - p1.Y()) * 0.05 + p2.Y();\n                },\n                function () {\n                    var n,\n                        d = Type.evaluate(p3.visProp.digits),\n                        sl = Type.evaluate(p3.visProp.suffixlabel),\n                        ul = Type.evaluate(p3.visProp.unitlabel),\n                        pl = Type.evaluate(p3.visProp.postlabel);\n\n                    if (d === 2 && Type.evaluate(p3.visProp.precision) !== 2) {\n                        // Backwards compatibility\n                        d = Type.evaluate(p3.visProp.precision);\n                    }\n\n                    if (sl !== null) {\n                        n = sl;\n                    } else if (p3.name && p3.name !== \"\") {\n                        n = p3.name + \" = \";\n                    } else {\n                        n = \"\";\n                    }\n\n                    n += Type.toFixed(p3.Value(), d);\n\n                    if (ul !== null) {\n                        n += ul;\n                    }\n                    if (pl !== null) {\n                        n += pl;\n                    }\n\n                    return n;\n                }\n            ],\n            attr\n        );\n\n        /**\n         * The text element to the right of the slider, indicating its current value.\n         * @memberOf Slider.prototype\n         * @name label\n         * @type JXG.Text\n         */\n        p3.label = t;\n\n        // reset the withlabel attribute\n        p3.visProp.withlabel = true;\n        p3.hasLabel = true;\n    }\n\n    /**\n     * Start point of the base line.\n     * @memberOf Slider.prototype\n     * @name point1\n     * @type JXG.Point\n     */\n    p3.point1 = p1;\n\n    /**\n     * End point of the base line.\n     * @memberOf Slider.prototype\n     * @name point2\n     * @type JXG.Point\n     */\n    p3.point2 = p2;\n\n    /**\n     * The baseline the glider is bound to.\n     * @memberOf Slider.prototype\n     * @name baseline\n     * @type JXG.Line\n     */\n    p3.baseline = l1;\n\n    /**\n     * A line on top of the baseline, indicating the slider's progress.\n     * @memberOf Slider.prototype\n     * @name highline\n     * @type JXG.Line\n     */\n    p3.highline = l2;\n\n    if (withTicks) {\n        // Function to generate correct label texts\n\n        attr = Type.copyAttributes(attributes, board.options, \"slider\", \"ticks\");\n        if (!Type.exists(attr.generatelabeltext)) {\n            attr.generateLabelText = function (tick, zero, value) {\n                var labelText,\n                    dFull = p3.point1.Dist(p3.point2),\n                    smin = p3._smin,\n                    smax = p3._smax,\n                    val = (this.getDistanceFromZero(zero, tick) * (smax - smin)) / dFull + smin;\n\n                if (dFull < Mat.eps || Math.abs(val) < Mat.eps) {\n                    // Point is zero\n                    labelText = \"0\";\n                } else {\n                    labelText = this.formatLabelText(val);\n                }\n                return labelText;\n            };\n        }\n        ticks = 2;\n        ti = board.create(\n            \"ticks\",\n            [\n                p3.baseline,\n                p3.point1.Dist(p1) / ticks,\n\n                function (tick) {\n                    var dFull = p3.point1.Dist(p3.point2),\n                        d = p3.point1.coords.distance(Const.COORDS_BY_USER, tick);\n\n                    if (dFull < Mat.eps) {\n                        return 0;\n                    }\n\n                    return (d / dFull) * sdiff + smin;\n                }\n            ],\n            attr\n        );\n\n        /**\n         * Ticks give a rough indication about the slider's current value.\n         * @memberOf Slider.prototype\n         * @name ticks\n         * @type JXG.Ticks\n         */\n        p3.ticks = ti;\n    }\n\n    // override the point's remove method to ensure the removal of all elements\n    p3.remove = function () {\n        if (withText) {\n            board.removeObject(t);\n        }\n\n        board.removeObject(l2);\n        board.removeObject(l1);\n        board.removeObject(p2);\n        board.removeObject(p1);\n\n        Point.Point.prototype.remove.call(p3);\n    };\n\n    p1.dump = false;\n    p2.dump = false;\n    l1.dump = false;\n    l2.dump = false;\n    if (withText) {\n        t.dump = false;\n    }\n\n    p3.elType = \"slider\";\n    p3.parents = parents;\n    p3.subs = {\n        point1: p1,\n        point2: p2,\n        baseLine: l1,\n        highLine: l2\n    };\n    p3.inherits.push(p1, p2, l1, l2);\n\n    if (withTicks) {\n        ti.dump = false;\n        p3.subs.ticks = ti;\n        p3.inherits.push(ti);\n    }\n\n    p3.getParents = function () {\n        return [\n            this.point1.coords.usrCoords.slice(1),\n            this.point2.coords.usrCoords.slice(1),\n            [this._smin, this.position * (this._smax - this._smin) + this._smin, this._smax]\n        ];\n    };\n\n    p3.baseline.on(\"up\", function (evt) {\n        var pos, c;\n\n        if (Type.evaluate(p3.visProp.moveonup) && !Type.evaluate(p3.visProp.fixed)) {\n            pos = l1.board.getMousePosition(evt, 0);\n            c = new Coords(Const.COORDS_BY_SCREEN, pos, this.board);\n            p3.moveTo([c.usrCoords[1], c.usrCoords[2]]);\n            p3.triggerEventHandlers(['drag'], [evt]);\n        }\n    });\n\n    // Save the visibility attribute of the sub-elements\n    // for (el in p3.subs) {\n    //     p3.subs[el].status = {\n    //         visible: p3.subs[el].visProp.visible\n    //     };\n    // }\n\n    // p3.hideElement = function () {\n    //     var el;\n    //     GeometryElement.prototype.hideElement.call(this);\n    //\n    //     for (el in this.subs) {\n    //         // this.subs[el].status.visible = this.subs[el].visProp.visible;\n    //         this.subs[el].hideElement();\n    //     }\n    // };\n\n    //         p3.showElement = function () {\n    //             var el;\n    //             GeometryElement.prototype.showElement.call(this);\n    //\n    //             for (el in this.subs) {\n    // //                if (this.subs[el].status.visible) {\n    //                 this.subs[el].showElement();\n    // //                }\n    //             }\n    //         };\n\n    // This is necessary to show baseline, highline and ticks\n    // when opening the board in case the visible attributes are set\n    // to 'inherit'.\n    p3.prepareUpdate().update();\n    if (!board.isSuspendedUpdate) {\n        p3.updateVisibility().updateRenderer();\n        p3.baseline.updateVisibility().updateRenderer();\n        p3.highline.updateVisibility().updateRenderer();\n        if (withTicks) {\n            p3.ticks.updateVisibility().updateRenderer();\n        }\n    }\n\n    return p3;\n};\n\nJXG.registerElement(\"slider\", JXG.createSlider);\n\nexport default {\n    createSlider: JXG.createSlider\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview Geometry objects for measurements are defined in this file. This file stores all\n * style and functional properties that are required to use a tape measure on\n * a board.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\nimport GeometryElement from \"../base/element\";\n\n/**\n * @class A tape measure can be used to measure distances between points.\n * @pseudo\n * @description\n * @name Tapemeasure\n * @augments Segment\n * @constructor\n * @type JXG.Segment\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Array_Array} start,end, The two arrays give the initial position where the tape measure\n * is drawn on the board.\n * @example\n * // Create a tape measure\n * var p1 = board.create('point', [0,0]);\n * var p2 = board.create('point', [1,1]);\n * var p3 = board.create('point', [3,1]);\n * var tape = board.create('tapemeasure', [[1, 2], [4, 2]], {name:'dist'});\n * </pre><div class=\"jxgbox\" id=\"JXG6d9a2cda-22fe-4cd1-9d94-34283b1bdc01\" style=\"width: 200px; height: 200px;\"></div>\n * <script type=\"text/javascript\">\n *   (function () {\n *     var board = JXG.JSXGraph.initBoard('JXG6d9a2cda-22fe-4cd1-9d94-34283b1bdc01', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});\n *     var p1 = board.create('point', [0,0]);\n *     var p2 = board.create('point', [1,1]);\n *     var p3 = board.create('point', [3,1]);\n *     var tape = board.create('tapemeasure', [[1, 2], [4, 2]], {name:'dist'} );\n *   })();\n * </script><pre>\n */\nJXG.createTapemeasure = function (board, parents, attributes) {\n    var pos0, pos1, attr, withTicks, withText, digits, li, p1, p2, n, ti;\n\n    pos0 = parents[0];\n    pos1 = parents[1];\n\n    // start point\n    attr = Type.copyAttributes(attributes, board.options, \"tapemeasure\", \"point1\");\n    p1 = board.create(\"point\", pos0, attr);\n\n    // end point\n    attr = Type.copyAttributes(attributes, board.options, \"tapemeasure\", \"point2\");\n    p2 = board.create(\"point\", pos1, attr);\n\n    p1.setAttribute({ ignoredSnapToPoints: [p2] });\n    p2.setAttribute({ ignoredSnapToPoints: [p1] });\n\n    // tape measure line\n    attr = Type.copyAttributes(attributes, board.options, \"tapemeasure\");\n    withTicks = attr.withticks;\n    withText = attr.withlabel;\n    digits = attr.digits;\n\n    if (digits === 2 && attr.precision !== 2) {\n        // Backward compatibility\n        digits = attr.precision;\n    }\n\n    // Below, we will replace the label by the measurement function.\n    if (withText) {\n        attr.withlabel = true;\n    }\n    li = board.create(\"segment\", [p1, p2], attr);\n    // p1, p2 are already added to li.inherits\n\n    if (withText) {\n        if (attributes.name && attributes.name !== \"\") {\n            n = attributes.name + \" = \";\n        } else {\n            n = \"\";\n        }\n        li.label.setText(function () {\n            return n + Type.toFixed(p1.Dist(p2), digits);\n        });\n    }\n\n    if (withTicks) {\n        attr = Type.copyAttributes(attributes, board.options, \"tapemeasure\", \"ticks\");\n        //ticks  = 2;\n        ti = board.create(\"ticks\", [li, 0.1], attr);\n        li.inherits.push(ti);\n    }\n\n    // override the segments's remove method to ensure the removal of all elements\n    /** @ignore */\n    li.remove = function () {\n        if (withTicks) {\n            li.removeTicks(ti);\n        }\n\n        board.removeObject(p2);\n        board.removeObject(p1);\n\n        GeometryElement.prototype.remove.call(this);\n    };\n\n    /**\n     * Returns the length of the tape measure.\n     * @name Value\n     * @memberOf Tapemeasure.prototype\n     * @function\n     * @returns {Number} length of tape measure.\n     */\n    li.Value = function () {\n        return p1.Dist(p2);\n    };\n\n    p1.dump = false;\n    p2.dump = false;\n\n    li.elType = \"tapemeasure\";\n    li.getParents = function () {\n        return [\n            [p1.X(), p1.Y()],\n            [p2.X(), p2.Y()]\n        ];\n    };\n\n    li.subs = {\n        point1: p1,\n        point2: p2\n    };\n\n    if (withTicks) {\n        ti.dump = false;\n    }\n\n    li.methodMap = JXG.deepCopy(li.methodMap, {\n        Value: \"Value\"\n    });\n\n    li.prepareUpdate().update();\n    if (!board.isSuspendedUpdate) {\n        li.updateVisibility().updateRenderer();\n        // The point updates are necessary in case of snapToGrid==true\n        li.point1.updateVisibility().updateRenderer();\n        li.point2.updateVisibility().updateRenderer();\n    }\n\n    return li;\n};\n\nJXG.registerElement(\"tapemeasure\", JXG.createTapemeasure);\n\nexport default {\n    createTapemeasure: JXG.createTapemeasure\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, document: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The JXG.DataSource is a helper class for data organization. Currently supported data sources are\n * javascript arrays and HTML tables.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n\nJXG.DataSource = function () {\n    this.data = [];\n    this.columnHeaders = [];\n    this.rowHeaders = [];\n\n    return this;\n};\n\nJXG.extend(\n    JXG.DataSource.prototype,\n    /** @lends JXG.DataSource.prototype */ {\n        loadFromArray: function (table, columnHeader, rowHeader) {\n            var i, j, cell;\n\n            if (Type.isArray(columnHeader)) {\n                this.columnHeaders = columnHeader;\n                columnHeader = false;\n            }\n\n            if (Type.isArray(rowHeader)) {\n                this.rowHeaders = rowHeader;\n                rowHeader = false;\n            }\n\n            this.data = [];\n\n            if (columnHeader) {\n                this.columnHeaders = [];\n            }\n\n            if (rowHeader) {\n                this.rowHeaders = [];\n            }\n\n            if (Type.exists(table)) {\n                // extract the data\n                this.data = [];\n\n                for (i = 0; i < table.length; i++) {\n                    this.data[i] = [];\n\n                    for (j = 0; j < table[i].length; j++) {\n                        cell = table[i][j];\n                        if (parseFloat(cell).toString() === cell) {\n                            this.data[i][j] = parseFloat(cell);\n                        } else if (cell !== \"-\") {\n                            this.data[i][j] = cell;\n                        } else {\n                            this.data[i][j] = NaN;\n                        }\n                    }\n                }\n\n                if (columnHeader) {\n                    this.columnHeaders = this.data[0].slice(1);\n                    this.data = this.data.slice(1);\n                }\n\n                if (rowHeader) {\n                    this.rowHeaders = [];\n                    for (i = 0; i < this.data.length; i++) {\n                        this.rowHeaders.push(this.data[i][0]);\n                        this.data[i] = this.data[i].slice(1);\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        loadFromTable: function (table, columnHeader, rowHeader) {\n            var row, i, j, col, cell, name;\n\n            if (Type.isArray(columnHeader)) {\n                this.columnHeaders = columnHeader;\n                columnHeader = false;\n            }\n\n            if (Type.isArray(rowHeader)) {\n                this.rowHeaders = rowHeader;\n                rowHeader = false;\n            }\n\n            this.data = [];\n\n            if (columnHeader) {\n                this.columnHeaders = [];\n            }\n\n            if (rowHeader) {\n                this.rowHeaders = [];\n            }\n\n            // to adjust: examples in examples folder & wiki\n            table = document.getElementById(table);\n\n            if (Type.exists(table)) {\n                // extract the data\n                row = table.getElementsByTagName(\"tr\");\n                this.data = [];\n\n                for (i = 0; i < row.length; i++) {\n                    col = row[i].getElementsByTagName(\"td\");\n                    this.data[i] = [];\n\n                    for (j = 0; j < col.length; j++) {\n                        cell = col[j].innerHTML;\n\n                        if (parseFloat(cell).toString() === cell) {\n                            this.data[i][j] = parseFloat(cell);\n                        } else if (cell !== \"-\") {\n                            this.data[i][j] = cell;\n                        } else {\n                            this.data[i][j] = NaN;\n                        }\n                    }\n                }\n\n                if (columnHeader) {\n                    this.columnHeaders = this.data[0].slice(1);\n                    this.data = this.data.slice(1);\n                }\n\n                if (rowHeader) {\n                    this.rowHeaders = [];\n                    for (i = 0; i < this.data.length; i++) {\n                        this.rowHeaders.push(this.data[i][0]);\n                        this.data[i] = this.data[i].slice(1);\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        addColumn: function (name, pos, data) {\n            throw new Error(\"not implemented\");\n        },\n\n        addRow: function (name, pos, data) {\n            throw new Error(\"not implemented\");\n        },\n\n        getColumn: function (col) {\n            var i,\n                result = [];\n\n            // get column index if column is given as column header title\n            if (Type.isString(col)) {\n                for (i = 0; i < this.columnHeaders.length; i++) {\n                    if (col === this.columnHeaders[i]) {\n                        col = i;\n                        break;\n                    }\n                }\n            }\n\n            // build column array\n            for (i = 0; i < this.data.length; i++) {\n                if (this.data[i].length > col) {\n                    result[i] = parseFloat(this.data[i][col]);\n                }\n            }\n\n            return result;\n        },\n\n        getRow: function (row) {\n            var result, i;\n\n            // get column index if column is given as column header title\n            if (Type.isString(row)) {\n                for (i = 0; i < this.rowHeaders.length; i++) {\n                    if (row === this.rowHeaders[i]) {\n                        row = i;\n                        break;\n                    }\n                }\n            }\n\n            // allocate memory for result array\n            result = [];\n\n            // build column array. result = this.data[row] is a flat copy and will\n            // destroy our local data copy, that's why we're copying it element wise.\n            for (i = 0; i < this.data[row].length; i++) {\n                result[i] = this.data[row][i];\n            }\n\n            return result;\n        }\n    }\n);\n\nexport default JXG.DataSource;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, document: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Numerics from \"../math/numerics\";\nimport Statistics from \"../math/statistics\";\nimport Const from \"./constants\";\nimport Coords from \"./coords\";\nimport GeometryElement from \"./element\";\nimport DataSource from \"../parser/datasource\";\nimport Color from \"../utils/color\";\nimport Type from \"../utils/type\";\nimport Env from \"../utils/env\";\n// import Curve from \"./curve\";\n// import Point from \"./point\";\n// import Text from \"./text\";\n// import Polygon from \"./polygon\";\n// import Sector from \"../element/sector\";\n// import Transform from \"./transformation\";\n// import Line from \"./line\";\n// import Circle from \"./circle\";\n\n/**\n *\n * The Chart class is a basic class for the chart object.\n * @class Creates a new basic chart object. Do not use this constructor to create a chart.\n * Use {@link JXG.Board#create} with type {@link Chart} instead.\n * @constructor\n * @augments JXG.GeometryElement\n * @param {String,JXG.Board} board The board the new chart is drawn on.\n * @param {Array} parent data arrays for the chart\n * @param {Object} attributes Javascript object containing attributes like name, id and colors.\n *\n */\nJXG.Chart = function (board, parents, attributes) {\n    this.constructor(board, attributes);\n\n    var x, y, i, c, style, len;\n\n    if (!Type.isArray(parents) || parents.length === 0) {\n        throw new Error(\"JSXGraph: Can't create a chart without data\");\n    }\n\n    /**\n     * Contains pointers to the various subelements of the chart.\n     */\n    this.elements = [];\n\n    if (Type.isNumber(parents[0])) {\n        // parents looks like [a,b,c,..]\n        // x has to be filled\n\n        y = parents;\n        x = [];\n        for (i = 0; i < y.length; i++) {\n            x[i] = i + 1;\n        }\n    } else if (parents.length === 1 && Type.isArray(parents[0])) {\n        // parents looks like [[a,b,c,..]]\n        // x has to be filled\n\n        y = parents[0];\n        x = [];\n\n        len = Type.evaluate(y).length;\n        for (i = 0; i < len; i++) {\n            x[i] = i + 1;\n        }\n    } else if (parents.length === 2) {\n        // parents looks like [[x0,x1,x2,...],[y1,y2,y3,...]]\n        len = Math.min(parents[0].length, parents[1].length);\n        x = parents[0].slice(0, len);\n        y = parents[1].slice(0, len);\n    }\n\n    if (Type.isArray(y) && y.length === 0) {\n        throw new Error(\"JSXGraph: Can't create charts without data.\");\n    }\n\n    // does this really need to be done here? this should be done in createChart and then\n    // there should be an extra chart for each chartstyle\n    style = attributes.chartstyle.replace(/ /g, \"\").split(\",\");\n    for (i = 0; i < style.length; i++) {\n        switch (style[i]) {\n            case \"bar\":\n                c = this.drawBar(board, x, y, attributes);\n                break;\n            case \"line\":\n                c = this.drawLine(board, x, y, attributes);\n                break;\n            case \"fit\":\n                c = this.drawFit(board, x, y, attributes);\n                break;\n            case \"spline\":\n                c = this.drawSpline(board, x, y, attributes);\n                break;\n            case \"pie\":\n                c = this.drawPie(board, y, attributes);\n                break;\n            case \"point\":\n                c = this.drawPoints(board, x, y, attributes);\n                break;\n            case \"radar\":\n                c = this.drawRadar(board, parents, attributes);\n                break;\n        }\n        this.elements.push(c);\n    }\n    this.id = this.board.setId(this, \"Chart\");\n\n    return this.elements;\n};\n\nJXG.Chart.prototype = new GeometryElement();\n\nJXG.extend(\n    JXG.Chart.prototype,\n    /** @lends JXG.Chart.prototype */ {\n        /**\n         * Create line chart defined by two data arrays.\n         *\n         * @param  {String,JXG.Board} board      The board the chart is drawn on\n         * @param  {Array} x          Array of x-coordinates\n         * @param  {Array} y          Array of y-coordinates\n         * @param  {Object} attributes  Javascript object containing attributes like colors\n         * @returns {JXG.Curve}       JSXGraph curve\n         */\n        drawLine: function (board, x, y, attributes) {\n            // we don't want the line chart to be filled\n            attributes.fillcolor = \"none\";\n            attributes.highlightfillcolor = \"none\";\n\n            return board.create(\"curve\", [x, y], attributes);\n        },\n\n        /**\n         * Create line chart that consists of a natural spline curve\n         * defined by two data arrays.\n         *\n         * @param  {String,JXG.Board} board      The board the chart is drawn on\n         * @param  {Array} x          Array of x-coordinates\n         * @param  {Array} y          Array of y-coordinates\n         * @param  {Object} attributes Javascript object containing attributes like colors\n         * @returns {JXG.Curve}       JSXGraph (natural) spline curve\n         */\n        drawSpline: function (board, x, y, attributes) {\n            // we don't want the spline chart to be filled\n            attributes.fillColor = \"none\";\n            attributes.highlightfillcolor = \"none\";\n\n            return board.create(\"spline\", [x, y], attributes);\n        },\n\n        /**\n         * Create line chart where the curve is given by a regression polynomial\n         * defined by two data arrays. The degree of the polynomial is supplied\n         * through the attribute \"degree\" in attributes.\n         *\n         * @param  {String,JXG.Board} board      The board the chart is drawn on\n         * @param  {Array} x          Array of x-coordinates\n         * @param  {Array} y          Array of y-coordinates\n         * @param  {Object} attributes Javascript object containing attributes like colors\n         * @returns {JXG.Curve}    JSXGraph function graph object\n         */\n        drawFit: function (board, x, y, attributes) {\n            var deg = attributes.degree;\n\n            deg = Math.max(parseInt(deg, 10), 1) || 1;\n\n            // never fill\n            attributes.fillcolor = \"none\";\n            attributes.highlightfillcolor = \"none\";\n\n            return board.create(\n                \"functiongraph\",\n                [Numerics.regressionPolynomial(deg, x, y)],\n                attributes\n            );\n        },\n\n        /**\n         * Create bar chart defined by two data arrays.\n         * Attributes to change the layout of the bar chart are:\n         * <ul>\n         * <li> width (optional)\n         * <li> dir: 'horizontal' or 'vertical'\n         * <li> colors: array of colors\n         * <li> labels: array of labels\n         * </ul>\n         *\n         * @param  {String,JXG.Board} board      The board the chart is drawn on\n         * @param  {Array} x          Array of x-coordinates\n         * @param  {Array} y          Array of y-coordinates\n         * @param  {Object} attributes Javascript object containing attributes like colors\n         * @returns {Array}    Array of JXG polygons defining the bars\n         */\n        drawBar: function (board, x, y, attributes) {\n            var i,\n                strwidth,\n                text,\n                w,\n                xp0,\n                xp1,\n                xp2,\n                yp,\n                colors,\n                pols = [],\n                p = [],\n                attr,\n                attrSub,\n                makeXpFun = function (i, f) {\n                    return function () {\n                        return x[i]() - f * w;\n                    };\n                },\n                hiddenPoint = {\n                    fixed: true,\n                    withLabel: false,\n                    visible: false,\n                    name: \"\"\n                };\n\n            attr = Type.copyAttributes(attributes, board.options, \"chart\");\n\n            // Determine the width of the bars\n            if (attr && attr.width) {\n                // width given\n                w = attr.width;\n            } else {\n                if (x.length <= 1) {\n                    w = 1;\n                } else {\n                    // Find minimum distance between to bars.\n                    w = x[1] - x[0];\n                    for (i = 1; i < x.length - 1; i++) {\n                        w = x[i + 1] - x[i] < w ? x[i + 1] - x[i] : w;\n                    }\n                }\n                w *= 0.8;\n            }\n\n            attrSub = Type.copyAttributes(attributes, board.options, \"chart\", \"label\");\n\n            for (i = 0; i < x.length; i++) {\n                if (Type.isFunction(x[i])) {\n                    xp0 = makeXpFun(i, -0.5);\n                    xp1 = makeXpFun(i, 0);\n                    xp2 = makeXpFun(i, 0.5);\n                } else {\n                    xp0 = x[i] - w * 0.5;\n                    xp1 = x[i];\n                    xp2 = x[i] + w * 0.5;\n                }\n                if (Type.isFunction(y[i])) {\n                    yp = y[i]();\n                } else {\n                    yp = y[i];\n                }\n                yp = y[i];\n\n                if (attr.dir === \"horizontal\") {\n                    // horizontal bars\n                    p[0] = board.create(\"point\", [0, xp0], hiddenPoint);\n                    p[1] = board.create(\"point\", [yp, xp0], hiddenPoint);\n                    p[2] = board.create(\"point\", [yp, xp2], hiddenPoint);\n                    p[3] = board.create(\"point\", [0, xp2], hiddenPoint);\n\n                    if (Type.exists(attr.labels) && Type.exists(attr.labels[i])) {\n                        attrSub.anchorY = \"middle\";\n                        text = board.create(\"text\", [yp, xp1, attr.labels[i]], attrSub);\n                        text.visProp.anchorx = (function (txt) {\n                            return function () {\n                                return txt.X() >= 0 ? \"left\" : \"right\";\n                            };\n                        })(text);\n                    }\n                } else {\n                    // vertical bars\n                    p[0] = board.create(\"point\", [xp0, 0], hiddenPoint);\n                    p[1] = board.create(\"point\", [xp0, yp], hiddenPoint);\n                    p[2] = board.create(\"point\", [xp2, yp], hiddenPoint);\n                    p[3] = board.create(\"point\", [xp2, 0], hiddenPoint);\n\n                    if (Type.exists(attr.labels) && Type.exists(attr.labels[i])) {\n                        attrSub.anchorX = \"middle\";\n\n                        text = board.create(\"text\", [xp1, yp, attr.labels[i]], attrSub);\n\n                        text.visProp.anchory = (function (txt) {\n                            return function () {\n                                return txt.Y() >= 0 ? \"bottom\" : \"top\";\n                            };\n                        })(text);\n                    }\n                }\n\n                if (Type.isArray(attr.colors)) {\n                    colors = attr.colors;\n                    attr.fillcolor = colors[i % colors.length];\n                }\n\n                pols[i] = board.create(\"polygon\", p, attr);\n                if (Type.exists(attr.labels) && Type.exists(attr.labels[i])) {\n                    pols[i].text = text;\n                }\n            }\n\n            return pols;\n        },\n\n        /**\n         * Create chart consisting of JSXGraph points.\n         * Attributes to change the layout of the point chart are:\n         * <ul>\n         * <li> fixed (Boolean)\n         * <li> infoboxArray (Array): Texts for the infobox\n         * </ul>\n         *\n         * @param  {String,JXG.Board} board      The board the chart is drawn on\n         * @param  {Array} x          Array of x-coordinates\n         * @param  {Array} y          Array of y-coordinates\n         * @param  {Object} attributes Javascript object containing attributes like colors\n         * @returns {Array} Array of JSXGraph points\n         */\n        drawPoints: function (board, x, y, attributes) {\n            var i,\n                points = [],\n                infoboxArray = attributes.infoboxarray;\n\n            attributes.fixed = true;\n            attributes.name = \"\";\n\n            for (i = 0; i < x.length; i++) {\n                attributes.infoboxtext = infoboxArray\n                    ? infoboxArray[i % infoboxArray.length]\n                    : false;\n                points[i] = board.create(\"point\", [x[i], y[i]], attributes);\n            }\n\n            return points;\n        },\n\n        /**\n         * Create pie chart.\n         * Attributes to change the layout of the pie chart are:\n         * <ul>\n         * <li> labels: array of labels\n         * <li> colors: (Array)\n         * <li> highlightColors (Array)\n         * <li> radius\n         * <li> center (coordinate array)\n         * <li> highlightOnSector (Boolean)\n         * </ul>\n         *\n         * @param  {String,JXG.Board} board      The board the chart is drawn on\n         * @param  {Array} y          Array of x-coordinates\n         * @param  {Object} attributes Javascript object containing attributes like colors\n         * @returns {Object}  with keys: \"{sectors, points, midpoint}\"\n         */\n        drawPie: function (board, y, attributes) {\n            var i,\n                center,\n                p = [],\n                sector = [],\n                s = Statistics.sum(y),\n                colorArray = attributes.colors,\n                highlightColorArray = attributes.highlightcolors,\n                labelArray = attributes.labels,\n                r = attributes.radius || 4,\n                radius = r,\n                cent = attributes.center || [0, 0],\n                xc = cent[0],\n                yc = cent[1],\n                makeRadPointFun = function (j, fun, xc) {\n                    return function () {\n                        var s,\n                            i,\n                            rad,\n                            t = 0;\n\n                        for (i = 0; i <= j; i++) {\n                            t += parseFloat(Type.evaluate(y[i]));\n                        }\n\n                        s = t;\n                        for (i = j + 1; i < y.length; i++) {\n                            s += parseFloat(Type.evaluate(y[i]));\n                        }\n                        rad = s !== 0 ? (2 * Math.PI * t) / s : 0;\n\n                        return radius() * Math[fun](rad) + xc;\n                    };\n                },\n                highlightHandleLabel = function (f, s) {\n                    var dx = -this.point1.coords.usrCoords[1] + this.point2.coords.usrCoords[1],\n                        dy = -this.point1.coords.usrCoords[2] + this.point2.coords.usrCoords[2];\n\n                    if (Type.exists(this.label)) {\n                        this.label.rendNode.style.fontSize =\n                            s * Type.evaluate(this.label.visProp.fontsize) + \"px\";\n                        this.label.fullUpdate();\n                    }\n\n                    this.point2.coords = new Coords(\n                        Const.COORDS_BY_USER,\n                        [\n                            this.point1.coords.usrCoords[1] + dx * f,\n                            this.point1.coords.usrCoords[2] + dy * f\n                        ],\n                        this.board\n                    );\n                    this.fullUpdate();\n                },\n                highlightFun = function () {\n                    if (!this.highlighted) {\n                        this.highlighted = true;\n                        this.board.highlightedObjects[this.id] = this;\n                        this.board.renderer.highlight(this);\n\n                        highlightHandleLabel.call(this, 1.1, 2);\n                    }\n                },\n                noHighlightFun = function () {\n                    if (this.highlighted) {\n                        this.highlighted = false;\n                        this.board.renderer.noHighlight(this);\n\n                        highlightHandleLabel.call(this, 0.9090909, 1);\n                    }\n                },\n                hiddenPoint = {\n                    fixed: true,\n                    withLabel: false,\n                    visible: false,\n                    name: \"\"\n                };\n\n            if (!Type.isArray(labelArray)) {\n                labelArray = [];\n                for (i = 0; i < y.length; i++) {\n                    labelArray[i] = \"\";\n                }\n            }\n\n            if (!Type.isFunction(r)) {\n                radius = function () {\n                    return r;\n                };\n            }\n\n            attributes.highlightonsector = attributes.highlightonsector || false;\n            attributes.straightfirst = false;\n            attributes.straightlast = false;\n\n            center = board.create(\"point\", [xc, yc], hiddenPoint);\n            p[0] = board.create(\n                \"point\",\n                [\n                    function () {\n                        return radius() + xc;\n                    },\n                    function () {\n                        return yc;\n                    }\n                ],\n                hiddenPoint\n            );\n\n            for (i = 0; i < y.length; i++) {\n                p[i + 1] = board.create(\n                    \"point\",\n                    [makeRadPointFun(i, \"cos\", xc), makeRadPointFun(i, \"sin\", yc)],\n                    hiddenPoint\n                );\n\n                attributes.name = labelArray[i];\n                attributes.withlabel = attributes.name !== \"\";\n                attributes.fillcolor = colorArray && colorArray[i % colorArray.length];\n                attributes.labelcolor = colorArray && colorArray[i % colorArray.length];\n                attributes.highlightfillcolor =\n                    highlightColorArray && highlightColorArray[i % highlightColorArray.length];\n\n                sector[i] = board.create(\"sector\", [center, p[i], p[i + 1]], attributes);\n\n                if (attributes.highlightonsector) {\n                    // overwrite hasPoint so that the whole sector is used for highlighting\n                    sector[i].hasPoint = sector[i].hasPointSector;\n                }\n                if (attributes.highlightbysize) {\n                    sector[i].highlight = highlightFun;\n\n                    sector[i].noHighlight = noHighlightFun;\n                }\n            }\n\n            // Not enough! We need points, but this gives an error in setAttribute.\n            return { sectors: sector, points: p, midpoint: center };\n        },\n\n        /**\n         * Create radar chart.\n         * Attributes to change the layout of the pie chart are:\n         * <ul>\n         * <li> paramArray: labels for axes, [ paramx, paramy, paramz ]\n         * <li> startShiftRatio: 0 <= offset from chart center <=1\n         * <li> endShiftRatio:  0 <= offset from chart radius <=1\n         * <li> startShiftArray: Adjust offsets per each axis\n         * <li> endShiftArray: Adjust offsets per each axis\n         * <li> startArray: Values for inner circle. Default values: minimums\n         * <li> start: one value to overwrite all startArray values\n         * <li> endArray: Values for outer circle, maximums by default\n         * <li> end: one value to overwrite all endArray values\n         * <li> labelArray\n         * <li> polyStrokeWidth\n         * <li> colors\n         * <li> highlightcolors\n         * <li> labelArray: [ row1, row2, row3 ]\n         * <li> radius\n         * <li> legendPosition\n         * <li> showCircles\n         * <li> circleLabelArray\n         * <li> circleStrokeWidth\n         * </ul>\n         *\n         * @param  {String,JXG.Board} board      The board the chart is drawn on\n         * @param  {Array} parents    Array of coordinates, e.g. [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3]]\n         * @param  {Object} attributes Javascript object containing attributes like colors\n         * @returns {Object} with keys \"{circles, lines, points, midpoint, polygons}\"\n         */\n        drawRadar: function (board, parents, attributes) {\n            var i,\n                j,\n                paramArray,\n                numofparams,\n                maxes,\n                mins,\n                la,\n                pdata,\n                ssa,\n                esa,\n                ssratio,\n                esratio,\n                sshifts,\n                eshifts,\n                starts,\n                ends,\n                labelArray,\n                colorArray,\n                highlightColorArray,\n                radius,\n                myAtts,\n                cent,\n                xc,\n                yc,\n                center,\n                start_angle,\n                rad,\n                p,\n                line,\n                t,\n                xcoord,\n                ycoord,\n                polygons,\n                legend_position,\n                circles,\n                lxoff,\n                lyoff,\n                cla,\n                clabelArray,\n                ncircles,\n                pcircles,\n                angle,\n                dr,\n                sw,\n                data,\n                len = parents.length,\n                get_anchor = function () {\n                    var x1,\n                        x2,\n                        y1,\n                        y2,\n                        relCoords = Type.evaluate(this.visProp.label.offset).slice(0);\n\n                    x1 = this.point1.X();\n                    x2 = this.point2.X();\n                    y1 = this.point1.Y();\n                    y2 = this.point2.Y();\n                    if (x2 < x1) {\n                        relCoords[0] = -relCoords[0];\n                    }\n\n                    if (y2 < y1) {\n                        relCoords[1] = -relCoords[1];\n                    }\n\n                    this.setLabelRelativeCoords(relCoords);\n\n                    return new Coords(\n                        Const.COORDS_BY_USER,\n                        [this.point2.X(), this.point2.Y()],\n                        this.board\n                    );\n                },\n                get_transform = function (angle, i) {\n                    var t, tscale, trot;\n\n                    t = board.create(\"transform\", [-(starts[i] - sshifts[i]), 0], {\n                        type: \"translate\"\n                    });\n                    tscale = board.create(\n                        \"transform\",\n                        [radius / (ends[i] + eshifts[i] - (starts[i] - sshifts[i])), 1],\n                        { type: \"scale\" }\n                    );\n                    t.melt(tscale);\n                    trot = board.create(\"transform\", [angle], { type: \"rotate\" });\n                    t.melt(trot);\n\n                    return t;\n                };\n\n            if (len <= 0) {\n                throw new Error(\"JSXGraph radar chart: no data\");\n            }\n            // labels for axes\n            paramArray = attributes.paramarray;\n            if (!Type.exists(paramArray)) {\n                throw new Error(\"JSXGraph radar chart: need paramArray attribute\");\n            }\n            numofparams = paramArray.length;\n            if (numofparams <= 1) {\n                throw new Error(\"JSXGraph radar chart: need more than one param in paramArray\");\n            }\n\n            for (i = 0; i < len; i++) {\n                if (numofparams !== parents[i].length) {\n                    throw new Error(\n                        \"JSXGraph radar chart: use data length equal to number of params (\" +\n                            parents[i].length +\n                            \" != \" +\n                            numofparams +\n                            \")\"\n                    );\n                }\n            }\n\n            maxes = [];\n            mins = [];\n\n            for (j = 0; j < numofparams; j++) {\n                maxes[j] = parents[0][j];\n                mins[j] = maxes[j];\n            }\n\n            for (i = 1; i < len; i++) {\n                for (j = 0; j < numofparams; j++) {\n                    if (parents[i][j] > maxes[j]) {\n                        maxes[j] = parents[i][j];\n                    }\n\n                    if (parents[i][j] < mins[j]) {\n                        mins[j] = parents[i][j];\n                    }\n                }\n            }\n\n            la = [];\n            pdata = [];\n\n            for (i = 0; i < len; i++) {\n                la[i] = \"\";\n                pdata[i] = [];\n            }\n\n            ssa = [];\n            esa = [];\n\n            // 0 <= Offset from chart center <=1\n            ssratio = attributes.startshiftratio || 0;\n            // 0 <= Offset from chart radius <=1\n            esratio = attributes.endshiftratio || 0;\n\n            for (i = 0; i < numofparams; i++) {\n                ssa[i] = (maxes[i] - mins[i]) * ssratio;\n                esa[i] = (maxes[i] - mins[i]) * esratio;\n            }\n\n            // Adjust offsets per each axis\n            sshifts = attributes.startshiftarray || ssa;\n            eshifts = attributes.endshiftarray || esa;\n            // Values for inner circle, minimums by default\n            starts = attributes.startarray || mins;\n\n            if (Type.exists(attributes.start)) {\n                for (i = 0; i < numofparams; i++) {\n                    starts[i] = attributes.start;\n                }\n            }\n\n            // Values for outer circle, maximums by default\n            ends = attributes.endarray || maxes;\n            if (Type.exists(attributes.end)) {\n                for (i = 0; i < numofparams; i++) {\n                    ends[i] = attributes.end;\n                }\n            }\n\n            if (sshifts.length !== numofparams) {\n                throw new Error(\n                    \"JSXGraph radar chart: start shifts length is not equal to number of parameters\"\n                );\n            }\n\n            if (eshifts.length !== numofparams) {\n                throw new Error(\n                    \"JSXGraph radar chart: end shifts length is not equal to number of parameters\"\n                );\n            }\n\n            if (starts.length !== numofparams) {\n                throw new Error(\n                    \"JSXGraph radar chart: starts length is not equal to number of parameters\"\n                );\n            }\n\n            if (ends.length !== numofparams) {\n                throw new Error(\n                    \"JSXGraph radar chart: snds length is not equal to number of parameters\"\n                );\n            }\n\n            // labels for legend\n            labelArray = attributes.labelarray || la;\n            colorArray = attributes.colors;\n            highlightColorArray = attributes.highlightcolors;\n            radius = attributes.radius || 10;\n            sw = attributes.strokewidth || 1;\n\n            if (!Type.exists(attributes.highlightonsector)) {\n                attributes.highlightonsector = false;\n            }\n\n            myAtts = {\n                name: attributes.name,\n                id: attributes.id,\n                strokewidth: sw,\n                polystrokewidth: attributes.polystrokewidth || sw,\n                strokecolor: attributes.strokecolor || \"black\",\n                straightfirst: false,\n                straightlast: false,\n                fillcolor: attributes.fillColor || \"#FFFF88\",\n                fillopacity: attributes.fillOpacity || 0.4,\n                highlightfillcolor: attributes.highlightFillColor || \"#FF7400\",\n                highlightstrokecolor: attributes.highlightStrokeColor || \"black\",\n                gradient: attributes.gradient || \"none\"\n            };\n\n            cent = attributes.center || [0, 0];\n            xc = cent[0];\n            yc = cent[1];\n            center = board.create(\"point\", [xc, yc], {\n                name: \"\",\n                fixed: true,\n                withlabel: false,\n                visible: false\n            });\n            start_angle = Math.PI / 2 - Math.PI / numofparams;\n            start_angle = attributes.startangle || 0;\n            rad = start_angle;\n            p = [];\n            line = [];\n\n            for (i = 0; i < numofparams; i++) {\n                rad += (2 * Math.PI) / numofparams;\n                xcoord = radius * Math.cos(rad) + xc;\n                ycoord = radius * Math.sin(rad) + yc;\n\n                p[i] = board.create(\"point\", [xcoord, ycoord], {\n                    name: \"\",\n                    fixed: true,\n                    withlabel: false,\n                    visible: false\n                });\n                line[i] = board.create(\"line\", [center, p[i]], {\n                    name: paramArray[i],\n                    strokeColor: myAtts.strokecolor,\n                    strokeWidth: myAtts.strokewidth,\n                    strokeOpacity: 1.0,\n                    straightFirst: false,\n                    straightLast: false,\n                    withLabel: true,\n                    highlightStrokeColor: myAtts.highlightstrokecolor\n                });\n                line[i].getLabelAnchor = get_anchor;\n                t = get_transform(rad, i);\n\n                for (j = 0; j < parents.length; j++) {\n                    data = parents[j][i];\n                    pdata[j][i] = board.create(\"point\", [data, 0], {\n                        name: \"\",\n                        fixed: true,\n                        withlabel: false,\n                        visible: false\n                    });\n                    pdata[j][i].addTransform(pdata[j][i], t);\n                }\n            }\n\n            polygons = [];\n            for (i = 0; i < len; i++) {\n                myAtts.labelcolor = colorArray && colorArray[i % colorArray.length];\n                myAtts.strokecolor = colorArray && colorArray[i % colorArray.length];\n                myAtts.fillcolor = colorArray && colorArray[i % colorArray.length];\n                polygons[i] = board.create(\"polygon\", pdata[i], {\n                    withLines: true,\n                    withLabel: false,\n                    fillColor: myAtts.fillcolor,\n                    fillOpacity: myAtts.fillopacity,\n                    highlightFillColor: myAtts.highlightfillcolor\n                });\n\n                for (j = 0; j < numofparams; j++) {\n                    polygons[i].borders[j].setAttribute(\n                        \"strokecolor:\" + colorArray[i % colorArray.length]\n                    );\n                    polygons[i].borders[j].setAttribute(\n                        \"strokewidth:\" + myAtts.polystrokewidth\n                    );\n                }\n            }\n\n            legend_position = attributes.legendposition || \"none\";\n            switch (legend_position) {\n                case \"right\":\n                    lxoff = attributes.legendleftoffset || 2;\n                    lyoff = attributes.legendtopoffset || 1;\n\n                    this.legend = board.create(\n                        \"legend\",\n                        [xc + radius + lxoff, yc + radius - lyoff],\n                        {\n                            labels: labelArray,\n                            colors: colorArray\n                        }\n                    );\n                    break;\n                case \"none\":\n                    break;\n                default:\n                    JXG.debug(\"Unknown legend position\");\n            }\n\n            circles = [];\n            if (attributes.showcircles) {\n                cla = [];\n                for (i = 0; i < 6; i++) {\n                    cla[i] = 20 * i;\n                }\n                cla[0] = \"0\";\n                clabelArray = attributes.circlelabelarray || cla;\n                ncircles = clabelArray.length;\n\n                if (ncircles < 2) {\n                    throw new Error(\n                        \"JSXGraph radar chart: too less circles in circleLabelArray\"\n                    );\n                }\n\n                pcircles = [];\n                angle = start_angle + Math.PI / numofparams;\n                t = get_transform(angle, 0);\n\n                myAtts.fillcolor = \"none\";\n                myAtts.highlightfillcolor = \"none\";\n                myAtts.strokecolor = attributes.strokecolor || \"black\";\n                myAtts.strokewidth = attributes.circlestrokewidth || 0.5;\n                myAtts.layer = 0;\n\n                // we have ncircles-1 intervals between ncircles circles\n                dr = (ends[0] - starts[0]) / (ncircles - 1);\n\n                for (i = 0; i < ncircles; i++) {\n                    pcircles[i] = board.create(\"point\", [starts[0] + i * dr, 0], {\n                        name: clabelArray[i],\n                        size: 0,\n                        fixed: true,\n                        withLabel: true,\n                        visible: true\n                    });\n                    pcircles[i].addTransform(pcircles[i], t);\n                    circles[i] = board.create(\"circle\", [center, pcircles[i]], myAtts);\n                }\n            }\n            this.rendNode = polygons[0].rendNode;\n            return {\n                circles: circles,\n                lines: line,\n                points: pdata,\n                midpoint: center,\n                polygons: polygons\n            };\n        },\n\n        /**\n         * Uses the boards renderer to update the chart.\n         * @private\n         */\n        updateRenderer: function () {\n            return this;\n        },\n\n        // documented in base/element\n        update: function () {\n            if (this.needsUpdate) {\n                this.updateDataArray();\n            }\n\n            return this;\n        },\n\n        /**\n         * Template for dynamic charts update.\n         * This method is used to compute new entries\n         * for the arrays this.dataX and\n         * this.dataY. It is used in update.\n         * Default is an empty method, can be overwritten\n         * by the user.\n         *\n         * @returns {JXG.Chart} Reference to this chart object.\n         */\n        updateDataArray: function () {\n            return this;\n        }\n    }\n);\n\n/**\n * @class Constructor for a chart.\n * @pseudo\n * @description\n * @name Chart\n * @augments JXG.Chart\n * @constructor\n * @type JXG.Chart\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Array} x Array of x-coordinates (default case, see below for alternatives)\n * @param {Array} y Array of y-coordinates (default case, see below for alternatives)\n * <p>\n * The parent array may be of one of the following forms:\n * <ol>\n * <li> Parents array looks like [number, number, number, ...]. It is interpreted as array of y-coordinates.\n * The x coordinates are automatically set to [1, 2, ...]\n * <li> Parents array looks like [[number, number, number, ...]]. The content is interpreted as array of y-coordinates.\n * The x coordinates are automatically set to [1, 2, ...]x coordinates are automatically set to [1, 2, ...]\n * Default case: [[x0,x1,x2,...],[y1,y2,y3,...]]\n * </ol>\n *\n * The attribute value for the key 'chartStyle' determines the type(s) of the chart. 'chartStyle' is a comma\n * separated list of strings of the possible chart types\n * 'bar', 'fit', 'line',  'pie', 'point', 'radar', 'spline'.\n *\n * @see JXG.Chart#drawBar\n * @see JXG.Chart#drawFit\n * @see JXG.Chart#drawLine\n * @see JXG.Chart#drawPie\n * @see JXG.Chart#drawPoints\n * @see JXG.Chart#drawRadar\n * @see JXG.Chart#drawSpline\n *\n * @example\n *   board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox:[-0.5,8,9,-2],axis:true});\n *\n *   var f = [4, 2, -1, 3, 6, 7, 2];\n *   var chart = board.create('chart', f,\n *                 {chartStyle:'bar',\n *                  width:0.8,\n *                  labels:f,\n *                  colorArray:['#8E1B77','#BE1679','#DC1765','#DA2130','#DB311B','#DF4917','#E36317','#E87F1A',\n *                              '#F1B112','#FCF302','#C1E212'],\n *                  label: {fontSize:30, display:'internal', anchorX:'left', rotate:90}\n *             });\n *\n * </pre><div id=\"JXG1528c395-9fa4-4210-ada6-7fc5652ed920\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG1528c395-9fa4-4210-ada6-7fc5652ed920',\n *             {boundingbox: [-0.5,8,9,-2], axis: true, showcopyright: false, shownavigation: false});\n *                 var f = [4,2,-1,3,6,7,2];\n *                 var chart = board.create('chart', f,\n *                     {chartStyle:'bar',\n *                      width:0.8,\n *                      labels:f,\n *                      colorArray:['#8E1B77','#BE1679','#DC1765','#DA2130','#DB311B','#DF4917','#E36317','#E87F1A',\n *                                  '#F1B112','#FCF302','#C1E212'],\n *                      label: {fontSize:30, display:'internal', anchorX:'left', rotate:90}\n *                 });\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n *   board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 9, 13, -3], axis:true});\n *\n *   var s = board.create('slider', [[4,7],[8,7],[1,1,1.5]], {name:'S', strokeColor:'black', fillColor:'white'});\n *   var f = [function(){return (s.Value()*4.5).toFixed(2);},\n *                      function(){return (s.Value()*(-1)).toFixed(2);},\n *                      function(){return (s.Value()*3).toFixed(2);},\n *                      function(){return (s.Value()*2).toFixed(2);},\n *                      function(){return (s.Value()*(-0.5)).toFixed(2);},\n *                      function(){return (s.Value()*5.5).toFixed(2);},\n *                      function(){return (s.Value()*2.5).toFixed(2);},\n *                      function(){return (s.Value()*(-0.75)).toFixed(2);},\n *                      function(){return (s.Value()*3.5).toFixed(2);},\n *                      function(){return (s.Value()*2).toFixed(2);},\n *                      function(){return (s.Value()*(-1.25)).toFixed(2);}\n *                      ];\n *   var chart = board.create('chart', [f],\n *                                             {chartStyle:'bar',width:0.8,labels:f,\n *                                              colorArray:['#8E1B77','#BE1679','#DC1765','#DA2130','#DB311B','#DF4917','#E36317','#E87F1A',\n *                                                          '#F1B112','#FCF302','#C1E212']});\n *\n *   var dataArr = [4,1,3,2,5,6.5,1.5,2,0.5,1.5,-1];\n *   var chart2 = board.create('chart', dataArr, {chartStyle:'line,point'});\n *   chart2[0].setAttribute('strokeColor:black','strokeWidth:2pt');\n *   for(var i=0; i<11;i++) {\n *            chart2[1][i].setAttribute({strokeColor:'black',fillColor:'white',face:'[]', size:4, strokeWidth:'2pt'});\n *   }\n *   board.unsuspendUpdate();\n *\n * </pre><div id=\"JXG22deb158-48c6-41c3-8157-b88b4b968a55\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG22deb158-48c6-41c3-8157-b88b4b968a55',\n *             {boundingbox: [-1, 9, 13, -3], axis: true, showcopyright: false, shownavigation: false});\n *                 var s = board.create('slider', [[4,7],[8,7],[1,1,1.5]], {name:'S', strokeColor:'black', fillColor:'white'});\n *                 var f = [function(){return (s.Value()*4.5).toFixed(2);},\n *                          function(){return (s.Value()*(-1)).toFixed(2);},\n *                          function(){return (s.Value()*3).toFixed(2);},\n *                          function(){return (s.Value()*2).toFixed(2);},\n *                          function(){return (s.Value()*(-0.5)).toFixed(2);},\n *                          function(){return (s.Value()*5.5).toFixed(2);},\n *                          function(){return (s.Value()*2.5).toFixed(2);},\n *                          function(){return (s.Value()*(-0.75)).toFixed(2);},\n *                          function(){return (s.Value()*3.5).toFixed(2);},\n *                          function(){return (s.Value()*2).toFixed(2);},\n *                          function(){return (s.Value()*(-1.25)).toFixed(2);}\n *                          ];\n *                 var chart = board.create('chart', [f],\n *                                                 {chartStyle:'bar',width:0.8,labels:f,\n *                                                  colorArray:['#8E1B77','#BE1679','#DC1765','#DA2130','#DB311B','#DF4917','#E36317','#E87F1A',\n *                                                              '#F1B112','#FCF302','#C1E212']});\n *\n *                 var dataArr = [4,1,3,2,5,6.5,1.5,2,0.5,1.5,-1];\n *                 var chart2 = board.create('chart', dataArr, {chartStyle:'line,point'});\n *                 chart2[0].setAttribute('strokeColor:black','strokeWidth:2pt');\n *                 for(var i=0; i<11;i++) {\n *                     chart2[1][i].setAttribute({strokeColor:'black',fillColor:'white',face:'[]', size:4, strokeWidth:'2pt'});\n *                 }\n *                 board.unsuspendUpdate();\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n *         var dataArr = [4, 1.2, 3, 7, 5, 4, 1.54, function () { return 2; }];\n *         var a = board.create('chart', dataArr, {\n *                 chartStyle:'pie', colors:['#B02B2C','#3F4C6B','#C79810','#D15600'],\n *                 fillOpacity:0.9,\n *                 center:[5,2],\n *                 strokeColor:'#ffffff',\n *                 strokeWidth:6,\n *                 highlightBySize:true,\n *                 highlightOnSector:true\n *             });\n *\n * </pre><div id=\"JXG1180b7dd-b048-436a-a5ad-87ffa82d5aff\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG1180b7dd-b048-436a-a5ad-87ffa82d5aff',\n *             {boundingbox: [0, 8, 12, -4], axis: true, showcopyright: false, shownavigation: false});\n *             var dataArr = [4, 1.2, 3, 7, 5, 4, 1.54, function () { return 2; }];\n *             var a = board.create('chart', dataArr, {\n *                     chartStyle:'pie', colors:['#B02B2C','#3F4C6B','#C79810','#D15600'],\n *                     fillOpacity:0.9,\n *                     center:[5,2],\n *                     strokeColor:'#ffffff',\n *                     strokeWidth:6,\n *                     highlightBySize:true,\n *                     highlightOnSector:true\n *                 });\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n *             board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-12, 12, 20, -12], axis: false});\n *             board.suspendUpdate();\n *             // See labelArray and paramArray\n *             var dataArr = [[23, 14, 15.0], [60, 8, 25.0], [0, 11.0, 25.0], [10, 15, 20.0]];\n *\n *             var a = board.create('chart', dataArr, {\n *                 chartStyle:'radar',\n *                 colorArray:['#0F408D','#6F1B75','#CA147A','#DA2228','#E8801B','#FCF302','#8DC922','#15993C','#87CCEE','#0092CE'],\n *                 //fillOpacity:0.5,\n *                 //strokeColor:'black',\n *                 //strokeWidth:1,\n *                 //polyStrokeWidth:1,\n *                 paramArray:['Speed','Flexibility', 'Costs'],\n *                 labelArray:['Ruby','JavaScript', 'PHP', 'Python'],\n *                 //startAngle:Math.PI/4,\n *                 legendPosition:'right',\n *                 //\"startShiftRatio\": 0.1,\n *                 //endShiftRatio:0.1,\n *                 //startShiftArray:[0,0,0],\n *                 //endShiftArray:[0.5,0.5,0.5],\n *                 start:0\n *                 //end:70,\n *                 //startArray:[0,0,0],\n *                 //endArray:[7,7,7],\n *                 //radius:3,\n *                 //showCircles:true,\n *                 //circleLabelArray:[1,2,3,4,5],\n *                 //highlightColorArray:['#E46F6A','#F9DF82','#F7FA7B','#B0D990','#69BF8E','#BDDDE4','#92C2DF','#637CB0','#AB91BC','#EB8EBF'],\n *             });\n *             board.unsuspendUpdate();\n *\n * </pre><div id=\"JXG985fbbe6-0488-4073-b73b-cb3ebaea488a\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG985fbbe6-0488-4073-b73b-cb3ebaea488a',\n *             {boundingbox: [-12, 12, 20, -12], axis: false, showcopyright: false, shownavigation: false});\n *                 board.suspendUpdate();\n *                 // See labelArray and paramArray\n *                 var dataArr = [[23, 14, 15.0], [60, 8, 25.0], [0, 11.0, 25.0], [10, 15, 20.0]];\n *\n *                 var a = board.create('chart', dataArr, {\n *                     chartStyle:'radar',\n *                     colorArray:['#0F408D','#6F1B75','#CA147A','#DA2228','#E8801B','#FCF302','#8DC922','#15993C','#87CCEE','#0092CE'],\n *                     //fillOpacity:0.5,\n *                     //strokeColor:'black',\n *                     //strokeWidth:1,\n *                     //polyStrokeWidth:1,\n *                     paramArray:['Speed','Flexibility', 'Costs'],\n *                     labelArray:['Ruby','JavaScript', 'PHP', 'Python'],\n *                     //startAngle:Math.PI/4,\n *                     legendPosition:'right',\n *                     //\"startShiftRatio\": 0.1,\n *                     //endShiftRatio:0.1,\n *                     //startShiftArray:[0,0,0],\n *                     //endShiftArray:[0.5,0.5,0.5],\n *                     start:0\n *                     //end:70,\n *                     //startArray:[0,0,0],\n *                     //endArray:[7,7,7],\n *                     //radius:3,\n *                     //showCircles:true,\n *                     //circleLabelArray:[1,2,3,4,5],\n *                     //highlightColorArray:['#E46F6A','#F9DF82','#F7FA7B','#B0D990','#69BF8E','#BDDDE4','#92C2DF','#637CB0','#AB91BC','#EB8EBF'],\n *                 });\n *                 board.unsuspendUpdate();\n *\n *     })();\n *\n * </script><pre>\n *\n * For more examples see\n * <ul>\n * <li><a href=\"https://jsxgraph.org/wiki/index.php/Charts_from_HTML_tables_-_tutorial\">JSXgraph wiki: Charts from HTML tables - tutorial</a>\n * <li><a href=\"https://jsxgraph.org/wiki/index.php/Pie_chart\">JSXgraph wiki: Pie chart</a>\n * <li><a href=\"https://jsxgraph.org/wiki/index.php/Different_chart_styles\">JSXgraph wiki: Various chart styles</a>\n * <li><a href=\"https://jsxgraph.org/wiki/index.php/Dynamic_bar_chart\">JSXgraph wiki: Dynamic bar chart</a>\n * </ul>\n */\nJXG.createChart = function (board, parents, attributes) {\n    var data,\n        row,\n        i,\n        j,\n        col,\n        charts = [],\n        w,\n        x,\n        showRows,\n        attr,\n        originalWidth,\n        name,\n        strokeColor,\n        fillColor,\n        hStrokeColor,\n        hFillColor,\n        len,\n        table = Env.isBrowser ? board.document.getElementById(parents[0]) : null;\n\n    if (parents.length === 1 && Type.isString(parents[0])) {\n        if (Type.exists(table)) {\n            // extract the data\n            attr = Type.copyAttributes(attributes, board.options, \"chart\");\n\n            table = new DataSource().loadFromTable(\n                parents[0],\n                attr.withheaders,\n                attr.withheaders\n            );\n            data = table.data;\n            col = table.columnHeaders;\n            row = table.rowHeaders;\n\n            originalWidth = attr.width;\n            name = attr.name;\n            strokeColor = attr.strokecolor;\n            fillColor = attr.fillcolor;\n            hStrokeColor = attr.highlightstrokecolor;\n            hFillColor = attr.highlightfillcolor;\n\n            board.suspendUpdate();\n\n            len = data.length;\n            showRows = [];\n            if (attr.rows && Type.isArray(attr.rows)) {\n                for (i = 0; i < len; i++) {\n                    for (j = 0; j < attr.rows.length; j++) {\n                        if (\n                            attr.rows[j] === i ||\n                            (attr.withheaders && attr.rows[j] === row[i])\n                        ) {\n                            showRows.push(data[i]);\n                            break;\n                        }\n                    }\n                }\n            } else {\n                showRows = data;\n            }\n\n            len = showRows.length;\n\n            for (i = 0; i < len; i++) {\n                x = [];\n                if (attr.chartstyle && attr.chartstyle.indexOf(\"bar\") !== -1) {\n                    if (originalWidth) {\n                        w = originalWidth;\n                    } else {\n                        w = 0.8;\n                    }\n\n                    x.push(1 - w / 2 + ((i + 0.5) * w) / len);\n\n                    for (j = 1; j < showRows[i].length; j++) {\n                        x.push(x[j - 1] + 1);\n                    }\n\n                    attr.width = w / len;\n                }\n\n                if (name && name.length === len) {\n                    attr.name = name[i];\n                } else if (attr.withheaders) {\n                    attr.name = col[i];\n                }\n\n                if (strokeColor && strokeColor.length === len) {\n                    attr.strokecolor = strokeColor[i];\n                } else {\n                    attr.strokecolor = Color.hsv2rgb(((i + 1) / len) * 360, 0.9, 0.6);\n                }\n\n                if (fillColor && fillColor.length === len) {\n                    attr.fillcolor = fillColor[i];\n                } else {\n                    attr.fillcolor = Color.hsv2rgb(((i + 1) / len) * 360, 0.9, 1.0);\n                }\n\n                if (hStrokeColor && hStrokeColor.length === len) {\n                    attr.highlightstrokecolor = hStrokeColor[i];\n                } else {\n                    attr.highlightstrokecolor = Color.hsv2rgb(((i + 1) / len) * 360, 0.9, 1.0);\n                }\n\n                if (hFillColor && hFillColor.length === len) {\n                    attr.highlightfillcolor = hFillColor[i];\n                } else {\n                    attr.highlightfillcolor = Color.hsv2rgb(((i + 1) / len) * 360, 0.9, 0.6);\n                }\n\n                if (attr.chartstyle && attr.chartstyle.indexOf(\"bar\") !== -1) {\n                    charts.push(new JXG.Chart(board, [x, showRows[i]], attr));\n                } else {\n                    charts.push(new JXG.Chart(board, [showRows[i]], attr));\n                }\n            }\n\n            board.unsuspendUpdate();\n        }\n        return charts;\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"chart\");\n    return new JXG.Chart(board, parents, attr);\n};\n\nJXG.registerElement(\"chart\", JXG.createChart);\n\n/**\n * Legend for chart\n * TODO\n *\n * The Legend class is a basic class for legends.\n * @class Creates a new Lgend object. Do not use this constructor to create a legend.\n * Use {@link JXG.Board#create} with type {@link Legend} instead.\n * <p>\n * The legend object consists of segements with labels. These lines can be\n * access with the property \"lines\" of the element.\n * @constructor\n * @augments JXG.GeometryElement\n * @param {String,JXG.Board} board The board the new legend is drawn on.\n * @param {Array} coords Coordinates of the left top point of the legend.\n * @param  {Object} attributes Attributes of the legend\n */\nJXG.Legend = function (board, coords, attributes) {\n    var attr;\n\n    /* Call the constructor of GeometryElement */\n    this.constructor();\n\n    attr = Type.copyAttributes(attributes, board.options, \"legend\");\n\n    this.board = board;\n    this.coords = new Coords(Const.COORDS_BY_USER, coords, this.board);\n    this.myAtts = {};\n    this.label_array = attr.labelarray || attr.labels;\n    this.color_array = attr.colorarray || attr.colors;\n    this.lines = [];\n    this.myAtts.strokewidth = attr.strokewidth || 5;\n    this.myAtts.straightfirst = false;\n    this.myAtts.straightlast = false;\n    this.myAtts.withlabel = true;\n    this.myAtts.fixed = true;\n    this.style = attr.legendstyle || attr.style;\n\n    if (this.style === \"vertical\") {\n        this.drawVerticalLegend(board, attr);\n    } else {\n        throw new Error(\"JSXGraph: Unknown legend style: \" + this.style);\n    }\n};\n\nJXG.Legend.prototype = new GeometryElement();\n\n/**\n * Draw a vertical legend.\n *\n * @private\n * @param  {String,JXG.Board} board      The board the legend is drawn on\n * @param  {Object} attributes Attributes of the legend\n */\nJXG.Legend.prototype.drawVerticalLegend = function (board, attributes) {\n    var i,\n        line_length = attributes.linelength || 1,\n        offy = (attributes.rowheight || 20) / this.board.unitY,\n        getLabelAnchor = function () {\n            this.setLabelRelativeCoords(this.visProp.label.offset);\n            return new Coords(\n                Const.COORDS_BY_USER,\n                [this.point2.X(), this.point2.Y()],\n                this.board\n            );\n        };\n\n    for (i = 0; i < this.label_array.length; i++) {\n        this.myAtts.name = this.label_array[i];\n        this.myAtts.strokecolor = this.color_array[i % this.color_array.length];\n        this.myAtts.highlightstrokecolor = this.color_array[i % this.color_array.length];\n        this.myAtts.label = {\n            offset: [10, 0],\n            strokeColor: this.color_array[i % this.color_array.length],\n            strokeWidth: this.myAtts.strokewidth\n        };\n\n        this.lines[i] = board.create(\n            \"line\",\n            [\n                [this.coords.usrCoords[1], this.coords.usrCoords[2] - i * offy],\n                [this.coords.usrCoords[1] + line_length, this.coords.usrCoords[2] - i * offy]\n            ],\n            this.myAtts\n        );\n\n        this.lines[i].getLabelAnchor = getLabelAnchor;\n        this.lines[i]\n            .prepareUpdate()\n            .update()\n            .updateVisibility(Type.evaluate(this.lines[i].visProp.visible))\n            .updateRenderer();\n    }\n};\n\n/**\n * @class This element is used to provide a constructor for a chart legend.\n * Parameter is a pair of coordinates. The label names and  the label colors are\n * supplied in the attributes:\n * <ul>\n * <li> labels (Array): array of strings containing label names\n * <li> labelArray (Array): alternative array for label names (has precedence over 'labels')\n * <li> colors (Array): array of color values\n * <li> colorArray (Array): alternative array for color values (has precedence over 'colors')\n * <li> legendStyle or style: at the time being only 'vertical' is supported.\n * <li> rowHeight.\n * </ul>\n *\n * @pseudo\n * @description\n * @name Legend\n * @augments JXG.Legend\n * @constructor\n * @type JXG.Legend\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Number} x Horizontal coordinate of the left top point of the legend\n * @param {Number} y Vertical coordinate of the left top point of the legend\n *\n * @example\n * var board = JXG.JSXGraph.initBoard('jxgbox', {axis:true,boundingbox:[-4,48.3,12.0,-2.3]});\n * var x       = [-3,-2,-1,0,1,2,3,4,5,6,7,8];\n * var dataArr = [4,7,7,27,33,37,46,22,11,4,1,0];\n *\n * colors = ['green', 'yellow', 'red', 'blue'];\n * board.create('chart', [x,dataArr], {chartStyle:'bar', width:1.0, labels:dataArr, colors: colors} );\n * board.create('legend', [8, 45], {labels:dataArr, colors: colors, strokeWidth:5} );\n *\n * </pre><div id=\"JXGeeb588d9-a4fd-41bf-93f4-cd6f7a016682\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGeeb588d9-a4fd-41bf-93f4-cd6f7a016682',\n *             {boundingbox: [-4,48.3,12.0,-2.3], axis: true, showcopyright: false, shownavigation: false});\n *     var x       = [-3,-2,-1,0,1,2,3,4,5,6,7,8];\n *     var dataArr = [4,7,7,27,33,37,46,22,11,4,1,0];\n *\n *     colors = ['green', 'yellow', 'red', 'blue'];\n *     board.create('chart', [x,dataArr], {chartStyle:'bar', width:1.0, labels:dataArr, colors: colors} );\n *     board.create('legend', [8, 45], {labels:dataArr, colors: colors, strokeWidth:5} );\n *\n *     })();\n *\n * </script><pre>\n *\n *\n */\nJXG.createLegend = function (board, parents, attributes) {\n    //parents are coords of left top point of the legend\n    var start_from = [0, 0];\n\n    if (Type.exists(parents) && parents.length === 2) {\n        start_from = parents;\n    } else {\n        throw new Error(\"JSXGraph: Legend element needs two numbers as parameters\");\n    }\n\n    return new JXG.Legend(board, start_from, attributes);\n};\n\nJXG.registerElement(\"legend\", JXG.createLegend);\n\nexport default {\n    Chart: JXG.Chart,\n    Legend: JXG.Legend,\n    createChart: JXG.createChart,\n    createLegend: JXG.createLegend\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The JSXGraph object Turtle is defined. It acts like\n * \"turtle graphics\".\n * @author A.W.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport GeometryElement from \"./element\";\nimport Type from \"../utils/type\";\n\n/**\n * Constructs a new Turtle object.\n * @class This is the Turtle class.\n * It is derived from {@link JXG.GeometryElement}.\n * It stores all properties required\n * to move a turtle.\n * @constructor\n * @param {JXG.Board} board The board the new turtle is drawn on.\n * @param {Array} parents Start position and start direction of the turtle. Possible values are\n * [x, y, angle]\n * [[x, y], angle]\n * [x, y]\n * [[x, y]]\n * @param {Object} attributes Attributes to change the visual properties of the turtle object\n * All angles are in degrees.\n *\n * @example\n *\n * //creates a figure 8 animation\n * var board = JXG.JSXGraph.initBoard('jxgbox',{boundingbox: [-250, 250, 250, -250]});\n * var t = board.create('turtle',[0, 0], {strokeOpacity:0.5});\n * t.setPenSize(3);\n * t.right(90);\n * var alpha = 0;\n *\n * var run = function() {\n *  t.forward(2);\n *  if (Math.floor(alpha / 360) % 2 === 0) {\n *   t.left(1);        // turn left by 1 degree\n *  } else {\n *   t.right(1);       // turn right by 1 degree\n *  }\n *  alpha += 1;\n *\n *  if (alpha < 1440) {  // stop after two rounds\n *   setTimeout(run, 20);\n *  }\n * }\n *\n *run();\n *\n * </pre><div class=\"jxgbox\" id=\"JXG14167b1c-2ad3-11e5-8dd9-901b0e1b8723\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var brd = JXG.JSXGraph.initBoard('JXG14167b1c-2ad3-11e5-8dd9-901b0e1b8723',\n *             {boundingbox: [-250, 250, 250, -250], axis: true, showcopyright: false, shownavigation: false});\n *               var t = brd.create('turtle',[0, 0], {strokeOpacity:0.5});\n *               t.setPenSize(3);\n *               t.right(90);\n *               var alpha = 0;\n *\n *              var run = function() {\n *              t.forward(2);\n *             if (Math.floor(alpha / 360) % 2 === 0) {\n *                t.left(1);        // turn left by 1 degree\n *              } else {\n *                   t.right(1);       // turn right by 1 degree\n *             }\n *             alpha += 1;\n *\n *             if (alpha < 1440) {  // stop after two rounds\n *                 setTimeout(run, 20);\n *               }\n *             }\n *\n *          run();\n *\n *     })();\n *\n * </script><pre>\n */\nJXG.Turtle = function (board, parents, attributes) {\n    var x, y, dir;\n\n    this.constructor(board, attributes, Const.OBJECT_TYPE_TURTLE, Const.OBJECT_CLASS_OTHER);\n\n    this.turtleIsHidden = false;\n    this.board = board;\n    this.visProp.curveType = \"plot\";\n\n    // Save visProp in this._attributes.\n    // this._attributes is overwritten by setPenSize, setPenColor...\n    // Setting the color or size affects the turtle from the time of\n    // calling the method,\n    // whereas Turtle.setAttribute affects all turtle curves.\n    this._attributes = Type.copyAttributes(this.visProp, board.options, \"turtle\");\n    delete this._attributes.id;\n\n    x = 0;\n    y = 0;\n    dir = 90;\n\n    if (parents.length !== 0) {\n        // [x,y,dir]\n        if (parents.length === 3) {\n            // Only numbers are accepted at the moment\n            x = parents[0];\n            y = parents[1];\n            dir = parents[2];\n        } else if (parents.length === 2) {\n            // [[x,y],dir]\n            if (Type.isArray(parents[0])) {\n                x = parents[0][0];\n                y = parents[0][1];\n                dir = parents[1];\n                // [x,y]\n            } else {\n                x = parents[0];\n                y = parents[1];\n            }\n            // [[x,y]]\n        } else {\n            x = parents[0][0];\n            y = parents[0][1];\n        }\n    }\n\n    this.init(x, y, dir);\n\n        this.methodMap = Type.deepCopy(this.methodMap, {\n            forward: 'forward',\n            fd: 'forward',\n            back: 'back',\n            bk: 'back',\n            right: 'right',\n            rt: 'right',\n            left: 'left',\n            lt: 'left',\n            penUp: 'penUp',\n            pu: 'penUp',\n            penDown: 'penDown',\n            pd: 'penDown',\n            clearScreen: 'clearScreen',\n            cs: 'clearScreen',\n            clean: 'clean',\n            setPos: 'setPos',\n            home: 'home',\n            hideTurtle: 'hideTurtle',\n            ht: 'hideTurtle',\n            showTurtle: 'showTurtle',\n            st: 'showTurtle',\n            penSize: 'setPenSize',\n            penColor: 'setPenColor',\n            getPenColor: 'getPenColor',\n            getHighlightPenColor: 'getHighlightPenColor',\n            getPenSize: 'getPenSize',\n            pushTurtle: 'pushTurtle',\n            push: 'pushTurtle',\n            popTurtle: 'popTurtle',\n            pop: 'popTurtle',\n            lookTo: 'lookTo',\n            pos: 'pos',\n            moveTo: 'moveTo',\n            X: 'X',\n            Y: 'Y'\n        });\n\n    return this;\n};\n\nJXG.Turtle.prototype = new GeometryElement();\n\nJXG.extend(\n    JXG.Turtle.prototype,\n    /** @lends JXG.Turtle.prototype */ {\n        /**\n         * Initialize a new turtle or reinitialize a turtle after {@link JXG.Turtle#clearScreen}.\n         * @private\n         */\n        init: function (x, y, dir) {\n            var hiddenPointAttr = {\n                fixed: true,\n                name: \"\",\n                visible: false,\n                withLabel: false\n            };\n\n            this.arrowLen =\n                20 /\n                Math.sqrt(\n                    this.board.unitX * this.board.unitX + this.board.unitY * this.board.unitY\n                );\n\n            this.pos = [x, y];\n            this.isPenDown = true;\n            this.dir = 90;\n            this.stack = [];\n            this.objects = [];\n            this.curve = this.board.create(\n                \"curve\",\n                [[this.pos[0]], [this.pos[1]]],\n                this._attributes\n            );\n            this.objects.push(this.curve);\n\n            this.turtle = this.board.create(\"point\", this.pos, hiddenPointAttr);\n            this.objects.push(this.turtle);\n\n            this.turtle2 = this.board.create(\n                \"point\",\n                [this.pos[0], this.pos[1] + this.arrowLen],\n                hiddenPointAttr\n            );\n            this.objects.push(this.turtle2);\n\n            this.visProp.arrow.lastArrow = true;\n            this.visProp.arrow.straightFirst = false;\n            this.visProp.arrow.straightLast = false;\n            this.arrow = this.board.create(\n                \"line\",\n                [this.turtle, this.turtle2],\n                this.visProp.arrow\n            );\n            this.objects.push(this.arrow);\n\n            this.subs = {\n                arrow: this.arrow\n            };\n            this.inherits.push(this.arrow);\n\n            this.right(90 - dir);\n            this.board.update();\n        },\n\n        /**\n         * Move the turtle forward.\n         * @param {Number} len of forward move in user coordinates\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        forward: function (len) {\n            if (len === 0) {\n                return this;\n            }\n\n            var t,\n                dx = len * Math.cos((this.dir * Math.PI) / 180),\n                dy = len * Math.sin((this.dir * Math.PI) / 180);\n\n            if (!this.turtleIsHidden) {\n                t = this.board.create(\"transform\", [dx, dy], { type: \"translate\" });\n\n                t.applyOnce(this.turtle);\n                t.applyOnce(this.turtle2);\n            }\n\n            if (this.isPenDown) {\n                // IE workaround\n                if (this.curve.dataX.length >= 8192) {\n                    this.curve = this.board.create(\n                        \"curve\",\n                        [[this.pos[0]], [this.pos[1]]],\n                        this._attributes\n                    );\n                    this.objects.push(this.curve);\n                }\n            }\n\n            this.pos[0] += dx;\n            this.pos[1] += dy;\n\n            if (this.isPenDown) {\n                this.curve.dataX.push(this.pos[0]);\n                this.curve.dataY.push(this.pos[1]);\n            }\n\n            this.board.update();\n            return this;\n        },\n\n        /**\n         * Move the turtle backwards.\n         * @param {Number} len of backwards move in user coordinates\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        back: function (len) {\n            return this.forward(-len);\n        },\n\n        /**\n         * Rotate the turtle direction to the right\n         * @param {Number} angle of the rotation in degrees\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        right: function (angle) {\n            this.dir -= angle;\n            this.dir %= 360;\n\n            if (!this.turtleIsHidden) {\n                var t = this.board.create(\n                    \"transform\",\n                    [(-angle * Math.PI) / 180, this.turtle],\n                    { type: \"rotate\" }\n                );\n                t.applyOnce(this.turtle2);\n            }\n\n            this.board.update();\n            return this;\n        },\n\n        /**\n         * Rotate the turtle direction to the right.\n         * @param {Number} angle of the rotation in degrees\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        left: function (angle) {\n            return this.right(-angle);\n        },\n\n        /**\n         * Pen up, stops visible drawing\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        penUp: function () {\n            this.isPenDown = false;\n            return this;\n        },\n\n        /**\n         * Pen down, continues visible drawing\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        penDown: function () {\n            this.isPenDown = true;\n            this.curve = this.board.create(\n                \"curve\",\n                [[this.pos[0]], [this.pos[1]]],\n                this._attributes\n            );\n            this.objects.push(this.curve);\n\n            return this;\n        },\n\n        /**\n         * Removes the turtle curve from the board. The turtle stays in its position.\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        clean: function () {\n            var i, el;\n\n            for (i = 0; i < this.objects.length; i++) {\n                el = this.objects[i];\n                if (el.type === Const.OBJECT_TYPE_CURVE) {\n                    this.board.removeObject(el);\n                    this.objects.splice(i, 1);\n                }\n            }\n\n            this.curve = this.board.create(\n                \"curve\",\n                [[this.pos[0]], [this.pos[1]]],\n                this._attributes\n            );\n            this.objects.push(this.curve);\n            this.board.update();\n\n            return this;\n        },\n\n        /**\n         *  Removes the turtle completely and resets it to its initial position and direction.\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        clearScreen: function () {\n            var i,\n                el,\n                len = this.objects.length;\n\n            for (i = 0; i < len; i++) {\n                el = this.objects[i];\n                this.board.removeObject(el);\n            }\n\n            this.init(0, 0, 90);\n            return this;\n        },\n\n        /**\n         *  Moves the turtle without drawing to a new position\n         * @param {Number} x new x- coordinate\n         * @param {Number} y new y- coordinate\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        setPos: function (x, y) {\n            var t;\n\n            if (Type.isArray(x)) {\n                this.pos = x;\n            } else {\n                this.pos = [x, y];\n            }\n\n            if (!this.turtleIsHidden) {\n                this.turtle.setPositionDirectly(Const.COORDS_BY_USER, [x, y]);\n                this.turtle2.setPositionDirectly(Const.COORDS_BY_USER, [x, y + this.arrowLen]);\n                t = this.board.create(\n                    \"transform\",\n                    [(-(this.dir - 90) * Math.PI) / 180, this.turtle],\n                    { type: \"rotate\" }\n                );\n                t.applyOnce(this.turtle2);\n            }\n\n            this.curve = this.board.create(\n                \"curve\",\n                [[this.pos[0]], [this.pos[1]]],\n                this._attributes\n            );\n            this.objects.push(this.curve);\n            this.board.update();\n\n            return this;\n        },\n\n        /**\n         *  Sets the pen size. Equivalent to setAttribute({strokeWidth:size})\n         * but affects only the future turtle.\n         * @param {Number} size\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        setPenSize: function (size) {\n            //this.visProp.strokewidth = size;\n            this.curve = this.board.create(\n                \"curve\",\n                [[this.pos[0]], [this.pos[1]]],\n                this.copyAttr(\"strokeWidth\", size)\n            );\n            this.objects.push(this.curve);\n            return this;\n        },\n\n        /**\n         *  Sets the pen color. Equivalent to setAttribute({strokeColor:color})\n         * but affects only the future turtle.\n         * @param {String} color\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        setPenColor: function (color) {\n            this.curve = this.board.create(\n                \"curve\",\n                [[this.pos[0]], [this.pos[1]]],\n                this.copyAttr(\"strokeColor\", color)\n            );\n            this.objects.push(this.curve);\n\n            return this;\n        },\n\n        /**\n         * Get attribute of the last turtle curve object.\n         * \n         * @param {String} key \n         * @returns attribute value\n         * @private\n         */\n        getPenAttribute: function(key) {\n            var pos, le = this.objects.length;\n            if (le === 4) {\n                // No new turtle objects have been created\n                pos = 0;\n            } else {\n                pos = le - 1;\n            }\n            return Type.evaluate(this.objects[pos].visProp[key]);\n        },\n\n        /**\n         * Get most recently set turtle size (in pixel).\n         * @returns Number Size of the last turtle segment in pixel.\n         */\n        getPenSize: function() {\n            return this.getPenAttribute('strokewidth');\n        },\n\n        /**\n         * Get most recently set turtle color.\n         * @returns String RGB color value of the last turtle segment.\n         */\n        getPenColor: function() {\n            return this.getPenAttribute('strokecolor');\n        },\n\n        /**\n         * Get most recently set turtle color.\n         * @returns String RGB highlight color value of the last turtle segment.\n         */\n         getHighlightPenColor: function() {\n            return this.getPenAttribute('highlightstrokecolor');\n        },\n\n        /**\n         *  Sets the highlight pen color. Equivalent to setAttribute({highlightStrokeColor:color})\n         * but affects only the future turtle.\n         * @param {String} color\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        setHighlightPenColor: function (color) {\n            //this.visProp.highlightstrokecolor = colStr;\n            this.curve = this.board.create(\n                \"curve\",\n                [[this.pos[0]], [this.pos[1]]],\n                this.copyAttr(\"highlightStrokeColor\", color)\n            );\n            this.objects.push(this.curve);\n            return this;\n        },\n\n        /**\n         * Sets properties of the turtle, see also {@link JXG.GeometryElement#setAttribute}.\n         * Sets the property for all curves of the turtle in the past and in the future.\n         * @param {Object} attributes key:value pairs\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        setAttribute: function (attributes) {\n            var i,\n                el,\n                tmp,\n                len = this.objects.length;\n\n            for (i = 0; i < len; i++) {\n                el = this.objects[i];\n                if (el.type === Const.OBJECT_TYPE_CURVE) {\n                    el.setAttribute(attributes);\n                }\n            }\n\n            // Set visProp of turtle\n            tmp = this.visProp.id;\n            this.visProp = Type.deepCopy(this.curve.visProp);\n            this.visProp.id = tmp;\n            this._attributes = Type.deepCopy(this.visProp);\n            delete this._attributes.id;\n\n            return this;\n        },\n\n        /**\n         * Set a future attribute of the turtle.\n         * @private\n         * @param {String} key\n         * @param {Number|String} val\n         * @returns {Object} pointer to the attributes object\n         */\n        copyAttr: function (key, val) {\n            this._attributes[key.toLowerCase()] = val;\n            return this._attributes;\n        },\n\n        /**\n         * Sets the visibility of the turtle head to true,\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        showTurtle: function () {\n            this.turtleIsHidden = false;\n            this.arrow.setAttribute({ visible: true });\n            this.visProp.arrow.visible = false;\n            this.setPos(this.pos[0], this.pos[1]);\n            this.board.update();\n\n            return this;\n        },\n\n        /**\n         * Sets the visibility of the turtle head to false,\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        hideTurtle: function () {\n            this.turtleIsHidden = true;\n            this.arrow.setAttribute({ visible: false });\n            this.visProp.arrow.visible = false;\n            this.board.update();\n\n            return this;\n        },\n\n        /**\n         * Moves the turtle to position [0,0].\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        home: function () {\n            this.pos = [0, 0];\n            this.setPos(this.pos[0], this.pos[1]);\n\n            return this;\n        },\n\n        /**\n         *  Pushes the position of the turtle on the stack.\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        pushTurtle: function () {\n            this.stack.push([this.pos[0], this.pos[1], this.dir]);\n\n            return this;\n        },\n\n        /**\n         *  Gets the last position of the turtle on the stack, sets the turtle to this position and removes this\n         * position from the stack.\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        popTurtle: function () {\n            var status = this.stack.pop();\n            this.pos[0] = status[0];\n            this.pos[1] = status[1];\n            this.dir = status[2];\n            this.setPos(this.pos[0], this.pos[1]);\n\n            return this;\n        },\n\n        /**\n         * Rotates the turtle into a new direction.\n         * There are two possibilities:\n         * @param {Number|Array} target If a number is given, it is interpreted as the new direction to look to; If an array\n         * consisting of two Numbers is given targeted is used as a pair coordinates.\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        lookTo: function (target) {\n            var ax, ay, bx, by, beta;\n\n            if (Type.isArray(target)) {\n                ax = this.pos[0];\n                ay = this.pos[1];\n                bx = target[0];\n                by = target[1];\n\n                // Rotate by the slope of the line [this.pos, target]\n                beta = Math.atan2(by - ay, bx - ax);\n                this.right(this.dir - (beta * 180) / Math.PI);\n            } else if (Type.isNumber(target)) {\n                this.right(this.dir - target);\n            }\n            return this;\n        },\n\n        /**\n         * Moves the turtle to a given coordinate pair.\n         * The direction is not changed.\n         * @param {Array} target Coordinates of the point where the turtle looks to.\n         * @returns {JXG.Turtle} pointer to the turtle object\n         */\n        moveTo: function (target) {\n            var dx, dy, t;\n\n            if (Type.isArray(target)) {\n                dx = target[0] - this.pos[0];\n                dy = target[1] - this.pos[1];\n\n                if (!this.turtleIsHidden) {\n                    t = this.board.create(\"transform\", [dx, dy], { type: \"translate\" });\n                    t.applyOnce(this.turtle);\n                    t.applyOnce(this.turtle2);\n                }\n\n                if (this.isPenDown) {\n                    // IE workaround\n                    if (this.curve.dataX.length >= 8192) {\n                        this.curve = this.board.create(\n                            \"curve\",\n                            [[this.pos[0]], [this.pos[1]]],\n                            this._attributes\n                        );\n                        this.objects.push(this.curve);\n                    }\n                }\n\n                this.pos[0] = target[0];\n                this.pos[1] = target[1];\n\n                if (this.isPenDown) {\n                    this.curve.dataX.push(this.pos[0]);\n                    this.curve.dataY.push(this.pos[1]);\n                }\n                this.board.update();\n            }\n\n            return this;\n        },\n\n        /**\n         * Alias for {@link JXG.Turtle#forward}\n         */\n        fd: function (len) {\n            return this.forward(len);\n        },\n        /**\n         * Alias for {@link JXG.Turtle#back}\n         */\n        bk: function (len) {\n            return this.back(len);\n        },\n        /**\n         * Alias for {@link JXG.Turtle#left}\n         */\n        lt: function (angle) {\n            return this.left(angle);\n        },\n        /**\n         * Alias for {@link JXG.Turtle#right}\n         */\n        rt: function (angle) {\n            return this.right(angle);\n        },\n        /**\n         * Alias for {@link JXG.Turtle#penUp}\n         */\n        pu: function () {\n            return this.penUp();\n        },\n        /**\n         * Alias for {@link JXG.Turtle#penDown}\n         */\n        pd: function () {\n            return this.penDown();\n        },\n        /**\n         * Alias for {@link JXG.Turtle#hideTurtle}\n         */\n        ht: function () {\n            return this.hideTurtle();\n        },\n        /**\n         * Alias for {@link JXG.Turtle#showTurtle}\n         */\n        st: function () {\n            return this.showTurtle();\n        },\n        /**\n         * Alias for {@link JXG.Turtle#clearScreen}\n         */\n        cs: function () {\n            return this.clearScreen();\n        },\n        /**\n         * Alias for {@link JXG.Turtle#pushTurtle}\n         */\n        push: function () {\n            return this.pushTurtle();\n        },\n        /**\n         * Alias for {@link JXG.Turtle#popTurtle}\n         */\n        pop: function () {\n            return this.popTurtle();\n        },\n\n        /**\n         * The \"co\"-coordinate of the turtle curve at position t is returned.\n         *\n         * @param {Number} t parameter\n         * @param {String} co. Either 'X' or 'Y'.\n         * @returns {Number} x-coordinate of the turtle position or x-coordinate of turtle at position t\n         */\n        evalAt: function (t, co) {\n            var i,\n                j,\n                el,\n                tc,\n                len = this.objects.length;\n\n            for (i = 0, j = 0; i < len; i++) {\n                el = this.objects[i];\n\n                if (el.elementClass === Const.OBJECT_CLASS_CURVE) {\n                    if (j <= t && t < j + el.numberPoints) {\n                        tc = t - j;\n                        return el[co](tc);\n                    }\n                    j += el.numberPoints;\n                }\n            }\n\n            return this[co]();\n        },\n\n        /**\n         * if t is not supplied the x-coordinate of the turtle is returned. Otherwise\n         * the x-coordinate of the turtle curve at position t is returned.\n         * @param {Number} t parameter\n         * @returns {Number} x-coordinate of the turtle position or x-coordinate of turtle at position t\n         */\n        X: function (t) {\n            if (!Type.exists(t)) {\n                return this.pos[0];\n            }\n\n            return this.evalAt(t, \"X\");\n        },\n\n        /**\n         * if t is not supplied the y-coordinate of the turtle is returned. Otherwise\n         * the y-coordinate of the turtle curve at position t is returned.\n         * @param {Number} t parameter\n         * @returns {Number} x-coordinate of the turtle position or x-coordinate of turtle at position t\n         */\n        Y: function (t) {\n            if (!Type.exists(t)) {\n                return this.pos[1];\n            }\n            return this.evalAt(t, \"Y\");\n        },\n\n        /**\n         * @returns {Number} z-coordinate of the turtle position\n         */\n        Z: function (t) {\n            return 1.0;\n        },\n\n        /**\n         * Gives the lower bound of the parameter if the the turtle is treated as parametric curve.\n         */\n        minX: function () {\n            return 0;\n        },\n\n        /**\n         * Gives the upper bound of the parameter if the the turtle is treated as parametric curve.\n         * May be overwritten in @see generateTerm.\n         */\n        maxX: function () {\n            var i,\n                el,\n                len = this.objects.length,\n                np = 0;\n\n            for (i = 0; i < len; i++) {\n                el = this.objects[i];\n                if (el.elementClass === Const.OBJECT_CLASS_CURVE) {\n                    np += this.objects[i].numberPoints;\n                }\n            }\n            return np;\n        },\n\n        /**\n         * Checks whether (x,y) is near the curve.\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} True if (x,y) is near the curve, False otherwise.\n         */\n        hasPoint: function (x, y) {\n            var i, el;\n\n            // run through all curves of this turtle\n            for (i = 0; i < this.objects.length; i++) {\n                el = this.objects[i];\n\n                if (el.type === Const.OBJECT_TYPE_CURVE) {\n                    if (el.hasPoint(x, y)) {\n                        // So what??? All other curves have to be notified now (for highlighting)\n                        return true;\n                        // This has to be done, yet.\n                    }\n                }\n            }\n            return false;\n        }\n    }\n);\n\n/**\n * @class This element is used to provide a constructor for a turtle.\n * @pseudo\n * @description  Creates a new turtle\n * @name Turtle\n * @augments JXG.Turtle\n * @constructor\n * @type JXG.Turtle\n *\n * @param {JXG.Board} board The board the turtle is put on.\n * @param {Array} parents\n * @param {Object} attributes Object containing properties for the element such as stroke-color and visibility. See {@link JXG.GeometryElement#setAttribute}\n * @returns {JXG.Turtle} Reference to the created turtle object.\n */\nJXG.createTurtle = function (board, parents, attributes) {\n    var attr;\n    parents = parents || [];\n\n    attr = Type.copyAttributes(attributes, board.options, \"turtle\");\n    return new JXG.Turtle(board, parents, attr);\n};\n\nJXG.registerElement(\"turtle\", JXG.createTurtle);\n\nexport default {\n    Turtle: JXG.Turtle,\n    createTurtle: JXG.createTurtle\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the geometry object Ticks is defined. Ticks provides\n * methods for creation and management of ticks on an axis.\n * @author graphjs\n * @version 0.1\n */\n\nimport JXG from \"../jxg\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Numerics from \"../math/numerics\";\nimport Const from \"./constants\";\nimport GeometryElement from \"./element\";\nimport Coords from \"./coords\";\nimport Type from \"../utils/type\";\nimport Text from \"./text\";\n\n/**\n * Creates ticks for an axis.\n * @class Ticks provides methods for creation and management\n * of ticks on an axis.\n * @param {JXG.Line} line Reference to the axis the ticks are drawn on.\n * @param {Number|Array} ticks Number defining the distance between two major ticks or an array defining static ticks.\n * @param {Object} attributes Properties\n * @see JXG.Line#addTicks\n * @constructor\n * @extends JXG.GeometryElement\n */\nJXG.Ticks = function (line, ticks, attributes) {\n    this.constructor(line.board, attributes, Const.OBJECT_TYPE_TICKS, Const.OBJECT_CLASS_OTHER);\n\n    /**\n     * The line the ticks belong to.\n     * @type JXG.Line\n     */\n    this.line = line;\n\n    /**\n     * The board the ticks line is drawn on.\n     * @type JXG.Board\n     */\n    this.board = this.line.board;\n\n    /**\n     * A function calculating ticks delta depending on the ticks number.\n     * @type Function\n     */\n    this.ticksFunction = null;\n\n    /**\n     * Array of fixed ticks.\n     * @type Array\n     */\n    this.fixedTicks = null;\n\n    /**\n     * Equidistant ticks. Distance is defined by ticksFunction\n     * @type Boolean\n     */\n    this.equidistant = false;\n\n    this.labelsData = [];\n\n    if (Type.isFunction(ticks)) {\n        this.ticksFunction = ticks;\n        throw new Error(\"Function arguments are no longer supported.\");\n    }\n\n    if (Type.isArray(ticks)) {\n        this.fixedTicks = ticks;\n    } else {\n        if (Math.abs(ticks) < Mat.eps || ticks < 0) {\n            ticks = attributes.defaultdistance;\n        }\n\n        /*\n         * Ticks function:\n         * determines the distance (in user units) of two major ticks\n         */\n        this.ticksFunction = this.makeTicksFunction(ticks);\n\n        this.equidistant = true;\n    }\n\n    /**\n     * Least distance between two ticks, measured in pixels.\n     * @type int\n     */\n    this.minTicksDistance = attributes.minticksdistance;\n\n    /**\n     * Stores the ticks coordinates\n     * @type Array\n     */\n    this.ticks = [];\n\n    /**\n     * Distance between two major ticks in user coordinates\n     * @type Number\n     */\n    this.ticksDelta = 1;\n\n    /**\n     * Array where the labels are saved. There is an array element for every tick,\n     * even for minor ticks which don't have labels. In this case the array element\n     * contains just <tt>null</tt>.\n     * @type Array\n     */\n    this.labels = [];\n\n    /**\n     * A list of labels which have to be displayed in updateRenderer.\n     * @type Array\n     */\n    this.labelData = [];\n\n    /**\n     * To ensure the uniqueness of label ids this counter is used.\n     * @type number\n     */\n    this.labelCounter = 0;\n\n    this.id = this.line.addTicks(this);\n    this.elType = \"ticks\";\n    this.inherits.push(this.labels);\n    this.board.setId(this, \"Ti\");\n};\n\nJXG.Ticks.prototype = new GeometryElement();\n\nJXG.extend(\n    JXG.Ticks.prototype,\n    /** @lends JXG.Ticks.prototype */ {\n        /**\n         * Ticks function:\n         * determines the distance (in user units) of two major ticks.\n         * See above in constructor and in @see JXG.GeometryElement#setAttribute\n         *\n         * @private\n         * @param {Number} ticks Distance between two major ticks\n         * @returns {Function} returns method ticksFunction\n         */\n        makeTicksFunction: function (ticks) {\n            return function () {\n                var delta, b, dist;\n\n                if (Type.evaluate(this.visProp.insertticks)) {\n                    b = this.getLowerAndUpperBounds(this.getZeroCoordinates(), \"ticksdistance\");\n                    dist = b.upper - b.lower;\n\n                    delta = Math.pow(10, Math.floor(Math.log(0.6 * dist) / Math.LN10));\n                    if (dist <= 6 * delta) {\n                        delta *= 0.5;\n                    }\n                    return delta;\n                }\n\n                // upto 0.99.1:\n                return ticks;\n            };\n        },\n\n        /**\n         * Checks whether (x,y) is near the line.\n         * Only available for line elements,  not for ticks on curves.\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} True if (x,y) is near the line, False otherwise.\n         */\n        hasPoint: function (x, y) {\n            var i,\n                t,\n                len = (this.ticks && this.ticks.length) || 0,\n                r,\n                type;\n\n            if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n                type = this.board._inputDevice;\n                r = Type.evaluate(this.visProp.precision[type]);\n            } else {\n                // 'inherit'\n                r = this.board.options.precision.hasPoint;\n            }\n            r += Type.evaluate(this.visProp.strokewidth) * 0.5;\n            if (\n                !Type.evaluate(this.line.visProp.scalable) ||\n                this.line.elementClass === Const.OBJECT_CLASS_CURVE\n            ) {\n                return false;\n            }\n\n            // Ignore non-axes and axes that are not horizontal or vertical\n            if (\n                this.line.stdform[1] !== 0 &&\n                this.line.stdform[2] !== 0 &&\n                this.line.type !== Const.OBJECT_TYPE_AXIS\n            ) {\n                return false;\n            }\n\n            for (i = 0; i < len; i++) {\n                t = this.ticks[i];\n\n                // Skip minor ticks\n                if (t[2]) {\n                    // Ignore ticks at zero\n                    if (\n                        !(\n                            (this.line.stdform[1] === 0 &&\n                                Math.abs(t[0][0] - this.line.point1.coords.scrCoords[1]) <\n                                    Mat.eps) ||\n                            (this.line.stdform[2] === 0 &&\n                                Math.abs(t[1][0] - this.line.point1.coords.scrCoords[2]) <\n                                    Mat.eps)\n                        )\n                    ) {\n                        // tick length is not zero, ie. at least one pixel\n                        if (\n                            Math.abs(t[0][0] - t[0][1]) >= 1 ||\n                            Math.abs(t[1][0] - t[1][1]) >= 1\n                        ) {\n                            if (this.line.stdform[1] === 0) {\n                                // Allow dragging near axes only.\n                                if (\n                                    Math.abs(y - (t[1][0] + t[1][1]) * 0.5) < 2 * r &&\n                                    t[0][0] - r < x &&\n                                    x < t[0][1] + r\n                                ) {\n                                    return true;\n                                }\n                            } else if (this.line.stdform[2] === 0) {\n                                if (\n                                    Math.abs(x - (t[0][0] + t[0][1]) * 0.5) < 2 * r &&\n                                    t[1][0] - r < y &&\n                                    y < t[1][1] + r\n                                ) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Sets x and y coordinate of the tick.\n         * @param {number} method The type of coordinates used here. Possible values are {@link JXG.COORDS_BY_USER} and {@link JXG.COORDS_BY_SCREEN}.\n         * @param {Array} coords coordinates in screen/user units\n         * @param {Array} oldcoords previous coordinates in screen/user units\n         * @returns {JXG.Ticks} this element\n         */\n        setPositionDirectly: function (method, coords, oldcoords) {\n            var dx,\n                dy,\n                c = new Coords(method, coords, this.board),\n                oldc = new Coords(method, oldcoords, this.board),\n                bb = this.board.getBoundingBox();\n\n            if (\n                this.line.type !== Const.OBJECT_TYPE_AXIS ||\n                !Type.evaluate(this.line.visProp.scalable)\n            ) {\n                return this;\n            }\n\n            if (\n                Math.abs(this.line.stdform[1]) < Mat.eps &&\n                Math.abs(c.usrCoords[1] * oldc.usrCoords[1]) > Mat.eps\n            ) {\n                // Horizontal line\n                dx = oldc.usrCoords[1] / c.usrCoords[1];\n                bb[0] *= dx;\n                bb[2] *= dx;\n                this.board.setBoundingBox(bb, this.board.keepaspectratio, \"update\");\n            } else if (\n                Math.abs(this.line.stdform[2]) < Mat.eps &&\n                Math.abs(c.usrCoords[2] * oldc.usrCoords[2]) > Mat.eps\n            ) {\n                // Vertical line\n                dy = oldc.usrCoords[2] / c.usrCoords[2];\n                bb[3] *= dy;\n                bb[1] *= dy;\n                this.board.setBoundingBox(bb, this.board.keepaspectratio, \"update\");\n            }\n\n            return this;\n        },\n\n        /**\n         * (Re-)calculates the ticks coordinates.\n         * @private\n         */\n        calculateTicksCoordinates: function () {\n            var coordsZero, bounds, r_max, bb;\n\n            if (this.line.elementClass === Const.OBJECT_CLASS_LINE) {\n                // Calculate Ticks width and height in Screen and User Coordinates\n                this.setTicksSizeVariables();\n\n                // If the parent line is not finite, we can stop here.\n                if (Math.abs(this.dx) < Mat.eps && Math.abs(this.dy) < Mat.eps) {\n                    return;\n                }\n            }\n\n            // Get Zero (coords element for lines , number for curves)\n            coordsZero = this.getZeroCoordinates();\n\n            // Calculate lower bound and upper bound limits based on distance\n            // between p1 and center and p2 and center\n            if (this.line.elementClass === Const.OBJECT_CLASS_LINE) {\n                bounds = this.getLowerAndUpperBounds(coordsZero);\n            } else {\n                bounds = {\n                    lower: this.line.minX(),\n                    upper: this.line.maxX()\n                };\n            }\n\n            if (Type.evaluate(this.visProp.type) === \"polar\") {\n                bb = this.board.getBoundingBox();\n                r_max = Math.max(\n                    Math.sqrt(bb[0] * bb[0] + bb[1] * bb[1]),\n                    Math.sqrt(bb[2] * bb[2] + bb[3] * bb[3])\n                );\n                bounds.upper = r_max;\n            }\n\n            // Clean up\n            this.ticks = [];\n            this.labelsData = [];\n            // Create Ticks Coordinates and Labels\n            if (this.equidistant) {\n                this.generateEquidistantTicks(coordsZero, bounds);\n            } else {\n                this.generateFixedTicks(coordsZero, bounds);\n            }\n\n            return this;\n        },\n\n        /**\n         * Sets the variables used to set the height and slope of each tick.\n         *\n         * @private\n         */\n        setTicksSizeVariables: function (pos) {\n            var d,\n                mi,\n                ma,\n                len,\n                distMaj = Type.evaluate(this.visProp.majorheight) * 0.5,\n                distMin = Type.evaluate(this.visProp.minorheight) * 0.5;\n\n            // For curves:\n            if (Type.exists(pos)) {\n                mi = this.line.minX();\n                ma = this.line.maxX();\n                len = this.line.points.length;\n                if (len < 2) {\n                    this.dxMaj = 0;\n                    this.dyMaj = 0;\n                } else if (Mat.relDif(pos, mi) < Mat.eps) {\n                    this.dxMaj =\n                        this.line.points[0].usrCoords[2] - this.line.points[1].usrCoords[2];\n                    this.dyMaj =\n                        this.line.points[1].usrCoords[1] - this.line.points[0].usrCoords[1];\n                } else if (Mat.relDif(pos, ma) < Mat.eps) {\n                    this.dxMaj =\n                        this.line.points[len - 2].usrCoords[2] -\n                        this.line.points[len - 1].usrCoords[2];\n                    this.dyMaj =\n                        this.line.points[len - 1].usrCoords[1] -\n                        this.line.points[len - 2].usrCoords[1];\n                } else {\n                    this.dxMaj = -Numerics.D(this.line.Y)(pos);\n                    this.dyMaj = Numerics.D(this.line.X)(pos);\n                }\n            } else {\n                // ticks width and height in screen units\n                this.dxMaj = this.line.stdform[1];\n                this.dyMaj = this.line.stdform[2];\n            }\n            this.dxMin = this.dxMaj;\n            this.dyMin = this.dyMaj;\n\n            // ticks width and height in user units\n            this.dx = this.dxMaj;\n            this.dy = this.dyMaj;\n\n            // After this, the length of the vector (dxMaj, dyMaj) in screen coordinates is equal to distMaj pixel.\n            d = Math.sqrt(\n                this.dxMaj * this.dxMaj * this.board.unitX * this.board.unitX +\n                    this.dyMaj * this.dyMaj * this.board.unitY * this.board.unitY\n            );\n            this.dxMaj *= (distMaj / d) * this.board.unitX;\n            this.dyMaj *= (distMaj / d) * this.board.unitY;\n            this.dxMin *= (distMin / d) * this.board.unitX;\n            this.dyMin *= (distMin / d) * this.board.unitY;\n\n            // Grid-like ticks?\n            this.minStyle = Type.evaluate(this.visProp.minorheight) < 0 ? \"infinite\" : \"finite\";\n            this.majStyle = Type.evaluate(this.visProp.majorheight) < 0 ? \"infinite\" : \"finite\";\n        },\n\n        /**\n         * Returns the coordinates of the point zero of the line.\n         *\n         * If the line is an {@link Axis}, the coordinates of the projection of the board's zero point is returned\n         *\n         * Otherwise, the coordinates of the point that acts as zero are\n         * established depending on the value of {@link JXG.Ticks#anchor}\n         *\n         * @returns {JXG.Coords} Coords object for the zero point on the line\n         * @private\n         */\n        getZeroCoordinates: function () {\n            var c1x,\n                c1y,\n                c1z,\n                c2x,\n                c2y,\n                c2z,\n                t,\n                mi,\n                ma,\n                ev_a = Type.evaluate(this.visProp.anchor);\n\n            if (this.line.elementClass === Const.OBJECT_CLASS_LINE) {\n                if (this.line.type === Const.OBJECT_TYPE_AXIS) {\n                    return Geometry.projectPointToLine(\n                        {\n                            coords: {\n                                usrCoords: [1, 0, 0]\n                            }\n                        },\n                        this.line,\n                        this.board\n                    );\n                }\n                c1z = this.line.point1.coords.usrCoords[0];\n                c1x = this.line.point1.coords.usrCoords[1];\n                c1y = this.line.point1.coords.usrCoords[2];\n                c2z = this.line.point2.coords.usrCoords[0];\n                c2x = this.line.point2.coords.usrCoords[1];\n                c2y = this.line.point2.coords.usrCoords[2];\n\n                if (ev_a === \"right\") {\n                    return this.line.point2.coords;\n                }\n                if (ev_a === \"middle\") {\n                    return new Coords(\n                        Const.COORDS_BY_USER,\n                        [(c1z + c2z) * 0.5, (c1x + c2x) * 0.5, (c1y + c2y) * 0.5],\n                        this.board\n                    );\n                }\n                if (Type.isNumber(ev_a)) {\n                    return new Coords(\n                        Const.COORDS_BY_USER,\n                        [\n                            c1z + (c2z - c1z) * ev_a,\n                            c1x + (c2x - c1x) * ev_a,\n                            c1y + (c2y - c1y) * ev_a\n                        ],\n                        this.board\n                    );\n                }\n                return this.line.point1.coords;\n            }\n            mi = this.line.minX();\n            ma = this.line.maxX();\n            if (ev_a === \"right\") {\n                t = ma;\n            } else if (ev_a === \"middle\") {\n                t = (mi + ma) * 0.5;\n            } else if (Type.isNumber(ev_a)) {\n                t = mi * (1 - ev_a) + ma * ev_a;\n                // t = ev_a;\n            } else {\n                t = mi;\n            }\n            return t;\n        },\n\n        /**\n         * Calculate the lower and upper bounds for tick rendering\n         * If {@link JXG.Ticks#includeBoundaries} is false, the boundaries will exclude point1 and point2\n         *\n         * @param  {JXG.Coords} coordsZero\n         * @returns {String} type  (Optional) If type=='ticksdistance' the bounds are\n         *                         the intersection of the line with the bounding box of the board.\n         *                         Otherwise, it is the projection of the corners of the bounding box\n         *                         to the line. The first case is needed to automatically\n         *                         generate ticks. The second case is for drawing of the ticks.\n         * @returns {Object}     contains the lower and upper bounds\n         *\n         * @private\n         */\n        getLowerAndUpperBounds: function (coordsZero, type) {\n            var lowerBound,\n                upperBound,\n                fA,\n                lA,\n                point1,\n                point2,\n                isPoint1inBoard,\n                isPoint2inBoard,\n                // We use the distance from zero to P1 and P2 to establish lower and higher points\n                dZeroPoint1,\n                dZeroPoint2,\n                ev_sf = Type.evaluate(this.line.visProp.straightfirst),\n                ev_sl = Type.evaluate(this.line.visProp.straightlast),\n                ev_i = Type.evaluate(this.visProp.includeboundaries);\n\n            // The line's defining points that will be adjusted to be within the board limits\n            if (this.line.elementClass === Const.OBJECT_CLASS_CURVE) {\n                return {\n                    lower: this.line.minX(),\n                    upper: this.line.maxX()\n                };\n            }\n\n            point1 = new Coords(\n                Const.COORDS_BY_USER,\n                this.line.point1.coords.usrCoords,\n                this.board\n            );\n            point2 = new Coords(\n                Const.COORDS_BY_USER,\n                this.line.point2.coords.usrCoords,\n                this.board\n            );\n            // Are the original defining points within the board?\n            isPoint1inBoard =\n                Math.abs(point1.usrCoords[0]) >= Mat.eps &&\n                point1.scrCoords[1] >= 0.0 &&\n                point1.scrCoords[1] <= this.board.canvasWidth &&\n                point1.scrCoords[2] >= 0.0 &&\n                point1.scrCoords[2] <= this.board.canvasHeight;\n            isPoint2inBoard =\n                Math.abs(point2.usrCoords[0]) >= Mat.eps &&\n                point2.scrCoords[1] >= 0.0 &&\n                point2.scrCoords[1] <= this.board.canvasWidth &&\n                point2.scrCoords[2] >= 0.0 &&\n                point2.scrCoords[2] <= this.board.canvasHeight;\n\n            // Adjust line limit points to be within the board\n            if (Type.exists(type) || type === \"tickdistance\") {\n                // The good old calcStraight is needed for determining the distance between major ticks.\n                // Here, only the visual area is of importance\n                Geometry.calcStraight(\n                    this.line,\n                    point1,\n                    point2,\n                    Type.evaluate(this.line.visProp.margin)\n                );\n            } else {\n                // This function projects the corners of the board to the line.\n                // This is important for diagonal lines with infinite tick lines.\n                Geometry.calcLineDelimitingPoints(this.line, point1, point2);\n            }\n\n            // Shorten ticks bounds such that ticks are not through arrow heads\n            fA = Type.evaluate(this.line.visProp.firstarrow);\n            lA = Type.evaluate(this.line.visProp.lastarrow);\n            if (fA || lA) {\n                this.board.renderer.getPositionArrowHead(\n                    this.line,\n                    point1,\n                    point2,\n                    Type.evaluate(this.line.visProp.strokewidth)\n                );\n\n                if (fA) {\n                    point1.setCoordinates(Const.COORDS_BY_SCREEN, [\n                        point1.scrCoords[1],\n                        point1.scrCoords[2]\n                    ]);\n                }\n                if (lA) {\n                    point2.setCoordinates(Const.COORDS_BY_SCREEN, [\n                        point2.scrCoords[1],\n                        point2.scrCoords[2]\n                    ]);\n                }\n                // if (fA) {\n                //     point1.setCoordinates(Const.COORDS_BY_SCREEN, [\n                //         point1.scrCoords[1] - obj.d1x,\n                //         point1.scrCoords[2] - obj.d1y\n                //     ]);\n                // }\n                // if (lA) {\n                //     point2.setCoordinates(Const.COORDS_BY_SCREEN, [\n                //         point2.scrCoords[1] - obj.d2x,\n                //         point2.scrCoords[2] - obj.d2y\n                //     ]);\n                // }\n            }\n\n            // Calculate (signed) distance from Zero to P1 and to P2\n            dZeroPoint1 = this.getDistanceFromZero(coordsZero, point1);\n            dZeroPoint2 = this.getDistanceFromZero(coordsZero, point2);\n\n            // We have to establish if the direction is P1->P2 or P2->P1 to set the lower and upper\n            // boundaries appropriately. As the distances contain also a sign to indicate direction,\n            // we can compare dZeroPoint1 and dZeroPoint2 to establish the line direction\n            if (dZeroPoint1 < dZeroPoint2) {\n                // Line goes P1->P2\n                lowerBound = dZeroPoint1;\n                if (!ev_sf && isPoint1inBoard && !ev_i) {\n                    lowerBound += Mat.eps;\n                }\n                upperBound = dZeroPoint2;\n                if (!ev_sl && isPoint2inBoard && !ev_i) {\n                    upperBound -= Mat.eps;\n                }\n            } else if (dZeroPoint2 < dZeroPoint1) {\n                // Line goes P2->P1\n                lowerBound = dZeroPoint2;\n                if (!ev_sl && isPoint2inBoard && !ev_i) {\n                    lowerBound += Mat.eps;\n                }\n                upperBound = dZeroPoint1;\n                if (!ev_sf && isPoint1inBoard && !ev_i) {\n                    upperBound -= Mat.eps;\n                }\n            } else {\n                // P1 = P2 = Zero, we can't do a thing\n                lowerBound = 0;\n                upperBound = 0;\n            }\n\n            return {\n                lower: lowerBound,\n                upper: upperBound\n            };\n        },\n\n        /**\n         * Calculates the distance in user coordinates from zero to a given point including its sign.\n         * Sign is positive, if the direction from zero to point is the same as the direction\n         * zero to point2 of the line.\n         *\n         * @param  {JXG.Coords} zero  coordinates of the point considered zero\n         * @param  {JXG.Coords} point coordinates of the point to find out the distance\n         * @returns {Number}           distance between zero and point, including its sign\n         * @private\n         */\n        getDistanceFromZero: function (zero, point) {\n            var p1, p2, dirLine, dirPoint, distance;\n\n            p1 = this.line.point1.coords;\n            p2 = this.line.point2.coords;\n            distance = zero.distance(Const.COORDS_BY_USER, point);\n\n            // Establish sign\n            dirLine = [\n                p2.usrCoords[0] - p1.usrCoords[0],\n                p2.usrCoords[1] - p1.usrCoords[1],\n                p2.usrCoords[2] - p1.usrCoords[2]\n            ];\n            dirPoint = [\n                point.usrCoords[0] - zero.usrCoords[0],\n                point.usrCoords[1] - zero.usrCoords[1],\n                point.usrCoords[2] - zero.usrCoords[2]\n            ];\n            if (Mat.innerProduct(dirLine, dirPoint, 3) < 0) {\n                distance *= -1;\n            }\n\n            return distance;\n        },\n\n        /**\n         * Creates ticks coordinates and labels automatically.\n         * The frequency of ticks is affected by the values of {@link JXG.Ticks#insertTicks} and {@link JXG.Ticks#ticksDistance}\n         *\n         * @param  {JXG.Coords} coordsZero coordinates of the point considered zero\n         * @param  {Object}     bounds     contains the lower and upper boundaries for ticks placement\n         * @private\n         */\n        generateEquidistantTicks: function (coordsZero, bounds) {\n            var tickPosition,\n                eps2 = Mat.eps,\n                deltas,\n                // Distance between two major ticks in user coordinates\n                ticksDelta = this.equidistant ? this.ticksFunction(1) : this.ticksDelta,\n                ev_it = Type.evaluate(this.visProp.insertticks),\n                ev_mt = Type.evaluate(this.visProp.minorticks);\n\n            if (this.line.elementClass === Const.OBJECT_CLASS_LINE) {\n                // Calculate X and Y distance between two major ticks\n                deltas = this.getXandYdeltas();\n            }\n\n            // adjust ticks distance\n            ticksDelta *= Type.evaluate(this.visProp.scale);\n            if (ev_it && this.minTicksDistance > Mat.eps) {\n                ticksDelta = this.adjustTickDistance(ticksDelta, coordsZero, deltas);\n                ticksDelta /= ev_mt + 1;\n            } else if (!ev_it) {\n                ticksDelta /= ev_mt + 1;\n            }\n            // Now, ticksdelta is the distance between two minor ticks\n            this.ticksDelta = ticksDelta;\n\n            if (ticksDelta < Mat.eps) {\n                return;\n            }\n\n            // Position ticks from zero to the positive side while not reaching the upper boundary\n            tickPosition = 0;\n            if (!Type.evaluate(this.visProp.drawzero)) {\n                tickPosition = ticksDelta;\n            }\n            while (tickPosition <= bounds.upper + eps2) {\n                // Only draw ticks when we are within bounds, ignore case where tickPosition < lower < upper\n                if (tickPosition >= bounds.lower - eps2) {\n                    this.processTickPosition(coordsZero, tickPosition, ticksDelta, deltas);\n                }\n                tickPosition += ticksDelta;\n\n                // Emergency out\n                if (bounds.upper - tickPosition > ticksDelta * 10000) {\n                    break;\n                }\n            }\n\n            // Position ticks from zero (not inclusive) to the negative side while not reaching the lower boundary\n            tickPosition = -ticksDelta;\n            while (tickPosition >= bounds.lower - eps2) {\n                // Only draw ticks when we are within bounds, ignore case where lower < upper < tickPosition\n                if (tickPosition <= bounds.upper + eps2) {\n                    this.processTickPosition(coordsZero, tickPosition, ticksDelta, deltas);\n                }\n                tickPosition -= ticksDelta;\n\n                // Emergency out\n                if (tickPosition - bounds.lower > ticksDelta * 10000) {\n                    break;\n                }\n            }\n        },\n\n        /**\n         * Auxiliary method used by {@link JXG.Ticks#generateEquidistantTicks} to adjust the\n         * distance between two ticks depending on {@link JXG.Ticks#minTicksDistance} value\n         *\n         * @param  {Number}     ticksDelta  distance between two major ticks in user coordinates\n         * @param  {JXG.Coords} coordsZero  coordinates of the point considered zero\n         * @param  {Object}     deltas      x and y distance in pixel between two user units\n         * @param  {Object}     bounds      upper and lower bound of the tick positions in user units.\n         * @private\n         */\n        adjustTickDistance: function (ticksDelta, coordsZero, deltas) {\n            var nx,\n                ny,\n                bounds,\n                distScr,\n                sgn = 1,\n                ev_minti = Type.evaluate(this.visProp.minorticks);\n\n            if (this.line.elementClass === Const.OBJECT_CLASS_CURVE) {\n                return ticksDelta;\n            }\n            bounds = this.getLowerAndUpperBounds(coordsZero, \"ticksdistance\");\n            nx = coordsZero.usrCoords[1] + deltas.x * ticksDelta;\n            ny = coordsZero.usrCoords[2] + deltas.y * ticksDelta;\n            distScr = coordsZero.distance(\n                Const.COORDS_BY_SCREEN,\n                new Coords(Const.COORDS_BY_USER, [nx, ny], this.board)\n            );\n\n            if (ticksDelta === 0.0) {\n                return 0.0;\n            }\n\n            while (distScr / (ev_minti + 1) < this.minTicksDistance) {\n                if (sgn === 1) {\n                    ticksDelta *= 2;\n                } else {\n                    ticksDelta *= 5;\n                }\n                sgn *= -1;\n\n                nx = coordsZero.usrCoords[1] + deltas.x * ticksDelta;\n                ny = coordsZero.usrCoords[2] + deltas.y * ticksDelta;\n                distScr = coordsZero.distance(\n                    Const.COORDS_BY_SCREEN,\n                    new Coords(Const.COORDS_BY_USER, [nx, ny], this.board)\n                );\n            }\n            return ticksDelta;\n        },\n\n        /**\n         * Auxiliary method used by {@link JXG.Ticks#generateEquidistantTicks} to create a tick\n         * in the line at the given tickPosition.\n         *\n         * @param  {JXG.Coords} coordsZero    coordinates of the point considered zero\n         * @param  {Number}     tickPosition  current tick position relative to zero\n         * @param  {Number}     ticksDelta    distance between two major ticks in user coordinates\n         * @param  {Object}     deltas      x and y distance between two major ticks\n         * @private\n         */\n        processTickPosition: function (coordsZero, tickPosition, ticksDelta, deltas) {\n            var x,\n                y,\n                tickCoords,\n                ti,\n                isLabelPosition,\n                ticksPerLabel = Type.evaluate(this.visProp.ticksperlabel),\n                labelVal = null;\n\n            // Calculates tick coordinates\n            if (this.line.elementClass === Const.OBJECT_CLASS_LINE) {\n                x = coordsZero.usrCoords[1] + tickPosition * deltas.x;\n                y = coordsZero.usrCoords[2] + tickPosition * deltas.y;\n            } else {\n                x = this.line.X(coordsZero + tickPosition);\n                y = this.line.Y(coordsZero + tickPosition);\n            }\n            tickCoords = new Coords(Const.COORDS_BY_USER, [x, y], this.board);\n            if (this.line.elementClass === Const.OBJECT_CLASS_CURVE) {\n                labelVal = coordsZero + tickPosition;\n                this.setTicksSizeVariables(labelVal);\n            }\n\n            // Test if tick is a major tick.\n            // This is the case if tickPosition/ticksDelta is\n            // a multiple of the number of minorticks+1\n            tickCoords.major =\n                Math.round(tickPosition / ticksDelta) %\n                    (Type.evaluate(this.visProp.minorticks) + 1) ===\n                0;\n\n            if (!ticksPerLabel) {\n                // In case of null, 0 or false, majorTicks are labelled\n                ticksPerLabel = Type.evaluate(this.visProp.minorticks) + 1;\n            }\n            isLabelPosition = Math.round(tickPosition / ticksDelta) % ticksPerLabel === 0;\n\n            // Compute the start position and the end position of a tick.\n            // If both positions are out of the canvas, ti is empty.\n            ti = this.createTickPath(tickCoords, tickCoords.major);\n            if (ti.length === 3) {\n                this.ticks.push(ti);\n                if (isLabelPosition && Type.evaluate(this.visProp.drawlabels)) {\n                    // Create a label at this position\n                    this.labelsData.push(\n                        this.generateLabelData(\n                            this.generateLabelText(tickCoords, coordsZero, labelVal),\n                            tickCoords,\n                            this.ticks.length\n                        )\n                    );\n                } else {\n                    // minor ticks have no labels\n                    this.labelsData.push(null);\n                }\n            }\n        },\n\n        /**\n         * Creates ticks coordinates and labels based on {@link JXG.Ticks#fixedTicks} and {@link JXG.Ticks#labels}.\n         *\n         * @param  {JXG.Coords} coordsZero Coordinates of the point considered zero\n         * @param  {Object}     bounds     contains the lower and upper boundaries for ticks placement\n         * @private\n         */\n        generateFixedTicks: function (coordsZero, bounds) {\n            var tickCoords,\n                labelText,\n                i,\n                ti,\n                x,\n                y,\n                eps2 = Mat.eps,\n                fixedTick,\n                hasLabelOverrides = Type.isArray(this.visProp.labels),\n                deltas,\n                ev_dl = Type.evaluate(this.visProp.drawlabels);\n\n            // Calculate X and Y distance between two major points in the line\n            if (this.line.elementClass === Const.OBJECT_CLASS_LINE) {\n                deltas = this.getXandYdeltas();\n            }\n            for (i = 0; i < this.fixedTicks.length; i++) {\n                if (this.line.elementClass === Const.OBJECT_CLASS_LINE) {\n                    fixedTick = this.fixedTicks[i];\n                    x = coordsZero.usrCoords[1] + fixedTick * deltas.x;\n                    y = coordsZero.usrCoords[2] + fixedTick * deltas.y;\n                } else {\n                    fixedTick = coordsZero + this.fixedTicks[i];\n                    x = this.line.X(fixedTick);\n                    y = this.line.Y(fixedTick);\n                }\n                tickCoords = new Coords(Const.COORDS_BY_USER, [x, y], this.board);\n\n                if (this.line.elementClass === Const.OBJECT_CLASS_CURVE) {\n                    this.setTicksSizeVariables(fixedTick);\n                }\n\n                // Compute the start position and the end position of a tick.\n                // If tick is out of the canvas, ti is empty.\n                ti = this.createTickPath(tickCoords, true);\n                if (\n                    ti.length === 3 &&\n                    fixedTick >= bounds.lower - eps2 &&\n                    fixedTick <= bounds.upper + eps2\n                ) {\n                    this.ticks.push(ti);\n\n                    if (ev_dl && (hasLabelOverrides || Type.exists(this.visProp.labels[i]))) {\n                        labelText = hasLabelOverrides\n                            ? Type.evaluate(this.visProp.labels[i])\n                            : fixedTick;\n                        this.labelsData.push(\n                            this.generateLabelData(\n                                this.generateLabelText(tickCoords, coordsZero, labelText),\n                                tickCoords,\n                                i\n                            )\n                        );\n                    } else {\n                        this.labelsData.push(null);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Calculates the x and y distance in pixel between two units in user space.\n         *\n         * @returns {Object}\n         * @private\n         */\n        getXandYdeltas: function () {\n            var // Auxiliary points to store the start and end of the line according to its direction\n                point1UsrCoords,\n                point2UsrCoords,\n                distP1P2 = this.line.point1.Dist(this.line.point2);\n\n            if (this.line.type === Const.OBJECT_TYPE_AXIS) {\n                // When line is an Axis, direction depends on Board Coordinates system\n\n                // assume line.point1 and line.point2 are in correct order\n                point1UsrCoords = this.line.point1.coords.usrCoords;\n                point2UsrCoords = this.line.point2.coords.usrCoords;\n\n                // Check if direction is incorrect, then swap\n                if (\n                    point1UsrCoords[1] > point2UsrCoords[1] ||\n                    (Math.abs(point1UsrCoords[1] - point2UsrCoords[1]) < Mat.eps &&\n                        point1UsrCoords[2] > point2UsrCoords[2])\n                ) {\n                    point1UsrCoords = this.line.point2.coords.usrCoords;\n                    point2UsrCoords = this.line.point1.coords.usrCoords;\n                }\n            } /* if (this.line.elementClass === Const.OBJECT_CLASS_LINE)*/ else {\n                // line direction is always from P1 to P2 for non Axis types\n                point1UsrCoords = this.line.point1.coords.usrCoords;\n                point2UsrCoords = this.line.point2.coords.usrCoords;\n            }\n            return {\n                x: (point2UsrCoords[1] - point1UsrCoords[1]) / distP1P2,\n                y: (point2UsrCoords[2] - point1UsrCoords[2]) / distP1P2\n            };\n        },\n\n        /**\n         * Check if (parts of) the tick is inside the canvas. The tick intersects the boundary\n         * at two positions: [x[0], y[0]] and [x[1], y[1]] in screen coordinates.\n         * @param  {Array}  x Array of length two\n         * @param  {Array}  y Array of length two\n         * @return {Boolean}   true if parts of the tick are inside of the canvas or on the boundary.\n         */\n        _isInsideCanvas: function (x, y, m) {\n            var cw = this.board.canvasWidth,\n                ch = this.board.canvasHeight;\n\n            if (m === undefined) {\n                m = 0;\n            }\n            return (\n                (x[0] >= m && x[0] <= cw - m && y[0] >= m && y[0] <= ch - m) ||\n                (x[1] >= m && x[1] <= cw - m && y[1] >= m && y[1] <= ch - m)\n            );\n        },\n\n        /**\n         * @param {JXG.Coords} coords Coordinates of the tick on the line.\n         * @param {Boolean} major True if tick is major tick.\n         * @returns {Array} Array of length 3 containing path coordinates in screen coordinates\n         *                 of the tick (arrays of length 2). 3rd entry is true if major tick otherwise false.\n         *                 If the tick is outside of the canvas, the return array is empty.\n         * @private\n         */\n        createTickPath: function (coords, major) {\n            var c,\n                lineStdForm,\n                intersection,\n                dxs,\n                dys,\n                dxr,\n                dyr,\n                alpha,\n                style,\n                x = [-2000000, -2000000],\n                y = [-2000000, -2000000],\n                i, r, r_max, bb, full, delta,\n                // Used for infinite ticks\n                te0, te1, // Tick ending visProps\n                dists; // 'signed' distances of intersections to the parent line\n\n            c = coords.scrCoords;\n            if (major) {\n                dxs = this.dxMaj;\n                dys = this.dyMaj;\n                style = this.majStyle;\n                te0 = Type.evaluate(this.visProp.majortickendings[0]) > 0;\n                te1 = Type.evaluate(this.visProp.majortickendings[1]) > 0;\n            } else {\n                dxs = this.dxMin;\n                dys = this.dyMin;\n                style = this.minStyle;\n                te0 = Type.evaluate(this.visProp.tickendings[0]) > 0;\n                te1 = Type.evaluate(this.visProp.tickendings[1]) > 0;\n            }\n            lineStdForm = [-dys * c[1] - dxs * c[2], dys, dxs];\n\n            // For all ticks regardless if of finite or infinite\n            // tick length the intersection with the canvas border is\n            // computed.\n            if (major && Type.evaluate(this.visProp.type) === \"polar\") {\n                // polar style\n                bb = this.board.getBoundingBox();\n                full = 2.0 * Math.PI;\n                delta = full / 180;\n                //ratio = this.board.unitY / this.board.X;\n\n                // usrCoords: Test if 'circle' is inside of the canvas\n                c = coords.usrCoords;\n                r = Math.sqrt(c[1] * c[1] + c[2] * c[2]);\n                r_max = Math.max(\n                    Math.sqrt(bb[0] * bb[0] + bb[1] * bb[1]),\n                    Math.sqrt(bb[2] * bb[2] + bb[3] * bb[3])\n                );\n\n                if (r < r_max) {\n                    // Now, switch to screen coords\n                    x = [];\n                    y = [];\n                    for (i = 0; i <= full; i += delta) {\n                        x.push(\n                            this.board.origin.scrCoords[1] + r * Math.cos(i) * this.board.unitX\n                        );\n                        y.push(\n                            this.board.origin.scrCoords[2] + r * Math.sin(i) * this.board.unitY\n                        );\n                    }\n                    return [x, y, major];\n                }\n            } else {\n                // line style\n                if (style === 'infinite') {\n                    // Problematic are infinite ticks which have set tickendings:[0,1].\n                    // For example, this is the default setting for minor ticks\n                    if (Type.evaluate(this.visProp.ignoreinfinitetickendings)) {\n                        te0 = te1 = true;\n                    }\n                    intersection = Geometry.meetLineBoard(lineStdForm, this.board);\n\n                    if (te0 && te1) {\n                        x[0] = intersection[0].scrCoords[1];\n                        x[1] = intersection[1].scrCoords[1];\n                        y[0] = intersection[0].scrCoords[2];\n                        y[1] = intersection[1].scrCoords[2];\n                    } else {\n                        // Assuming the usrCoords of both intersections are normalized, a 'signed distance'\n                        // with respect to the parent line is computed for the intersections. The sign is\n                        // used to conclude whether the point is either at the left or right side of the\n                        // line. The magnitude can be used to compare the points and determine which point\n                        // is closest to the line.\n                        dists = [\n                            Mat.innerProduct(\n                                intersection[0].usrCoords.slice(1, 3),\n                                this.line.stdform.slice(1, 3)\n                            ) + this.line.stdform[0],\n                            Mat.innerProduct(\n                                intersection[1].usrCoords.slice(1, 3),\n                                this.line.stdform.slice(1, 3)\n                            ) + this.line.stdform[0],\n                        ];\n\n                        // Reverse intersection array order if first intersection is not the leftmost one.\n                        if (dists[0] < dists[1]) {\n                            intersection.reverse();\n                            dists.reverse();\n                        }\n\n                        if (te0) { // Left-infinite tick\n                            if (dists[0] < 0) { // intersections at the wrong side of line\n                                return [];\n                            } else if (dists[1] < 0) { // 'default' case, tick drawn from line to board bounds\n                                x[0] = intersection[0].scrCoords[1];\n                                y[0] = intersection[0].scrCoords[2];\n                                x[1] = c[1];\n                                y[1] = c[2];\n                            } else { // tick visible, but coords of tick on line are outside the visible area\n                                x[0] = intersection[0].scrCoords[1];\n                                y[0] = intersection[0].scrCoords[2];\n                                x[1] = intersection[1].scrCoords[1];\n                                y[1] = intersection[1].scrCoords[2];\n                            }\n                        } else if (te1) { // Right-infinite tick\n                            if (dists[1] > 0) { // intersections at the wrong side of line\n                                return [];\n                            } else if (dists[0] > 0) { // 'default' case, tick drawn from line to board bounds\n                                x[0] = c[1];\n                                y[0] = c[2];\n                                x[1] = intersection[1].scrCoords[1];\n                                y[1] = intersection[1].scrCoords[2];\n                            } else { // tick visible, but coords of tick on line are outside the visible area\n                                x[0] = intersection[0].scrCoords[1];\n                                y[0] = intersection[0].scrCoords[2];\n                                x[1] = intersection[1].scrCoords[1];\n                                y[1] = intersection[1].scrCoords[2];\n                            }\n                        }\n                    }\n                } else {\n                    if (Type.evaluate(this.visProp.face) === \">\") {\n                        alpha = Math.PI / 4;\n                    } else if (Type.evaluate(this.visProp.face) === \"<\") {\n                        alpha = -Math.PI / 4;\n                    } else {\n                        alpha = 0;\n                    }\n                    dxr = Math.cos(alpha) * dxs - Math.sin(alpha) * dys;\n                    dyr = Math.sin(alpha) * dxs + Math.cos(alpha) * dys;\n\n                    x[0] = c[1] + dxr * te0; // Type.evaluate(this.visProp.tickendings[0]);\n                    y[0] = c[2] - dyr * te0; // Type.evaluate(this.visProp.tickendings[0]);\n                    x[1] = c[1];\n                    y[1] = c[2];\n\n                    alpha = -alpha;\n                    dxr = Math.cos(alpha) * dxs - Math.sin(alpha) * dys;\n                    dyr = Math.sin(alpha) * dxs + Math.cos(alpha) * dys;\n\n                    x[2] = c[1] - dxr * te1; // Type.evaluate(this.visProp.tickendings[1]);\n                    y[2] = c[2] + dyr * te1; // Type.evaluate(this.visProp.tickendings[1]);\n                }\n\n                // Check if (parts of) the tick is inside the canvas.\n                if (this._isInsideCanvas(x, y)) {\n                    return [x, y, major];\n                }\n            }\n\n            return [];\n        },\n\n        /**\n         * Format label texts. Show the desired number of digits\n         * and use utf-8 minus sign.\n         * @param  {Number} value Number to be displayed\n         * @return {String}       The value converted into a string.\n         * @private\n         */\n        formatLabelText: function (value) {\n            var labelText,\n                digits,\n                ev_s = Type.evaluate(this.visProp.scalesymbol);\n\n            // if value is Number\n            if (Type.isNumber(value)) {\n                labelText = (Math.round(value * 1e11) / 1e11).toString();\n                if (\n                    labelText.length > Type.evaluate(this.visProp.maxlabellength) ||\n                    labelText.indexOf(\"e\") !== -1\n                ) {\n                    digits = Type.evaluate(this.visProp.digits);\n                    if (Type.evaluate(this.visProp.precision) !== 3 && digits === 3) {\n                        // Use the deprecated attribute \"precision\"\n                        digits = Type.evaluate(this.visProp.precision);\n                    }\n\n                    //labelText = value.toPrecision(digits).toString();\n                    labelText = value.toExponential(digits).toString();\n                }\n\n                if (Type.evaluate(this.visProp.beautifulscientificticklabels)) {\n                    labelText = this.beautifyScientificNotationLabel(labelText);\n                }\n\n                if (labelText.indexOf(\".\") > -1 && labelText.indexOf(\"e\") === -1) {\n                    // trim trailing zeros\n                    labelText = labelText.replace(/0+$/, \"\");\n                    // trim trailing .\n                    labelText = labelText.replace(/\\.$/, \"\");\n                }\n            } else {\n                labelText = value.toString();\n            }\n\n            if (ev_s.length > 0) {\n                if (labelText === \"1\") {\n                    labelText = ev_s;\n                } else if (labelText === \"-1\") {\n                    labelText = \"-\" + ev_s;\n                } else if (labelText !== \"0\") {\n                    labelText = labelText + ev_s;\n                }\n            }\n\n            if (Type.evaluate(this.visProp.useunicodeminus)) {\n                labelText = labelText.replace(/-/g, \"\\u2212\");\n            }\n            return labelText;\n        },\n\n        /**\n         * Formats label texts to make labels displayed in scientific notation look beautiful.\n         * For example, label 5.00e+6 will become 5•10⁶, label -1.00e-7 will become into -1•10⁻⁷\n         * @param {String} labelText - The label that we want to convert\n         * @returns {String} If labelText was not in scientific notation, return labelText without modifications.\n         * Otherwise returns beautified labelText with proper superscript notation.\n         */\n        beautifyScientificNotationLabel: function (labelText) {\n            var returnString;\n\n            if (labelText.indexOf(\"e\") === -1) {\n                return labelText;\n            }\n\n            // Clean up trailing 0's, so numbers like 5.00e+6.0 for example become into 5e+6\n            returnString =\n                parseFloat(labelText.substring(0, labelText.indexOf(\"e\"))) +\n                labelText.substring(labelText.indexOf(\"e\"));\n\n            // Replace symbols like -,0,1,2,3,4,5,6,7,8,9 with their superscript version.\n            // Gets rid of + symbol since there is no need for it anymore.\n            returnString = returnString.replace(/e(.*)$/g, function (match, $1) {\n                var temp = \"\\u2022\" + \"10\";\n                // Note: Since board ticks do not support HTTP elements like <sub>, we need to replace\n                // all the numbers with superscript Unicode characters.\n                temp += $1\n                    .replace(/-/g, \"\\u207B\")\n                    .replace(/\\+/g, \"\")\n                    .replace(/0/g, \"\\u2070\")\n                    .replace(/1/g, \"\\u00B9\")\n                    .replace(/2/g, \"\\u00B2\")\n                    .replace(/3/g, \"\\u00B3\")\n                    .replace(/4/g, \"\\u2074\")\n                    .replace(/5/g, \"\\u2075\")\n                    .replace(/6/g, \"\\u2076\")\n                    .replace(/7/g, \"\\u2077\")\n                    .replace(/8/g, \"\\u2078\")\n                    .replace(/9/g, \"\\u2079\");\n\n                return temp;\n            });\n\n            return returnString;\n        },\n\n        /**\n         * Creates the label text for a given tick. A value for the text can be provided as a number or string\n         *\n         * @param  {JXG.Coords}    tick  The Coords-object of the tick to create a label for\n         * @param  {JXG.Coords}    zero  The Coords-object of line's zero\n         * @param  {Number|String} value A predefined value for this tick\n         * @returns {String}\n         * @private\n         */\n        generateLabelText: function (tick, zero, value) {\n            var labelText, distance;\n\n            // No value provided, equidistant, so assign distance as value\n            if (!Type.exists(value)) {\n                // could be null or undefined\n                distance = this.getDistanceFromZero(zero, tick);\n                if (Math.abs(distance) < Mat.eps) {\n                    // Point is zero\n                    return \"0\";\n                }\n                value = distance / Type.evaluate(this.visProp.scale);\n            }\n            labelText = this.formatLabelText(value);\n\n            return labelText;\n        },\n\n        /**\n         * Create a tick label data, i.e. text and coordinates\n         * @param  {String}     labelText\n         * @param  {JXG.Coords} tick\n         * @param  {Number}     tickNumber\n         * @returns {Object} with properties 'x', 'y', 't' (text), 'i' (tick number) or null in case of o label\n         * @private\n         */\n        generateLabelData: function (labelText, tick, tickNumber) {\n            var xa, ya, m, fs;\n\n            // Test if large portions of the label are inside of the canvas\n            // This is the last chance to abandon the creation of the label if it is mostly\n            // outside of the canvas.\n            fs = Type.evaluate(this.visProp.label.fontsize);\n            xa = [tick.scrCoords[1], tick.scrCoords[1]];\n            ya = [tick.scrCoords[2], tick.scrCoords[2]];\n            m = fs === undefined ? 12 : fs;\n            m *= 0.5;\n            if (!this._isInsideCanvas(xa, ya, m)) {\n                return null;\n            }\n\n            xa = Type.evaluate(this.visProp.label.offset[0]);\n            ya = Type.evaluate(this.visProp.label.offset[1]);\n\n            return {\n                x: tick.usrCoords[1] + xa / this.board.unitX,\n                y: tick.usrCoords[2] + ya / this.board.unitY,\n                t: labelText,\n                i: tickNumber\n            };\n        },\n\n        /**\n         * Recalculate the tick positions and the labels.\n         * @returns {JXG.Ticks}\n         */\n        update: function () {\n            if (this.needsUpdate) {\n                //this.visPropCalc.visible = Type.evaluate(this.visProp.visible);\n                // A canvas with no width or height will create an endless loop, so ignore it\n                if (this.board.canvasWidth !== 0 && this.board.canvasHeight !== 0) {\n                    this.calculateTicksCoordinates();\n                }\n                // this.updateVisibility(this.line.visPropCalc.visible);\n                //\n                // for (var i = 0; i < this.labels.length; i++) {\n                //     if (this.labels[i] !== null) {\n                //         this.labels[i].prepareUpdate()\n                //             .updateVisibility(this.line.visPropCalc.visible)\n                //             .updateRenderer();\n                //     }\n                // }\n            }\n\n            return this;\n        },\n\n        /**\n         * Uses the boards renderer to update the arc.\n         * @returns {JXG.Ticks} Reference to the object.\n         */\n        updateRenderer: function () {\n            if (!this.needsUpdate) {\n                return this;\n            }\n\n            if (this.visPropCalc.visible) {\n                this.board.renderer.updateTicks(this);\n            }\n            this.updateRendererLabels();\n\n            this.setDisplayRendNode();\n            // if (this.visPropCalc.visible != this.visPropOld.visible) {\n            //     this.board.renderer.display(this, this.visPropCalc.visible);\n            //     this.visPropOld.visible = this.visPropCalc.visible;\n            // }\n\n            this.needsUpdate = false;\n            return this;\n        },\n\n        /**\n         * Updates the label elements of the major ticks.\n         *\n         * @private\n         * @returns {JXG.Ticks} Reference to the object.\n         */\n        updateRendererLabels: function () {\n            var i, j, lenData, lenLabels, attr, label, ld, visible;\n\n            // The number of labels needed\n            lenData = this.labelsData.length;\n            // The number of labels which already exist\n            // The existing labels are stored in this.labels[]\n            // The new label positions and label values are stored in this.labelsData[]\n            lenLabels = this.labels.length;\n\n            for (i = 0, j = 0; i < lenData; i++) {\n                if (this.labelsData[i] === null) {\n                    // This is a tick without label\n                    continue;\n                }\n\n                ld = this.labelsData[i];\n                if (j < lenLabels) {\n                    // Take an already existing text element\n                    label = this.labels[j];\n                    label.setText(ld.t);\n                    label.setCoords(ld.x, ld.y);\n                    j++;\n                } else {\n                    // A new text element is needed\n                    this.labelCounter += 1;\n\n                    attr = {\n                        isLabel: true,\n                        layer: this.board.options.layer.line,\n                        highlightStrokeColor: this.board.options.text.strokeColor,\n                        highlightStrokeWidth: this.board.options.text.strokeWidth,\n                        highlightStrokeOpacity: this.board.options.text.strokeOpacity,\n                        priv: this.visProp.priv\n                    };\n                    attr = Type.deepCopy(attr, this.visProp.label);\n                    attr.id = this.id + ld.i + \"Label\" + this.labelCounter;\n\n                    label = Text.createText(this.board, [ld.x, ld.y, ld.t], attr);\n                    this.addChild(label);\n                    label.setParents(this);\n                    label.isDraggable = false;\n                    label.dump = false;\n                    this.labels.push(label);\n                }\n\n                // Look-ahead if the label inherits visiblity.\n                // If yes, update label.\n                visible = Type.evaluate(this.visProp.label.visible);\n                if (visible === \"inherit\") {\n                    visible = this.visPropCalc.visible;\n                }\n\n                label.prepareUpdate().updateVisibility(visible).updateRenderer();\n\n                label.distanceX = Type.evaluate(this.visProp.label.offset[0]);\n                label.distanceY = Type.evaluate(this.visProp.label.offset[1]);\n            }\n\n            // Hide unused labels\n            lenData = j;\n            for (j = lenData; j < lenLabels; j++) {\n                this.board.renderer.display(this.labels[j], false);\n                // Tick labels have the attribute \"visible: 'inherit'\"\n                // This must explicitely set to false, otherwise\n                // this labels would be set to visible in the upcoming\n                // update of the labels.\n                this.labels[j].visProp.visible = this.labels[j].visPropCalc.visible = false;\n            }\n\n            return this;\n        },\n\n        hideElement: function () {\n            var i;\n\n            JXG.deprecated(\"Element.hideElement()\", \"Element.setDisplayRendNode()\");\n\n            this.visPropCalc.visible = false;\n            this.board.renderer.display(this, false);\n            for (i = 0; i < this.labels.length; i++) {\n                if (Type.exists(this.labels[i])) {\n                    this.labels[i].hideElement();\n                }\n            }\n\n            return this;\n        },\n\n        showElement: function () {\n            var i;\n\n            JXG.deprecated(\"Element.showElement()\", \"Element.setDisplayRendNode()\");\n\n            this.visPropCalc.visible = true;\n            this.board.renderer.display(this, false);\n\n            for (i = 0; i < this.labels.length; i++) {\n                if (Type.exists(this.labels[i])) {\n                    this.labels[i].showElement();\n                }\n            }\n\n            return this;\n        }\n    }\n);\n\n/**\n * @class Ticks are used as distance markers on a line or curve.\n * They are\n * mainly used for axis elements and slider elements. Ticks may stretch infinitely\n * or finitely, which can be set with {@link Ticks#majorHeight} and {@link Ticks#minorHeight}.\n *\n * @pseudo\n * @description Ticks are markers on straight line elements or curves.\n * @name Ticks\n * @augments JXG.Ticks\n * @constructor\n * @type JXG.Ticks\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {JXG.Line|JXG.Curve} line The parents consist of the line or curve the ticks are going to be attached to.\n * @param {Number|Array} distance Number defining the distance between two major ticks or an\n * array defining static ticks. In case a number is specified, the ticks are <i>equidistant</i>,\n * in case of an array, a fixed number of static ticks is created at user-supplied positions.\n * Alternatively, the distance can be specified with the attribute\n * \"ticksDistance\". For arbitrary lines (and not axes) a \"zero coordinate\" is determined\n * which defines where the first tick is positioned. This zero coordinate\n * can be altered with the attribute \"anchor\". Possible values are \"left\", \"middle\", \"right\" or a number.\n * The default value is \"left\".\n *\n * @example\n * // Create an axis providing two coordinate pairs.\n *   var p1 = board.create('point', [0, 3]);\n *   var p2 = board.create('point', [1, 3]);\n *   var l1 = board.create('line', [p1, p2]);\n *   var t = board.create('ticks', [l1], {ticksDistance: 2});\n * </pre><div class=\"jxgbox\" id=\"JXGee7f2d68-75fc-4ec0-9931-c76918427e63\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXGee7f2d68-75fc-4ec0-9931-c76918427e63', {boundingbox: [-1, 7, 7, -1], showcopyright: false, shownavigation: false});\n *   var p1 = board.create('point', [0, 3]);\n *   var p2 = board.create('point', [1, 3]);\n *   var l1 = board.create('line', [p1, p2]);\n *   var t = board.create('ticks', [l1, 2], {ticksDistance: 2});\n * })();\n * </script><pre>\n */\nJXG.createTicks = function (board, parents, attributes) {\n    var el,\n        dist,\n        attr = Type.copyAttributes(attributes, board.options, \"ticks\");\n\n    if (parents.length < 2) {\n        dist = attr.ticksdistance;\n    } else {\n        dist = parents[1];\n    }\n\n    if (\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE ||\n        parents[0].elementClass === Const.OBJECT_CLASS_CURVE\n    ) {\n        el = new JXG.Ticks(parents[0], dist, attr);\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create Ticks with parent types '\" + typeof parents[0] + \"'.\"\n        );\n    }\n\n    // deprecated\n    if (Type.isFunction(attr.generatelabelvalue)) {\n        el.generateLabelText = attr.generatelabelvalue;\n    }\n    if (Type.isFunction(attr.generatelabeltext)) {\n        el.generateLabelText = attr.generatelabeltext;\n    }\n\n    el.setParents(parents[0]);\n    el.isDraggable = true;\n    el.fullUpdate(parents[0].visPropCalc.visible);\n\n    return el;\n};\n\n    /**\n     * @class Hatches can be used to mark congruent lines or curves.\n     * @pseudo\n     * @description\n     * @name Hatch\n     * @augments JXG.Ticks\n     * @constructor\n     * @type JXG.Ticks\n     * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n     * @param {JXG.Line|JXG.curve} line The line or curve the hatch marks are going to be attached to.\n     * @param {Number} numberofhashes Number of dashes. The distance of the hashes can be controlled with the attribute ticksDistance.\n     * @example\n     * // Create an axis providing two coords pairs.\n     *   var p1 = board.create('point', [0, 3]);\n     *   var p2 = board.create('point', [1, 3]);\n     *   var l1 = board.create('line', [p1, p2]);\n     *   var t = board.create('hatch', [l1, 3]);\n     * </pre><div class=\"jxgbox\" id=\"JXG4a20af06-4395-451c-b7d1-002757cf01be\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     * (function () {\n     *   var board = JXG.JSXGraph.initBoard('JXG4a20af06-4395-451c-b7d1-002757cf01be', {boundingbox: [-1, 7, 7, -1], showcopyright: false, shownavigation: false});\n     *   var p1 = board.create('point', [0, 3]);\n     *   var p2 = board.create('point', [1, 3]);\n     *   var l1 = board.create('line', [p1, p2]);\n     *   var t = board.create('hatch', [l1, 3]);\n     * })();\n     * </script><pre>\n     *\n     * @example\n     * // Alter the position of the hatch\n     *\n     * var p = board.create('point', [-5, 0]);\n     * var q = board.create('point', [5, 0]);\n     * var li = board.create('line', [p, q]);\n     * var h = board.create('hatch', [li, 2], {anchor: 0.2, ticksDistance:0.4});\n     *\n     * </pre><div id=\"JXG05d720ee-99c9-11e6-a9c7-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG05d720ee-99c9-11e6-a9c7-901b0e1b8723',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *\n     *     var p = board.create('point', [-5, 0]);\n     *     var q = board.create('point', [5, 0]);\n     *     var li = board.create('line', [p, q]);\n     *     var h = board.create('hatch', [li, 2], {anchor: 0.2, ticksDistance:0.4});\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     * @example\n     * // Alternative hatch faces\n     *\n     * var li = board.create('line', [[-6,0], [6,3]]);\n     * var h1 = board.create('hatch', [li, 2], {tickEndings: [1,1], face:'|'});\n     * var h2 = board.create('hatch', [li, 2], {tickEndings: [1,1], face:'>', anchor: 0.3});\n     * var h3 = board.create('hatch', [li, 2], {tickEndings: [1,1], face:'<', anchor: 0.7});\n     *\n     * </pre><div id=\"JXG974f7e89-eac8-4187-9aa3-fb8068e8384b\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG974f7e89-eac8-4187-9aa3-fb8068e8384b',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     // Alternative hatch faces\n     *\n     *     var li = board.create('line', [[-6,0], [6,3]]);\n     *     var h1 = board.create('hatch', [li, 2], {tickEndings: [1,1], face:'|'});\n     *     var h2 = board.create('hatch', [li, 2], {tickEndings: [1,1], face:'>', anchor: 0.3});\n     *     var h3 = board.create('hatch', [li, 2], {tickEndings: [1,1], face:'<', anchor: 0.7});\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    JXG.createHatchmark = function (board, parents, attributes) {\n        var num, i, base, width, totalwidth, el,\n            pos = [],\n            attr = Type.copyAttributes(attributes, board.options, 'hatch');\n\n    if (\n        (parents[0].elementClass !== Const.OBJECT_CLASS_LINE &&\n            parents[0].elementClass !== Const.OBJECT_CLASS_CURVE) ||\n        typeof parents[1] !== \"number\"\n    ) {\n        throw new Error(\n            \"JSXGraph: Can't create Hatch mark with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \" and ''\" +\n                typeof parents[2] +\n                \"'.\"\n        );\n    }\n\n    num = parents[1];\n    width = attr.ticksdistance;\n    totalwidth = (num - 1) * width;\n    base = -totalwidth * 0.5;\n\n    for (i = 0; i < num; i++) {\n        pos[i] = base + i * width;\n    }\n\n        el = board.create('ticks', [parents[0], pos], attr);\n        el.elType = 'hatch';\n        parents[0].inherits.push(el);\n\n    return el;\n};\n\nJXG.registerElement(\"ticks\", JXG.createTicks);\nJXG.registerElement(\"hash\", JXG.createHatchmark);\nJXG.registerElement(\"hatch\", JXG.createHatchmark);\n\nexport default {\n    Ticks: JXG.Ticks,\n    createTicks: JXG.createTicks,\n    createHashmark: JXG.createHatchmark,\n    createHatchmark: JXG.createHatchmark\n};\n","/*\n JessieCode Computer algebra algorithms\n\n    Copyright 2011-2019\n        Michael Gerhaeuser,\n        Alfred Wassermann\n\n    JessieCode is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JessieCode is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JessieCode. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true, console: true, self: true, document: true, parser: true*/\n/*jslint nomen: true, plusplus: true*/\n/*eslint eqeqeq: \"off\"*/\n\n/**\n * @fileoverview Here, the computer algebra algorithms are implemented.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n// import Const from \"../base/constants\";\n// import Text from \"../base/text\";\n// import Mat from \"../math/math\";\n// import Geometry from \"../math/geometry\";\n// import Statistics from \"../math/statistics\";\n// import Env from \"../utils/env\";\n\n/**\n * A JessieCode object provides an interface to the parser and stores all variables and objects used within a JessieCode script.\n * The optional argument <tt>code</tt> is interpreted after initializing. To evaluate more code after initializing a JessieCode instance\n * please use {@link JXG.JessieCode#parse}. For code snippets like single expressions use {@link JXG.JessieCode#snippet}.\n * @constructor\n * @param {String} [code] Code to parse.\n * @param {Boolean} [geonext=false] Geonext compatibility mode.\n */\nJXG.CA = function (node, createNode, parser) {\n    this.node = node;\n    this.createNode = createNode;\n    this.parser = parser;\n};\n\nJXG.extend(\n    JXG.CA.prototype,\n    /** @lends JXG.CA.prototype */ {\n        findMapNode: function (mapname, node) {\n            var i, len, ret;\n\n            //console.log(\"FINDMAP\", node);\n            if (node.value === \"op_assign\" && node.children[0].value === mapname) {\n                return node.children[1];\n            } else if (node.children) {\n                len = node.children.length;\n                for (i = 0; i < len; ++i) {\n                    ret = this.findMapNode(mapname, node.children[i]);\n                    if (ret !== null) {\n                        return ret;\n                    }\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Declare all subnodes as math nodes,\n         * i.e recursively set node.isMath = true;\n         */\n        setMath: function (node) {\n            var i, len;\n\n            if (\n                (node.type == \"node_op\" &&\n                    (node.value == \"op_add\" ||\n                        node.value == \"op_sub\" ||\n                        node.value == \"op_mul\" ||\n                        node.value == \"op_div\" ||\n                        node.value == \"op_neg\" ||\n                        node.value == \"op_execfun\" ||\n                        node.value == \"op_exp\")) ||\n                node.type == \"node_var\" ||\n                node.type == \"node_const\"\n            ) {\n                node.isMath = true;\n            }\n            if (node.children) {\n                len = node.children.length;\n                for (i = 0; i < len; ++i) {\n                    this.setMath(node.children[i]);\n                }\n            }\n        },\n\n        deriveElementary: function (node, varname) {\n            var fun = node.children[0].value,\n                arg = node.children[1],\n                newNode;\n\n            switch (fun) {\n                case \"abs\":\n                    // x / sqrt(x * x)\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        arg[0],\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sqrt\"),\n                            [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    Type.deepCopy(arg[0]),\n                                    Type.deepCopy(arg[0])\n                                )\n                            ]\n                        )\n                    );\n                    break;\n\n                case \"sqrt\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_mul\",\n                            this.createNode(\"node_const\", 2.0),\n                            this.createNode(\n                                node.type,\n                                node.value,\n                                Type.deepCopy(node.children[0]),\n                                Type.deepCopy(node.children[1])\n                            )\n                        )\n                    );\n                    break;\n\n                case \"sin\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_execfun\",\n                        this.createNode(\"node_var\", \"cos\"),\n                        Type.deepCopy(arg)\n                    );\n                    break;\n\n                case \"cos\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_neg\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sin\"),\n                            Type.deepCopy(arg)\n                        )\n                    );\n                    break;\n\n                case \"tan\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_exp\",\n                            this.createNode(\n                                \"node_op\",\n                                \"op_execfun\",\n                                this.createNode(\"node_var\", \"cos\"),\n                                Type.deepCopy(arg)\n                            ),\n                            this.createNode(\"node_const\", 2)\n                        )\n                    );\n                    break;\n\n                case \"cot\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_neg\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_exp\",\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_execfun\",\n                                    this.createNode(\"node_var\", \"sin\"),\n                                    Type.deepCopy(arg)\n                                ),\n                                this.createNode(\"node_const\", 2)\n                            )\n                        )\n                    );\n                    break;\n\n                case \"exp\":\n                    newNode = this.createNode(\n                        node.type,\n                        node.value,\n                        Type.deepCopy(node.children[0]),\n                        Type.deepCopy(node.children[1])\n                    );\n                    break;\n\n                case \"pow\":\n                    // (f^g)' = f^g*(f'g/f + g' log(f))\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_mul\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            Type.deepCopy(node.children[0]),\n                            Type.deepCopy(node.children[1])\n                        ),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_add\",\n                            this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                this.derivative(node.children[1][0], varname),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_div\",\n                                    Type.deepCopy(node.children[1][1]),\n                                    Type.deepCopy(node.children[1][0])\n                                )\n                            ),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                this.derivative(node.children[1][1], varname),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_execfun\",\n                                    this.createNode(\"node_var\", \"log\"),\n                                    [Type.deepCopy(node.children[1][0])]\n                                )\n                            )\n                        )\n                    );\n                    break;\n\n                case \"log\":\n                case \"ln\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        // Attention: single variable mode\n                        Type.deepCopy(arg[0])\n                    );\n                    break;\n\n                case \"log2\":\n                case \"lb\":\n                case \"ld\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_mul\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            // Attention: single variable mode\n                            Type.deepCopy(arg[0])\n                        ),\n                        this.createNode(\"node_const\", 1.4426950408889634) // 1/log(2)\n                    );\n                    break;\n\n                case \"log10\":\n                case \"lg\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_mul\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            // Attention: single variable mode\n                            Type.deepCopy(arg[0])\n                        ),\n                        this.createNode(\"node_const\", 0.43429448190325176) // 1/log(10)\n                    );\n                    break;\n\n                case \"asin\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sqrt\"),\n                            [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    this.createNode(\"node_const\", 1.0),\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        Type.deepCopy(arg[0]),\n                                        Type.deepCopy(arg[0])\n                                    )\n                                )\n                            ]\n                        )\n                    );\n                    break;\n\n                case \"acos\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_neg\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_execfun\",\n                                this.createNode(\"node_var\", \"sqrt\"),\n                                [\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_sub\",\n                                        this.createNode(\"node_const\", 1.0),\n                                        this.createNode(\n                                            \"node_op\",\n                                            \"op_mul\",\n                                            Type.deepCopy(arg[0]),\n                                            Type.deepCopy(arg[0])\n                                        )\n                                    )\n                                ]\n                            )\n                        )\n                    );\n                    break;\n\n                //case 'atan2':\n\n                case \"atan\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_add\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                Type.deepCopy(arg[0]),\n                                Type.deepCopy(arg[0])\n                            )\n                        )\n                    );\n                    break;\n\n                case \"acot\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_neg\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_add\",\n                                this.createNode(\"node_const\", 1.0),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    Type.deepCopy(arg[0]),\n                                    Type.deepCopy(arg[0])\n                                )\n                            )\n                        )\n                    );\n                    break;\n\n                case \"sinh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_execfun\",\n                        this.createNode(\"node_var\", \"cosh\"),\n                        [Type.deepCopy(arg[0])]\n                    );\n                    break;\n\n                case \"cosh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_execfun\",\n                        this.createNode(\"node_var\", \"sinh\"),\n                        [Type.deepCopy(arg[0])]\n                    );\n                    break;\n\n                case \"tanh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_sub\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_exp\",\n                            this.createNode(\n                                \"node_op\",\n                                \"op_execfun\",\n                                this.createNode(\"node_var\", \"tanh\"),\n                                [Type.deepCopy(arg[0])]\n                            ),\n                            this.createNode(\"node_const\", 2.0)\n                        )\n                    );\n                    break;\n\n                case \"asinh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sqrt\"),\n                            [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        Type.deepCopy(arg[0]),\n                                        Type.deepCopy(arg[0])\n                                    ),\n                                    this.createNode(\"node_const\", 1.0)\n                                )\n                            ]\n                        )\n                    );\n                    break;\n\n                case \"acosh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sqrt\"),\n                            [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        Type.deepCopy(arg[0]),\n                                        Type.deepCopy(arg[0])\n                                    ),\n                                    this.createNode(\"node_const\", 1.0)\n                                )\n                            ]\n                        )\n                    );\n                    break;\n\n                case \"atanh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_sub\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                Type.deepCopy(arg[0]),\n                                Type.deepCopy(arg[0])\n                            )\n                        )\n                    );\n                    break;\n\n                default:\n                    newNode = this.createNode(\"node_const\", 0.0);\n                    console.log('Derivative of \"' + fun + '\" not yet implemented');\n                    throw new Error(\"Error(\" + this.line + \"): \");\n                //  this._error('Derivative of \"' + fun + '\" not yet implemented');\n            }\n\n            return newNode;\n        },\n\n        derivative: function (node, varname) {\n            var newNode;\n\n            switch (node.type) {\n                case \"node_op\":\n                    switch (node.value) {\n                        /*\n                        case 'op_map':\n                            if (true) {\n                                newNode = this.createNode('node_op', 'op_map',\n                                        Type.deepCopy(node.children[0]),\n                                        this.derivative(node.children[1], varname)\n                                    );\n                            } else {\n                                newNode = this.derivative(node.children[1], varname);\n                            }\n                            break;\n                        */\n                        case \"op_execfun\":\n                            // f'(g(x))g'(x)\n                            if (node.children[0].value == \"pow\") {\n                                newNode = this.deriveElementary(node, varname);\n                            } else {\n                                if (node.children[1].length === 0) {\n                                    newNode = this.createNode(\"node_const\", 0.0);\n                                } else {\n                                    newNode = this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        this.deriveElementary(node, varname),\n                                        // Warning: single variable mode\n                                        this.derivative(node.children[1][0], varname)\n                                    );\n                                }\n                            }\n                            break;\n\n                        case \"op_div\":\n                            // (f'g − g'f )/(g*g)\n                            newNode = this.createNode(\n                                \"node_op\",\n                                \"op_div\",\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        this.derivative(node.children[0], varname),\n                                        Type.deepCopy(node.children[1])\n                                    ),\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        Type.deepCopy(node.children[0]),\n                                        this.derivative(node.children[1], varname)\n                                    )\n                                ),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    Type.deepCopy(node.children[1]),\n                                    Type.deepCopy(node.children[1])\n                                )\n                            );\n                            break;\n\n                        case \"op_mul\":\n                            // fg' + f'g\n                            newNode = this.createNode(\n                                \"node_op\",\n                                \"op_add\",\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    Type.deepCopy(node.children[0]),\n                                    this.derivative(node.children[1], varname)\n                                ),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    this.derivative(node.children[0], varname),\n                                    Type.deepCopy(node.children[1])\n                                )\n                            );\n                            break;\n\n                        case \"op_neg\":\n                            newNode = this.createNode(\n                                \"node_op\",\n                                \"op_neg\",\n                                this.derivative(node.children[0], varname)\n                            );\n                            break;\n\n                        case \"op_add\":\n                        case \"op_sub\":\n                            newNode = this.createNode(\n                                \"node_op\",\n                                node.value,\n                                this.derivative(node.children[0], varname),\n                                this.derivative(node.children[1], varname)\n                            );\n                            break;\n\n                        case \"op_exp\":\n                            // (f^g)' = f^g*(f'g/f + g' log(f))\n                            newNode = this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                Type.deepCopy(node),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        this.derivative(node.children[0], varname),\n                                        this.createNode(\n                                            \"node_op\",\n                                            \"op_div\",\n                                            Type.deepCopy(node.children[1]),\n                                            Type.deepCopy(node.children[0])\n                                        )\n                                    ),\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        this.derivative(node.children[1], varname),\n                                        this.createNode(\n                                            \"node_op\",\n                                            \"op_execfun\",\n                                            this.createNode(\"node_var\", \"log\"),\n                                            [Type.deepCopy(node.children[0])]\n                                        )\n                                    )\n                                )\n                            );\n                            break;\n                    }\n                    break;\n\n                case \"node_var\":\n                    //console.log('node_var', node);\n                    if (node.value === varname) {\n                        newNode = this.createNode(\"node_const\", 1.0);\n                    } else {\n                        newNode = this.createNode(\"node_const\", 0.0);\n                    }\n                    break;\n\n                case \"node_const\":\n                    newNode = this.createNode(\"node_const\", 0.0);\n                    break;\n\n                case \"node_const_bool\":\n                    break;\n\n                case \"node_str\":\n                    break;\n            }\n\n            return newNode;\n        },\n\n        /**\n         * f = map (x) -> x*sin(x);\n         * Usages:\n         * h = D(f, x);\n         * h = map (x) -> D(f, x);\n         *\n         */\n        expandDerivatives: function (node, parent, ast) {\n            var len,\n                i,\n                j,\n                mapNode,\n                codeNode,\n                ret,\n                node2,\n                newNode,\n                mapName,\n                varname,\n                vArray,\n                order;\n\n            ret = 0;\n            if (!node) {\n                return ret;\n            }\n\n            this.line = node.line;\n            this.col = node.col;\n\n            // First we have to go down in the tree.\n            // This ensures that in cases like D(D(f,x),x) the inner D is expanded first.\n            len = node.children.length;\n            for (i = 0; i < len; ++i) {\n                if (node.children[i] && node.children[i].type) {\n                    node.children[i] = this.expandDerivatives(node.children[i], node, ast);\n                } else if (Type.isArray(node.children[i])) {\n                    for (j = 0; j < node.children[i].length; ++j) {\n                        if (node.children[i][j] && node.children[i][j].type) {\n                            node.children[i][j] = this.expandDerivatives(\n                                node.children[i][j],\n                                node,\n                                ast\n                            );\n                        }\n                    }\n                }\n            }\n\n            switch (node.type) {\n                case \"node_op\":\n                    switch (node.value) {\n                        case \"op_execfun\":\n                            if (node.children[0] && node.children[0].value === \"D\") {\n                                if (node.children[1][0].type == \"node_var\") {\n                                    /*\n                                     * Derive map, that is compute D(f,x)\n                                     * where e.g. f = map (x) -> x^2\n                                     *\n                                     * First step: find node where the map is defined\n                                     */\n                                    mapName = node.children[1][0].value;\n                                    mapNode = this.findMapNode(mapName, ast);\n                                    vArray = mapNode.children[0];\n\n                                    // Variable name for differentiation\n                                    if (node.children[1].length >= 2) {\n                                        varname = node.children[1][1].value;\n                                    } else {\n                                        varname = mapNode.children[0][0]; // Usually it's 'x'\n                                    }\n                                    codeNode = mapNode.children[1];\n                                } else {\n                                    /*\n                                     * Derive expression, e.g.\n                                     *     D(2*x, x)\n                                     */\n                                    codeNode = node.children[1][0];\n                                    vArray = [\"x\"];\n\n                                    // Variable name for differentiation and order\n                                    if (node.children[1].length >= 2) {\n                                        varname = node.children[1][1].value;\n                                    } else {\n                                        varname = \"x\";\n                                    }\n                                }\n\n                                // Differentiation order\n                                if (node.children[1].length >= 3) {\n                                    order = node.children[1][2].value;\n                                } else {\n                                    order = 1;\n                                }\n\n                                // Create node which contains the derivative\n                                newNode = codeNode;\n                                //newNode = this.removeTrivialNodes(newNode);\n                                if (order >= 1) {\n                                    while (order >= 1) {\n                                        newNode = this.derivative(newNode, varname);\n                                        newNode = this.removeTrivialNodes(newNode);\n                                        order--;\n                                    }\n                                }\n\n                                // Replace the node containing e.g. D(f,x) by the derivative.\n                                if (parent.type == \"node_op\" && parent.value == \"op_assign\") {\n                                    // If D is an assignment it has to be replaced by a map\n                                    // h = D(f, x)\n                                    node2 = this.createNode(\n                                        \"node_op\",\n                                        \"op_map\",\n                                        vArray,\n                                        newNode\n                                    );\n                                } else {\n                                    node2 = newNode;\n                                }\n\n                                this.setMath(node2);\n                                node.type = node2.type;\n                                node.value = node2.value;\n                                node.children[0] = node2.children[0];\n                                node.children[1] = node2.children[1];\n                            }\n                    }\n                    break;\n\n                case \"node_var\":\n                case \"node_const\":\n                case \"node_const_bool\":\n                case \"node_str\":\n                    break;\n            }\n\n            return node;\n        },\n\n        removeTrivialNodes: function (node) {\n            var i, len, n0, n1, swap;\n\n            // In case of 'op_execfun' the children[1] node is an array.\n            if (Type.isArray(node)) {\n                len = node.length;\n                for (i = 0; i < len; ++i) {\n                    node[i] = this.removeTrivialNodes(node[i]);\n                }\n            }\n            if (node.type != \"node_op\" || !node.children) {\n                return node;\n            }\n\n            len = node.children.length;\n            for (i = 0; i < len; ++i) {\n                this.mayNotBeSimplified = false;\n                do {\n                    node.children[i] = this.removeTrivialNodes(node.children[i]);\n                } while (this.mayNotBeSimplified);\n            }\n\n            switch (node.value) {\n                // Allow maps of the form\n                //  map (x) -> x;\n                case \"op_map\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n1.type == \"node_var\") {\n                        for (i = 0; i < n0.length; ++i) {\n                            // Allow maps of the form map(x) -> x\n                            if (n0[i] == n1.value) {\n                                n1.isMath = true;\n                                break;\n                            }\n                        }\n                    }\n                    break;\n\n                // a + 0 -> a\n                // 0 + a -> a\n                case \"op_add\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n0.type == \"node_const\" && n0.value === 0.0) {\n                        return n1;\n                    }\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        return n0;\n                    }\n\n                    // const + const -> const\n                    if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n                        n0.value += n1.value;\n                        return n0;\n                    }\n                    break;\n\n                // 1 * a = a\n                // a * 1 = a\n                // a * 0 = 0\n                // 0 * a = 0\n                // - * - = +\n                // Order children\n                case \"op_mul\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n0.type == \"node_const\" && n0.value == 1.0) {\n                        return n1;\n                    }\n                    if (n1.type == \"node_const\" && n1.value == 1.0) {\n                        return n0;\n                    }\n                    if (n0.type == \"node_const\" && n0.value === 0.0) {\n                        return n0;\n                    }\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        return n1;\n                    }\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        return n1;\n                    }\n\n                    // (-a) * (-b) -> a*b\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_neg\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_neg\"\n                    ) {\n                        node.children = [n0.children[0], n1.children[0]];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // (-a) * b -> -(a*b)\n                    if (n0.value == \"op_neg\" && n1.value != \"op_neg\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [\n                            this.createNode(\"node_op\", \"op_mul\", n0.children[0], n1)\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a * (-b) -> -(a*b)\n                    if (n0.value != \"op_neg\" && n1.value == \"op_neg\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [\n                            this.createNode(\"node_op\", \"op_mul\", n0, n1.children[0])\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // (1 / a) * b -> a / b\n                    if (\n                        n0.value == \"op_div\" &&\n                        n0.children[0].type == \"node_const\" &&\n                        n0.children[0].value == 1.0\n                    ) {\n                        node.type = \"node_op\";\n                        node.value = \"op_div\";\n                        node.children = [n1, n0.children[1]];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a * (1 / b) -> a / b\n                    if (\n                        n1.value == \"op_div\" &&\n                        n1.children[0].type == \"node_const\" &&\n                        n1.children[0].value == 1.0\n                    ) {\n                        node.type = \"node_op\";\n                        node.value = \"op_div\";\n                        node.children = [n0, n1.children[1]];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // Order children\n                    // a * const -> const * a\n                    if (n0.type != \"node_const\" && n1.type == \"node_const\") {\n                        node.children = [n1, n0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a + (-const) -> -const * a\n                    if (\n                        n0.type != \"node_const\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_neg\" &&\n                        n1.children[0].type == \"node_const\"\n                    ) {\n                        node.children = [n1, n0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // a * var -> var * a\n                    // a * fun -> fun * a\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value != \"op_execfun\" &&\n                        (n1.type == \"node_var\" ||\n                            (n1.type == \"node_op\" && n1.value == \"op_execfun\"))\n                    ) {\n                        node.children = [n1, n0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // a + (-var) -> -var * a\n                    if (\n                        n0.type != \"node_op\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_neg\" &&\n                        n1.children[0].type == \"node_var\"\n                    ) {\n                        node.children = [n1, n0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a * (const * b) -> const * (a*b)\n                    // a * (const / b) -> const * (a/b)\n                    if (\n                        n0.type != \"node_const\" &&\n                        n1.type == \"node_op\" &&\n                        (n1.value == \"op_mul\" || n1.value == \"op_div\") &&\n                        n1.children[0].type == \"node_const\"\n                    ) {\n                        swap = n1.children[0];\n                        n1.children[0] = n0;\n                        node.children = [swap, n1];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // (const * a) * b -> const * (a * b)\n                    if (\n                        n1.type != \"node_const\" &&\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_mul\" &&\n                        n0.children[0].type == \"node_const\"\n                    ) {\n                        node.children = [\n                            n0.children[0],\n                            this.createNode(\"node_op\", \"op_mul\", n0.children[1], n1)\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // const * const -> const\n                    if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n                        n0.value *= n1.value;\n                        return n0;\n                    }\n\n                    // const * (const * a) -> const * a\n                    // const * (const / a) -> const / a\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_op\" &&\n                        (n1.value == \"op_mul\" || n1.value == \"op_div\") &&\n                        n1.children[0].type == \"node_const\"\n                    ) {\n                        n1.children[0].value *= n0.value;\n                        return n1;\n                    }\n\n                    // a * a-> a^2\n                    n0.hash = this.parser.compile(n0);\n                    n1.hash = this.parser.compile(n1);\n                    if (n0.hash === n1.hash) {\n                        node.value = \"op_exp\";\n                        node.children[1] = this.createNode(\"node_const\", 2.0);\n                        return node;\n                    }\n\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_op\" &&\n                        (n1.value == \"op_mul\" || n1.value == \"op_div\") &&\n                        n1.children[0].type == \"node_const\"\n                    ) {\n                        n1.children[0].value *= n0.value;\n                        return n1;\n                    }\n\n                    // a * a^b -> a^(b+1)\n                    if (n1.type == \"node_op\" && n1.value == \"op_exp\") {\n                        if (!n0.hash) {\n                            n0.hash = this.parser.compile(n0);\n                        }\n                        if (!n1.children[0].hash) {\n                            n1.children[0].hash = this.parser.compile(n1.children[0]);\n                        }\n                        if (n0.hash === n1.children[0].hash) {\n                            n1.children[1] = this.createNode(\n                                \"node_op\",\n                                \"op_add\",\n                                n1.children[1],\n                                this.createNode(\"node_const\", 1.0)\n                            );\n                            this.mayNotBeSimplified = true;\n                            return n1;\n                        }\n                    }\n\n                    // a^b * a^c -> a^(b+c)\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_exp\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_exp\"\n                    ) {\n                        n0.children[0].hash = this.parser.compile(n0.children[0]);\n                        n1.children[0].hash = this.parser.compile(n1.children[0]);\n                        if (n0.children[0].hash === n1.children[0].hash) {\n                            n0.children[1] = this.createNode(\n                                \"node_op\",\n                                \"op_add\",\n                                n0.children[1],\n                                n1.children[1]\n                            );\n                            this.mayNotBeSimplified = true;\n                            return n0;\n                        }\n                    }\n\n                    break;\n\n                // 0 - a -> -a\n                // a - 0 -> a\n                // a - a -> 0\n                case \"op_sub\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n0.type == \"node_const\" && n0.value === 0.0) {\n                        node.value = \"op_neg\";\n                        node.children[0] = n1;\n                        return node;\n                    }\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        return n0;\n                    }\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_const\" &&\n                        n0.value == n1.value\n                    ) {\n                        return this.createNode(\"node_const\", 0.0);\n                    }\n                    if (\n                        n0.type == \"node_var\" &&\n                        n1.type == \"node_var\" &&\n                        n0.value == n1.value\n                    ) {\n                        return this.createNode(\"node_const\", 0.0);\n                    }\n\n                    // const - const -> const\n                    if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n                        n0.value -= n1.value;\n                        return n0;\n                    }\n\n                    // const * a - const * a -> const * a\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_mul\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_mul\"\n                    ) {\n                        n0.children[1].hash = this.parser.compile(n0.children[1]);\n                        n1.children[1].hash = this.parser.compile(n1.children[1]);\n                        if (n0.children[1].hash === n1.children[1].hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    n0.children[0],\n                                    n1.children[0]\n                                ),\n                                n0.children[1]\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n                    // const * a - a -> (const - 1) * a\n                    if (n0.type == \"node_op\" && n0.value == \"op_mul\") {\n                        n0.children[1].hash = this.parser.compile(n0.children[1]);\n                        n1.hash = this.parser.compile(n1);\n                        if (n0.children[1].hash === n1.hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    n0.children[0],\n                                    this.createNode(\"node_const\", 1.0)\n                                ),\n                                n1\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n                    // a - const*a -> (const - 1) * a\n                    if (n1.type == \"node_op\" && n1.value == \"op_mul\") {\n                        n1.children[1].hash = this.parser.compile(n1.children[1]);\n                        n0.hash = this.parser.compile(n0);\n                        if (n1.children[1].hash === n0.hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    this.createNode(\"node_const\", 1.0),\n                                    n1.children[0]\n                                ),\n                                n0\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n\n                    break;\n\n                // -0 -> 0\n                // -(-b) = b\n                case \"op_neg\":\n                    n0 = node.children[0];\n                    if (n0.type == \"node_const\" && n0.value === 0.0) {\n                        return n0;\n                    }\n                    if (n0.type == \"node_op\" && n0.value == \"op_neg\") {\n                        return n0.children[0];\n                    }\n                    break;\n\n                // a / a -> 1, a != 0\n                // 0 / a -> 0, a != 0\n                // a / 0 -> Infinity, a != 0\n                // 0 / 0 -> NaN, a == 0\n                case \"op_div\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_const\" &&\n                        n0.value == n1.value &&\n                        n0.value !== 0\n                    ) {\n                        n0.value = 1.0;\n                        return n0;\n                    }\n                    if (\n                        n0.type == \"node_const\" &&\n                        n0.value === 0 &&\n                        n1.type == \"node_const\" &&\n                        n1.value !== 0\n                    ) {\n                        n0.value = 0.0;\n                        return n0;\n                    }\n\n                    // Risky: 0 / (something != 0) -> 0.0\n                    if (\n                        n0.type == \"node_const\" &&\n                        n0.value === 0 &&\n                        (n1.type == \"node_op\" || n1.type == \"node_var\")\n                    ) {\n                        node.type = \"node_const\";\n                        node.value = 0.0;\n                        return node;\n                    }\n\n                    if (\n                        n0.type == \"node_var\" &&\n                        n1.type == \"node_var\" &&\n                        n0.value == n1.value\n                    ) {\n                        return this.createNode(\"node_const\", 1.0);\n                    }\n                    if (\n                        n0.type == \"node_const\" &&\n                        n0.value !== 0 &&\n                        n1.type == \"node_const\" &&\n                        n1.value === 0\n                    ) {\n                        if (n0.value > 0.0) {\n                            n0.value = Infinity;\n                        } else {\n                            n0.value = -Infinity; // Do we ever need this?\n                        }\n                        return n0;\n                    }\n\n                    // (-a) / (-b) -> a/b\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_neg\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_neg\"\n                    ) {\n                        node.children = [n0.children[0], n1.children[0]];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // (-a) / b -> -(a/b)\n                    if (n0.value == \"op_neg\" && n1.value != \"op_neg\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [\n                            this.createNode(\"node_op\", \"op_div\", n0.children[0], n1)\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a / (-b) -> -(a/b)\n                    if (n0.value != \"op_neg\" && n1.value == \"op_neg\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [\n                            this.createNode(\"node_op\", \"op_div\", n0, n1.children[0])\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // a^b / a -> a^(b-1)\n                    if (n0.type == \"node_op\" && n0.value == \"op_exp\") {\n                        if (!n1.hash) {\n                            n1.hash = this.parser.compile(n1);\n                        }\n                        if (!n0.children[0].hash) {\n                            n0.children[0].hash = this.parser.compile(n0.children[0]);\n                        }\n                        if (n1.hash === n0.children[0].hash) {\n                            n0.children[1] = this.createNode(\n                                \"node_op\",\n                                \"op_sub\",\n                                n0.children[1],\n                                this.createNode(\"node_const\", 1.0)\n                            );\n                            this.mayNotBeSimplified = true;\n                            return n0;\n                        }\n                    }\n\n                    // (const * a) / b -> const * (a / b)\n                    if (\n                        n1.type != \"node_const\" &&\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_mul\" &&\n                        n0.children[0].type == \"node_const\"\n                    ) {\n                        node.value = \"op_mul\";\n                        node.children = [\n                            n0.children[0],\n                            this.createNode(\"node_op\", \"op_div\", n0.children[1], n1)\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // a^b / a^c -> a^(b-c)\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_exp\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_exp\"\n                    ) {\n                        n0.children[0].hash = this.parser.compile(n0.children[0]);\n                        n1.children[0].hash = this.parser.compile(n1.children[0]);\n                        if (n0.children[0].hash === n1.children[0].hash) {\n                            n0.children[1] = this.createNode(\n                                \"node_op\",\n                                \"op_sub\",\n                                n0.children[1],\n                                n1.children[1]\n                            );\n                            this.mayNotBeSimplified = true;\n                            return n0;\n                        }\n                    }\n\n                    break;\n\n                // a^0 = 1\n                // a^1 -> a\n                // 1^a -> 1\n                // 0^a -> 0: a const != 0\n                case \"op_exp\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        n1.value = 1.0;\n                        return n1;\n                    }\n                    if (n1.type == \"node_const\" && n1.value == 1.0) {\n                        return n0;\n                    }\n                    if (n0.type == \"node_const\" && n0.value == 1.0) {\n                        return n0;\n                    }\n                    if (\n                        n0.type == \"node_const\" &&\n                        n0.value === 0.0 &&\n                        n1.type == \"node_const\" &&\n                        n1.value !== 0.0\n                    ) {\n                        return n0;\n                    }\n\n                    // (a^b)^c -> a^(b*c)\n                    if (n0.type == \"node_op\" && n0.value == \"op_exp\") {\n                        node.children = [\n                            n0.children[0],\n                            this.createNode(\"node_op\", \"op_mul\", n0.children[1], n1)\n                        ];\n                        return node;\n                    }\n                    break;\n            }\n\n            switch (node.value) {\n                // const_1 + const_2 -> (const_1 + const_2)\n                // a + a -> 2*a\n                // a + (-b) = a - b\n                case \"op_add\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_const\" &&\n                        n0.value == n1.value\n                    ) {\n                        n0.value += n1.value;\n                        return n0;\n                    }\n\n                    if (\n                        n0.type == \"node_var\" &&\n                        n1.type == \"node_var\" &&\n                        n0.value == n1.value\n                    ) {\n                        node.children[0] = this.createNode(\"node_const\", 2.0);\n                        node.value = \"op_mul\";\n                        return node;\n                    }\n\n                    if (n0.type == \"node_op\" && n0.value == \"op_neg\") {\n                        node.value = \"op_sub\";\n                        node.children[0] = n1;\n                        node.children[1] = n0.children[0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    if (n1.type == \"node_op\" && n1.value == \"op_neg\") {\n                        node.value = \"op_sub\";\n                        node.children[1] = n1.children[0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // const * a + const * a -> const * a\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_mul\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_mul\"\n                    ) {\n                        n0.children[1].hash = this.parser.compile(n0.children[1]);\n                        n1.children[1].hash = this.parser.compile(n1.children[1]);\n                        if (n0.children[1].hash === n1.children[1].hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    n0.children[0],\n                                    n1.children[0]\n                                ),\n                                n0.children[1]\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n                    // const * a + a -> (const + 1) * a\n                    if (n0.type == \"node_op\" && n0.value == \"op_mul\") {\n                        n0.children[1].hash = this.parser.compile(n0.children[1]);\n                        n1.hash = this.parser.compile(n1);\n                        if (n0.children[1].hash === n1.hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    n0.children[0],\n                                    this.createNode(\"node_const\", 1.0)\n                                ),\n                                n1\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n                    // a + const*a -> (const + 1) * a\n                    if (n1.type == \"node_op\" && n1.value == \"op_mul\") {\n                        n1.children[1].hash = this.parser.compile(n1.children[1]);\n                        n0.hash = this.parser.compile(n0);\n                        if (n1.children[1].hash === n0.hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    this.createNode(\"node_const\", 1.0),\n                                    n1.children[0]\n                                ),\n                                n0\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n\n                    break;\n\n                // a - (-b) = a + b\n                case \"op_sub\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n1.type == \"node_op\" && n1.value == \"op_neg\") {\n                        node.value = \"op_add\";\n                        node.children[1] = n1.children[0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    break;\n\n                case \"op_execfun\":\n                    return this.simplifyElementary(node);\n            }\n\n            return node;\n        },\n\n        simplifyElementary: function (node) {\n            var fun = node.children[0].value,\n                arg = node.children[1];\n\n            // Catch errors of the form sin()\n            if (arg.length == 0) {\n                return node;\n            }\n\n            switch (fun) {\n                // sin(0) -> 0\n                // sin(PI) -> 0\n                // sin (int * PI) -> 0\n                // sin (PI * int) -> 0\n                // Same for tan()\n                case \"sin\":\n                case \"tan\":\n                    if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n                        node.type = \"node_const\";\n                        node.value = 0.0;\n                        return node;\n                    }\n                    if (arg[0].type == \"node_var\" && arg[0].value == \"PI\") {\n                        node.type = \"node_const\";\n                        node.value = 0.0;\n                        return node;\n                    }\n                    if (\n                        arg[0].type == \"node_op\" &&\n                        arg[0].value == \"op_mul\" &&\n                        arg[0].children[0].type == \"node_const\" &&\n                        arg[0].children[0].value % 1 === 0 &&\n                        arg[0].children[1].type == \"node_var\" &&\n                        arg[0].children[1].value == \"PI\"\n                    ) {\n                        node.type = \"node_const\";\n                        node.value = 0.0;\n                        return node;\n                    }\n                    break;\n\n                // cos(0) -> 1.0\n                // cos(PI) -> -1.0\n                // cos(int * PI) -> +/- 1.0\n                // cos(PI * int) -> +/- 1.0\n                case \"cos\":\n                    if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n                        node.type = \"node_const\";\n                        node.value = 1.0;\n                        return node;\n                    }\n                    if (arg[0].type == \"node_var\" && arg[0].value == \"PI\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [this.createNode(\"node_const\", 1.0)];\n                        return node;\n                    }\n                    /*\n                    if (arg[0].type == 'node_op' && arg[0].value == 'op_mul' &&\n                        ((arg[0].children[0].type == 'node_const' && arg[0].children[0].value % 1 === 0 &&\n                         arg[0].children[1].type == 'node_var' && arg[0].children[1].value == 'PI') ||\n                         (arg[0].children[1].type == 'node_const' && arg[0].children[1].value % 1 === 0 &&\n                          arg[0].children[0].type == 'node_var' && arg[0].children[0].value == 'PI'))) {\n                        node.type = 'node_const';\n                        node.value = 1.0;\n                        return node;\n                    }\n                    */\n                    break;\n\n                // exp(0) -> 1\n                case \"exp\":\n                    if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n                        node.type = \"node_const\";\n                        node.value = 1.0;\n                        return node;\n                    }\n                    break;\n\n                // pow(a, 0) -> 1\n                case \"pow\":\n                    if (arg[1].type == \"node_const\" && arg[1].value === 0) {\n                        node.type = \"node_const\";\n                        node.value = 1.0;\n                        return node;\n                    }\n                    break;\n            }\n\n            return node;\n        }\n    }\n);\n\nexport default JXG.CA;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The JXG.Dump namespace provides methods to save a board to javascript.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"./type\";\n\n/**\n * The JXG.Dump namespace provides classes and methods to save a board to javascript.\n * @namespace\n */\nJXG.Dump = {\n    /**\n     * Adds markers to every element of the board\n     * @param {JXG.Board} board\n     * @param {Array|String} markers\n     * @param {Array} values\n     */\n    addMarkers: function (board, markers, values) {\n        var e, l, i;\n\n        if (!Type.isArray(markers)) {\n            markers = [markers];\n        }\n\n        if (!Type.isArray(values)) {\n            values = [values];\n        }\n\n        l = Math.min(markers.length, values.length);\n\n        markers.length = l;\n        values.length = l;\n\n        for (e in board.objects) {\n            if (board.objects.hasOwnProperty(e)) {\n                for (i = 0; i < l; i++) {\n                    board.objects[e][markers[i]] = values[i];\n                }\n            }\n        }\n    },\n\n    /**\n     * Removes markers from every element on the board.\n     * @param {JXG.Board} board\n     * @param {Array|String} markers\n     */\n    deleteMarkers: function (board, markers) {\n        var e, l, i;\n\n        if (!Type.isArray(markers)) {\n            markers = [markers];\n        }\n\n        l = markers.length;\n\n        markers.length = l;\n\n        for (e in board.objects) {\n            if (board.objects.hasOwnProperty(e)) {\n                for (i = 0; i < l; i++) {\n                    delete board.objects[e][markers[i]];\n                }\n            }\n        }\n    },\n\n    /**\n     * Stringifies a string, i.e. puts some quotation marks around <tt>s</tt> if it is of type string.\n     * @param {*} s\n     * @returns {String} \" + s + \"\n     */\n    str: function (s) {\n        if (typeof s === \"string\" && s.substr(0, 7) !== \"function\") {\n            s = '\"' + s + '\"';\n        }\n\n        return s;\n    },\n\n    /**\n     * Eliminate default values given by {@link JXG.Options} from the attributes object.\n     * @param {Object} instance Attribute object of the element\n     * @param {Object} s Arbitrary number of objects <tt>instance</tt> will be compared to. Usually these are\n     * sub-objects of the {@link JXG.Board#options} structure.\n     * @returns {Object} Minimal attributes object\n     */\n    minimizeObject: function (instance, s) {\n        var p,\n            pl,\n            i,\n            def = {},\n            copy = Type.deepCopy(instance),\n            defaults = [];\n\n        for (i = 1; i < arguments.length; i++) {\n            defaults.push(arguments[i]);\n        }\n\n        def = Type.deepCopy(def, JXG.Options.elements, true);\n        for (i = defaults.length; i > 0; i--) {\n            def = Type.deepCopy(def, defaults[i - 1], true);\n        }\n\n        for (p in def) {\n            if (def.hasOwnProperty(p)) {\n                pl = p.toLowerCase();\n\n                if (typeof def[p] !== \"object\" && def[p] === copy[pl]) {\n                    // console.log(\"delete\", p);\n                    delete copy[pl];\n                }\n            }\n        }\n\n        return copy;\n    },\n\n    /**\n     * Prepare the attributes object for an element to be dumped as JavaScript or JessieCode code.\n     * @param {JXG.Board} board\n     * @param {JXG.GeometryElement} obj Geometry element which attributes object is generated\n     * @returns {Object} An attributes object.\n     */\n    prepareAttributes: function (board, obj) {\n        var a, s;\n\n        a = this.minimizeObject(obj.getAttributes(), JXG.Options[obj.elType]);\n\n        for (s in obj.subs) {\n            if (obj.subs.hasOwnProperty(s)) {\n                a[s] = this.minimizeObject(\n                    obj.subs[s].getAttributes(),\n                    JXG.Options[obj.elType][s],\n                    JXG.Options[obj.subs[s].elType]\n                );\n                a[s].id = obj.subs[s].id;\n                a[s].name = obj.subs[s].name;\n            }\n        }\n\n        a.id = obj.id;\n        a.name = obj.name;\n\n        return a;\n    },\n\n    setBoundingBox: function (methods, board, boardVarName) {\n        methods.push({\n            obj: boardVarName,\n            method: \"setBoundingBox\",\n            params: [board.getBoundingBox(), board.keepaspectratio]\n        });\n\n        return methods;\n    },\n\n    /**\n     * Generate a save-able structure with all elements. This is used by {@link JXG.Dump#toJessie} and\n     * {@link JXG.Dump#toJavaScript} to generate the script.\n     * @param {JXG.Board} board\n     * @returns {Array} An array with all metadata necessary to save the construction.\n     */\n    dump: function (board) {\n        var e,\n            obj,\n            element,\n            s,\n            props = [],\n            methods = [],\n            elementList = [],\n            len = board.objectsList.length;\n\n        this.addMarkers(board, \"dumped\", false);\n\n        for (e = 0; e < len; e++) {\n            obj = board.objectsList[e];\n            element = {};\n\n            if (!obj.dumped && obj.dump) {\n                element.type = obj.getType();\n                element.parents = obj.getParents().slice();\n\n                // Extract coordinates of a point\n                if (element.type === \"point\" && element.parents[0] === 1) {\n                    element.parents = element.parents.slice(1);\n                }\n\n                for (s = 0; s < element.parents.length; s++) {\n                    if (\n                        Type.isString(element.parents[s]) &&\n                        element.parents[s][0] !== \"'\" &&\n                        element.parents[s][0] !== '\"'\n                    ) {\n                        element.parents[s] = '\"' + element.parents[s] + '\"';\n                    } else if (Type.isArray(element.parents[s])) {\n                        element.parents[s] = \"[\" + element.parents[s].toString() + \"]\";\n                    }\n                }\n\n                element.attributes = this.prepareAttributes(board, obj);\n                if (element.type === \"glider\" && obj.onPolygon) {\n                    props.push({\n                        obj: obj.id,\n                        prop: \"onPolygon\",\n                        val: true\n                    });\n                }\n\n                elementList.push(element);\n            }\n        }\n\n        this.deleteMarkers(board, \"dumped\");\n\n        return {\n            elements: elementList,\n            props: props,\n            methods: methods\n        };\n    },\n\n    /**\n     * Converts an array of different values into a parameter string that can be used by the code generators.\n     * @param {Array} a\n     * @param {function} converter A function that is used to transform the elements of <tt>a</tt>. Usually\n     * {@link JXG.toJSON} or {@link JXG.Dump.toJCAN} are used.\n     * @returns {String}\n     */\n    arrayToParamStr: function (a, converter) {\n        var i,\n            s = [];\n\n        for (i = 0; i < a.length; i++) {\n            s.push(converter.call(this, a[i]));\n        }\n\n        return s.join(\", \");\n    },\n\n    /**\n     * Converts a JavaScript object into a JCAN (JessieCode Attribute Notation) string.\n     * @param {Object} obj A JavaScript object, functions will be ignored.\n     * @returns {String} The given object stored in a JCAN string.\n     */\n    toJCAN: function (obj) {\n        var i, list, prop;\n\n        switch (typeof obj) {\n            case \"object\":\n                if (obj) {\n                    list = [];\n\n                    if (Type.isArray(obj)) {\n                        for (i = 0; i < obj.length; i++) {\n                            list.push(this.toJCAN(obj[i]));\n                        }\n\n                        return \"[\" + list.join(\",\") + \"]\";\n                    }\n\n                    for (prop in obj) {\n                        if (obj.hasOwnProperty(prop)) {\n                            list.push(prop + \": \" + this.toJCAN(obj[prop]));\n                        }\n                    }\n\n                    return \"<<\" + list.join(\", \") + \">> \";\n                }\n                return \"null\";\n            case \"string\":\n                return \"'\" + obj.replace(/\\\\/g, \"\\\\\\\\\").replace(/([\"'])/g, \"\\\\$1\") + \"'\";\n            case \"number\":\n            case \"boolean\":\n                return obj.toString();\n            case \"null\":\n                return \"null\";\n        }\n    },\n\n    /**\n     * Saves the construction in <tt>board</tt> to JessieCode.\n     * @param {JXG.Board} board\n     * @returns {String} JessieCode\n     */\n    toJessie: function (board) {\n        var i,\n            elements,\n            id,\n            dump = this.dump(board),\n            script = [];\n\n        dump.methods = this.setBoundingBox(dump.methods, board, \"$board\");\n\n        elements = dump.elements;\n\n        for (i = 0; i < elements.length; i++) {\n            if (elements[i].attributes.name.length > 0) {\n                script.push(\"// \" + elements[i].attributes.name);\n            }\n            script.push(\n                \"s\" +\n                    i +\n                    \" = \" +\n                    elements[i].type +\n                    \"(\" +\n                    elements[i].parents.join(\", \") +\n                    \") \" +\n                    this.toJCAN(elements[i].attributes).replace(/\\n/, \"\\\\n\") +\n                    \";\"\n            );\n\n            if (elements[i].type === \"axis\") {\n                // Handle the case that remove[All]Ticks had been called.\n                id = elements[i].attributes.id;\n                if (board.objects[id].defaultTicks === null) {\n                    script.push(\"s\" + i + \".removeAllTicks();\");\n                }\n            }\n            script.push(\"\");\n        }\n\n        for (i = 0; i < dump.methods.length; i++) {\n            script.push(\n                dump.methods[i].obj +\n                    \".\" +\n                    dump.methods[i].method +\n                    \"(\" +\n                    this.arrayToParamStr(dump.methods[i].params, this.toJCAN) +\n                    \");\"\n            );\n            script.push(\"\");\n        }\n\n        for (i = 0; i < dump.props.length; i++) {\n            script.push(\n                dump.props[i].obj +\n                    \".\" +\n                    dump.props[i].prop +\n                    \" = \" +\n                    this.toJCAN(dump.props[i].val) +\n                    \";\"\n            );\n            script.push(\"\");\n        }\n\n        return script.join(\"\\n\");\n    },\n\n    /**\n     * Saves the construction in <tt>board</tt> to JavaScript.\n     * @param {JXG.Board} board\n     * @returns {String} JavaScript\n     */\n    toJavaScript: function (board) {\n        var i,\n            elements,\n            id,\n            dump = this.dump(board),\n            script = [];\n\n        dump.methods = this.setBoundingBox(dump.methods, board, \"board\");\n\n        elements = dump.elements;\n\n        for (i = 0; i < elements.length; i++) {\n            script.push(\n                'board.create(\"' +\n                    elements[i].type +\n                    '\", [' +\n                    elements[i].parents.join(\", \") +\n                    \"], \" +\n                    Type.toJSON(elements[i].attributes) +\n                    \");\"\n            );\n\n            if (elements[i].type === \"axis\") {\n                // Handle the case that remove[All]Ticks had been called.\n                id = elements[i].attributes.id;\n                if (board.objects[id].defaultTicks === null) {\n                    script.push(\n                        'board.objects[\"' +\n                            id +\n                            '\"].removeTicks(board.objects[\"' +\n                            id +\n                            '\"].defaultTicks);'\n                    );\n                }\n            }\n        }\n\n        for (i = 0; i < dump.methods.length; i++) {\n            script.push(\n                dump.methods[i].obj +\n                    \".\" +\n                    dump.methods[i].method +\n                    \"(\" +\n                    this.arrayToParamStr(dump.methods[i].params, Type.toJSON) +\n                    \");\"\n            );\n            script.push(\"\");\n        }\n\n        for (i = 0; i < dump.props.length; i++) {\n            script.push(\n                dump.props[i].obj +\n                    \".\" +\n                    dump.props[i].prop +\n                    \" = \" +\n                    Type.toJSON(dump.props[i].val) +\n                    \";\"\n            );\n            script.push(\"\");\n        }\n\n        return script.join(\"\\n\");\n    }\n};\n\nexport default JXG.Dump;\n","/*\n    Copyright 2018-2022\n        Alfred Wassermann,\n        Tigran Saluev\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the Comb element is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\nimport Point from \"../base/point\";\n\n/**\n * @class A comb to display domains of inequalities.\n * @pseudo\n * @name Comb\n * @augments JXG.Curve\n * @constructor\n * @type JXG.Curve\n * @throws {Error} If the element cannot be constructed with the given parent\n *  objects an exception is thrown.\n * Parameter options:\n * @param {JXG.Point,array,function_JXG.Point,array,function} point1,point2 Parent elements\n * can be two elements either of type {@link JXG.Point} or array of\n * numbers describing the coordinates of a point. In the latter case the point\n * will be constructed automatically as a fixed invisible point.\n * It is possible to provide a function returning an array or a point,\n * instead of providing an array or a point.\n * @example\n * // Create a simple horizontal comb with invisible endpoints\n * var c = board.create('comb', [[1, 0], [3, 0]]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXG951ccb6a-52bc-4dc2-80e9-43db064f0f1b\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG951ccb6a-52bc-4dc2-80e9-43db064f0f1b', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false}),\n *     c = board.create('comb', [[1, 0], [3, 0]]);\n * })();\n * </script><pre>\n *\n * @example\n * var p1 = board.create('glider', [-3, 0, board.defaultAxes.x]);\n * var p2 = board.create('glider', [-1, 0, board.defaultAxes.x]);\n * var c1 = board.create('comb', [p1, p2], {width: 0.2, frequency: 0.1, angle: Math.PI / 4});\n *\n * </pre><div id=\"JXG04186fd2-6340-11e8-9fb9-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG04186fd2-6340-11e8-9fb9-901b0e1b8723',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p1 = board.create('glider', [-3, 0, board.defaultAxes.x]);\n *     var p2 = board.create('glider', [-1, 0, board.defaultAxes.x]);\n *     var c1 = board.create('comb', [p1, p2], {width: 0.2, frequency: 0.1, angle: Math.PI / 4});\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * var s = board.create('slider', [[1,3], [4,3], [0.1, 0.3, 0.8]]);\n * var p1 = board.create('glider', [-3, 0, board.defaultAxes.x]);\n * var p2 = board.create('glider', [-1, 0, board.defaultAxes.x]);\n * var c1 = board.create('comb', [p1, p2], {\n *     width: function(){ return 4*s.Value(); },\n *     reverse: function(){ return (s.Value()<0.5) ? false : true; },\n *     frequency: function(){ return s.Value(); },\n *     angle: function(){ return s.Value() * Math.PI / 2; },\n *     curve: {\n *         strokeColor: 'red'\n *     }\n * });\n *\n * </pre><div id=\"JXG6eb1bcd1-407e-4f13-8f0c-45ef39a0cfb3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG6eb1bcd1-407e-4f13-8f0c-45ef39a0cfb3',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var s = board.create('slider', [[1,3], [4,3], [0.1, 0.3, 0.8]]);\n *     var p1 = board.create('glider', [-3, 0, board.defaultAxes.x]);\n *     var p2 = board.create('glider', [-1, 0, board.defaultAxes.x]);\n *     var c1 = board.create('comb', [p1, p2], {\n *         width: function(){ return 4*s.Value(); },\n *         reverse: function(){ return (s.Value()<0.5) ? false : true; },\n *         frequency: function(){ return s.Value(); },\n *         angle: function(){ return s.Value() * Math.PI / 2; },\n *         curve: {\n *             strokeColor: 'red'\n *         }\n *     });\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createComb = function (board, parents, attributes) {\n    var p1, p2, c, attr, parent_types;\n    //ds, angle, width, p;\n\n    if (parents.length === 2) {\n        // point 1 given by coordinates\n        if (Type.isArray(parents[0]) && parents[0].length > 1) {\n            attr = Type.copyAttributes(attributes, board.options, \"comb\", \"point1\");\n            p1 = board.create(\"point\", parents[0], attr);\n        } else if (Type.isString(parents[0]) || Type.isPoint(parents[0])) {\n            p1 = board.select(parents[0]);\n        } else if (Type.isFunction(parents[0]) && Type.isPoint(parents[0]())) {\n            p1 = parents[0]();\n        } else if (\n            Type.isFunction(parents[0]) &&\n            parents[0]().length &&\n            parents[0]().length >= 2\n        ) {\n            attr = Type.copyAttributes(attributes, board.options, \"comb\", \"point1\");\n            p1 = Point.createPoint(board, parents[0](), attr);\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create comb with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]\"\n            );\n        }\n\n        // point 2 given by coordinates\n        if (Type.isArray(parents[1]) && parents[1].length > 1) {\n            attr = Type.copyAttributes(attributes, board.options, \"comb\", \"point2\");\n            p2 = board.create(\"point\", parents[1], attr);\n        } else if (Type.isString(parents[1]) || Type.isPoint(parents[1])) {\n            p2 = board.select(parents[1]);\n        } else if (Type.isFunction(parents[1]) && Type.isPoint(parents[1]())) {\n            p2 = parents[1]();\n        } else if (\n            Type.isFunction(parents[1]) &&\n            parents[1]().length &&\n            parents[1]().length >= 2\n        ) {\n            attr = Type.copyAttributes(attributes, board.options, \"comb\", \"point2\");\n            p2 = Point.createPoint(board, parents[1](), attr);\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create comb with parent types '\" +\n                    typeof parents[0] +\n                    \"' and '\" +\n                    typeof parents[1] +\n                    \"'.\" +\n                    \"\\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]\"\n            );\n        }\n    } else {\n        parent_types = parents.map(function (parent) {\n            return \"'\" + typeof parent + \"'\";\n        });\n        throw new Error(\n            \"JSXGraph: Can't create comb with parent types \" +\n                parent_types.join(\", \") +\n                \".\" +\n                \"\\nPossible parent types: [point,point], [[x1,y1],[x2,y2]]\"\n        );\n    }\n\n    // attr = Type.copyAttributes(attributes, board.options, 'comb', 'curve');\n    attr = Type.copyAttributes(attributes, board.options, \"comb\");\n    Type.merge(attr, Type.copyAttributes(attributes, board.options, \"comb\", \"curve\"));\n    c = board.create(\"curve\", [[0], [0]], attr);\n\n    /**\n     * @ignore\n     */\n    c.updateDataArray = function () {\n        var s = 0,\n            max_s = p1.Dist(p2),\n            cs,\n            sn,\n            dx,\n            dy,\n            x,\n            y,\n            f,\n            p1_inner = p1,\n            p2_inner = p2,\n            ds,\n            angle,\n            width;\n\n        ds = Type.evaluate(c.visProp.frequency);\n        angle = -Type.evaluate(c.visProp.angle);\n        width = Type.evaluate(c.visProp.width);\n        if (Type.evaluate(c.visProp.reverse)) {\n            p1_inner = p2;\n            p2_inner = p1;\n            angle = -angle;\n        }\n        cs = Math.cos(angle);\n        sn = Math.sin(angle);\n        dx = (p2_inner.X() - p1_inner.X()) / max_s;\n        dy = (p2_inner.Y() - p1_inner.Y()) / max_s;\n\n        // But instead of lifting by sin(angle), we want lifting by width.\n        cs *= width / Math.abs(sn);\n        sn *= width / Math.abs(sn);\n\n        this.dataX = [];\n        this.dataY = [];\n        // TODO Handle infinite boundaries?\n        while (s < max_s) {\n            x = p1_inner.X() + dx * s;\n            y = p1_inner.Y() + dy * s;\n\n            // We may need to cut the last piece of a comb.\n            f = Math.min(cs, max_s - s) / Math.abs(cs);\n            sn *= f;\n            cs *= f;\n\n            this.dataX.push(x);\n            this.dataY.push(y);\n\n            this.dataX.push(x + dx * cs + dy * sn);\n            this.dataY.push(y - dx * sn + dy * cs);\n\n            this.dataX.push(NaN); // Force a jump\n            this.dataY.push(NaN);\n            s += ds;\n        }\n    };\n\n    return c;\n};\n\nJXG.registerElement(\"comb\", JXG.createComb);\n\nexport default {\n    createComb: JXG.createComb\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview Example file for a triangle implemented as a extension to JSXGraph.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\nimport Const from \"../base/constants\";\nimport Polygon from \"../base/polygon\";\n\nvar priv = {\n    removeSlopeTriangle: function () {\n        Polygon.Polygon.prototype.remove.call(this);\n\n        this.board.removeObject(this.toppoint);\n        this.board.removeObject(this.glider);\n\n        this.board.removeObject(this.baseline);\n        this.board.removeObject(this.basepoint);\n\n        this.board.removeObject(this.label);\n\n        if (this._isPrivateTangent) {\n            this.board.removeObject(this.tangent);\n        }\n    },\n    Value: function () {\n        return this.tangent.getSlope();\n    }\n};\n\n/**\n * @class Slope triangle for a point on a line.\n * @pseudo\n * @name Slopetriangle\n * @augments JXG.Line\n * @constructor\n * @type JXG.Polygon\n * @throws {Error} If the element cannot be constructed with the given parent objects an exception is thrown.\n * Parameter options:\n * @param {JXG.Line} t A tangent based on a glider on some object, e.g. curve, circle, line or turtle.\n * @param {JXG.Line_JXG.Point} li, p A line and a point on that line.\n *  The user has to take care that the point is a member of the line.\n * @example\n * // Create a slopetriangle on a tangent\n * var f = board.create('plot', ['sin(x)']),\n *     g = board.create('glider', [1, 2, f]),\n *     t = board.create('tangent', [g]),\n *\n *     st = board.create('slopetriangle', [t]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXG951ccb6a-52bc-4dc2-80e9-43db064f0f1b\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXG951ccb6a-52bc-4dc2-80e9-43db064f0f1b', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false}),\n *     f = board.create('plot', ['sin(x)']),\n *     g = board.create('glider', [1, 2, f]),\n *     t = board.create('tangent', [g]),\n *\n *     st = board.create('slopetriangle', [t]);\n * })();\n * </script><pre>\n *\n * @example\n * // Create a on a line and a point on that line\n * var p1 = board.create('point', [-2, 3]),\n *     p2 = board.create('point', [2, -3]),\n *     li = board.create('line', [p1, p2]),\n *     p = board.create('glider', [0, 0, li]),\n *\n *     st = board.create('slopetriangle', [li, p]);\n *\n * </pre><div class=\"jxgbox\" id=\"JXGb52f451c-22cf-4677-852a-0bb9d764ee95\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function () {\n *   var board = JXG.JSXGraph.initBoard('JXGb52f451c-22cf-4677-852a-0bb9d764ee95', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false}),\n *     p1 = board.create('point', [-2, 3]),\n *     p2 = board.create('point', [2, -3]),\n *     li = board.create('line', [p1, p2]),\n *     p = board.create('glider', [0, 0, li]),\n *\n *     st = board.create('slopetriangle', [li, p]);\n * })();\n * </script><pre>\n */\nJXG.createSlopeTriangle = function (board, parents, attributes) {\n    var el,\n        tangent,\n        tglide,\n        glider,\n        toppoint,\n        baseline,\n        basepoint,\n        label,\n        attr,\n        isPrivateTangent = false;\n\n    if (parents.length === 1 && parents[0].type === Const.OBJECT_TYPE_TANGENT) {\n        tangent = parents[0];\n        tglide = tangent.glider;\n    } else if (parents.length === 1 && parents[0].type === Const.OBJECT_TYPE_GLIDER) {\n        tglide = parents[0];\n        attr = Type.copyAttributes(attributes, board.options, \"slopetriangle\", \"tangent\");\n        tangent = board.create(\"tangent\", [tglide], attr);\n        isPrivateTangent = true;\n    } else if (\n        parents.length === 2 &&\n        parents[0].elementClass === Const.OBJECT_CLASS_LINE &&\n        Type.isPoint(parents[1])\n    ) {\n        tangent = parents[0];\n        tglide = parents[1];\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create slope triangle with parent types '\" +\n                typeof parents[0] +\n                \"'.\"\n        );\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"slopetriangle\", \"basepoint\");\n    basepoint = board.create(\n        \"point\",\n        [\n            function () {\n                return [tglide.X() + 1, tglide.Y()];\n            }\n        ],\n        attr\n    );\n\n    attr = Type.copyAttributes(attributes, board.options, \"slopetriangle\", \"baseline\");\n    baseline = board.create(\"line\", [tglide, basepoint], attr);\n\n    attr = Type.copyAttributes(attributes, board.options, \"slopetriangle\", \"glider\");\n    glider = board.create(\"glider\", [tglide.X() + 1, tglide.Y(), baseline], attr);\n\n    attr = Type.copyAttributes(attributes, board.options, \"slopetriangle\", \"toppoint\");\n    toppoint = board.create(\n        \"point\",\n        [\n            function () {\n                return [\n                    glider.X(),\n                    glider.Y() + (glider.X() - tglide.X()) * tangent.getSlope()\n                ];\n            }\n        ],\n        attr\n    );\n\n    attr = Type.copyAttributes(attributes, board.options, \"slopetriangle\");\n    attr.borders = Type.copyAttributes(attr.borders, board.options, \"slopetriangle\", \"borders\");\n    el = board.create(\"polygon\", [tglide, glider, toppoint], attr);\n\n    /**\n     * Returns the value of the slope triangle, that is the slope of the tangent.\n     * @name Value\n     * @memberOf Slopetriangle.prototype\n     * @function\n     * @returns {Number} slope of the tangent.\n     */\n    el.Value = priv.Value;\n    el.tangent = tangent;\n    el._isPrivateTangent = isPrivateTangent;\n\n    //el.borders[0].setArrow(false, {type: 2, size: 10});\n    //el.borders[1].setArrow(false, {type: 2, size: 10});\n    el.borders[2].setArrow(false, false);\n\n    attr = Type.copyAttributes(attributes, board.options, \"slopetriangle\", \"label\");\n    label = board.create(\n        \"text\",\n        [\n            function () {\n                return glider.X() + 0.1;\n            },\n            function () {\n                return (glider.Y() + toppoint.Y()) * 0.5;\n            },\n            function () {\n                return \"\";\n            }\n        ],\n        attr\n    );\n\n    label._setText(function () {\n        return Type.toFixed(el.Value(), Type.evaluate(label.visProp.digits));\n    });\n    label.fullUpdate();\n\n    el.glider = glider;\n    el.basepoint = basepoint;\n    el.baseline = baseline;\n    el.toppoint = toppoint;\n    el.label = label;\n\n    el.subs = {\n        glider: glider,\n        basePoint: basepoint,\n        baseLine: baseline,\n        topPoint: toppoint,\n        label: label\n    };\n    el.inherits.push(glider, basepoint, baseline, toppoint, label);\n\n    el.methodMap = JXG.deepCopy(el.methodMap, {\n        tangent: \"tangent\",\n        glider: \"glider\",\n        basepoint: \"basepoint\",\n        baseline: \"baseline\",\n        toppoint: \"toppoint\",\n        label: \"label\",\n        Value: \"Value\",\n        V: \"Value\"\n    });\n\n    el.remove = priv.removeSlopeTriangle;\n\n    return el;\n};\n\nJXG.registerElement(\"slopetriangle\", JXG.createSlopeTriangle);\n\nexport default {\n    createSlopeTriangle: JXG.createSlopeTriangle\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the Text element is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Env from \"../utils/env\";\nimport Type from \"../utils/type\";\n\nvar priv = {\n    CheckboxChangeEventHandler: function () {\n        this._value = this.rendNodeCheckbox.checked;\n        this.board.update();\n    }\n};\n\n/**\n * @class This element is used to provide a constructor for special texts containing a\n * form checkbox element.\n * <p>\n * For this element, the attribute \"display\" has to have the value 'html' (which is the default).\n * <p>\n * The underlying HTML checkbox element can be accessed through the sub-object 'rendNodeCheck', e.g. to\n * add event listeners.\n * \n * @pseudo\n * @description\n * @name Checkbox\n * @augments Text\n * @constructor\n * @type JXG.Text\n *\n * @param {number,function_number,function_String,function} x,y,label Parent elements for checkbox elements.\n *   <p>\n *   x and y are the coordinates of the lower left corner of the text box.\n *    The position of the text is fixed,\n *   x and y are numbers. The position is variable if x or y are functions.\n *   <p>\n *   The label of the input element may be given as string or function.\n *   <p>\n *   The value of the checkbox can be controlled with the attribute <tt>checked</tt>\n *   <p>The HTML node can be accessed with <tt>element.rendNodeCheckbox</tt>\n *\n * @example\n *   // Create a checkbox element at position [0,3].\n *   var checkbox = board.create('checkbox', [0, 3, 'Change Y'], {});\n *   var p = board.create('point', [\n *       function(){ return 0.5;}, // X-coordinate\n *       function() {\n *           y = 0.5;\n *           if (checkbox.Value()) {\n *               y += 0.5;\n *           }\n *           return y;\n *       }]);\n * </pre><div class=\"jxgbox\" id=\"JXG0e835e0b-ed0c-4b85-b682-78158c0e6f5c\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function() {\n *   var t1_board = JXG.JSXGraph.initBoard('JXG0e835e0b-ed0c-4b85-b682-78158c0e6f5c', {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *   var checkbox = t1_board.create('checkbox', [0, 3, 'Change Y'], {});\n *   var p = t1_board.create('point', [\n *       function(){ return 0.5;}, // X-coordinate\n *       function() {\n *           y = 0.5;\n *           if (checkbox.Value()) {\n *               y += 0.5;\n *           }\n *           return y;\n *       }]);\n * })();\n * </script><pre>\n *\n * The checkbox can be supplied with custom-made events by using the property rendNodeCheckbox.\n * @example\n * var checkbox = board.create('checkbox', [0, 4, 'Click me']),\n *     p = board.create('point', [1, 1]);\n *\n * JXG.addEvent(checkbox.rendNodeCheckbox, 'change', function() {\n *     if (this.Value()) {\n *         p.moveTo([4, 1]);\n *     } else {\n *         p.moveTo([1, 1]);\n *     }\n * }, checkbox);\n * </pre><div class=\"jxgbox\" id=\"JXGb2f2345a-057d-44ce-bd7a-6aaff70bc810\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n * (function() {\n * var board = JXG.JSXGraph.initBoard('JXGb2f2345a-057d-44ce-bd7a-6aaff70bc810', {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n * var checkbox = board.create('checkbox', [0, 4, 'Click me']),\n *     p = board.create('point', [1, 1]);\n *\n * JXG.addEvent(checkbox.rendNodeCheckbox, 'change', function() {\n *     if (this.Value()) {\n *         p.moveTo([4, 1]);\n *     } else {\n *         p.moveTo([1, 1]);\n *     }\n * }, checkbox);\n * })();\n * </script><pre>\n *\n * @example\n *         var i1 = board.create('input', [-3, 4, 'sin(x)', 'f(x)='], {cssStyle: 'width:4em', maxlength: 2});\n *         var c1 = board.create('checkbox', [-3, 2, 'label 1'], {});\n *         var b1 = board.create('button', [-3, -1, 'Change texts', function () {\n *                 i1.setText('g(x)');\n *                 i1.set('cos(x)');\n *                 c1.setText('label 2');\n *                 b1.setText('Texts are changed');\n *             }],\n *             {cssStyle: 'width:400px'});\n *\n * </pre><div id=\"JXG11cac8gg-2354-47e7-9da4-eb298e53de05\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG11cac8gg-2354-47e7-9da4-eb298e53de05',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             var i1 = board.create('input', [-3, 4, 'sin(x)', 'f(x)='], {cssStyle: 'width:4em', maxlength: 2});\n *             var c1 = board.create('checkbox', [-3, 2, 'label 1'], {});\n *             var b1 = board.create('button', [-3, -1, 'Change texts', function () {\n *                     i1.setText('g(x)');\n *                     i1.set('cos(x)');\n *                     c1.setText('label 2');\n *                     b1.setText('Texts are changed');\n *                 }],\n *                 {cssStyle: 'width:400px'});\n *\n *     })();\n *\n * </script><pre>\n */\nJXG.createCheckbox = function (board, parents, attributes) {\n    var t,\n        par,\n        attr = Type.copyAttributes(attributes, board.options, \"checkbox\");\n\n    //if (parents.length !== 3) {\n    //throw new Error(\"JSXGraph: Can't create checkbox with parent types '\" +\n    //    (typeof parents[0]) + \"' and '\" + (typeof parents[1]) + \"'.\" +\n    //    \"\\nPossible parents are: [[x,y], label]\");\n    //}\n\n    par = [\n        parents[0],\n        parents[1],\n        '<span style=\"display:inline\">' +\n            '<input type=\"checkbox\" /><label for=\"\"></label>' +\n            \"</span>\"\n    ];\n\n    // 1. Create checkbox element with empty label\n    t = board.create(\"text\", par, attr);\n    t.type = Type.OBJECT_TYPE_CHECKBOX;\n\n    t.rendNodeCheckbox = t.rendNode.childNodes[0].childNodes[0];\n    t.rendNodeLabel = t.rendNode.childNodes[0].childNodes[1];\n\n    t.rendNodeTag = t.rendNodeCheckbox; // Needed for unified treatment in setAttribute\n    t.rendNodeTag.disabled = !!attr.disabled;\n\n    // t.rendNodeLabel.innerHTML = parents[2];\n    t.rendNodeCheckbox.id = t.rendNode.id + \"_checkbox\";\n    t.rendNodeLabel.id = t.rendNode.id + \"_label\";\n    t.rendNodeLabel.setAttribute(\"for\", t.rendNodeCheckbox.id);\n\n    // 2. Set parents[2] (string|function) as label of the checkbox element.\n    // abstract.js selects the correct DOM element for the update\n    t.setText(parents[2]);\n\n    // This sets the font-size of the checkbox itself\n    t.visPropOld.fontsize = \"0px\";\n    board.renderer.updateTextStyle(t, false);\n\n    t.rendNodeCheckbox.checked = attr.checked;\n\n    t._value = attr.checked;\n\n    /**\n     * Returns the value of the checkbox element\n     * @name Value\n     * @memberOf Checkbox.prototype\n     * @function\n     * @returns {String} value of the checkbox.\n     */\n    t.Value = function () {\n        return this._value;\n    };\n\n    t.update = function () {\n        if (this.needsUpdate) {\n            JXG.Text.prototype.update.call(this);\n            this._value = this.rendNodeCheckbox.checked;\n        }\n        return this;\n    };\n\n    Env.addEvent(t.rendNodeCheckbox, \"change\", priv.CheckboxChangeEventHandler, t);\n\n    return t;\n};\n\nJXG.registerElement(\"checkbox\", JXG.createCheckbox);\n\nexport default {\n    createCheckbox: JXG.createCheckbox\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the Text element is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Env from \"../utils/env\";\nimport Type from \"../utils/type\";\n\nvar priv = {\n    InputInputEventHandler: function (evt) {\n        this._value = this.rendNodeInput.value;\n        this.board.update();\n    }\n};\n\n/**\n * @class This element is used to provide a constructor for special texts containing a\n * HTML form input element.\n * <p>\n * If the width of element is set with the attribute \"cssStyle\", the width of the\n * label must be added.\n * <p>\n * For this element, the attribute \"display\" has to have the value 'html' (which is the default).\n * <p>\n * The underlying HTML input field can be accessed through the sub-object 'rendNodeInput', e.g. to\n * add event listeners.\n * \n * @pseudo\n * @description\n * @name Input\n * @augments Text\n * @constructor\n * @type JXG.Text\n *\n * @param {number,function_number,function_String_String,function} x,y,value,label Parent elements for input elements.\n *   <p>\n *   x and y are the coordinates of the lower left corner of the text box. The position of the text is fixed,\n *   x and y are numbers. The position is variable if x or y are functions.\n *   <p>\n *   The default value of the input element must be given as string.\n *   <p>\n *   The label of the input element may be given as string or function.\n *\n * @example\n *  // Create an input element at position [1,4].\n *  var input = board.create('input', [0, 1, 'sin(x)*x', 'f(x)='], {cssStyle: 'width: 100px'});\n *  var f = board.jc.snippet(input.Value(), true, 'x', false);\n *  var graph = board.create('functiongraph',[f,\n *          function() {\n *            var c = new JXG.Coords(JXG.COORDS_BY_SCREEN,[0,0],board);\n *            return c.usrCoords[1];\n *          },\n *          function() {\n *            var c = new JXG.Coords(JXG.COORDS_BY_SCREEN,[board.canvasWidth,0],board);\n *            return c.usrCoords[1];\n *          }\n *        ]);\n *\n *  board.create('text', [1, 3, '&lt;button onclick=\"updateGraph()\"&gt;Update graph&lt;/button&gt;']);\n *\n *  var updateGraph = function() {\n *      graph.Y = board.jc.snippet(input.Value(), true, 'x', false);\n *      graph.updateCurve();\n *      board.update();\n *  }\n * </pre><div class=\"jxgbox\" id=\"JXGc70f55f1-21ba-4719-a37d-a93ae2943faa\" style=\"width: 500px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *   var t1_board = JXG.JSXGraph.initBoard('JXGc70f55f1-21ba-4719-a37d-a93ae2943faa', {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *   var input = t1_board.create('input', [1, 4, 'sin(x)*x', 'f(x)='], {cssStyle: 'width: 100px'});\n *   var f = t1_board.jc.snippet(input.Value(), true, 'x', false);\n *   var graph = t1_board.create('functiongraph',[f,\n *          function() {\n *            var c = new JXG.Coords(JXG.COORDS_BY_SCREEN,[0,0],t1_board);\n *            return c.usrCoords[1];\n *          },\n *          function() {\n *            var c = new JXG.Coords(JXG.COORDS_BY_SCREEN,[t1_board.canvasWidth,0],t1_board);\n *            return c.usrCoords[1];\n *          }\n *        ]);\n *\n *  t1_board.create('text', [1, 3, '<button onclick=\"updateGraph()\">Update graph</button>']);\n *\n *  var updateGraph = function() {\n *      graph.Y = t1_board.jc.snippet(input.Value(), true, 'x', false);\n *      graph.updateCurve();\n *      t1_board.update();\n *  }\n * </script><pre>\n * \n * @example\n * // Add the `keyup` event to an input field\n * var A = board.create('point', [3, -2]);\n * var i = board.create('input', [-4, -4, \"1\", \"x \"]);\n * \n * i.rendNodeInput.addEventListener(\"keyup\", ( function () {\n *    var x = parseFloat(this.value);\n *    if (!isNaN(x)) {\n * \t   A.moveTo([x, 3], 100);\n *    }\n * }));\n * \n * </pre><div id=\"JXG81c84fa7-3f36-4874-9e0f-d4b9e93e755b\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG81c84fa7-3f36-4874-9e0f-d4b9e93e755b',\n *             {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false});\n *     var A = board.create('point', [3, -2]);\n *     var i = board.create('input', [-4, -4, \"1\", \"x \"]);\n *     \n *     i.rendNodeInput.addEventListener(\"keyup\", ( function () {\n *        var x = parseFloat(this.value);\n *        if (!isNaN(x)) {\n *     \t    A.moveTo([x, 3], 100);\n *        }\n *     }));\n * \n *     })();\n * \n * </script><pre>\n * \n * @example\n * // Add the `change` event to an input field\n * var A = board.create('point', [3, -2]);\n * var i = board.create('input', [-4, -4, \"1\", \"x \"]);\n * \n * i.rendNodeInput.addEventListener(\"change\", ( function () {\n *    var x = parseFloat(i.Value());\n *    A.moveTo([x, 2], 100);\n * }));\n * \n * </pre><div id=\"JXG51c4d78b-a7ad-4c34-a983-b3ddae6192d7\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG51c4d78b-a7ad-4c34-a983-b3ddae6192d7',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var A = board.create('point', [3, -2]);\n *     var i = board.create('input', [-4, -4, \"1\", \"x \"]);\n *     \n *     i.rendNodeInput.addEventListener(\"change\", ( function () {\n *        var x = parseFloat(i.Value());\n *        A.moveTo([x, 2], 100);\n *     }));\n * \n *     })();\n * \n * </script><pre>\n * \n */\nJXG.createInput = function (board, parents, attributes) {\n    var t,\n        par,\n        attr = Type.copyAttributes(attributes, board.options, \"input\");\n\n    par = [\n        parents[0],\n        parents[1],\n        '<span style=\"display:inline; white-space:nowrap; padding:0px;\">' +\n            '<span></span><input type=\"text\" maxlength=\"' +\n            attr.maxlength +\n            '\" style=\"width:100%\"/>' +\n            \"</span>\"\n    ];\n\n    // 1. Create input element with empty label\n    t = board.create(\"text\", par, attr);\n    t.type = Type.OBJECT_TYPE_INPUT;\n\n    t.rendNodeLabel = t.rendNode.childNodes[0].childNodes[0];\n    t.rendNodeInput = t.rendNode.childNodes[0].childNodes[1];\n    // t.rendNodeLabel.innerHTML = parents[3];\n    t.rendNodeInput.value = parents[2];\n    t.rendNodeTag = t.rendNodeInput; // Needed for unified treatment in setAttribute\n    t.rendNodeTag.disabled = !!attr.disabled;\n    t.rendNodeLabel.id = t.rendNode.id + \"_label\";\n    t.rendNodeInput.id = t.rendNode.id + \"_input\";\n\n    // 2. Set parents[3] (string|function) as label of the input element.\n    // abstract.js selects the correct DOM element for the update\n    t.setText(parents[3]);\n\n    t._value = parents[2];\n    t.update = function () {\n        if (this.needsUpdate) {\n            JXG.Text.prototype.update.call(this);\n            this._value = this.rendNodeInput.value;\n        }\n        return this;\n    };\n\n    /**\n     * Returns the value (content) of the input element\n     * @name Value\n     * @memberOf Input.prototype\n     * @function\n     * @returns {String} content of the input field.\n     */\n    t.Value = function () {\n        return this._value;\n    };\n\n    /**\n     * Sets value of the input element.\n     * @name set\n     * @memberOf Input.prototype\n     * @function\n     *\n     * @param {String} val\n     * @returns {JXG.GeometryElement} Reference to the element.\n     *\n     * @example\n     *         var i1 = board.create('input', [-3, 4, 'sin(x)', 'f(x)='], {cssStyle: 'width:4em', maxlength: 2});\n     *         var c1 = board.create('checkbox', [-3, 2, 'label 1'], {});\n     *         var b1 = board.create('button', [-3, -1, 'Change texts', function () {\n     *                 i1.setText('g(x)');\n     *                 i1.set('cos(x)');\n     *                 c1.setText('label 2');\n     *                 b1.setText('Texts are changed');\n     *             }],\n     *             {cssStyle: 'width:400px'});\n     *\n     * </pre><div id=\"JXG11cac8ff-2354-47e7-9da4-eb298e53de05\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG11cac8ff-2354-47e7-9da4-eb298e53de05',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *             var i1 = board.create('input', [-3, 4, 'sin(x)', 'f(x)='], {cssStyle: 'width:4em', maxlength: 2});\n     *             var c1 = board.create('checkbox', [-3, 2, 'label 1'], {});\n     *             var b1 = board.create('button', [-3, -1, 'Change texts', function () {\n     *                     i1.setText('g(x)');\n     *                     i1.set('cos(x)');\n     *                     c1.setText('label 2');\n     *                     b1.setText('Texts are changed');\n     *                 }],\n     *                 {cssStyle: 'width:400px'});\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    t.set = function (val) {\n        this._value = val;\n        this.rendNodeInput.value = val;\n        return this;\n    };\n\n    Env.addEvent(t.rendNodeInput, \"input\", priv.InputInputEventHandler, t);\n    Env.addEvent(\n        t.rendNodeInput,\n        \"mousedown\",\n        function (evt) {\n            if (Type.exists(evt.stopPropagation)) {\n                evt.stopPropagation();\n            }\n        },\n        t\n    );\n    Env.addEvent(\n        t.rendNodeInput,\n        \"touchstart\",\n        function (evt) {\n            if (Type.exists(evt.stopPropagation)) {\n                evt.stopPropagation();\n            }\n        },\n        t\n    );\n    Env.addEvent(\n        t.rendNodeInput,\n        \"pointerdown\",\n        function (evt) {\n            if (Type.exists(evt.stopPropagation)) {\n                evt.stopPropagation();\n            }\n        },\n        t\n    );\n\n    // This sets the font-size of the input HTML element\n    t.visPropOld.fontsize = \"0px\";\n    board.renderer.updateTextStyle(t, false);\n\n    return t;\n};\n\nJXG.registerElement(\"input\", JXG.createInput);\n\nexport default {\n    createInput: JXG.createInput\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the Text element is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Env from \"../utils/env\";\nimport Type from \"../utils/type\";\n\nvar priv = {\n    ButtonClickEventHandler: function () {\n        if (this._handler) {\n            this._handler();\n        }\n        this.board.update();\n    }\n};\n\n/**\n * @class This element is used to provide a constructor for special texts containing a\n * form button element.\n * <p>\n * For this element, the attribute \"display\" has to have the value 'html' (which is the default).\n * <p>\n * The underlying HTML button element can be accessed through the sub-object 'rendNodeButton', e.g. to\n * add event listeners.\n *\n * @pseudo\n * @description\n * @name Button\n * @augments Text\n * @constructor\n * @type JXG.Text\n *\n * @param {number,function_number,function_String,function_function} x,y,label,handler Parent elements for button elements.\n *  <p>\n *  x and y are the coordinates of the lower left corner of the text box.\n *   The position of the text is fixed,\n *  x and y are numbers. The position is variable if x or y are functions.\n *  <p>\n *  The label of the input element may be given  as string.\n *  <p>\n *  The (optional) handler function which is called when the button is pressed.\n *\n * @example\n *  var p = board.create('point', [0.5, 0.5], {id: 'p1'});\n *\n *  // Create a button element at position [1,2].\n *  var button1 = board.create('button', [1, 2, 'Change Y with JavaScript', function() {\n *      p.moveTo([p.X(), p.Y() + 0.5], 100);\n *  }], {});\n *\n *  // Create a button element at position [1,4].\n *  var button2 = board.create('button', [1, 4, 'Change Y with JessieCode',\n *      \"$('p1').Y = $('p1').Y() - 0.5;\"\n *  ], {});\n *\n * </pre><div class=\"jxgbox\" id=\"JXGf19b1bce-dd00-4e35-be97-ff1817d11514\" style=\"width: 500px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *  var t1_board = JXG.JSXGraph.initBoard('JXGf19b1bce-dd00-4e35-be97-ff1817d11514', {boundingbox: [-3, 6, 5, -3], axis: true, showcopyright: false, shownavigation: false});\n *  var p = t1_board.create('point', [0, -1], {id: 'p1'});\n *\n *  // Create a button element at position [1,2].\n *  var button1 = t1_board.create('button', [1, 2, 'Change Y with JavaScript', function() {\n *      p.moveTo([p.X(), p.Y() + 0.5], 100);\n *  }], {});\n *\n *  // Create a button element at position [1,4].\n *  var button2 = t1_board.create('button', [1, 4, 'Change Y with JessieCode',\n *      \"$('p1').Y = $('p1').Y() - 0.5;\"\n *  ], {});\n *\n * </script><pre>\n *\n * @example\n * // A toggle button\n * var butt = board.create('button', [-2, -2, 'Off', function() {\n *   var txt;\n *   butt.value = !butt.value;\n *   if (butt.value) {\n *   \ttxt = 'On';\n *   } else {\n *   \ttxt = 'Off';\n *   }\n * \tbutt.rendNodeButton.innerHTML = txt;\n * }]);\n *\n * // Set initial value for the button\n * if (!JXG.exists(butt.value)) {\n * \tbutt.value = false;\n * }\n *\n * var p = board.create('point', [2, -2], {\n * \tvisible: () => butt.value\n * });\n *\n *\n *\n * </pre><div id=\"JXGa1eaab8f-c73b-4660-96ce-4ca17bcac4d6\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGa1eaab8f-c73b-4660-96ce-4ca17bcac4d6',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var butt = board.create('button', [-2, -2, 'Off', function() {\n *       var txt;\n *       butt.value = !butt.value;\n *       if (butt.value) {\n *       \ttxt = 'On';\n *       } else {\n *       \ttxt = 'Off';\n *       }\n *     \tbutt.rendNodeButton.innerHTML = txt;\n *     }]);\n *\n *     // Set initial value for the button\n *     if (!JXG.exists(butt.value)) {\n *     \tbutt.value = false;\n *     }\n *\n *     var p = board.create('point', [2, -2], {\n *     \tvisible: () => butt.value\n *     });\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n *         var i1 = board.create('input', [-3, 4, 'sin(x)', 'f(x)='], {cssStyle: 'width:4em', maxlength: 2});\n *         var c1 = board.create('checkbox', [-3, 2, 'label 1'], {});\n *         var b1 = board.create('button', [-3, -1, 'Change texts', function () {\n *                 i1.setText('g(x)');\n *                 i1.set('cos(x)');\n *                 c1.setText('label 2');\n *                 b1.setText('Texts are changed');\n *             }],\n *             {cssStyle: 'width:400px'});\n *\n * </pre><div id=\"JXG11cac8ff-2354-47e7-9da4-eb928e53de05\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG11cac8ff-2354-47e7-9da4-eb928e53de05',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             var i1 = board.create('input', [-3, 4, 'sin(x)', 'f(x)='], {cssStyle: 'width:4em', maxlength: 2});\n *             var c1 = board.create('checkbox', [-3, 2, 'label 1'], {});\n *             var b1 = board.create('button', [-3, -1, 'Change texts', function () {\n *                     i1.setText('g(x)');\n *                     i1.set('cos(x)');\n *                     c1.setText('label 2');\n *                     b1.setText('Texts are changed');\n *                 }],\n *                 {cssStyle: 'width:400px'});\n *\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createButton = function (board, parents, attributes) {\n    var t,\n        par,\n        attr = Type.copyAttributes(attributes, board.options, \"button\");\n\n    //if (parents.length < 3) {\n    //throw new Error(\"JSXGraph: Can't create button with parent types '\" +\n    //    (typeof parents[0]) + \"' and '\" + (typeof parents[1]) + \"'.\" +\n    //    \"\\nPossible parents are: [x, y, label, handler]\");\n    //}\n\n    // 1. Create empty button\n    par = [parents[0], parents[1], '<button type=\"button\" style=\"width:100%;\"></button>'];\n    t = board.create(\"text\", par, attr);\n    t.type = Type.OBJECT_TYPE_BUTTON;\n\n    t.rendNodeButton = t.rendNode.childNodes[0];\n    t.rendNodeButton.id = t.rendNode.id + \"_button\";\n    // t.rendNodeButton.innerHTML = parents[2];\n\n    t.rendNodeTag = t.rendNodeButton; // Needed for unified treatment in setAttribute\n    t.rendNodeTag.disabled = !!attr.disabled;\n\n    // 2. Set parents[2] (string|function) as content of the button.\n    // abstract.js selects the correct DOM element for the update\n    t.setText(parents[2]);\n\n    // This sets the font-size of the button text\n    t.visPropOld.fontsize = \"0px\";\n    board.renderer.updateTextStyle(t, false);\n\n    if (parents[3]) {\n        if (Type.isString(parents[3])) {\n            t._jc = new JXG.JessieCode();\n            t._jc.use(board);\n            t._handler = function () {\n                t._jc.parse(parents[3]);\n            };\n        } else {\n            t._handler = parents[3];\n        }\n    }\n\n    Env.addEvent(t.rendNodeButton, \"click\", priv.ButtonClickEventHandler, t);\n    Env.addEvent(\n        t.rendNodeButton,\n        \"mousedown\",\n        function (evt) {\n            if (Type.exists(evt.stopPropagation)) {\n                evt.stopPropagation();\n            }\n        },\n        t\n    );\n    Env.addEvent(\n        t.rendNodeButton,\n        \"touchstart\",\n        function (evt) {\n            if (Type.exists(evt.stopPropagation)) {\n                evt.stopPropagation();\n            }\n        },\n        t\n    );\n    Env.addEvent(\n        t.rendNodeButton,\n        \"pointerdown\",\n        function (evt) {\n            if (Type.exists(evt.stopPropagation)) {\n                evt.stopPropagation();\n            }\n        },\n        t\n    );\n\n    return t;\n};\n\nJXG.registerElement(\"button\", JXG.createButton);\n\nexport default {\n    createButton: JXG.createButton\n};\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the ForeignObject element is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport Coords from \"./coords\";\nimport GeometryElement from \"./element\";\nimport Mat from \"../math/math\";\nimport Type from \"../utils/type\";\nimport CoordsElement from \"./coordselement\";\n\n/**\n * Construct and handle SVG foreignObjects.\n *\n * @class Creates a new foreignObject object. Do not use this constructor to create a foreignObject. Use {@link JXG.Board#create} with\n * type {@link foreignobject} instead.\n * @augments JXG.GeometryElement\n * @augments JXG.CoordsElement\n * @param {string|JXG.Board} board The board the new foreignObject is drawn on.\n * @param {Array} coordinates An array with the user coordinates of the foreignObject.\n * @param {Object} attributes An object containing visual and - optionally - a name and an id.\n * @param {string|function} url An URL string or a function returning an URL string.\n * @param  {Array} size Array containing width and height of the foreignObject in user coordinates.\n *\n */\nJXG.ForeignObject = function (board, coords, attributes, content, size) {\n    this.constructor(\n        board,\n        attributes,\n        Const.OBJECT_TYPE_FOREIGNOBJECT,\n        Const.OBJECT_CLASS_OTHER\n    );\n    this.element = this.board.select(attributes.anchor);\n    this.coordsConstructor(coords);\n\n    this._useUserSize = false;\n\n    /**\n     * Array of length two containing [width, height] of the foreignObject in pixel.\n     * @type Array\n     */\n    this.size = [1, 1];\n    if (Type.exists(size) && size.length > 0) {\n        this._useUserSize = true;\n\n        this.W = Type.createFunction(size[0], this.board, \"\");\n        this.H = Type.createFunction(size[1], this.board, \"\");\n        this.usrSize = [this.W(), this.H()];\n    }\n\n    // this.size = [Math.abs(this.usrSize[0] * board.unitX), Math.abs(this.usrSize[1] * board.unitY)];\n\n    /**\n     * 'href' of the foreignObject.\n     * @type {string}\n     */\n    this.content = content;\n\n    this.elType = \"foreignobject\";\n\n    // span contains the anchor point and the two vectors\n    // spanning the foreignObject rectangle.\n    // this.span = [\n    //     this.coords.usrCoords.slice(0),\n    //     [this.coords.usrCoords[0], this.W(), 0],\n    //     [this.coords.usrCoords[0], 0, this.H()]\n    // ];\n    //this.parent = board.select(attributes.anchor);\n\n    this.id = this.board.setId(this, \"Im\");\n\n    this.board.renderer.drawForeignObject(this);\n    this.board.finalizeAdding(this);\n\n    this.methodMap = JXG.deepCopy(this.methodMap, {\n        addTransformation: \"addTransform\",\n        trans: \"addTransform\"\n    });\n};\n\nJXG.ForeignObject.prototype = new GeometryElement();\nType.copyPrototypeMethods(JXG.ForeignObject, CoordsElement, \"coordsConstructor\");\n\nJXG.extend(\n    JXG.ForeignObject.prototype,\n    /** @lends JXG.ForeignObject.prototype */ {\n        /**\n         * Checks whether (x,y) is over or near the image;\n         * @param {Number} x Coordinate in x direction, screen coordinates.\n         * @param {Number} y Coordinate in y direction, screen coordinates.\n         * @returns {Boolean} True if (x,y) is over the image, False otherwise.\n         */\n        hasPoint: function (x, y) {\n            var dx,\n                dy,\n                r,\n                type,\n                prec,\n                c,\n                v,\n                p,\n                dot,\n                len = this.transformations.length;\n\n            if (Type.isObject(Type.evaluate(this.visProp.precision))) {\n                type = this.board._inputDevice;\n                prec = Type.evaluate(this.visProp.precision[type]);\n            } else {\n                // 'inherit'\n                prec = this.board.options.precision.hasPoint;\n            }\n\n            // Easy case: no transformation\n            if (len === 0) {\n                dx = x - this.coords.scrCoords[1];\n                dy = this.coords.scrCoords[2] - y;\n                r = prec;\n\n                return dx >= -r && dx - this.size[0] <= r && dy >= -r && dy - this.size[1] <= r;\n            }\n\n            // foreignObject is transformed\n            c = new Coords(Const.COORDS_BY_SCREEN, [x, y], this.board);\n            // v is the vector from anchor point to the drag point\n            c = c.usrCoords;\n            v = [c[0] - this.span[0][0], c[1] - this.span[0][1], c[2] - this.span[0][2]];\n            dot = Mat.innerProduct; // shortcut\n\n            // Project the drag point to the sides.\n            p = dot(v, this.span[1]);\n            if (0 <= p && p <= dot(this.span[1], this.span[1])) {\n                p = dot(v, this.span[2]);\n\n                if (0 <= p && p <= dot(this.span[2], this.span[2])) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        /**\n         * Recalculate the coordinates of lower left corner and the width and height.\n         *\n         * @returns {JXG.ForeignObject} A reference to the element\n         * @private\n         */\n        update: function (fromParent) {\n            if (!this.needsUpdate) {\n                return this;\n            }\n            this.updateCoords(fromParent);\n            this.updateSize();\n            // this.updateSpan();\n            return this;\n        },\n\n        /**\n         * Send an update request to the renderer.\n         * @private\n         */\n        updateRenderer: function () {\n            return this.updateRendererGeneric(\"updateForeignObject\");\n        },\n\n        /**\n         * Updates the internal arrays containing size of the foreignObject.\n         * @returns {JXG.ForeignObject} A reference to the element\n         * @private\n         */\n        updateSize: function () {\n            var bb = [0, 0];\n\n            if (this._useUserSize) {\n                this.usrSize = [this.W(), this.H()];\n                this.size = [\n                    Math.abs(this.usrSize[0] * this.board.unitX),\n                    Math.abs(this.usrSize[1] * this.board.unitY)\n                ];\n            } else {\n                if (this.rendNode.hasChildNodes()) {\n                    bb = this.rendNode.childNodes[0].getBoundingClientRect();\n                    this.size = [bb.width, bb.height];\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Update the anchor point of the foreignObject, i.e. the lower left corner\n         * and the two vectors which span the rectangle.\n         * @returns {JXG.ForeignObject} A reference to the element\n         * @private\n         *\n         */\n        updateSpan: function () {\n            var i,\n                j,\n                len = this.transformations.length,\n                v = [];\n\n            if (len === 0) {\n                this.span = [\n                    [this.Z(), this.X(), this.Y()],\n                    [this.Z(), this.W(), 0],\n                    [this.Z(), 0, this.H()]\n                ];\n            } else {\n                // v contains the three defining corners of the rectangle/image\n                v[0] = [this.Z(), this.X(), this.Y()];\n                v[1] = [this.Z(), this.X() + this.W(), this.Y()];\n                v[2] = [this.Z(), this.X(), this.Y() + this.H()];\n\n                // Transform the three corners\n                for (i = 0; i < len; i++) {\n                    for (j = 0; j < 3; j++) {\n                        v[j] = Mat.matVecMult(this.transformations[i].matrix, v[j]);\n                    }\n                }\n                // Normalize the vectors\n                for (j = 0; j < 3; j++) {\n                    v[j][1] /= v[j][0];\n                    v[j][2] /= v[j][0];\n                    v[j][0] /= v[j][0];\n                }\n                // Compute the two vectors spanning the rectangle\n                // by subtracting the anchor point.\n                for (j = 1; j < 3; j++) {\n                    v[j][0] -= v[0][0];\n                    v[j][1] -= v[0][1];\n                    v[j][2] -= v[0][2];\n                }\n                this.span = v;\n            }\n\n            return this;\n        },\n\n        addTransform: function (transform) {\n            var i;\n\n            if (Type.isArray(transform)) {\n                for (i = 0; i < transform.length; i++) {\n                    this.transformations.push(transform[i]);\n                }\n            } else {\n                this.transformations.push(transform);\n            }\n\n            return this;\n        },\n\n        // Documented in element.js\n        getParents: function () {\n            var p = [this.url, [this.Z(), this.X(), this.Y()], this.usrSize];\n\n            if (this.parents.length !== 0) {\n                p = this.parents;\n            }\n\n            return p;\n        },\n\n        /**\n         * Set the width and height of the foreignObject. After setting a new size,\n         * board.update() or foreignobject.fullUpdate()\n         * has to be called to make the change visible.\n         * @param  {number, function, string} width  Number, function or string\n         *                            that determines the new width of the foreignObject\n         * @param  {number, function, string} height Number, function or string\n         *                            that determines the new height of the foreignObject\n         * @returns {JXG.ForeignObject} A reference to the element\n         *\n         */\n        setSize: function (width, height) {\n            this.W = Type.createFunction(width, this.board, \"\");\n            this.H = Type.createFunction(height, this.board, \"\");\n            this._useUserSize = true;\n\n            return this;\n        },\n\n        /**\n         * Returns the width of the foreignObject in user coordinates.\n         * @returns {number} width of the image in user coordinates\n         */\n        W: function () {}, // Needed for docs, defined in constructor\n\n        /**\n         * Returns the height of the foreignObject in user coordinates.\n         * @returns {number} height of the image in user coordinates\n         */\n        H: function () {} // Needed for docs, defined in constructor\n    }\n);\n\n/**\n * @class This element is used to provide a constructor for arbitrary content in\n * an SVG foreignObject container.\n * <p>\n * Instead of board.create('foreignobject') the shortcut board.create('fo') may be used.\n *\n * <p style=\"background-color:#dddddd; padding:10px\"><b>NOTE:</b> In Safari up to version 15, a foreignObject does not obey the layer structure\n * if it contains &lt;video&gt; or &lt;iframe&gt; tags, as well as elements which are\n * positioned with <tt>position:absolute|relative|fixed</tt>. In this  case, the foreignobject will be\n * \"above\" the JSXGraph construction.\n * </p>\n *\n * @pseudo\n * @description\n * @name ForeignObject\n * @augments JXG.ForeignObject\n * @constructor\n * @type JXG.ForeignObject\n *\n * @param {String} content HTML content of the foreignObject. May also be &lt;video&gt; or &lt;iframe&gt;\n * @param {Array} position Position of the foreignObject given by [x, y] in user coordinates. Same as for images.\n * @param {Array} [size] (Optional) argument size of the foreignObject in user coordinates. If not given, size is specified by the HTML attributes\n * or CSS properties of the content.\n *\n * @see Image\n *\n * @example\n * var p = board.create('point', [1, 7], {size: 16});\n * var fo = board.create('foreignobject', [\n *     '&lt;video width=\"300\" height=\"200\" src=\"https://eucbeniki.sio.si/vega2/278/Video_metanje_oge_.mp4\" type=\"html5video\" controls&gt;',\n *     [0, -3], [9, 6]],\n *     {layer: 8, fixed: true}\n *  );\n *\n * </pre><div id=\"JXG0c122f2c-3671-4a28-80a9-f4c523eeda89\" class=\"jxgbox\" style=\"width: 500px; height: 500px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG0c122f2c-3671-4a28-80a9-f4c523eeda89',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p = board.create('point', [1, 7], {size: 16});\n *     var fo = board.create('foreignobject', [\n *         '<video width=\"300\" height=\"200\" src=\"https://eucbeniki.sio.si/vega2/278/Video_metanje_oge_.mp4\" type=\"html5video\" controls>',\n *         [0, -3], [9, 6]],\n *         {layer: 8, fixed: true}\n *      );\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * var p = board.create('point', [1, 7], {size: 16});\n * var fo = board.create('fo', [\n *     '&lt;div style=\"background-color:blue; color: yellow; padding:20px; width:200px; height:50px; \"&gt;Hello&lt;/div&gt;',\n *     [-7, -6]],\n *     {layer: 1, fixed: false}\n *  );\n *\n * </pre><div id=\"JXG1759c868-1a4a-4767-802c-91f84902e3ec\" class=\"jxgbox\" style=\"width: 500px; height: 500px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG1759c868-1a4a-4767-802c-91f84902e3ec',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *     var p = board.create('point', [1, 7], {size: 16});\n *     var fo = board.create('foreignobject', [\n *         '<div style=\"background-color:blue; color: yellow; padding:20px; width:200px; height:50px; \">Hello</div>',\n *         [-7, -6]],\n *         {layer: 1, fixed: false}\n *      );\n *\n *     })();\n *\n * </script><pre>\n *\n * @example\n * board.renderer.container.style.backgroundColor = 'lightblue';\n * var points = [];\n * points.push( board.create('point', [-2, 3.5], {fixed:false,color: 'yellow', size: 6,name:'6 am'}) );\n * points.push( board.create('point', [0, 3.5],  {fixed:false,color: 'yellow', size: 6,name:'12 pm'}) );\n * points.push( board.create('point', [2, 3.5],  {fixed:false,color: 'yellow', size: 6,name:'6 pm'}) );\n *\n * var fo = board.create('fo', [\n *     '&lt;video width=\"100%\" height=\"100%\" src=\"https://benedu.net/moodle/aaimg/ajx_img/astro/tr/1vd.mp4\" type=\"html5video\" controls&gt;',\n *     [-6, -4], [12, 8]],\n *     {layer: 0, fixed: true}\n *  );\n *\n * var f = JXG.Math.Numerics.lagrangePolynomial(points);\n * var graph = board.create('functiongraph', [f, -10, 10], {fixed:true,strokeWidth:3, layer: 8});\n *\n * </pre><div id=\"JXGc3fc5520-13aa-4f66-abaa-42e9dc3fbf3f\" class=\"jxgbox\" style=\"width: 500px; height: 500px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGc3fc5520-13aa-4f66-abaa-42e9dc3fbf3f',\n *             {boundingbox: [-6,4,6,-4], axis: true, showcopyright: false, shownavigation: false});\n *     board.renderer.container.style.backgroundColor = 'lightblue';\n *     var points = [];\n *     points.push( board.create('point', [-2, 3.5], {fixed:false,color: 'yellow', size: 6,name:'6 am'}) );\n *     points.push( board.create('point', [0, 3.5],  {fixed:false,color: 'yellow', size: 6,name:'12 pm'}) );\n *     points.push( board.create('point', [2, 3.5],  {fixed:false,color: 'yellow', size: 6,name:'6 pm'}) );\n *\n *     var fo = board.create('fo', [\n *         '<video width=\"100%\" height=\"100%\" src=\"https://benedu.net/moodle/aaimg/ajx_img/astro/tr/1vd.mp4\" type=\"html5video\" controls>',\n *         [-6, -4], [12, 8]],\n *         {layer: 0, fixed: true}\n *      );\n *\n *     var f = JXG.Math.Numerics.lagrangePolynomial(points);\n *     var graph = board.create('functiongraph', [f, -10, 10], {fixed:true,strokeWidth:3, layer: 8});\n *\n *     })();\n *\n * </script><pre>\n *\n * Video \"24-hour time-lapse in Cascais, Portugal. Produced by Nuno Miguel Duarte\" adapted from\n * <a href=\"https://www.pbslearningmedia.org/resource/buac18-k2-sci-ess-sunposition/changing-position-of-the-sun-in-the-sky/\">https://www.pbslearningmedia.org/resource/buac18-k2-sci-ess-sunposition/changing-position-of-the-sun-in-the-sky/</a>,\n * ©2016 Nuno Miguel Duarte.\n *\n */\nJXG.createForeignObject = function (board, parents, attributes) {\n    var attr,\n        fo,\n        content = parents[0],\n        coords = parents[1],\n        size = [];\n\n    if (parents.length >= 2) {\n        size = parents[2];\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"foreignobject\");\n    fo = CoordsElement.create(JXG.ForeignObject, board, coords, attr, content, size);\n    if (!fo) {\n        throw new Error(\n            \"JSXGraph: Can't create foreignObject with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [string, [x, y], [w, h]], [string, [x, y]], [element,transformation]\"\n        );\n    }\n\n    return fo;\n};\n\nJXG.registerElement(\"foreignobject\", JXG.createForeignObject);\nJXG.registerElement(\"fo\", JXG.createForeignObject);\n\nexport default {\n    ForeignObject: JXG.ForeignObject,\n    createForeignobject: JXG.createForeignObject\n};\n","/*global JXG:true, define: true*/\n\nimport JXG from \"./jxg\";\nimport Options from \"./options\";\n\nJXG.extend(Options, {\n    // infobox: {\n    //     strokeColor: 'black'\n    // },\n\n    axes3d: {\n        /**#@+\n         * @visprop\n         */\n\n        /**\n         * Position of the main axes in a View3D element. Possible values are\n         * 'center' and 'border'.\n         *\n         * @type String\n         * @name View3D#axesPosition\n         * @default 'center'\n         */\n        axesPosition: \"center\", // Possible values: 'center', otherwise: border\n\n        // Main axes\n\n        /**\n         * Attributes of the 3D x-axis.\n         *\n         * @type Line3D\n         * @name View3D#xAxis\n         */\n        xAxis: { visible: true, point2: { name: \"x\" } },\n\n        /**\n         * Attributes of the 3D y-axis.\n         *\n         * @type Line3D\n         * @name View3D#yAxis\n         */\n        yAxis: { visible: true, point2: { name: \"y\" } },\n\n        /**\n         * Attributes of the 3D z-axis.\n         *\n         * @type Line3D\n         * @name View3D#zAxis\n         */\n        zAxis: { visible: true, point2: { name: \"z\" } },\n\n        // Planes\n        /**\n         * Attributes of the 3D plane orthogonal to the x-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#xPlaneRear\n         */\n        xPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } },\n        /**\n         * Attributes of the 3D plane orthogonal to the y-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#yPlaneRear\n         */\n        yPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } },\n        /**\n         * Attributes of the 3D plane orthogonal to the z-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#zPlaneRear\n         */\n        zPlaneRear: { visible: true, layer: 0, mesh3d: { layer: 1 } },\n\n        /**\n         * Attributes of the 3D plane orthogonal to the x-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#xPlaneFront\n         */\n        xPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } },\n        /**\n         * Attributes of the 3D plane orthogonal to the y-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#yPlaneFront\n         */\n        yPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } },\n        /**\n         * Attributes of the 3D plane orthogonal to the z-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#zPlaneFront\n         */\n        zPlaneFront: { visible: false, layer: 0, mesh3d: { layer: 1 } },\n\n        // Axes on the planes\n        /**\n         * Attributes of the 3D y-axis on the 3D plane orthogonal to the x-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#xPlaneRearYAxis\n         */\n        xPlaneRearYAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D z-axis on the 3D plane orthogonal to the x-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#xPlaneRearZAxis\n         */\n        xPlaneRearZAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D y-axis on the 3D plane orthogonal to the x-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#xPlaneFrontYAxis\n         */\n        xPlaneFrontYAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D z-axis on the 3D plane orthogonal to the x-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#xPlaneFrontZAxis\n         */\n        xPlaneFrontZAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n\n        /**\n         * Attributes of the 3D x-axis on the 3D plane orthogonal to the y-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#yPlaneRearXAxis\n         */\n        yPlaneRearXAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D z-axis on the 3D plane orthogonal to the y-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#yPlaneRearZAxis\n         */\n        yPlaneRearZAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D x-axis on the 3D plane orthogonal to the y-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#yPlaneFrontXAxis\n         */\n        yPlaneFrontXAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D z-axis on the 3D plane orthogonal to the y-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#yPlaneFrontZAxis\n         */\n        yPlaneFrontZAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n\n        /**\n         * Attributes of the 3D x-axis on the 3D plane orthogonal to the z-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#zPlaneRearXAxis\n         */\n        zPlaneRearXAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D y-axis on the 3D plane orthogonal to the z-axis at the \"rear\" of the cube.\n         * @type Plane3D\n         * @name View3D#zPlaneRearYAxis\n         */\n        zPlaneRearYAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D x-axis on the 3D plane orthogonal to the z-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#zPlaneFrontXAxis\n         */\n        zPlaneFrontXAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        },\n        /**\n         * Attributes of the 3D y-axis on the 3D plane orthogonal to the z-axis at the \"front\" of the cube.\n         * @type Plane3D\n         * @name View3D#zPlaneFrontYAxis\n         */\n        zPlaneFrontYAxis: {\n            visible: \"inherit\",\n            strokeColor: \"#888888\",\n            strokeWidth: 1\n        }\n\n        /**#@-*/\n    },\n\n    axis3d: {\n        highlight: false,\n        strokecolor: \"black\",\n        strokeWidth: 1,\n        tabindex: null,\n\n        point1: { visible: false, name: \"\" },\n        point2: { visible: false, name: \"\", label: { visible: true } }\n    },\n\n    curve3d: {\n        /**#@+\n         * @visprop\n         */\n\n        highlight: false,\n        tabindex: -1,\n        strokeWidth: 1,\n        numberPointsHigh: 200\n\n        /**#@-*/\n    },\n\n    mesh3d: {\n        strokeWidth: 1,\n        strokeColor: \"#9a9a9a\",\n        strokeOpacity: 0.6,\n        highlight: false,\n        fillColor: \"#9a9a9a\",\n        fillOpacity: 0.1,\n        tabindex: null,\n\n        visible: \"inherit\"\n    },\n\n    line3d: {\n        strokeWidth: 1,\n        strokeColor: \"black\",\n        fixed: true,\n        tabindex: null,\n\n        gradient: \"linear\",\n        gradientSecondColor: \"#ffffff\",\n\n        point: { visible: false, name: \"\" }, // Used only in case of point/point\n        point1: { visible: false, name: \"\" }, // Used only in case of point/direction/range\n        point2: { visible: false, name: \"\" }\n    },\n\n    plane3d: {\n        strokeWidth: 0,\n        strokeColor: \"black\",\n        strokeOpacity: 1,\n        highlight: false,\n        tabindex: null,\n\n        gradient: \"linear\",\n        gradientSecondColor: \"#ffffff\",\n        gradientAngle: Math.PI,\n        fillColor: \"#a7a7a7\",\n        fillOpacity: 0.6,\n\n        point: { visible: false, name: \"\", fixed: true }\n    },\n\n    point3d: {\n        infoboxDigits: \"auto\",\n        strokeWidth: 0,\n        gradient: \"radial\",\n        gradientSecondColor: \"#555555\",\n        fillColor: \"yellow\",\n        highlightStrokeColor: \"#555555\"\n    },\n\n    surface3d: {\n        /**#@+\n         * @visprop\n         */\n\n        highlight: false,\n        tabindex: -1,\n        strokeWidth: 1,\n\n        /**\n         * Number of intervals the mesh is divided into in direction of parameter u.\n         * @type Number\n         * @name ParametricSurface3D#stepsU\n         */\n        stepsU: 30,\n\n        /**\n         * Number of intervals the mesh is divided into in direction of parameter v.\n         * @type Number\n         * @name ParametricSurface3D#stepsV\n         */\n        stepsV: 30\n\n        /**#@-*/\n    },\n\n    view3d: {\n        needsRegularUpdate: true\n    }\n});\n\nexport default JXG.Options;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Carsten Miller,\n        Andreas Walter,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n/*global JXG:true, define: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Type from \"../utils/type\";\nimport Mat from \"../math/math\";\nimport GeometryElement from \"../base/element\";\nimport Composition from \"../base/composition\";\n\n/**\n * 3D view inside of a JXGraph board.\n *\n * @class Creates a new 3D view. Do not use this constructor to create a 3D view. Use {@link JXG.Board#create} with\n * type {@link View3D} instead.\n *\n * @augments JXG.GeometryElement\n * @param {Array} parents Array consisting of lower left corner [x, y] of the view inside the board, [width, height] of the view\n * and box size [[x1, x2], [y1,y2], [z1,z2]]. If the view's azimuth=0 and elevation=0, the 3D view will cover a rectangle with lower left corner\n * [x,y] and side lengths [w, h] of the board.\n */\nJXG.View3D = function (board, parents, attributes) {\n    this.constructor(board, attributes, Const.OBJECT_TYPE_VIEW3D, Const.OBJECT_CLASS_3D);\n\n    /**\n     * An associative array containing all geometric objects belonging to the view.\n     * Key is the id of the object and value is a reference to the object.\n     * @type Object\n     * @private\n     */\n    this.objects = {};\n\n    /**\n     * An array containing all geometric objects in this view in the order of construction.\n     * @type Array\n     * @private\n     */\n    this.objectsList = [];\n\n    /**\n     * An associative array / dictionary to store the objects of the board by name. The name of the object is the key and value is a reference to the object.\n     * @type Object\n     * @private\n     */\n    this.elementsByName = {};\n\n    /**\n     * Default axes of the 3D view, contains the axes of the view or null.\n     *\n     * @type {Object}\n     * @default null\n     */\n    this.defaultAxes = null;\n\n    /**\n     * 3D-to-2D transformation matrix\n     * @type  {Array} 3 x 4 matrix\n     * @private\n     */\n    this.matrix3D = [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0]\n    ];\n\n    /**\n     * Lower left corner [x, y] of the 3D view if elevation and azimuth are set to 0.\n     * @type array\n     * @private\n     */\n    this.llftCorner = parents[0];\n\n    /**\n     * Width and height [w, h] of the 3D view if elevation and azimuth are set to 0.\n     * @type array\n     * @private\n     */\n    this.size = parents[1];\n\n    /**\n     * Bounding box (cube) [[x1, x2], [y1,y2], [z1,z2]] of the 3D view\n     * @type array\n     */\n    this.bbox3D = parents[2];\n\n    /**\n     * Distance of the view to the origin. In other words, its\n     * the radius of the sphere where the camera sits.view.board.update\n     * @type Number\n     */\n    this.r = -1;\n\n    this.timeoutAzimuth = null;\n\n    this.id = this.board.setId(this, \"V\");\n    this.board.finalizeAdding(this);\n    this.elType = \"view3d\";\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        // TODO\n    });\n};\nJXG.View3D.prototype = new GeometryElement();\n\nJXG.extend(\n    JXG.View3D.prototype,\n    /** @lends JXG.View3D.prototype */ {\n        /**\n         * Creates a new 3D element of type elementType.\n         * @param {String} elementType Type of the element to be constructed given as a string e.g. 'point3d' or 'surface3d'.\n         * @param {Array} parents Array of parent elements needed to construct the element e.g. coordinates for a 3D point or two\n         * 3D points to construct a line. This highly depends on the elementType that is constructed. See the corresponding JXG.create*\n         * methods for a list of possible parameters.\n         * @param {Object} [attributes] An object containing the attributes to be set. This also depends on the elementType.\n         * Common attributes are name, visible, strokeColor.\n         * @returns {Object} Reference to the created element. This is usually a GeometryElement3D, but can be an array containing\n         * two or more elements.\n         */\n        create: function (elementType, parents, attributes) {\n            var prefix = [],\n                is3D = false,\n                el;\n\n            if (elementType.indexOf(\"3d\") > 0) {\n                is3D = true;\n                prefix.push(this);\n            }\n            el = this.board.create(elementType, prefix.concat(parents), attributes);\n\n            return el;\n        },\n\n        /**\n         * Select a single or multiple elements at once.\n         * @param {String|Object|function} str The name, id or a reference to a JSXGraph 3D element in the 3D view. An object will\n         * be used as a filter to return multiple elements at once filtered by the properties of the object.\n         * @param {Boolean} onlyByIdOrName If true (default:false) elements are only filtered by their id, name or groupId.\n         * The advanced filters consisting of objects or functions are ignored.\n         * @returns {JXG.GeometryElement3D|JXG.Composition}\n         * @example\n         * // select the element with name A\n         * view.select('A');\n         *\n         * // select all elements with strokecolor set to 'red' (but not '#ff0000')\n         * view.select({\n         *   strokeColor: 'red'\n         * });\n         *\n         * // select all points on or below the x/y plane and make them black.\n         * view.select({\n         *   elType: 'point3d',\n         *   Z: function (v) {\n         *     return v <= 0;\n         *   }\n         * }).setAttribute({color: 'black'});\n         *\n         * // select all elements\n         * view.select(function (el) {\n         *   return true;\n         * });\n         */\n        select: function (str, onlyByIdOrName) {\n            var flist,\n                olist,\n                i,\n                l,\n                s = str;\n\n            if (s === null) {\n                return s;\n            }\n\n            // It's a string, most likely an id or a name.\n            if (Type.isString(s) && s !== \"\") {\n                // Search by ID\n                if (Type.exists(this.objects[s])) {\n                    s = this.objects[s];\n                    // Search by name\n                } else if (Type.exists(this.elementsByName[s])) {\n                    s = this.elementsByName[s];\n                    // // Search by group ID\n                    // } else if (Type.exists(this.groups[s])) {\n                    //     s = this.groups[s];\n                }\n\n                // It's a function or an object, but not an element\n            } else if (\n                !onlyByIdOrName &&\n                (Type.isFunction(s) || (Type.isObject(s) && !Type.isFunction(s.setAttribute)))\n            ) {\n                flist = Type.filterElements(this.objectsList, s);\n\n                olist = {};\n                l = flist.length;\n                for (i = 0; i < l; i++) {\n                    olist[flist[i].id] = flist[i];\n                }\n                s = new Composition(olist);\n\n                // It's an element which has been deleted (and still hangs around, e.g. in an attractor list\n            } else if (\n                Type.isObject(s) &&\n                Type.exists(s.id) &&\n                !Type.exists(this.objects[s.id])\n            ) {\n                s = null;\n            }\n\n            return s;\n        },\n\n        update: function () {\n            // Update 3D-to-2D transformation matrix with the actual\n            // elevation and azimuth angles.\n\n            var e, r, a, f, mat;\n\n            if (\n                !Type.exists(this.el_slide) ||\n                !Type.exists(this.az_slide) ||\n                !this.needsUpdate\n            ) {\n                return this;\n            }\n\n            e = this.el_slide.Value();\n            r = this.r;\n            a = this.az_slide.Value();\n            f = r * Math.sin(e);\n            mat = [\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1]\n            ];\n\n            this.matrix3D = [\n                [1, 0, 0, 0],\n                [0, 1, 0, 0],\n                [0, 0, 1, 0]\n            ];\n\n            this.matrix3D[1][1] = r * Math.cos(a);\n            this.matrix3D[1][2] = -r * Math.sin(a);\n            this.matrix3D[2][1] = f * Math.sin(a);\n            this.matrix3D[2][2] = f * Math.cos(a);\n            this.matrix3D[2][3] = Math.cos(e);\n\n            mat[1][1] = this.size[0] / (this.bbox3D[0][1] - this.bbox3D[0][0]); // w / d_x\n            mat[2][2] = this.size[1] / (this.bbox3D[1][1] - this.bbox3D[1][0]); // h / d_y\n            mat[1][0] = this.llftCorner[0] - mat[1][1] * this.bbox3D[0][0]; // llft_x\n            mat[2][0] = this.llftCorner[1] - mat[2][2] * this.bbox3D[1][0]; // llft_y\n            this.matrix3D = Mat.matMatMult(mat, this.matrix3D);\n\n            return this;\n        },\n\n        updateRenderer: function () {\n            this.needsUpdate = false;\n            return this;\n        },\n\n        /**\n         * Project 3D coordinates to 2D board coordinates\n         * The 3D coordinates are provides as three numbers x, y, z or one array of length 3.\n         *\n         * @param  {Number|Array} x\n         * @param  {[Number]} y\n         * @param  {[Number]} z\n         * @returns {Array} Array of length 3 containing the projection on to the board\n         * in homogeneous user coordinates.\n         */\n        project3DTo2D: function (x, y, z) {\n            var vec;\n            if (arguments.length === 3) {\n                vec = [1, x, y, z];\n            } else {\n                // Argument is an array\n                if (x.length === 3) {\n                    vec = [1].concat(x);\n                } else {\n                    vec = x;\n                }\n            }\n            return Mat.matVecMult(this.matrix3D, vec);\n        },\n\n        /**\n         * Project a 2D coordinate to the plane defined by the point foot\n         * and the normal vector `normal`.\n         *\n         * @param  {JXG.Point} point\n         * @param  {Array} normal\n         * @param  {Array} foot\n         * @returns {Array} of length 4 containing the projected\n         * point in homogeneous coordinates.\n         */\n        project2DTo3DPlane: function (point2d, normal, foot) {\n            var mat,\n                rhs,\n                d,\n                le,\n                n = normal.slice(1),\n                sol = [1, 0, 0, 0];\n\n            foot = foot || [1, 0, 0, 0];\n            le = Mat.norm(n, 3);\n            d = Mat.innerProduct(foot.slice(1), n, 3) / le;\n\n            mat = this.matrix3D.slice(0, 3); // True copy\n            mat.push([0].concat(n));\n\n            // 2D coordinates of point:\n            rhs = point2d.coords.usrCoords.concat([d]);\n            try {\n                // Prevent singularity in case elevation angle is zero\n                if (mat[2][3] === 1.0) {\n                    mat[2][1] = mat[2][2] = Mat.eps * 0.001;\n                }\n                sol = Mat.Numerics.Gauss(mat, rhs);\n            } catch (err) {\n                sol = [0, NaN, NaN, NaN];\n            }\n\n            return sol;\n        },\n\n        /**\n         * Limit 3D coordinates to the bounding cube.\n         *\n         * @param {Array} c3d 3D coordinates [x,y,z]\n         * @returns Array with updated 3D coordinates.\n         */\n        project3DToCube: function (c3d) {\n            var cube = this.bbox3D;\n            if (c3d[1] < cube[0][0]) {\n                c3d[1] = cube[0][0];\n            }\n            if (c3d[1] > cube[0][1]) {\n                c3d[1] = cube[0][1];\n            }\n            if (c3d[2] < cube[1][0]) {\n                c3d[2] = cube[1][0];\n            }\n            if (c3d[2] > cube[1][1]) {\n                c3d[2] = cube[1][1];\n            }\n            if (c3d[3] < cube[2][0]) {\n                c3d[3] = cube[2][0];\n            }\n            if (c3d[3] > cube[2][1]) {\n                c3d[3] = cube[2][1];\n            }\n\n            return c3d;\n        },\n\n        /**\n         * Intersect a ray with the bounding cube of the 3D view.\n         * @param {Array} p 3D coordinates [x,y,z]\n         * @param {Array} d 3D direction vector of the line (array of length 3)\n         * @param {Number} r direction of the ray (positive if r > 0, negative if r < 0).\n         * @returns Affine ratio of the intersection of the line with the cube.\n         */\n        intersectionLineCube: function (p, d, r) {\n            var rnew, i, r0, r1;\n\n            rnew = r;\n            for (i = 0; i < 3; i++) {\n                if (d[i] !== 0) {\n                    r0 = (this.bbox3D[i][0] - p[i]) / d[i];\n                    r1 = (this.bbox3D[i][1] - p[i]) / d[i];\n                    if (r < 0) {\n                        rnew = Math.max(rnew, Math.min(r0, r1));\n                    } else {\n                        rnew = Math.min(rnew, Math.max(r0, r1));\n                    }\n                }\n            }\n            return rnew;\n        },\n\n        /**\n         * Test if coordinates are inside of the bounding cube.\n         * @param {array} q 3D coordinates [x,y,z] of a point.\n         * @returns Boolean\n         */\n        isInCube: function (q) {\n            return (\n                q[0] > this.bbox3D[0][0] - Mat.eps &&\n                q[0] < this.bbox3D[0][1] + Mat.eps &&\n                q[1] > this.bbox3D[1][0] - Mat.eps &&\n                q[1] < this.bbox3D[1][1] + Mat.eps &&\n                q[2] > this.bbox3D[2][0] - Mat.eps &&\n                q[2] < this.bbox3D[2][1] + Mat.eps\n            );\n        },\n\n        /**\n         *\n         * @param {JXG.Plane3D} plane1\n         * @param {JXG.Plane3D} plane2\n         * @param {JXG.Plane3D} d\n         * @returns {Array} of length 2 containing the coordinates of the defining points of\n         * of the intersection segment.\n         */\n        intersectionPlanePlane: function (plane1, plane2, d) {\n            var ret = [[], []],\n                p,\n                dir,\n                r,\n                q;\n\n            d = d || plane2.d;\n\n            p = Mat.Geometry.meet3Planes(\n                plane1.normal,\n                plane1.d,\n                plane2.normal,\n                d,\n                Mat.crossProduct(plane1.normal, plane2.normal),\n                0\n            );\n            dir = Mat.Geometry.meetPlanePlane(\n                plane1.vec1,\n                plane1.vec2,\n                plane2.vec1,\n                plane2.vec2\n            );\n            r = this.intersectionLineCube(p, dir, Infinity);\n            q = Mat.axpy(r, dir, p);\n            if (this.isInCube(q)) {\n                ret[0] = q;\n            }\n            r = this.intersectionLineCube(p, dir, -Infinity);\n            q = Mat.axpy(r, dir, p);\n            if (this.isInCube(q)) {\n                ret[1] = q;\n            }\n            return ret;\n        },\n\n        /**\n         * Generate mesh for a surface / plane.\n         * Returns array [dataX, dataY] for a JSXGraph curve's updateDataArray function.\n         * @param {Array,Function} func\n         * @param {Array} interval_u\n         * @param {Array} interval_v\n         * @returns Array\n         * @private\n         *\n         * @example\n         *  var el = view.create('curve', [[], []]);\n         *  el.updateDataArray = function () {\n         *      var steps_u = Type.evaluate(this.visProp.stepsu),\n         *           steps_v = Type.evaluate(this.visProp.stepsv),\n         *           r_u = Type.evaluate(this.range_u),\n         *           r_v = Type.evaluate(this.range_v),\n         *           func, ret;\n         *\n         *      if (this.F !== null) {\n         *          func = this.F;\n         *      } else {\n         *          func = [this.X, this.Y, this.Z];\n         *      }\n         *      ret = this.view.getMesh(func,\n         *          r_u.concat([steps_u]),\n         *          r_v.concat([steps_v]));\n         *\n         *      this.dataX = ret[0];\n         *      this.dataY = ret[1];\n         *  };\n         *\n         */\n        getMesh: function (func, interval_u, interval_v) {\n            var i_u,\n                i_v,\n                u,\n                v,\n                c2d,\n                delta_u,\n                delta_v,\n                p = [0, 0, 0],\n                steps_u = interval_u[2],\n                steps_v = interval_v[2],\n                dataX = [],\n                dataY = [];\n\n            delta_u = (Type.evaluate(interval_u[1]) - Type.evaluate(interval_u[0])) / steps_u;\n            delta_v = (Type.evaluate(interval_v[1]) - Type.evaluate(interval_v[0])) / steps_v;\n\n            for (i_u = 0; i_u <= steps_u; i_u++) {\n                u = interval_u[0] + delta_u * i_u;\n                for (i_v = 0; i_v <= steps_v; i_v++) {\n                    v = interval_v[0] + delta_v * i_v;\n                    if (Type.isFunction(func)) {\n                        p = func(u, v);\n                    } else {\n                        p = [func[0](u, v), func[1](u, v), func[2](u, v)];\n                    }\n                    c2d = this.project3DTo2D(p);\n                    dataX.push(c2d[1]);\n                    dataY.push(c2d[2]);\n                }\n                dataX.push(NaN);\n                dataY.push(NaN);\n            }\n\n            for (i_v = 0; i_v <= steps_v; i_v++) {\n                v = interval_v[0] + delta_v * i_v;\n                for (i_u = 0; i_u <= steps_u; i_u++) {\n                    u = interval_u[0] + delta_u * i_u;\n                    if (Type.isFunction(func)) {\n                        p = func(u, v);\n                    } else {\n                        p = [func[0](u, v), func[1](u, v), func[2](u, v)];\n                    }\n                    c2d = this.project3DTo2D(p);\n                    dataX.push(c2d[1]);\n                    dataY.push(c2d[2]);\n                }\n                dataX.push(NaN);\n                dataY.push(NaN);\n            }\n\n            return [dataX, dataY];\n        },\n\n        /**\n         *\n         */\n        animateAzimuth: function () {\n            var s = this.az_slide._smin,\n                e = this.az_slide._smax,\n                sdiff = e - s,\n                newVal = this.az_slide.Value() + 0.1;\n\n            this.az_slide.position = (newVal - s) / sdiff;\n            if (this.az_slide.position > 1) {\n                this.az_slide.position = 0.0;\n            }\n            this.board.update();\n\n            this.timeoutAzimuth = setTimeout(\n                function () {\n                    this.animateAzimuth();\n                }.bind(this),\n                200\n            );\n        },\n\n        /**\n         *\n         */\n        stopAzimuth: function () {\n            clearTimeout(this.timeoutAzimuth);\n            this.timeoutAzimuth = null;\n        }\n    }\n);\n\n/**\n * @class This element creates a 3D view.\n * @pseudo\n * @description  A View3D element provides the container and the methods to create and display 3D elements.\n * It is contained in a JSXGraph board.\n * @name View3D\n * @augments JXG.View3D\n * @constructor\n * @type Object\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Array_Array_Array} lower,dim,cube  Here, lower is an array of the form [x, y] and\n * dim is an array of the form [w, h].\n * The arrays [x, y] and [w, h] define the 2D frame into which the 3D cube is\n * (roughly) projected. If the view's azimuth=0 and elevation=0, the 3D view will cover a rectangle with lower left corner\n * [x,y] and side lengths [w, h] of the board.\n * The array 'cube' is of the form [[x1, x2], [y1, y2], [z1, z2]]\n * which determines the coordinate ranges of the 3D cube.\n *\n * @example\n *  var bound = [-5, 5];\n *  var view = board.create('view3d',\n *      [[-6, -3],\n *       [8, 8],\n *       [bound, bound, bound]],\n *      {\n *          // Main axes\n *          axesPosition: 'center',\n *          xAxis: { strokeColor: 'blue', strokeWidth: 3},\n *\n *          // Planes\n *          xPlaneRear: { fillColor: 'yellow',  mesh3d: {visible: false}},\n *          yPlaneFront: { visible: true, fillColor: 'blue'},\n *\n *          // Axes on planes\n *          xPlaneRearYAxis: {strokeColor: 'red'},\n *          xPlaneRearZAxis: {strokeColor: 'red'},\n *\n *          yPlaneFrontXAxis: {strokeColor: 'blue'},\n *          yPlaneFrontZAxis: {strokeColor: 'blue'},\n *\n *          zPlaneFrontXAxis: {visible: false},\n *          zPlaneFrontYAxis: {visible: false}\n *      });\n *\n * </pre><div id=\"JXGdd06d90e-be5d-4531-8f0b-65fc30b1a7c7\" class=\"jxgbox\" style=\"width: 500px; height: 500px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGdd06d90e-be5d-4531-8f0b-65fc30b1a7c7',\n *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});\n *         var bound = [-5, 5];\n *         var view = board.create('view3d',\n *             [[-6, -3], [8, 8],\n *             [bound, bound, bound]],\n *             {\n *                 // Main axes\n *                 axesPosition: 'center',\n *                 xAxis: { strokeColor: 'blue', strokeWidth: 3},\n *                 // Planes\n *                 xPlaneRear: { fillColor: 'yellow',  mesh3d: {visible: false}},\n *                 yPlaneFront: { visible: true, fillColor: 'blue'},\n *                 // Axes on planes\n *                 xPlaneRearYAxis: {strokeColor: 'red'},\n *                 xPlaneRearZAxis: {strokeColor: 'red'},\n *                 yPlaneFrontXAxis: {strokeColor: 'blue'},\n *                 yPlaneFrontZAxis: {strokeColor: 'blue'},\n *                 zPlaneFrontXAxis: {visible: false},\n *                 zPlaneFrontYAxis: {visible: false}\n *             });\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createView3D = function (board, parents, attributes) {\n    var view,\n        attr,\n        x,\n        y,\n        w,\n        h,\n        coords = parents[0], // llft corner\n        size = parents[1]; // [w, h]\n\n    attr = Type.copyAttributes(attributes, board.options, \"view3d\");\n    view = new JXG.View3D(board, parents, attr);\n    view.defaultAxes = view.create(\"axes3d\", parents, attributes);\n\n    x = coords[0];\n    y = coords[1];\n    w = size[0];\n    h = size[1];\n\n    /**\n     * Slider to adapt azimuth angle\n     * @name JXG.View3D#az_slide\n     * @type {Slider}\n     */\n    view.az_slide = board.create(\n        \"slider\",\n        [\n            [x - 1, y - 2],\n            [x + w + 1, y - 2],\n            [0, 1.0, 2 * Math.PI]\n        ],\n        {\n            style: 6,\n            name: \"az\",\n            point1: { frozen: true },\n            point2: { frozen: true }\n        }\n    );\n\n    /**\n     * Slider to adapt elevation angle\n     *\n     * @name JXG.View3D#el_slide\n     * @type {Slider}\n     */\n    view.el_slide = board.create(\n        \"slider\",\n        [\n            [x - 1, y],\n            [x - 1, y + h],\n            [0, 0.3, Math.PI / 2]\n        ],\n        {\n            style: 6,\n            name: \"el\",\n            point1: { frozen: true },\n            point2: { frozen: true }\n        }\n    );\n\n    view.board.highlightInfobox = function (x, y, el) {\n        var d,\n            i,\n            c3d,\n            foot,\n            brd = el.board,\n            p = null;\n\n        // Search 3D parent\n        for (i = 0; i < el.parents.length; i++) {\n            p = brd.objects[el.parents[i]];\n            if (p.is3D) {\n                break;\n            }\n        }\n        if (p) {\n            foot = [1, 0, 0, p.coords[3]];\n            c3d = view.project2DTo3DPlane(p.element2D, [1, 0, 0, 1], foot);\n            if (!view.isInCube(c3d)) {\n                view.board.highlightCustomInfobox(\"\", p);\n                return;\n            }\n            d = Type.evaluate(p.visProp.infoboxdigits);\n            if (d === \"auto\") {\n                view.board.highlightCustomInfobox(\n                    \"(\" +\n                        Type.autoDigits(p.X()) +\n                        \" | \" +\n                        Type.autoDigits(p.Y()) +\n                        \" | \" +\n                        Type.autoDigits(p.Z()) +\n                        \")\",\n                    p\n                );\n            } else {\n                view.board.highlightCustomInfobox(\n                    \"(\" +\n                        Type.toFixed(p.X(), d) +\n                        \" | \" +\n                        Type.toFixed(p.Y(), d) +\n                        \" | \" +\n                        Type.toFixed(p.Z(), d) +\n                        \")\",\n                    p\n                );\n            }\n        } else {\n            view.board.highlightCustomInfobox(\"(\" + x + \", \" + y + \")\", el);\n        }\n    };\n\n    view.board.update();\n\n    return view;\n};\nJXG.registerElement(\"view3d\", JXG.createView3D);\n\nexport default JXG.View3D;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Carsten Miller,\n        Andreas Walter,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n/*global JXG:true, define: true*/\n\nimport JXG from \"../jxg\";\n\n/**\n * Constructs a new GeometryElement3D object.\n * @class This is the basic class for 3D geometry elements like Point3D and Line3D.\n * @constructor\n * @param {string} elType\n * @borrows JXG.EventEmitter#on as this.on\n * @borrows JXG.EventEmitter#off as this.off\n * @borrows JXG.EventEmitter#triggerEventHandlers as this.triggerEventHandlers\n * @borrows JXG.EventEmitter#eventHandlers as this.eventHandlers\n */\nJXG.GeometryElement3D = function (view, elType) {\n    this.elType = elType;\n    this.id = this.board.setId(this, elType);\n\n    /**\n     * Pointer to the view3D in which the elemtn is constructed\n     * @type JXG.View3D\n     * @private\n     */\n    this.view = view;\n\n    /**\n     * Link to the 2D element(s) used to visualize the 3D element\n     * in a view. In case, there are several 2D elements, it is an array.\n     *\n     * @type JXG.GeometryElement,Array\n     * @private\n     *\n     * @example\n     *   p.element2D;\n     */\n    this.element2D = null;\n\n    /**\n     * If this property exists (and is true) the element is a 3D element.\n     *\n     * @type Boolean\n     * @private\n     */\n    this.is3D = true;\n    this.view.objects[this.id] = this;\n    this.view.objectsList.push(this);\n\n    if (this.name !== \"\") {\n        this.view.elementsByName[this.name] = this;\n    }\n};\n\nexport default JXG.GeometryElement3D;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Carsten Miller,\n        Andreas Walter,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n/*global JXG:true, define: true*/\n\n/**\n * Create axes and rear and front walls of the\n * view3d bounding box bbox3D.\n */\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n// import Mat from \"../math/math\";\n// import Geometry from \"../math/geometry\";\n\nJXG.createAxes3D = function (board, parents, attributes) {\n    var view = parents[0],\n    directions = [\"x\", \"y\", \"z\"],\n    suffixAxis = \"Axis\",\n    sides = [\"Rear\", \"Front\"],\n    rear = [0, 0, 0], // x, y, z\n    front = [0, 0, 0], // x, y, z\n    i, j, k, i1, i2, attr, pos,\n    dir, dir1,\n    from, to, vec1, vec2,\n    range1, range2,\n    na, na_parent,\n    ticks_attr,\n    axes = {};\n\n    if (Type.exists(view.bbox3D)) {\n        for (i = 0; i < directions.length; i++) {\n            rear[i] = view.bbox3D[i][0];\n            front[i] = view.bbox3D[i][1];\n        }\n    } else {\n        for (i = 0; i < directions.length; i++) {\n            rear[i] = parents[1][i];\n            front[i] = parents[2][1];\n        }\n    }\n\n    // Main 3D axes\n    attr = Type.copyAttributes(attributes, board.options, \"axes3d\");\n    pos = attr.axesposition;\n    for (i = 0; i < directions.length; i++) {\n        // Run through ['x', 'y', 'z']\n        dir = directions[i];\n        na = dir + suffixAxis;\n\n        if (pos === \"center\") {\n            // Axes centered\n            from = [0, 0, 0];\n            to = [0, 0, 0];\n            to[i] = front[i];\n            axes[na] = view.create(\"axis3d\", [from, to], attr[na.toLowerCase()]);\n        } else {\n            na += \"Border\"; // Axes bordered\n            from = rear.slice();\n            to = front.slice();\n            if (i === 2) {\n                from[1] = front[1];\n                to[0] = rear[0];\n            } else {\n                from[i] = front[i];\n                to[2] = rear[2];\n            }\n            to[i] = front[i];\n            attr[na.toLowerCase()].lastArrow = false;\n            axes[na] = view.create(\"axis3d\", [from, to], attr[na.toLowerCase()]);\n\n            // TODO\n            ticks_attr = {\n                visible: true, // Für z-Ticks wird path nicht berechnet\n                minorTicks: 0,\n                tickEndings: [0, 1],\n                drawLabels: false\n            };\n            if (i === 2) {\n                ticks_attr.tickEndings = [1, 0];\n            }\n            axes[na + \"Ticks\"] = view.create(\"ticks\", [axes[na], 1], ticks_attr);\n        }\n    }\n\n    // Origin (2D point)\n    axes.O = view.create(\n        \"intersection\",\n        [axes[directions[0] + suffixAxis], axes[directions[1] + suffixAxis]],\n        {\n            name: \"\",\n            visible: false,\n            withLabel: false\n        }\n    );\n\n    // Front and rear planes\n    for (i = 0; i < directions.length; i++) {\n        // Run through ['x', 'y', 'z']\n        i1 = (i + 1) % 3;\n        i2 = (i + 2) % 3;\n\n        dir = directions[i];\n        for (j = 0; j < sides.length; j++) {\n            // Run through ['Rear', 'Front']\n\n            from = [0, 0, 0];\n            from[i] = j === 0 ? rear[i] : front[i];\n            vec1 = [0, 0, 0];\n            vec2 = [0, 0, 0];\n            vec1[i1] = 1;\n            vec2[i2] = 1;\n            range1 = [rear[i1], front[i1]];\n            range2 = [rear[i2], front[i2]];\n            na = dir + \"Plane\" + sides[j];\n\n            attr = Type.copyAttributes(attributes, board.options, \"axes3d\", na);\n            axes[na] = view.create(\"plane3d\", [from, vec1, vec2, range1, range2], attr);\n            axes[na].elType = \"axisplane3d\";\n        }\n    }\n\n    // Axes on front and rear planes\n    for (i = 0; i < directions.length; i++) {\n        // Run through ['x', 'y', 'z']\n        dir = directions[i];\n        for (j = 0; j < sides.length; j++) {\n            for (k = 1; k <= 2; k++) {\n                i1 = (i + k) % 3;\n                dir1 = directions[i1];\n                na = dir + \"Plane\" + sides[j] + dir1.toUpperCase() + \"Axis\";\n                na_parent = dir + \"Plane\" + sides[j];\n\n                from = [0, 0, 0];\n                to = [0, 0, 0];\n                from[i] = to[i] = j === 0 ? rear[i] : front[i];\n\n                from[i1] = rear[i1];\n                to[i1] = front[i1];\n\n                attr = Type.copyAttributes(attributes, board.options, \"axes3d\", na);\n                axes[na] = view.create(\"axis3d\", [from, to], attr);\n                axes[na_parent].addChild(axes[na]);\n                axes[na_parent].element2D.inherits.push(axes[na]); // TODO: Access of element2D is not nice\n            }\n        }\n    }\n\n    return axes;\n};\nJXG.registerElement(\"axes3d\", JXG.createAxes3D);\n\nJXG.createAxis3D = function (board, parents, attributes) {\n    var view = parents[0],\n        attr,\n        start = parents[1],\n        end = parents[2],\n        el_start,\n        el_end,\n        el;\n\n    // Use 2D points to create axis\n    attr = Type.copyAttributes(attributes.point1, board.options, \"axis3d\", \"point1\");\n    el_start = view.create(\n        \"point\",\n        [\n            (function (xx, yy, zz) {\n                return function () {\n                    return view.project3DTo2D(xx, yy, zz)[1];\n                };\n            })(start[0], start[1], start[2]),\n            (function (xx, yy, zz) {\n                return function () {\n                    return view.project3DTo2D(xx, yy, zz)[2];\n                };\n            })(start[0], start[1], start[2])\n        ],\n        attr\n    );\n\n    attr = Type.copyAttributes(attributes.point2, board.options, \"axis3d\", \"point2\");\n    el_end = view.create(\n        \"point\",\n        [\n            (function (xx, yy, zz) {\n                return function () {\n                    return view.project3DTo2D(xx, yy, zz)[1];\n                };\n            })(end[0], end[1], end[2]),\n            (function (xx, yy, zz) {\n                return function () {\n                    return view.project3DTo2D(xx, yy, zz)[2];\n                };\n            })(end[0], end[1], end[2])\n        ],\n        attr\n    );\n\n    attr = Type.copyAttributes(attributes, board.options, \"axis3d\");\n    el = view.create(\"arrow\", [el_start, el_end], attr);\n\n    return el;\n};\nJXG.registerElement(\"axis3d\", JXG.createAxis3D);\n\nJXG.createMesh3D = function (board, parents, attr) {\n    var view = parents[0],\n        point = parents[1],\n        dir1 = parents[2],\n        range1 = parents[3],\n        dir2 = parents[4],\n        range2 = parents[5],\n        el;\n\n    el = view.create(\"curve\", [[], []], attr);\n    el.updateDataArray = function () {\n        var s1 = range1[0],\n            e1 = range1[1],\n            s2 = range2[0],\n            e2 = range2[1],\n            l1,\n            l2,\n            res,\n            i,\n            sol,\n            v1 = [0, 0, 0],\n            v2 = [0, 0, 0],\n            step = 1,\n            q = [0, 0, 0];\n\n        this.dataX = [];\n        this.dataY = [];\n\n        if (Type.isFunction(point)) {\n            q = point().slice(1);\n        } else {\n            for (i = 0; i < 3; i++) {\n                q[i] = Type.evaluate(point[i]);\n            }\n        }\n        for (i = 0; i < 3; i++) {\n            v1[i] = Type.evaluate(dir1[i]);\n            v2[i] = Type.evaluate(dir2[i]);\n        }\n        l1 = JXG.Math.norm(v1, 3);\n        l2 = JXG.Math.norm(v2, 3);\n        for (i = 0; i < 3; i++) {\n            v1[i] /= l1;\n            v2[i] /= l2;\n        }\n\n        // sol = Mat.Geometry.getPlaneBounds(v1, v2, q, s1, e1);\n        // if (sol !== null) {\n        //     s1 = sol[0];\n        //     e1 = sol[1];\n        //     s2 = sol[2];\n        //     e2 = sol[3];\n        // }\n\n        res = view.getMesh(\n            [\n                function (u, v) {\n                    return q[0] + u * v1[0] + v * v2[0];\n                },\n                function (u, v) {\n                    return q[1] + u * v1[1] + v * v2[1];\n                },\n                function (u, v) {\n                    return q[2] + u * v1[2] + v * v2[2];\n                }\n            ],\n            [Math.ceil(s1), Math.floor(e1), (Math.ceil(e1) - Math.floor(s1)) / step],\n            [Math.ceil(s2), Math.floor(e2), (Math.ceil(e2) - Math.floor(s2)) / step]\n        );\n        this.dataX = res[0];\n        this.dataY = res[1];\n    };\n    return el;\n};\nJXG.registerElement(\"mesh3d\", JXG.createMesh3D);\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Carsten Miller,\n        Andreas Walter,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n/*global JXG:true, define: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Type from \"../utils/type\";\n//, GeometryElement3D) {\n\n/**\n * A 3D point is the basic geometric element.\n * @class Creates a new 3D point object. Do not use this constructor to create a 3D point. Use {@link JXG.View3D#create} with\n * type {@link Point3D} instead.\n * @augments JXG.GeometryElement3D\n * @augments JXG.GeometryElement\n * @param {JXG.View3D} view The 3D view the point is drawn on.\n * @param {Function,Array} F Array of numbers, array of functions or function returning an array with defines the user coordinates of the point.\n * @parame {JXG.GeometryElement3D} slide Object the 3D point should be bound to. If null, the point is a free point.\n * @param {Object} attributes An object containing visual properties like in {@link JXG.Options#point3d} and\n * {@link JXG.Options#elements}, and optional a name and an id.\n * @see JXG.Board#generateName\n */\nJXG.Point3D = function (view, F, slide, attributes) {\n    this.constructor(view.board, attributes, Const.OBJECT_TYPE_POINT3D, Const.OBJECT_CLASS_3D);\n    this.constructor3D(view, \"point3d\");\n\n    this.id = this.view.board.setId(this, \"P3D\");\n    this.board.finalizeAdding(this);\n\n    /**\n     * Homogeneous coordinates of a Point3D, i.e. array of length 4: [w, x, y, z]. Usually, w=1 for finite points and w=0 for points\n     * which are infinitely far.\n     *\n     * @example\n     *   p.coords;\n     *\n     * @name Point3D#coords\n     * @type Array\n     * @private\n     */\n    this.coords = [0, 0, 0, 0];\n\n    /**\n     * Function or array of functions or array of numbers defining the coordinates of the point, used in {@link updateCoords}.\n     *\n     * @name F\n     * @memberOf Point3D\n     * @function\n     * @private\n     *\n     * @see updateCoords\n     */\n    this.F = F;\n\n    /**\n     * Optional slide element, i.e. element the Point3D lives on.\n     *\n     * @example\n     *   p.slide;\n     *\n     * @name Point3D#slide\n     * @type JXG.GeometryElement3D\n     * @default null\n     * @private\n     *\n     */\n    this.slide = slide;\n\n    /**\n     * Get x-coordinate of a 3D point.\n     *\n     * @name X\n     * @memberOf Point3D\n     * @function\n     * @returns {Number}\n     *\n     * @example\n     *   p.X();\n     */\n    this.X = function () {\n        return this.coords[1];\n    };\n\n    /**\n     * Get y-coordinate of a 3D point.\n     *\n     * @name Y\n     * @memberOf Point3D\n     * @function\n     * @returns Number\n     *\n     * @example\n     *   p.Y();\n     */\n    this.Y = function () {\n        return this.coords[2];\n    };\n\n    /**\n     * Get z-coordinate of a 3D point.\n     *\n     * @name Z\n     * @memberOf Point3D\n     * @function\n     * @returns Number\n     *\n     * @example\n     *   p.Z();\n     */\n    this.Z = function () {\n        return this.coords[3];\n    };\n\n    /**\n     * Store the last position of the 2D point for the optimizer.\n     *\n     * @type Array\n     * @private\n     */\n    this._params = null;\n\n    this._c2d = null;\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        // TODO\n    });\n};\nJXG.Point3D.prototype = new JXG.GeometryElement();\nType.copyPrototypeMethods(JXG.Point3D, JXG.GeometryElement3D, \"constructor3D\");\n\nJXG.extend(\n    JXG.Point3D.prototype,\n    /** @lends JXG.Point3D.prototype */ {\n        /**\n         * Update the the homogeneous coords array.\n         *\n         * @name updateCoords\n         * @memberOf Point3D\n         * @function\n         * @returns {Object} Reference to the Point3D object\n         * @private\n         * @example\n         *    p.updateCoords();\n         */\n        updateCoords: function () {\n            var i;\n\n            if (Type.isFunction(this.F)) {\n                this.coords = [1].concat(Type.evaluate(this.F));\n            } else {\n                this.coords[0] = 1;\n                for (i = 0; i < 3; i++) {\n                    // Attention: if F is array of numbers, coords are not updated.\n                    // Otherwise, dragging will not work anymore.\n                    if (Type.isFunction(this.F[i])) {\n                        this.coords[i + 1] = Type.evaluate(this.F[i]);\n                    }\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Initialize the coords array.\n         *\n         * @private\n         * @returns {Object} Reference to the Point3D object\n         */\n        initCoords: function () {\n            var i;\n\n            if (Type.isFunction(this.F)) {\n                this.coords = [1].concat(Type.evaluate(this.F));\n            } else {\n                this.coords[0] = 1;\n                for (i = 0; i < 3; i++) {\n                    this.coords[i + 1] = Type.evaluate(this.F[i]);\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Normalize homogeneous coordinates such the the first coordinate (the w-coordinate is equal to 1 or 0)-\n         *\n         * @name normalizeCoords\n         * @memberOf Point3D\n         * @function\n         * @returns {Object} Reference to the Point3D object\n         * @private\n         * @example\n         *    p.normalizeCoords();\n         */\n        normalizeCoords: function () {\n            if (Math.abs(this.coords[0]) > Mat.eps) {\n                this.coords[1] /= this.coords[0];\n                this.coords[2] /= this.coords[0];\n                this.coords[3] /= this.coords[0];\n                this.coords[0] = 1.0;\n            }\n            return this;\n        },\n\n        /**\n         * Set the position of a 3D point.\n         *\n         * @name setPosition\n         * @memberOf Point3D\n         * @function\n         * @param {Array} coords 3D coordinates. Either of the form [x,y,z] (Euclidean) or [w,x,y,z] (homogeneous).\n         * @param {Boolean} [noevent] If true, no events are triggered.\n         * @returns {Object} Reference to the Point3D object\n         *\n         * @example\n         *    p.setPosition([1, 3, 4]);\n         */\n        setPosition: function (coords, noevent) {\n            var c = this.coords,\n                oc = this.coords.slice(); // Copy of original values\n\n            if (coords.length === 3) {\n                // Euclidean coordinates\n                c[0] = 1.0;\n                c[1] = coords[0];\n                c[2] = coords[1];\n                c[3] = coords[2];\n            } else {\n                // Homogeneous coordinates (normalized)\n                c[0] = coords[0];\n                c[1] = coords[1];\n                c[2] = coords[2];\n                c[3] = coords[2];\n                this.normalizeCoords();\n            }\n\n            // console.log(el.emitter, !noevent, oc[0] !== c[0] || oc[1] !== c[1] || oc[2] !== c[2] || oc[3] !== c[3]);\n            // Not yet working\n            // if (el.emitter && !noevent &&\n            //     (oc[0] !== c[0] || oc[1] !== c[1] || oc[2] !== c[2] || oc[3] !== c[3])) {\n            //     this.triggerEventHandlers(['update3D'], [oc]);\n            // }\n            return this;\n        },\n\n        update: function (drag) {\n            var c3d, foot;\n\n            // Update is called from two methods:\n            // Once in setToPosition and\n            // once in the subsequent board.update\n            if (\n                this.element2D.draggable() &&\n                Geometry.distance(this._c2d, this.element2D.coords.usrCoords) !== 0\n            ) {\n                if (this.slide) {\n                    this.projectCoords2Surface();\n                } else {\n                    // Drag the point in its xy plane\n                    foot = [1, 0, 0, this.coords[3]];\n                    c3d = this.view.project2DTo3DPlane(this.element2D, [1, 0, 0, 1], foot);\n                    if (c3d[0] !== 0) {\n                        this.coords = this.view.project3DToCube(c3d);\n                    }\n                }\n            } else {\n                this.updateCoords();\n                // Update 2D point from its 3D view\n                this.element2D.coords.setCoordinates(\n                    Const.COORDS_BY_USER,\n                    this.view.project3DTo2D([1, this.X(), this.Y(), this.Z()])\n                );\n            }\n            this._c2d = this.element2D.coords.usrCoords.slice();\n\n            return this;\n        },\n\n        updateRenderer: function () {\n            this.needsUpdate = false;\n            return this;\n        },\n\n        projectCoords2Surface: function () {\n            var n = 2, // # of variables\n                m = 2, // number of constraints\n                x = [0, 0],\n                // Various Cobyla constants, see Cobyla docs in Cobyja.js\n                rhobeg = 5.0,\n                rhoend = 1.0e-6,\n                iprint = 0,\n                maxfun = 200,\n                surface = this.slide,\n                that = this,\n                r,\n                c3d,\n                c2d,\n                _minFunc;\n\n            if (surface === null) {\n                return;\n            }\n\n            _minFunc = function (n, m, x, con) {\n                var c3d = [\n                        1,\n                        surface.X(x[0], x[1]),\n                        surface.Y(x[0], x[1]),\n                        surface.Z(x[0], x[1])\n                    ],\n                    c2d = that.view.project3DTo2D(c3d);\n\n                con[0] = that.element2D.X() - c2d[1];\n                con[1] = that.element2D.Y() - c2d[2];\n\n                return con[0] * con[0] + con[1] * con[1];\n            };\n            if (Type.exists(this._params)) {\n                x = this._params.slice();\n            }\n            r = Mat.Nlp.FindMinimum(_minFunc, n, m, x, rhobeg, rhoend, iprint, maxfun);\n\n            c3d = [1, surface.X(x[0], x[1]), surface.Y(x[0], x[1]), surface.Z(x[0], x[1])];\n            c2d = this.view.project3DTo2D(c3d);\n            this._params = x;\n            this.coords = c3d;\n            this.element2D.coords.setCoordinates(Const.COORDS_BY_USER, c2d);\n            this._c2d = c2d;\n        },\n\n        // Not yet working\n        __evt__update3D: function (oc) {}\n    }\n);\n\n/**\n * @class This element is used to provide a constructor for a 3D Point.\n * @pseudo\n * @description A Point3D object is defined by 3 coordinates [x,y,z].\n * <p>\n * All numbers can also be provided as functions returning a number.\n *\n * @name Point3D\n * @augments JXG.Point3D\n * @constructor\n * @throws {Exception} If the element cannot be constructed with the given parent\n * objects an exception is thrown.\n * @param {number,function_number,function_number,function} x,y,z The coordinates are given as x, y, z consisting of numbers of functions.\n * @param {array,function} F Alternatively, the coordinates can be supplied as\n *  <ul>\n *   <li>array arr=[x,y,z] of length 3 consisting of numbers or\n *   <li>function returning an array [x,y,z] of length 3 of numbers.\n * </ul>\n *\n * @example\n *    var bound = [-5, 5];\n *    var view = board.create('view3d',\n *        [[-6, -3], [8, 8],\n *        [bound, bound, bound]],\n *        {});\n *    var p = view.create('point3d', [1, 2, 2], { name:'A', size: 5 });\n *    var q = view.create('point3d', function() { return [p.X(), p.Y(), p.Z() - 3]; }, { name:'B', size: 5, fixed: true });\n *\n * </pre><div id=\"JXGb9ee8f9f-3d2b-4f73-8221-4f82c09933f1\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGb9ee8f9f-3d2b-4f73-8221-4f82c09933f1',\n *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});\n *         var bound = [-5, 5];\n *         var view = board.create('view3d',\n *             [[-6, -3], [8, 8],\n *             [bound, bound, bound]],\n *             {});\n *         var p = view.create('point3d', [1, 2, 2], { name:'A', size: 5 });\n *         var q = view.create('point3d', function() { return [p.X(), p.Y(), p.Z() - 3]; }, { name:'B', size: 5 });\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createPoint3D = function (board, parents, attributes) {\n    //   parents[0]: view\n    // followed by\n    //   parents[1]: function or array\n    // or\n    //   parents[1..3]: coordinates\n\n    var view = parents[0],\n        attr,\n        F,\n        slide,\n        c2d,\n        el;\n\n    // If the last element of parents is a 3D object,\n    // the point is a glider on that element.\n    if (parents.length > 2 && Type.exists(parents[parents.length - 1].is3D)) {\n        slide = parents.pop();\n    } else {\n        slide = null;\n    }\n\n    if (parents.length === 2) {\n        // [view, array|fun] (Array [x, y, z] | function) returning [x, y, z]\n        F = parents[1];\n    } else if (parents.length === 4) {\n        // [view, x, y, z], (3 numbers | functions)\n        F = parents.slice(1);\n    } else {\n        throw new Error(\n            \"JSXGraph: Can't create point3d with parent types '\" +\n                typeof parents[0] +\n                \"' and '\" +\n                typeof parents[1] +\n                \"'.\" +\n                \"\\nPossible parent types: [[x,y,z]], [x,y,z]\"\n        );\n        //  \"\\nPossible parent types: [[x,y,z]], [x,y,z], [element,transformation]\"); // TODO\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"point3d\");\n    el = new JXG.Point3D(view, F, slide, attr);\n    el.initCoords();\n\n    c2d = view.project3DTo2D(el.coords);\n\n    attr.name = el.name;\n    el.element2D = view.create(\"point\", c2d, attr);\n    el.addChild(el.element2D);\n    el.inherits.push(el.element2D);\n    el.element2D.setParents(el);\n\n    el._c2d = el.element2D.coords.usrCoords.slice(); // Store a copy of the coordinates to detect dragging\n\n    return el;\n};\n\nJXG.registerElement(\"point3d\", JXG.createPoint3D);\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Carsten Miller,\n        Andreas Walter,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n/*global JXG:true, define: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Type from \"../utils/type\";\n\n/**\n * Constructor for 3D curves.\n * @class Creates a new 3D curve object. Do not use this constructor to create a 3D curve. Use {@link JXG.View3D#create} with type {@link Curve3D} instead.\n *\n * @augments JXG.GeometryElement3D\n * @augments JXG.GeometryElement\n * @param {View3D} view\n * @param {Function} F\n * @param {Function} X\n * @param {Function} Y\n * @param {Function} Z\n * @param {Array} range\n * @param {Object} attributes\n * @see JXG.Board#generateName\n */\nJXG.Curve3D = function (view, F, X, Y, Z, range, attributes) {\n    this.constructor(view.board, attributes, Const.OBJECT_TYPE_CURVE3D, Const.OBJECT_CLASS_3D);\n    this.constructor3D(view, \"surface3d\");\n\n    this.id = this.view.board.setId(this, \"S3D\");\n    this.board.finalizeAdding(this);\n\n    this.F = F;\n\n    /**\n     * Function which maps u to x; i.e. it defines the x-coordinate of the curve\n     * @function\n     * @returns Number\n     */\n    this.X = X;\n\n    /**\n     * Function which maps u to y; i.e. it defines the y-coordinate of the curve\n     * @function\n     * @returns Number\n     */\n    this.Y = Y;\n\n    /**\n     * Function which maps u to z; i.e. it defines the x-coordinate of the curve\n     * @function\n     * @returns Number\n     */\n    this.Z = Z;\n\n    if (this.F !== null) {\n        this.X = function (u) {\n            return this.F(u)[0];\n        };\n        this.Y = function (u) {\n            return this.F(u)[1];\n        };\n        this.Z = function (u) {\n            return this.F(u)[2];\n        };\n    }\n\n    this.range = range;\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        // TODO\n    });\n};\nJXG.Curve3D.prototype = new JXG.GeometryElement();\nType.copyPrototypeMethods(JXG.Curve3D, JXG.GeometryElement3D, \"constructor3D\");\n\nJXG.extend(\n    JXG.Curve3D.prototype,\n    /** @lends JXG.Curve3D.prototype */ {\n        updateDataArray: function () {\n            var steps = Type.evaluate(this.visProp.numberpointshigh),\n                r,\n                s,\n                e,\n                delta,\n                c2d,\n                u,\n                dataX,\n                dataY,\n                p = [0, 0, 0];\n\n            dataX = [];\n            dataY = [];\n\n            if (Type.isArray(this.X)) {\n                steps = this.X.length;\n                for (u = 0; u < steps; u++) {\n                    p = [this.X[u], this.Y[u], this.Z[u]];\n                    c2d = this.view.project3DTo2D(p);\n                    dataX.push(c2d[1]);\n                    dataY.push(c2d[2]);\n                }\n            } else {\n                r = Type.evaluate(this.range);\n                s = Type.evaluate(r[0]);\n                e = Type.evaluate(r[1]);\n                delta = (e - s) / (steps - 1);\n                for (u = s; u <= e; u += delta) {\n                    if (this.F !== null) {\n                        p = this.F(u);\n                    } else {\n                        p = [this.X(u), this.Y(u), this.Z(u)];\n                    }\n                    c2d = this.view.project3DTo2D(p);\n                    dataX.push(c2d[1]);\n                    dataY.push(c2d[2]);\n                }\n            }\n            return { X: dataX, Y: dataY };\n        },\n\n        update: function () {\n            return this;\n        },\n\n        updateRenderer: function () {\n            this.needsUpdate = false;\n            return this;\n        }\n    }\n);\n\n/**\n * @class This element creates a 3D parametric curves.\n * @pseudo\n * @description A 3D parametric curve is defined by a function\n *    <i>F: R<sup>1</sup> &rarr; R<sup>3</sup></i>.\n *\n * @name Curve3D\n * @augments Curve\n * @constructor\n * @type Object\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Function_Function_Function_Array,Function} F<sub>X</sub>,F<sub>Y</sub>,F<sub>Z</sub>,range\n * F<sub>X</sub>(u), F<sub>Y</sub>(u), F<sub>Z</sub>(u) are functions returning a number, range is the array containing\n * lower and upper bound for the range of the parameter u. range may also be a function returning an array of length two.\n * @param {Function_Array,Function} F,range Alternatively: F<sub>[X,Y,Z]</sub>(u) a function returning an array [x,y,z] of\n * numbers, range as above.\n * @param {Array_Array_Array} X,Y,Z Three arrays containing the coordinate points which define the curve.\n */\nJXG.createCurve3D = function (board, parents, attributes) {\n    var view = parents[0],\n        F,\n        X,\n        Y,\n        Z,\n        range,\n        attr,\n        el;\n\n    if (parents.length === 3) {\n        F = parents[1];\n        range = parents[2];\n        X = null;\n        Y = null;\n        Z = null;\n    } else {\n        X = parents[1];\n        Y = parents[2];\n        Z = parents[3];\n        range = parents[4];\n        F = null;\n    }\n    // TODO Throw error\n\n    attr = Type.copyAttributes(attributes, board.options, \"curve3d\");\n    el = new JXG.Curve3D(view, F, X, Y, Z, range, attr);\n\n    el.element2D = board.create(\"curve\", [[], []], attr);\n    el.element2D.updateDataArray = function () {\n        var ret = el.updateDataArray();\n        this.dataX = ret.X;\n        this.dataY = ret.Y;\n    };\n    el.addChild(el.element2D);\n    el.inherits.push(el.element2D);\n    el.element2D.setParents(el);\n\n    el.element2D.prepareUpdate().update();\n    if (!board.isSuspendedUpdate) {\n        el.element2D.updateVisibility().updateRenderer();\n    }\n\n    return el;\n};\nJXG.registerElement(\"curve3d\", JXG.createCurve3D);\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Carsten Miller,\n        Andreas Walter,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n/*global JXG:true, define: true*/\n\n/**\n * Create linear spaces of dimension at least one,\n * i.e. lines and planes.\n */\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Type from \"../utils/type\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\n\n// -----------------------\n//  Lines\n// -----------------------\n\n/**\n * Constructor for 3D lines.\n * @class Creates a new 3D line object. Do not use this constructor to create a 3D line. Use {@link JXG.View3D#create} with type {@link Line3D} instead.\n *\n * @augments JXG.GeometryElement3D\n * @augments JXG.GeometryElement\n * @param {View3D} view\n * @param {Point3D|Array} point\n * @param {Array} direction\n * @param {Array} range\n * @param {Object} attributes\n * @see JXG.Board#generateName\n */\nJXG.Line3D = function (view, point, direction, range, attributes) {\n    this.constructor(view.board, attributes, Const.OBJECT_TYPE_LINE3D, Const.OBJECT_CLASS_3D);\n    this.constructor3D(view, \"line3d\");\n\n    this.id = this.view.board.setId(this, \"L3D\");\n    this.board.finalizeAdding(this);\n\n    /**\n     * 3D point which - together with a direction - defines the line.\n     * @type JXG.Point3D\n     *\n     * @see JXG.Line3D#direction\n     */\n    this.point = point;\n\n    /**\n     * Direction which - together with a point - defines the line. Array of numbers or functions (of length 3) or function\n     * returning array of length 3.\n     *\n     * @type Array,Function\n     * @see JXG.Line3D#point\n     */\n    this.direction = direction;\n\n    /**\n     * Range [r1, r2] of the line. r1, r2 can be numbers or functions.\n     * The 3D line goes from (point + r1 * direction) to (point + r2 * direction)\n     * @type Array\n     */\n    this.range = range || [-Infinity, Infinity];\n\n    /**\n     * Starting point of the 3D line\n     * @type JXG.Point3D\n     * @private\n     */\n    this.point1 = null;\n\n    /**\n     * End point of the 3D line\n     * @type JXG.Point3D\n     * @private\n     */\n    this.point2 = null;\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        // TODO\n    });\n};\nJXG.Line3D.prototype = new JXG.GeometryElement();\nType.copyPrototypeMethods(JXG.Line3D, JXG.GeometryElement3D, \"constructor3D\");\n\nJXG.extend(\n    JXG.Line3D.prototype,\n    /** @lends JXG.Line3D.prototype */ {\n        /**\n         * Determine one end point of a 3D line from point, direction and range.\n         *\n         * @param {Number|function} r\n         * @private\n         * @returns Array\n         */\n        getPointCoords: function (r) {\n            var p = [],\n                d = [],\n                i,\n                r0;\n\n            p = [this.point.X(), this.point.Y(), this.point.Z()];\n\n            if (Type.isFunction(this.direction)) {\n                d = this.direction();\n            } else {\n                for (i = 1; i < 4; i++) {\n                    d.push(Type.evaluate(this.direction[i]));\n                }\n            }\n\n            r0 = Type.evaluate(r);\n            // TODO: test also in the finite case\n            if (Math.abs(r0) === Infinity) {\n                r = this.view.intersectionLineCube(p, d, r0);\n            }\n\n            return [p[0] + d[0] * r0, p[1] + d[1] * r0, p[2] + d[2] * r0];\n        },\n\n        update: function () {\n            return this;\n        },\n\n        updateRenderer: function () {\n            this.needsUpdate = false;\n            return this;\n        }\n    }\n);\n\n/**\n * @class This element is used to provide a constructor for a 3D line.\n * @pseudo\n * @description There are two possibilities to create a Line3D object.\n * <p>\n * First: the line in 3D is defined by two points in 3D (Point3D).\n * The points can be either existing points or coordinate arrays of\n * the form [x, y, z].\n * <p>Second: the line in 3D is defined by a point (or coordinate array [x, y, z])\n * a direction given as array [x, y, z] and an optional range\n * given as array [s, e]. The default value for the range is [-Infinity, Infinity].\n * <p>\n * All numbers can also be provided as functions returning a number.\n *\n * @name Line3D\n * @augments JXG.GeometryElement3D\n * @constructor\n * @type JXG.Line3D\n * @throws {Exception} If the element cannot be constructed with the given parent\n * objects an exception is thrown.\n * @param {JXG.Point3D,array,function_JXG.Point3D,array,function} point1,point2 First and second defining point.\n * @param {JXG.Point3D,array,function_array,function_array,function} point,direction,range Alternatively, point, direction and range can be supplied.\n * <ul>\n * <li> point: Point3D or array of length 3\n * <li> direction: array of length 3 or function returning an array of numbers or function returning an array\n * <li> range: array of length 2, elements can also be functions.\n * </ul>\n *\n * @example\n *     var bound = [-5, 5];\n *     var view = board.create('view3d',\n *         [[-6, -3], [8, 8],\n *         [bound, bound, bound]],\n *         {});\n *     var p = view.create('point3d', [1, 2, 2], { name:'A', size: 5 });\n *     // Lines through 2 points\n *     var l1 = view.create('line3d', [[1, 3, 3], [-3, -3, -3]], {point1: {visible: true}, point2: {visible: true} });\n *     var l2 = view.create('line3d', [p, l1.point1]);\n *\n *     // Line by point, direction, range\n *     var l3 = view.create('line3d', [p, [0, 0, 1], [-2, 4]]);\n *\n * </pre><div id=\"JXG05f9baa4-6059-4502-8911-6a934f823b3d\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG05f9baa4-6059-4502-8911-6a934f823b3d',\n *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});\n *         var bound = [-5, 5];\n *         var view = board.create('view3d',\n *             [[-6, -3], [8, 8],\n *             [bound, bound, bound]],\n *             {});\n *         var p = view.create('point3d', [1, 2, 2], { name:'A', size: 5 });\n *         // Lines through 2 points\n *         var l1 = view.create('line3d', [[1, 3, 3], [-3, -3, -3]], {name: 'll1', point1: {visible: true}, point2: {visible: true} });\n *         var l2 = view.create('line3d', [p, l1.point1]);\n *         // Line by point, direction, range\n *         var l3 = view.create('line3d', [p, [0, 0, 1], [-2, 4]]);\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createLine3D = function (board, parents, attributes) {\n    var view = parents[0],\n        attr,\n        points,\n        point,\n        direction,\n        range,\n        point1,\n        point2,\n        el;\n\n    attr = Type.copyAttributes(attributes, board.options, \"line3d\");\n\n    // In any case, parents[1] contains a point or point coordinates\n    point = Type.providePoints3D(view, [parents[1]], attributes, \"line3d\", [\"point\"])[0];\n\n    if (\n        Type.isPoint3D(parents[2]) ||\n        (parents.length === 3 && (Type.isArray(parents[2]) || Type.isFunction(parents[2])))\n    ) {\n        // Line defined by two points; [view, point1, point2]\n\n        point1 = point;\n        point2 = Type.providePoints3D(view, [parents[2]], attributes, \"line3d\", [\"point2\"])[0];\n        direction = function () {\n            return [point2.X() - point.X(), point2.Y() - point.Y(), point2.Z() - point.Z()];\n        };\n        range = [0, 1];\n        el = new JXG.Line3D(view, point, direction, range, attr);\n    } else {\n        // Line defined by point, direction and range\n\n        // Directions are handled as arrays of length 4,\n        // i.e. with homogeneous coordinates.\n        if (Type.isFunction(parents[2])) {\n            direction = parents[2];\n        } else if (parents[2].length === 3) {\n            direction = [1].concat(parents[2]);\n        } else if (parents[2].length === 4) {\n            direction = parents[2];\n        } else {\n            // TODO Throw error\n        }\n        range = parents[3];\n\n        points = Type.providePoints3D(\n            view,\n            [\n                [0, 0, 0],\n                [0, 0, 0]\n            ],\n            attributes,\n            \"line3d\",\n            [\"point1\", \"point2\"]\n        );\n\n        // Create a line3d with two dummy points\n        el = new JXG.Line3D(view, point, direction, range, attr);\n\n        // Now set the real points which define the line\n        /** @ignore */\n        points[0].F = function () {\n            return el.getPointCoords(Type.evaluate(el.range[0]));\n        };\n        points[0].prepareUpdate().update();\n        point1 = points[0];\n\n        /** @ignore */\n        points[1].F = function () {\n            return el.getPointCoords(Type.evaluate(el.range[1]));\n        };\n        points[1].prepareUpdate().update();\n        point2 = points[1];\n    }\n    // TODO Throw error\n\n    el.element2D = view.create(\"segment\", [point1.element2D, point2.element2D], attr);\n    el.addChild(el.element2D);\n    el.inherits.push(el.element2D);\n    el.element2D.setParents(el);\n\n    point1.addChild(el);\n    point2.addChild(el);\n    el.point1 = point1;\n    el.point2 = point2;\n\n    el.update();\n    el.element2D.prepareUpdate().update().updateRenderer();\n    return el;\n};\nJXG.registerElement(\"line3d\", JXG.createLine3D);\n\n// -----------------------\n//  Planes\n// -----------------------\n\n/**\n * Constructor for 3D planes.\n * @class Creates a new 3D plane object. Do not use this constructor to create a 3D plane. Use {@link JXG.Board#create} with type {@link Plane3D} instead.\n *\n * @augments JXG.GeometryElement3D\n * @augments JXG.GeometryElement\n * @param {View3D} view\n * @param {Point3D,Array} point\n * @param {Array} direction1\n * @param {Array} range1\n * @param {Array} direction2\n * @param {Array} range2\n * @param {Object} attributes\n * @see JXG.Board#generateName\n */\nJXG.Plane3D = function (view, point, dir1, range1, dir2, range2, attributes) {\n    this.constructor(view.board, attributes, Const.OBJECT_TYPE_PLANE3D, Const.OBJECT_CLASS_3D);\n    this.constructor3D(view, \"plane3d\");\n\n    this.id = this.view.board.setId(this, \"PL3D\");\n    this.board.finalizeAdding(this);\n\n    /**\n     * 3D point which - together with two direction vectors - defines the plane.\n     *\n     * @type JXG.Point3D\n     *\n     * @see JXG.3D#direction1\n     * @see JXG.3D#direction2\n     */\n    this.point = point;\n\n    /**\n     * Two linearly independent vectors - together with a point - define the plane. Each of these direction vectors is an\n     * array of numbers or functions (of length 3) or function returning array of length 3.\n     *\n     * @type Array,Function\n     *\n     * @see JXG.Plane3D#point\n     * @see JXG.Plane3D#direction2\n     */\n    this.direction1 = dir1;\n\n    /**\n     * Two linearly independent vectors - together with a point - define the plane. Each of these direction vectors is an\n     * array of numbers or functions (of length 3) or function returning array of length 3.\n     *\n     * @type Array,Function\n     * @see JXG.Plane3D#point\n     * @see JXG.Plane3D#direction1\n     */\n    this.direction2 = dir2;\n\n    /**\n     * Range [r1, r2] of {@link direction1}. The 3D line goes from (point + r1 * direction1) to (point + r2 * direction1)\n     * @type {Array}\n     */\n    this.range1 = range1 || [-Infinity, Infinity];\n\n    /**\n     * Range [r1, r2] of {@link direction2}. The 3D line goes from (point + r1 * direction2) to (point + r2 * direction2)\n     * @type {Array}\n     */\n    this.range2 = range2 || [-Infinity, Infinity];\n\n    /**\n     * Direction vector 1 of the 3D plane. Contains the evaluated coordinates from {@link direction1} and {@link range1}.\n     * @type Array\n     * @private\n     *\n     * @see updateNormal\n     */\n    this.vec1 = [0, 0, 0];\n\n    /**\n     * Direction vector 2 of the 3D plane. Contains the evaluated coordinates from {@link direction2} and {@link range2}.\n     *\n     * @type Array\n     * @private\n     *\n     * @see updateNormal\n     */\n    this.vec2 = [0, 0, 0];\n\n    this.grid = null;\n\n    /**\n         * Normal vector of the plane. Left hand side of the Hesse normal form.\n\n        * @type Array\n         * @private\n         *\n         * @see updateNormal\n         *\n         */\n    this.normal = [0, 0, 0];\n\n    /**\n         * Right hand side of the Hesse normal form.\n\n        * @type Array\n         * @private\n         *\n         * @see updateNormal\n         *\n         */\n    this.d = 0;\n\n    this.updateNormal();\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        // TODO\n    });\n};\nJXG.Plane3D.prototype = new JXG.GeometryElement();\nType.copyPrototypeMethods(JXG.Plane3D, JXG.GeometryElement3D, \"constructor3D\");\n\nJXG.extend(\n    JXG.Plane3D.prototype,\n    /** @lends JXG.Plane3D.prototype */ {\n        /**\n         * Update the Hesse normal form of the plane, i.e. update normal vector and right hand side.\n         * Updates also {@link vec1} and {@link vec2}.\n         *\n         * @name JXG.Plane3D#updateNormal\n         * @function\n         * @returns {Object} Reference to the Plane3D object\n         * @private\n         * @example\n         *    plane.updateNormal();\n         *\n         */\n        updateNormal: function () {\n            var i, len;\n            for (i = 0; i < 3; i++) {\n                this.vec1[i] = Type.evaluate(this.direction1[i]);\n                this.vec2[i] = Type.evaluate(this.direction2[i]);\n            }\n\n            this.normal = Mat.crossProduct(this.vec1, this.vec2);\n\n            len = Mat.norm(this.normal);\n            if (Math.abs(len) > Mat.eps) {\n                for (i = 0; i < 3; i++) {\n                    this.normal[i] /= len;\n                }\n            }\n            this.d = Mat.innerProduct(this.point.coords.slice(1), this.normal, 3);\n\n            return this;\n        },\n\n        updateDataArray: function () {\n            var s1,\n                e1,\n                s2,\n                e2,\n                c2d,\n                l1,\n                l2,\n                planes = [\"xPlaneRear\", \"yPlaneRear\", \"zPlaneRear\"],\n                points = [],\n                v1 = [0, 0, 0],\n                v2 = [0, 0, 0],\n                q = [0, 0, 0],\n                p = [0, 0, 0],\n                d,\n                i,\n                j,\n                a,\n                b,\n                first,\n                pos,\n                pos_akt,\n                view = this.view;\n\n            this.dataX = [];\n            this.dataY = [];\n\n            this.updateNormal();\n\n            // Infinite plane\n            if (\n                this.elType !== \"axisplane3d\" &&\n                view.defaultAxes &&\n                Type.evaluate(this.range1[0]) === -Infinity &&\n                Type.evaluate(this.range1[1]) === Infinity &&\n                Type.evaluate(this.range2[0]) === -Infinity &&\n                Type.evaluate(this.range2[1]) === Infinity\n            ) {\n                // Start with the rear plane.\n                // Determine the intersections with the view bbox3d\n                // For each face of the bbox3d we determine two points\n                // which are the ends of the intersection line.\n                // We start with the three rear planes.\n                for (j = 0; j < planes.length; j++) {\n                    p = view.intersectionPlanePlane(this, view.defaultAxes[planes[j]]);\n\n                    if (p[0].length === 3 && p[1].length === 3) {\n                        // This test is necessary to filter out intersection lines which are\n                        // identical to intersections of axis planes (they would occur twice).\n                        for (i = 0; i < points.length; i++) {\n                            if (\n                                (Geometry.distance(p[0], points[i][0], 3) < Mat.eps &&\n                                    Geometry.distance(p[1], points[i][1], 3) < Mat.eps) ||\n                                (Geometry.distance(p[0], points[i][1], 3) < Mat.eps &&\n                                    Geometry.distance(p[1], points[i][0], 3) < Mat.eps)\n                            ) {\n                                break;\n                            }\n                        }\n                        if (i === points.length) {\n                            points.push(p.slice());\n                        }\n                    }\n\n                    // Point on the front plane of the bbox3d\n                    p = [0, 0, 0];\n                    p[j] = view.bbox3D[j][1];\n\n                    // d is the rhs of the Hesse normal form of the front plane.\n                    d = Mat.innerProduct(p, view.defaultAxes[planes[j]].normal, 3);\n                    p = view.intersectionPlanePlane(this, view.defaultAxes[planes[j]], d);\n\n                    if (p[0].length === 3 && p[1].length === 3) {\n                        // Do the same test as above\n                        for (i = 0; i < points.length; i++) {\n                            if (\n                                (Geometry.distance(p[0], points[i][0], 3) < Mat.eps &&\n                                    Geometry.distance(p[1], points[i][1], 3) < Mat.eps) ||\n                                (Geometry.distance(p[0], points[i][1], 3) < Mat.eps &&\n                                    Geometry.distance(p[1], points[i][0], 3) < Mat.eps)\n                            ) {\n                                break;\n                            }\n                        }\n                        if (i === points.length) {\n                            points.push(p.slice());\n                        }\n                    }\n                }\n\n                // Concatenate the intersection points to a polygon.\n                // If all wents well, each intersection should appear\n                // twice in the list.\n                first = 0;\n                pos = first;\n                i = 0;\n                do {\n                    p = points[pos][i];\n                    if (p.length === 3) {\n                        c2d = view.project3DTo2D(p);\n                        this.dataX.push(c2d[1]);\n                        this.dataY.push(c2d[2]);\n                    }\n                    i = (i + 1) % 2;\n                    p = points[pos][i];\n\n                    pos_akt = pos;\n                    for (j = 0; j < points.length; j++) {\n                        if (j !== pos && Geometry.distance(p, points[j][0]) < Mat.eps) {\n                            pos = j;\n                            i = 0;\n                            break;\n                        }\n                        if (j !== pos && Geometry.distance(p, points[j][1]) < Mat.eps) {\n                            pos = j;\n                            i = 1;\n                            break;\n                        }\n                    }\n                    if (pos === pos_akt) {\n                        console.log(\"Error: update plane3d: did not find next\", pos);\n                        break;\n                    }\n                } while (pos !== first);\n\n                c2d = view.project3DTo2D(points[first][0]);\n                this.dataX.push(c2d[1]);\n                this.dataY.push(c2d[2]);\n            } else {\n                // 3D bounded flat\n                s1 = Type.evaluate(this.range1[0]);\n                e1 = Type.evaluate(this.range1[1]);\n                s2 = Type.evaluate(this.range2[0]);\n                e2 = Type.evaluate(this.range2[1]);\n\n                q = this.point.coords.slice(1);\n\n                v1 = this.vec1.slice();\n                v2 = this.vec2.slice();\n                l1 = Mat.norm(v1, 3);\n                l2 = Mat.norm(v2, 3);\n                for (i = 0; i < 3; i++) {\n                    v1[i] /= l1;\n                    v2[i] /= l2;\n                }\n\n                for (j = 0; j < 4; j++) {\n                    switch (j) {\n                        case 0:\n                            a = s1;\n                            b = s2;\n                            break;\n                        case 1:\n                            a = e1;\n                            b = s2;\n                            break;\n                        case 2:\n                            a = e1;\n                            b = e2;\n                            break;\n                        case 3:\n                            a = s1;\n                            b = e2;\n                    }\n                    for (i = 0; i < 3; i++) {\n                        p[i] = q[i] + a * v1[i] + b * v2[i];\n                    }\n                    c2d = view.project3DTo2D(p);\n                    this.dataX.push(c2d[1]);\n                    this.dataY.push(c2d[2]);\n                }\n                // Close the curve\n                this.dataX.push(this.dataX[0]);\n                this.dataY.push(this.dataY[0]);\n            }\n            return { X: this.dataX, Y: this.dataY };\n        },\n\n        update: function () {\n            return this;\n        },\n\n        updateRenderer: function () {\n            this.needsUpdate = false;\n            return this;\n        }\n    }\n);\n\n// TODO docs\nJXG.createPlane3D = function (board, parents, attributes) {\n    var view = parents[0],\n        attr,\n        point,\n        dir1 = parents[2],\n        dir2 = parents[3],\n        range1 = parents[4] || [-Infinity, Infinity],\n        range2 = parents[5] || [-Infinity, Infinity],\n        el,\n        grid;\n\n    point = Type.providePoints3D(view, [parents[1]], attributes, \"plane3d\", [\"point\"])[0];\n    if (point === false) {\n        // TODO Throw error\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"plane3d\");\n    el = new JXG.Plane3D(view, point, dir1, range1, dir2, range2, attr);\n    point.addChild(el);\n\n    el.element2D = view.create(\"curve\", [[], []], attr);\n    el.element2D.updateDataArray = function () {\n        var ret = el.updateDataArray();\n        this.dataX = ret.X;\n        this.dataY = ret.Y;\n    };\n    el.addChild(el.element2D);\n    el.inherits.push(el.element2D);\n    el.element2D.setParents(el);\n\n    attr = Type.copyAttributes(attributes.mesh3d, board.options, \"mesh3d\");\n    if (\n        Math.abs(el.range1[0]) !== Infinity &&\n        Math.abs(el.range1[1]) !== Infinity &&\n        Math.abs(el.range2[0]) !== Infinity &&\n        Math.abs(el.range2[1]) !== Infinity\n    ) {\n        grid = view.create(\n            \"mesh3d\",\n            [\n                function () {\n                    return point.coords;\n                },\n                dir1,\n                range1,\n                dir2,\n                range2\n            ],\n            attr\n        );\n        el.grid = grid;\n        el.addChild(grid);\n        el.inherits.push(grid);\n        grid.setParents(el);\n    }\n\n    el.element2D.prepareUpdate().update();\n    if (!board.isSuspendedUpdate) {\n        el.element2D.updateVisibility().updateRenderer();\n    }\n\n    return el;\n};\nJXG.registerElement(\"plane3d\", JXG.createPlane3D);\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Carsten Miller,\n        Andreas Walter,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n/*global JXG:true, define: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Type from \"../utils/type\";\n\n/**\n * Constructor for 3D surfaces.\n * @class Creates a new 3D surface object. Do not use this constructor to create a 3D surface. Use {@link JXG.View3D#create} with type {@link Surface3D} instead.\n *\n * @augments JXG.GeometryElement3D\n * @augments JXG.GeometryElement\n * @param {View3D} view\n * @param {Function} F\n * @param {Function} X\n * @param {Function} Y\n * @param {Function} Z\n * @param {Array} range_u\n * @param {Array} range_v\n * @param {Object} attributes\n * @see JXG.Board#generateName\n */\nJXG.Surface3D = function (view, F, X, Y, Z, range_u, range_v, attributes) {\n    this.constructor(\n        view.board,\n        attributes,\n        Const.OBJECT_TYPE_SURFACE3D,\n        Const.OBJECT_CLASS_3D\n    );\n    this.constructor3D(view, \"surface3d\");\n\n    this.id = this.view.board.setId(this, \"S3D\");\n    this.board.finalizeAdding(this);\n\n    this.F = F;\n\n    /**\n     * Function which maps (u, v) to x; i.e. it defines the x-coordinate of the surface\n     * @function\n     * @returns Number\n     */\n    this.X = X;\n\n    /**\n     * Function which maps (u, v) to y; i.e. it defines the y-coordinate of the surface\n     * @function\n     * @returns Number\n     */\n    this.Y = Y;\n\n    /**\n     * Function which maps (u, v) to z; i.e. it defines the x-coordinate of the surface\n     * @function\n     * @returns Number\n     */\n    this.Z = Z;\n\n    if (this.F !== null) {\n        this.X = function (u, v) {\n            return this.F(u, v)[0];\n        };\n        this.Y = function (u, v) {\n            return this.F(u, v)[1];\n        };\n        this.Z = function (u, v) {\n            return this.F(u, v)[2];\n        };\n    }\n\n    this.range_u = range_u;\n    this.range_v = range_v;\n\n    this.methodMap = Type.deepCopy(this.methodMap, {\n        // TODO\n    });\n};\nJXG.Surface3D.prototype = new JXG.GeometryElement();\nType.copyPrototypeMethods(JXG.Surface3D, JXG.GeometryElement3D, \"constructor3D\");\n\nJXG.extend(\n    JXG.Surface3D.prototype,\n    /** @lends JXG.Surface3D.prototype */ {\n        updateDataArray: function () {\n            var steps_u = Type.evaluate(this.visProp.stepsu),\n                steps_v = Type.evaluate(this.visProp.stepsv),\n                r_u = Type.evaluate(this.range_u),\n                r_v = Type.evaluate(this.range_v),\n                func,\n                res;\n\n            if (this.F !== null) {\n                func = this.F;\n            } else {\n                func = [this.X, this.Y, this.Z];\n            }\n            res = this.view.getMesh(func, r_u.concat([steps_u]), r_v.concat([steps_v]));\n\n            return { X: res[0], Y: res[1] };\n        },\n\n        update: function () {\n            return this;\n        },\n\n        updateRenderer: function () {\n            this.needsUpdate = false;\n            return this;\n        }\n    }\n);\n\n/**\n * @class This element creates a 3D parametric surface.\n * @pseudo\n * @description A 3D parametric surface is defined by a function\n *    <i>F: R<sup>2</sup> &rarr; R<sup>3</sup></i>.\n *\n * @name ParametricSurface3D\n * @augments Curve\n * @constructor\n * @type Object\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n *\n * @param {Function_Function_Function_Array,Function_Array,Function} F<sub>X</sub>,F<sub>Y</sub>,F<sub>Z</sub>,rangeU,rangeV F<sub>X</sub>(u,v), F<sub>Y</sub>(u,v), F<sub>Z</sub>(u,v)\n * are functions returning a number, rangeU is the array containing lower and upper bound for the range of parameter u, rangeV is the array containing lower and\n * upper bound for the range of parameter v. rangeU and rangeV may also be functions returning an array of length two.\n * @param {Function_Array,Function_Array,Function} F,rangeU,rangeV Alternatively: F<sub>[X,Y,Z]</sub>(u,v)\n * a function returning an array [x,y,z] of numbers, rangeU and rangeV as above.\n *\n * @example\n * var view = board.create('view3d',\n * \t\t        [[-6, -3], [8, 8],\n * \t\t        [[-5, 5], [-5, 5], [-5, 5]]]);\n *\n * // Sphere\n * var c = view.create('parametricsurface3d', [\n *     (u, v) => 2 * Math.sin(u) * Math.cos(v),\n *     (u, v) => 2 * Math.sin(u) * Math.sin(v),\n *     (u, v) => 2 * Math.cos(u),\n *     [0, 2 * Math.PI],\n *     [0, Math.PI]\n * ], {\n *     strokeColor: '#ff0000',\n *     stepsU: 30,\n *     stepsV: 30\n * });\n *\n * </pre><div id=\"JXG52da0ecc-1ba9-4d41-850c-36e5120025a5\" class=\"jxgbox\" style=\"width: 500px; height: 500px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG52da0ecc-1ba9-4d41-850c-36e5120025a5',\n *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});\n *     var view = board.create('view3d',\n *            [[-6, -3], [8, 8],\n *            [[-5, 5], [-5, 5], [-5, 5]]]);\n *\n *     // Sphere\n *     var c = view.create('parametricsurface3d', [\n *         (u, v) => 2 * Math.sin(u) * Math.cos(v),\n *         (u, v) => 2 * Math.sin(u) * Math.sin(v),\n *         (u, v) => 2 * Math.cos(u),\n *         [0, 2 * Math.PI],\n *         [0, Math.PI]\n *     ], {\n *         strokeColor: '#ff0000',\n *         stepsU: 20,\n *         stepsV: 20\n *     });\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createParametricSurface3D = function (board, parents, attributes) {\n    var view = parents[0],\n        F,\n        X,\n        Y,\n        Z,\n        range_u,\n        range_v,\n        attr,\n        el;\n\n    if (parents.length === 4) {\n        F = parents[1];\n        range_u = parents[2];\n        range_v = parents[3];\n        X = null;\n        Y = null;\n        Z = null;\n    } else {\n        X = parents[1];\n        Y = parents[2];\n        Z = parents[3];\n        range_u = parents[4];\n        range_v = parents[5];\n        F = null;\n    }\n\n    attr = Type.copyAttributes(attributes, board.options, \"surface3d\");\n    el = new JXG.Surface3D(view, F, X, Y, Z, range_u, range_v, attr);\n\n    el.element2D = view.create(\"curve\", [[], []], attr);\n    el.element2D.updateDataArray = function () {\n        var ret = el.updateDataArray();\n        this.dataX = ret.X;\n        this.dataY = ret.Y;\n    };\n    el.addChild(el.element2D);\n    el.inherits.push(el.element2D);\n    el.element2D.setParents(el);\n\n    el.element2D.prepareUpdate().update();\n    if (!board.isSuspendedUpdate) {\n        el.element2D.updateVisibility().updateRenderer();\n    }\n\n    return el;\n};\nJXG.registerElement(\"parametricsurface3d\", JXG.createParametricSurface3D);\n\n/**\n * @class This element creates a 3D function graph.\n * @pseudo\n * @description A 3D function graph is defined by a function\n *    <i>F: R<sup>2</sup> &rarr; R</i>.\n *\n * @name Functiongraph3D\n * @augments ParametricSurface3D\n * @constructor\n * @type Object\n * @throws {Exception} If the element cannot be constructed with the given parent objects an exception is thrown.\n * @param {Function_Array_Array} F,rangeX,rangeY  F(x,y) is a function returning a number, rangeX is the array containing\n * lower and upper bound for the range of x, rangeY is the array containing\n * lower and upper bound for the range of y.\n * @example\n * var box = [-5, 5];\n * var view = board.create('view3d',\n *     [\n *         [-6, -3], [8, 8],\n *         [box, box, box]\n *     ],\n *     {\n *         xPlaneRear: {visible: false},\n *         yPlaneRear: {visible: false},\n *     });\n *\n * // Function F to be plotted\n * var F = (x, y) => Math.sin(x * y / 4);\n *\n * // 3D surface\n * var c = view.create('functiongraph3d', [\n *     F,\n *     box, // () => [-s.Value()*5, s.Value() * 5],\n *     box, // () => [-s.Value()*5, s.Value() * 5],\n * ], {\n *     strokeWidth: 0.5,\n *     stepsU: 70,\n *     stepsV: 70\n * });\n *\n * </pre><div id=\"JXG87646dd4-9fe5-4c21-8734-089abc612515\" class=\"jxgbox\" style=\"width: 500px; height: 500px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXG87646dd4-9fe5-4c21-8734-089abc612515',\n *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});\n *     var box = [-5, 5];\n *     var view = board.create('view3d',\n *         [\n *             [-6, -3], [8, 8],\n *             [box, box, box]\n *         ],\n *         {\n *             xPlaneRear: {visible: false},\n *             yPlaneRear: {visible: false},\n *         });\n *\n *     // Function F to be plotted\n *     var F = (x, y) => Math.sin(x * y / 4);\n *\n *     // 3D surface\n *     var c = view.create('functiongraph3d', [\n *         F,\n *         box, // () => [-s.Value()*5, s.Value() * 5],\n *         box, // () => [-s.Value()*5, s.Value() * 5],\n *     ], {\n *         strokeWidth: 0.5,\n *         stepsU: 70,\n *         stepsV: 70\n *     });\n *     })();\n *\n * </script><pre>\n *\n */\nJXG.createFunctiongraph3D = function (board, parents, attributes) {\n    var view = parents[0],\n        X = function (u, v) {\n            return u;\n        },\n        Y = function (u, v) {\n            return v;\n        },\n        Z = parents[1],\n        range_u = parents[2],\n        range_v = parents[3];\n\n    return view.create(\"parametricsurface3d\", [X, Y, Z, range_u, range_v], attributes);\n};\nJXG.registerElement(\"functiongraph3d\", JXG.createFunctiongraph3D);\n","import JXG from \"./jxg\";\nimport Env from \"./utils/env\"; // Needed below\nimport \"./base/constants\";\nimport \"./utils/type\";\nimport \"./utils/xml\";\nimport \"./utils/event\";\nimport \"./utils/expect\";\nimport \"./math/math\";\nimport \"./math/probfuncs\";\nimport \"./math/ia\";\nimport \"./math/extrapolate\";\nimport \"./math/qdt\";\nimport \"./math/numerics\";\nimport \"./math/nlp\";\nimport \"./math/plot\";\nimport \"./math/metapost\";\nimport \"./math/statistics\";\nimport \"./math/symbolic\";\nimport \"./math/geometry\";\nimport \"./math/clip\";\nimport \"./math/poly\";\nimport \"./math/complex\";\nimport \"./renderer/abstract\";\nimport \"./reader/file\";\nimport \"./parser/geonext\";\nimport \"./base/board\";\nimport \"./options\";\nimport \"./jsxgraph\";\nimport \"./base/element\";\nimport \"./base/coords\";\nimport \"./base/coordselement\";\nimport \"./base/point\";\nimport \"./base/line\";\nimport \"./base/group\";\nimport \"./base/circle\";\nimport \"./element/conic\";\nimport \"./base/polygon\";\nimport \"./base/curve\";\nimport \"./element/arc\";\nimport \"./element/sector\";\nimport \"./base/composition\";\nimport \"./element/composition\";\nimport \"./element/locus\";\nimport \"./base/text\";\nimport \"./base/image\";\nimport \"./element/slider\";\nimport \"./element/measure\";\nimport \"./base/chart\";\nimport \"./base/transformation\";\nimport \"./base/turtle\";\nimport \"./utils/color\";\nimport \"./base/ticks\";\nimport \"./utils/zip\";\nimport \"./utils/base64\";\nimport \"./utils/uuid\";\nimport \"./utils/encoding\";\nimport \"./server/server\";\nimport \"./parser/datasource\";\nimport \"./parser/jessiecode\";\nimport \"./parser/ca\";\nimport \"./utils/dump\";\nimport \"./renderer/svg\";\nimport \"./renderer/vml\";\nimport \"./renderer/canvas\";\nimport \"./renderer/no\";\nimport \"./element/comb\";\nimport \"./element/slopetriangle\";\nimport \"./element/checkbox\";\nimport \"./element/input\";\nimport \"./element/button\";\nimport \"./base/foreignobject\";\nimport \"./options3d\";\nimport \"./3d/view3d\";\nimport \"./3d/element3d\";\nimport \"./3d/box3d\";\nimport \"./3d/point3d\";\nimport \"./3d/curve3d\";\nimport \"./3d/linspace3d\";\nimport \"./3d/surface3d\";\n\n\n// We're in the browser, export JXG to the global JXG symbol for backwards compatibility\nif (Env.isBrowser) {\n    window.JXG = JXG;\n\n    // In node there are two cases:\n    // 1) jsxgraph is used without requirejs (e.g. as jsxgraphcore.js)\n    // 2) jsxgraph is loaded using requirejs (e.g. the dev version)\n    //\n    // Nodejs compatibility is handled by webpack\n    // OLD: in case 2) module is undefined, the export is set in src/jsxgraphnode.js using\n    // the return value of this factory function\n    // } else if (Env.isNode() && typeof module === \"object\") {\n    //     module.exports = JXG;\n} else if (Env.isWebWorker()) {\n    self.JXG = JXG;\n}\n\nexport default JXG;\n\n\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Andreas Walter,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph and JSXCompressor.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n    JSXCompressor is free software dual licensed under the GNU LGPL or Apache License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n      OR\n      * Apache License Version 2.0\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License, Apache\n    License, and the MIT License along with JSXGraph. If not, see\n    <http://www.gnu.org/licenses/>, <https://www.apache.org/licenses/LICENSE-2.0.html>,\n    and <http://opensource.org/licenses/MIT/>.\n\n */\n\n/*global JXG: true, define: true, jQuery: true, window: true, document: true, navigator: true, require: true, module: true, console: true */\n/*jslint nomen:true, plusplus:true, forin:true*/\n\n/**\n * @fileoverview The JSXGraph object is defined in this file. JXG.JSXGraph controls all boards.\n * It has methods to create, save, load and free boards. Additionally some helper functions are\n * defined in this file directly in the JXG namespace.\n */\n\n/**\n * JXG is the top object of JSXGraph and defines the namespace\n * @exports jxg as JXG\n */\nvar jxg = {};\n\n// Make sure JXG.extend is not defined\n// If jsxgraph is loaded via loadjsxgraph.js, this is required, but JXG.extend will be undefined\n// If jsxgraph is compiled as an amd module, it is possible that another jsxgraph version is already loaded and we\n// therefore must not re-use the global JXG variable. But in this case JXG.extend will already be defined.\n// This is the reason for this check.\nif (typeof JXG === \"object\" && !JXG.extend) {\n    jxg = JXG;\n}\n\n// We need the following two methods \"extend\" and \"shortcut\" to create the JXG object via JXG.extend.\n\n/**\n * Copy all properties of the <tt>extension</tt> object to <tt>object</tt>.\n * @param {Object} object\n * @param {Object} extension\n * @param {Boolean} [onlyOwn=false] Only consider properties that belong to extension itself, not any inherited properties.\n * @param {Boolean} [toLower=false] If true the keys are convert to lower case. This is needed for visProp, see JXG#copyAttributes\n */\njxg.extend = function (object, extension, onlyOwn, toLower) {\n    var e, e2;\n\n    onlyOwn = onlyOwn || false;\n    toLower = toLower || false;\n\n    // the purpose of this for...in loop is indeed to use hasOwnProperty only if the caller\n    // explicitly wishes so.\n    for (e in extension) {\n        if (!onlyOwn || (onlyOwn && extension.hasOwnProperty(e))) {\n            if (toLower) {\n                e2 = e.toLowerCase();\n            } else {\n                e2 = e;\n            }\n\n            object[e2] = extension[e];\n        }\n    }\n};\n\n/**\n * Set a constant <tt>name</tt> in <tt>object</tt> to <tt>value</tt>. The value can't be changed after declaration.\n * @param {Object} object\n * @param {String} name\n * @param {Number|String|Boolean} value\n * @param {Boolean} ignoreRedefine This should be left at its default: false.\n */\njxg.defineConstant = function (object, name, value, ignoreRedefine) {\n    ignoreRedefine = ignoreRedefine || false;\n\n    if (ignoreRedefine && jxg.exists(object[name])) {\n        return;\n    }\n\n    Object.defineProperty(object, name, {\n        value: value,\n        writable: false,\n        enumerable: true,\n        configurable: false\n    });\n};\n\n/**\n * Copy all properties of the <tt>constants</tt> object in <tt>object</tt> as a constant.\n * @param {Object} object\n * @param {Object} constants\n * @param {Boolean} [onlyOwn=false] Only consider properties that belong to extension itself, not any inherited properties.\n * @param {Boolean} [toUpper=false] If true the keys are convert to lower case. This is needed for visProp, see JXG#copyAttributes\n */\njxg.extendConstants = function (object, constants, onlyOwn, toUpper) {\n    var e, e2;\n\n    onlyOwn = onlyOwn || false;\n    toUpper = toUpper || false;\n\n    // The purpose of this for...in loop is indeed to use hasOwnProperty only if the caller explicitly wishes so.\n    for (e in constants) {\n        if (!onlyOwn || (onlyOwn && constants.hasOwnProperty(e))) {\n            if (toUpper) {\n                e2 = e.toUpperCase();\n            } else {\n                e2 = e;\n            }\n\n            this.defineConstant(object, e2, constants[e]);\n        }\n    }\n};\n\njxg.extend(\n    jxg,\n    /** @lends JXG */ {\n        /**\n         * Store a reference to every board in this central list. This will at some point\n         * replace JXG.JSXGraph.boards.\n         * @type Object\n         */\n        boards: {},\n\n        /**\n         * Store the available file readers in this structure.\n         * @type Object\n         */\n        readers: {},\n\n        /**\n         * Associative array that keeps track of all constructable elements registered\n         * via {@link JXG.registerElement}.\n         * @type Object\n         */\n        elements: {},\n\n        /**\n         * This registers a new construction element to JSXGraph for the construction via the {@link JXG.Board.create}\n         * interface.\n         * @param {String} element The elements name. This is case-insensitive, existing elements with the same name\n         * will be overwritten.\n         * @param {Function} creator A reference to a function taking three parameters: First the board, the element is\n         * to be created on, a parent element array, and an attributes object. See {@link JXG.createPoint} or any other\n         * <tt>JXG.create...</tt> function for an example.\n         */\n        registerElement: function (element, creator) {\n            element = element.toLowerCase();\n            this.elements[element] = creator;\n        },\n\n        /**\n         * Register a file reader.\n         * @param {function} reader A file reader. This object has to provide two methods: <tt>prepareString()</tt>\n         * and <tt>read()</tt>.\n         * @param {Array} ext\n         */\n        registerReader: function (reader, ext) {\n            var i, e;\n\n            for (i = 0; i < ext.length; i++) {\n                e = ext[i].toLowerCase();\n\n                if (typeof this.readers[e] !== \"function\") {\n                    this.readers[e] = reader;\n                }\n            }\n        },\n\n        /**\n         * Creates a shortcut to a method, e.g. {@link JXG.Board#createElement} is a shortcut to {@link JXG.Board#create}.\n         * Sometimes the target is undefined by the time you want to define the shortcut so we need this little helper.\n         * @param {Object} object The object the method we want to create a shortcut for belongs to.\n         * @param {String} fun The method we want to create a shortcut for.\n         * @returns {Function} A function that calls the given method.\n         */\n        shortcut: function (object, fun) {\n            return function () {\n                return object[fun].apply(this, arguments);\n            };\n        },\n\n        /**\n         * s may be a string containing the name or id of an element or even a reference\n         * to the element itself. This function returns a reference to the element. Search order: id, name.\n         * @param {JXG.Board} board Reference to the board the element belongs to.\n         * @param {String} s String or reference to a JSXGraph element.\n         * @returns {Object} Reference to the object given in parameter object\n         * @deprecated Use {@link JXG.Board#select}\n         */\n        getRef: function (board, s) {\n            jxg.deprecated(\"JXG.getRef()\", \"Board.select()\");\n            return board.select(s);\n        },\n\n        /**\n         * This is just a shortcut to {@link JXG.getRef}.\n         * @deprecated Use {@link JXG.Board#select}.\n         */\n        getReference: function (board, s) {\n            jxg.deprecated(\"JXG.getReference()\", \"Board.select()\");\n            return board.select(s);\n        },\n\n        /**\n         * s may be the string containing the id of an HTML tag that hosts a JSXGraph board.\n         * This function returns the reference to the board.\n         * @param  {String} s String of an HTML tag that hosts a JSXGraph board\n         * @returns {Object} Reference to the board or null.\n         */\n        getBoardByContainerId: function (s) {\n            var b;\n            for (b in JXG.boards) {\n                if (JXG.boards.hasOwnProperty(b) && JXG.boards[b].container === s) {\n                    return JXG.boards[b];\n                }\n            }\n\n            return null;\n        },\n\n        /**\n         * This method issues a warning to the developer that the given function is deprecated\n         * and, if available, offers an alternative to the deprecated function.\n         * @param {String} what Describes the function that is deprecated\n         * @param {String} [replacement] The replacement that should be used instead.\n         */\n        deprecated: function (what, replacement) {\n            var warning = what + \" is deprecated.\";\n\n            if (replacement) {\n                warning += \" Please use \" + replacement + \" instead.\";\n            }\n\n            jxg.warn(warning);\n        },\n\n        /**\n         * Outputs a warning via console.warn(), if available. If console.warn() is\n         * unavailable this function will look for an HTML element with the id 'warning'\n         * and append the warning to this element's innerHTML.\n         * @param {String} warning The warning text\n         */\n        warn: function (warning) {\n            if (typeof window === \"object\" && window.console && console.warn) {\n                console.warn(\"WARNING:\", warning);\n            } else if (typeof document === \"object\" && document.getElementById(\"warning\")) {\n                document.getElementById(\"debug\").innerHTML += \"WARNING: \" + warning + \"<br />\";\n            }\n        },\n\n        /**\n         * Add something to the debug log. If available a JavaScript debug console is used. Otherwise\n         * we're looking for a HTML div with id \"debug\". If this doesn't exist, too, the output is omitted.\n         * @param s An arbitrary number of parameters.\n         * @see JXG#debugWST\n         */\n        debugInt: function (s) {\n            var i, p;\n\n            for (i = 0; i < arguments.length; i++) {\n                p = arguments[i];\n                if (typeof window === \"object\" && window.console && console.log) {\n                    console.log(p);\n                } else if (typeof document === \"object\" && document.getElementById(\"debug\")) {\n                    document.getElementById(\"debug\").innerHTML += p + \"<br/>\";\n                }\n            }\n        },\n\n        /**\n         * Add something to the debug log. If available a JavaScript debug console is used. Otherwise\n         * we're looking for a HTML div with id \"debug\". If this doesn't exist, too, the output is omitted.\n         * This method adds a stack trace (if available).\n         * @param s An arbitrary number of parameters.\n         * @see JXG#debug\n         */\n        debugWST: function (s) {\n            var e = new Error();\n\n            jxg.debugInt.apply(this, arguments);\n\n            if (e && e.stack) {\n                jxg.debugInt(\"stacktrace\");\n                jxg.debugInt(e.stack.split(\"\\n\").slice(1).join(\"\\n\"));\n            }\n        },\n\n        /**\n         * Add something to the debug log. If available a JavaScript debug console is used. Otherwise\n         * we're looking for a HTML div with id \"debug\". If this doesn't exist, too, the output is omitted.\n         * This method adds a line of the stack trace (if available).\n         *\n         * @param s An arbitrary number of parameters.\n         * @see JXG#debug\n         */\n        debugLine: function (s) {\n            var e = new Error();\n\n            jxg.debugInt.apply(this, arguments);\n\n            if (e && e.stack) {\n                jxg.debugInt(\"Called from\", e.stack.split(\"\\n\").slice(2, 3).join(\"\\n\"));\n            }\n        },\n\n        /**\n         * Add something to the debug log. If available a JavaScript debug console is used. Otherwise\n         * we're looking for a HTML div with id \"debug\". If this doesn't exist, too, the output is omitted.\n         * @param s An arbitrary number of parameters.\n         * @see JXG#debugWST\n         * @see JXG#debugLine\n         * @see JXG#debugInt\n         */\n        debug: function (s) {\n            jxg.debugInt.apply(this, arguments);\n        }\n    }\n);\n\nexport default jxg;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Andreas Walter,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains the Math.Geometry namespace for calculating algebraic/geometric\n * stuff like intersection points, angles, midpoint, and so on.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Numerics from \"./numerics\";\nimport Type from \"../utils/type\";\nimport Expect from \"../utils/expect\";\n\n/**\n * Math.Geometry namespace definition. This namespace holds geometrical algorithms,\n * especially intersection algorithms.\n * @name JXG.Math.Geometry\n * @namespace\n */\nMat.Geometry = {};\n\n// the splitting is necessary due to the shortcut for the circumcircleMidpoint method to circumcenter.\n\nJXG.extend(\n    Mat.Geometry,\n    /** @lends JXG.Math.Geometry */ {\n        /* ***************************************/\n        /* *** GENERAL GEOMETRIC CALCULATIONS ****/\n        /* ***************************************/\n\n        /**\n         * Calculates the angle defined by the points A, B, C.\n         * @param {JXG.Point,Array} A A point  or [x,y] array.\n         * @param {JXG.Point,Array} B Another point or [x,y] array.\n         * @param {JXG.Point,Array} C A circle - no, of course the third point or [x,y] array.\n         * @deprecated Use {@link JXG.Math.Geometry.rad} instead.\n         * @see #rad\n         * @see #trueAngle\n         * @returns {Number} The angle in radian measure.\n         */\n        angle: function (A, B, C) {\n            var u,\n                v,\n                s,\n                t,\n                a = [],\n                b = [],\n                c = [];\n\n            JXG.deprecated(\"Geometry.angle()\", \"Geometry.rad()\");\n            if (A.coords) {\n                a[0] = A.coords.usrCoords[1];\n                a[1] = A.coords.usrCoords[2];\n            } else {\n                a[0] = A[0];\n                a[1] = A[1];\n            }\n\n            if (B.coords) {\n                b[0] = B.coords.usrCoords[1];\n                b[1] = B.coords.usrCoords[2];\n            } else {\n                b[0] = B[0];\n                b[1] = B[1];\n            }\n\n            if (C.coords) {\n                c[0] = C.coords.usrCoords[1];\n                c[1] = C.coords.usrCoords[2];\n            } else {\n                c[0] = C[0];\n                c[1] = C[1];\n            }\n\n            u = a[0] - b[0];\n            v = a[1] - b[1];\n            s = c[0] - b[0];\n            t = c[1] - b[1];\n\n            return Math.atan2(u * t - v * s, u * s + v * t);\n        },\n\n        /**\n         * Calculates the angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.\n         * @param {JXG.Point,Array} A Point or [x,y] array\n         * @param {JXG.Point,Array} B Point or [x,y] array\n         * @param {JXG.Point,Array} C Point or [x,y] array\n         * @see #rad\n         * @returns {Number} The angle in degrees.\n         */\n        trueAngle: function (A, B, C) {\n            return this.rad(A, B, C) * 57.295779513082323; // *180.0/Math.PI;\n        },\n\n        /**\n         * Calculates the internal angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.\n         * @param {JXG.Point,Array} A Point or [x,y] array\n         * @param {JXG.Point,Array} B Point or [x,y] array\n         * @param {JXG.Point,Array} C Point or [x,y] array\n         * @see #trueAngle\n         * @returns {Number} Angle in radians.\n         */\n        rad: function (A, B, C) {\n            var ax, ay, bx, by, cx, cy, phi;\n\n            if (A.coords) {\n                ax = A.coords.usrCoords[1];\n                ay = A.coords.usrCoords[2];\n            } else {\n                ax = A[0];\n                ay = A[1];\n            }\n\n            if (B.coords) {\n                bx = B.coords.usrCoords[1];\n                by = B.coords.usrCoords[2];\n            } else {\n                bx = B[0];\n                by = B[1];\n            }\n\n            if (C.coords) {\n                cx = C.coords.usrCoords[1];\n                cy = C.coords.usrCoords[2];\n            } else {\n                cx = C[0];\n                cy = C[1];\n            }\n\n            phi = Math.atan2(cy - by, cx - bx) - Math.atan2(ay - by, ax - bx);\n\n            if (phi < 0) {\n                phi += 6.2831853071795862;\n            }\n\n            return phi;\n        },\n\n        /**\n         * Calculates a point on the bisection line between the three points A, B, C.\n         * As a result, the bisection line is defined by two points:\n         * Parameter B and the point with the coordinates calculated in this function.\n         * Does not work for ideal points.\n         * @param {JXG.Point} A Point\n         * @param {JXG.Point} B Point\n         * @param {JXG.Point} C Point\n         * @param [board=A.board] Reference to the board\n         * @returns {JXG.Coords} Coordinates of the second point defining the bisection.\n         */\n        angleBisector: function (A, B, C, board) {\n            var phiA,\n                phiC,\n                phi,\n                Ac = A.coords.usrCoords,\n                Bc = B.coords.usrCoords,\n                Cc = C.coords.usrCoords,\n                x,\n                y;\n\n            if (!Type.exists(board)) {\n                board = A.board;\n            }\n\n            // Parallel lines\n            if (Bc[0] === 0) {\n                return new Coords(\n                    Const.COORDS_BY_USER,\n                    [1, (Ac[1] + Cc[1]) * 0.5, (Ac[2] + Cc[2]) * 0.5],\n                    board\n                );\n            }\n\n            // Non-parallel lines\n            x = Ac[1] - Bc[1];\n            y = Ac[2] - Bc[2];\n            phiA = Math.atan2(y, x);\n\n            x = Cc[1] - Bc[1];\n            y = Cc[2] - Bc[2];\n            phiC = Math.atan2(y, x);\n\n            phi = (phiA + phiC) * 0.5;\n\n            if (phiA > phiC) {\n                phi += Math.PI;\n            }\n\n            x = Math.cos(phi) + Bc[1];\n            y = Math.sin(phi) + Bc[2];\n\n            return new Coords(Const.COORDS_BY_USER, [1, x, y], board);\n        },\n\n        // /**\n        //  * Calculates a point on the m-section line between the three points A, B, C.\n        //  * As a result, the m-section line is defined by two points:\n        //  * Parameter B and the point with the coordinates calculated in this function.\n        //  * The m-section generalizes the bisector to any real number.\n        //  * For example, the trisectors of an angle are simply the 1/3-sector and the 2/3-sector.\n        //  * Does not work for ideal points.\n        //  * @param {JXG.Point} A Point\n        //  * @param {JXG.Point} B Point\n        //  * @param {JXG.Point} C Point\n        //  * @param {Number} m Number\n        //  * @param [board=A.board] Reference to the board\n        //  * @returns {JXG.Coords} Coordinates of the second point defining the bisection.\n        //  */\n        // angleMsector: function (A, B, C, m, board) {\n        //     var phiA, phiC, phi,\n        //         Ac = A.coords.usrCoords,\n        //         Bc = B.coords.usrCoords,\n        //         Cc = C.coords.usrCoords,\n        //         x, y;\n\n        //     if (!Type.exists(board)) {\n        //         board = A.board;\n        //     }\n\n        //     // Parallel lines\n        //     if (Bc[0] === 0) {\n        //         return new Coords(Const.COORDS_BY_USER,\n        //             [1, (Ac[1] + Cc[1]) * m, (Ac[2] + Cc[2]) * m], board);\n        //     }\n\n        //     // Non-parallel lines\n        //     x = Ac[1] - Bc[1];\n        //     y = Ac[2] - Bc[2];\n        //     phiA =  Math.atan2(y, x);\n\n        //     x = Cc[1] - Bc[1];\n        //     y = Cc[2] - Bc[2];\n        //     phiC =  Math.atan2(y, x);\n\n        //     phi = phiA + ((phiC - phiA) * m);\n\n        //     if (phiA - phiC > Math.PI) {\n        //         phi += 2*m*Math.PI;\n        //     }\n\n        //     x = Math.cos(phi) + Bc[1];\n        //     y = Math.sin(phi) + Bc[2];\n\n        //     return new Coords(Const.COORDS_BY_USER, [1, x, y], board);\n        // },\n\n        /**\n         * Reflects the point along the line.\n         * @param {JXG.Line} line Axis of reflection.\n         * @param {JXG.Point} point Point to reflect.\n         * @param [board=point.board] Reference to the board\n         * @returns {JXG.Coords} Coordinates of the reflected point.\n         */\n        reflection: function (line, point, board) {\n            // (v,w) defines the slope of the line\n            var x0,\n                y0,\n                x1,\n                y1,\n                v,\n                w,\n                mu,\n                pc = point.coords.usrCoords,\n                p1c = line.point1.coords.usrCoords,\n                p2c = line.point2.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            v = p2c[1] - p1c[1];\n            w = p2c[2] - p1c[2];\n\n            x0 = pc[1] - p1c[1];\n            y0 = pc[2] - p1c[2];\n\n            mu = (v * y0 - w * x0) / (v * v + w * w);\n\n            // point + mu*(-y,x) is the perpendicular foot\n            x1 = pc[1] + 2 * mu * w;\n            y1 = pc[2] - 2 * mu * v;\n\n            return new Coords(Const.COORDS_BY_USER, [x1, y1], board);\n        },\n\n        /**\n         * Computes the new position of a point which is rotated\n         * around a second point (called rotpoint) by the angle phi.\n         * @param {JXG.Point} rotpoint Center of the rotation\n         * @param {JXG.Point} point point to be rotated\n         * @param {Number} phi rotation angle in arc length\n         * @param {JXG.Board} [board=point.board] Reference to the board\n         * @returns {JXG.Coords} Coordinates of the new position.\n         */\n        rotation: function (rotpoint, point, phi, board) {\n            var x0,\n                y0,\n                c,\n                s,\n                x1,\n                y1,\n                pc = point.coords.usrCoords,\n                rotpc = rotpoint.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            x0 = pc[1] - rotpc[1];\n            y0 = pc[2] - rotpc[2];\n\n            c = Math.cos(phi);\n            s = Math.sin(phi);\n\n            x1 = x0 * c - y0 * s + rotpc[1];\n            y1 = x0 * s + y0 * c + rotpc[2];\n\n            return new Coords(Const.COORDS_BY_USER, [x1, y1], board);\n        },\n\n        /**\n         * Calculates the coordinates of a point on the perpendicular to the given line through\n         * the given point.\n         * @param {JXG.Line} line A line.\n         * @param {JXG.Point} point Point which is projected to the line.\n         * @param {JXG.Board} [board=point.board] Reference to the board\n         * @returns {Array} Array of length two containing coordinates of a point on the perpendicular to the given line\n         *                  through the given point and boolean flag \"change\".\n         */\n        perpendicular: function (line, point, board) {\n            var x,\n                y,\n                change,\n                c,\n                z,\n                A = line.point1.coords.usrCoords,\n                B = line.point2.coords.usrCoords,\n                C = point.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            // special case: point is the first point of the line\n            if (point === line.point1) {\n                x = A[1] + B[2] - A[2];\n                y = A[2] - B[1] + A[1];\n                z = A[0] * B[0];\n\n                if (Math.abs(z) < Mat.eps) {\n                    x = B[2];\n                    y = -B[1];\n                }\n                c = [z, x, y];\n                change = true;\n\n                // special case: point is the second point of the line\n            } else if (point === line.point2) {\n                x = B[1] + A[2] - B[2];\n                y = B[2] - A[1] + B[1];\n                z = A[0] * B[0];\n\n                if (Math.abs(z) < Mat.eps) {\n                    x = A[2];\n                    y = -A[1];\n                }\n                c = [z, x, y];\n                change = false;\n\n                // special case: point lies somewhere else on the line\n            } else if (Math.abs(Mat.innerProduct(C, line.stdform, 3)) < Mat.eps) {\n                x = C[1] + B[2] - C[2];\n                y = C[2] - B[1] + C[1];\n                z = B[0];\n\n                if (Math.abs(z) < Mat.eps) {\n                    x = B[2];\n                    y = -B[1];\n                }\n\n                change = true;\n                if (\n                    Math.abs(z) > Mat.eps &&\n                    Math.abs(x - C[1]) < Mat.eps &&\n                    Math.abs(y - C[2]) < Mat.eps\n                ) {\n                    x = C[1] + A[2] - C[2];\n                    y = C[2] - A[1] + C[1];\n                    change = false;\n                }\n                c = [z, x, y];\n\n                // general case: point does not lie on the line\n                // -> calculate the foot of the dropped perpendicular\n            } else {\n                c = [0, line.stdform[1], line.stdform[2]];\n                c = Mat.crossProduct(c, C); // perpendicuar to line\n                c = Mat.crossProduct(c, line.stdform); // intersection of line and perpendicular\n                change = true;\n            }\n\n            return [new Coords(Const.COORDS_BY_USER, c, board), change];\n        },\n\n        /**\n         * @deprecated Please use {@link JXG.Math.Geometry.circumcenter} instead.\n         */\n        circumcenterMidpoint: function () {\n            JXG.deprecated(\"Geometry.circumcenterMidpoint()\", \"Geometry.circumcenter()\");\n            this.circumcenter.apply(this, arguments);\n        },\n\n        /**\n         * Calculates the center of the circumcircle of the three given points.\n         * @param {JXG.Point} point1 Point\n         * @param {JXG.Point} point2 Point\n         * @param {JXG.Point} point3 Point\n         * @param {JXG.Board} [board=point1.board] Reference to the board\n         * @returns {JXG.Coords} Coordinates of the center of the circumcircle of the given points.\n         */\n        circumcenter: function (point1, point2, point3, board) {\n            var u,\n                v,\n                m1,\n                m2,\n                A = point1.coords.usrCoords,\n                B = point2.coords.usrCoords,\n                C = point3.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point1.board;\n            }\n\n            u = [B[0] - A[0], -B[2] + A[2], B[1] - A[1]];\n            v = [(A[0] + B[0]) * 0.5, (A[1] + B[1]) * 0.5, (A[2] + B[2]) * 0.5];\n            m1 = Mat.crossProduct(u, v);\n\n            u = [C[0] - B[0], -C[2] + B[2], C[1] - B[1]];\n            v = [(B[0] + C[0]) * 0.5, (B[1] + C[1]) * 0.5, (B[2] + C[2]) * 0.5];\n            m2 = Mat.crossProduct(u, v);\n\n            return new Coords(Const.COORDS_BY_USER, Mat.crossProduct(m1, m2), board);\n        },\n\n        /**\n         * Calculates the Euclidean distance for two given arrays of the same length.\n         * @param {Array} array1 Array of Number\n         * @param {Array} array2 Array of Number\n         * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.\n         * @returns {Number} Euclidean distance of the given vectors.\n         */\n        distance: function (array1, array2, n) {\n            var i,\n                sum = 0;\n\n            if (!n) {\n                n = Math.min(array1.length, array2.length);\n            }\n\n            for (i = 0; i < n; i++) {\n                sum += (array1[i] - array2[i]) * (array1[i] - array2[i]);\n            }\n\n            return Math.sqrt(sum);\n        },\n\n        /**\n         * Calculates Euclidean distance for two given arrays of the same length.\n         * If one of the arrays contains a zero in the first coordinate, and the Euclidean distance\n         * is different from zero it is a point at infinity and we return Infinity.\n         * @param {Array} array1 Array containing elements of type number.\n         * @param {Array} array2 Array containing elements of type number.\n         * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.\n         * @returns {Number} Euclidean (affine) distance of the given vectors.\n         */\n        affineDistance: function (array1, array2, n) {\n            var d;\n\n            d = this.distance(array1, array2, n);\n\n            if (\n                d > Mat.eps &&\n                (Math.abs(array1[0]) < Mat.eps || Math.abs(array2[0]) < Mat.eps)\n            ) {\n                return Infinity;\n            }\n\n            return d;\n        },\n\n        /**\n         * Affine ratio of three collinear points a, b, c: (c - a) / (b - a).\n         * If r > 1 or r < 0 then c is outside of the segment ab.\n         *\n         * @param {Array|JXG.Coords} a\n         * @param {Array|JXG.Coords} b\n         * @param {Array|JXG.Coords} c\n         * @returns {Number} affine ratio (c - a) / (b - a)\n         */\n        affineRatio: function (a, b, c) {\n            var r = 0.0,\n                dx;\n\n            if (Type.exists(a.usrCoords)) {\n                a = a.usrCoords;\n            }\n            if (Type.exists(b.usrCoords)) {\n                b = b.usrCoords;\n            }\n            if (Type.exists(c.usrCoords)) {\n                c = c.usrCoords;\n            }\n\n            dx = b[1] - a[1];\n\n            if (Math.abs(dx) > Mat.eps) {\n                r = (c[1] - a[1]) / dx;\n            } else {\n                r = (c[2] - a[2]) / (b[2] - a[2]);\n            }\n            return r;\n        },\n\n        /**\n         * Sort vertices counter clockwise starting with the first point.\n         *\n         * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n         *\n         * @returns {Array}\n         */\n        sortVertices: function (p) {\n            var ll,\n                ps = Expect.each(p, Expect.coordsArray),\n                N = ps.length,\n                lastPoint = null;\n\n            // If the last point equals the first point, we take the last point out of the array.\n            // It may be that the several points at the end of the array are equal to the first point.\n            // The polygonal chain is been closed by JSXGraph, but this may also have been done by the user.\n            // Therefore, we use a while lopp to pop the last points.\n            while (\n                ps[0][0] === ps[N - 1][0] &&\n                ps[0][1] === ps[N - 1][1] &&\n                ps[0][2] === ps[N - 1][2]\n            ) {\n                lastPoint = ps.pop();\n                N--;\n            }\n            // Find the point with the lowest y value\n            // for (i = 1; i < N; i++) {\n            //     if ((ps[i][2] < ps[0][2]) ||\n            //         // if the current and the lowest point have the same y value, pick the one with\n            //         // the lowest x value.\n            //         (Math.abs(ps[i][2] - ps[0][2]) < Mat.eps && ps[i][1] < ps[0][1])) {\n            //         console.log(i, 0);\n            //         ps = Type.swap(ps, i, 0);\n            //     }\n            // }\n\n            ll = ps[0];\n            // Sort ps in increasing order of the angle between a point and the first point ll.\n            // If a point is equal to the first point ll, the angle is defined to be -Infinity.\n            // Otherwise, atan2 would return zero, which is a value which also attained by points\n            // on the same horizontal line.\n            ps.sort(function (a, b) {\n                var rad1 =\n                        a[2] === ll[2] && a[1] === ll[1]\n                            ? -Infinity\n                            : Math.atan2(a[2] - ll[2], a[1] - ll[1]),\n                    rad2 =\n                        b[2] === ll[2] && b[1] === ll[1]\n                            ? -Infinity\n                            : Math.atan2(b[2] - ll[2], b[1] - ll[1]);\n\n                return rad1 - rad2;\n            });\n\n            // If the last point has been taken out of the array, we put it in again.\n            if (lastPoint !== null) {\n                ps.push(lastPoint);\n            }\n\n            return ps;\n        },\n\n        /**\n         * Signed triangle area of the three points given.\n         *\n         * @param {JXG.Point|JXG.Coords|Array} p1\n         * @param {JXG.Point|JXG.Coords|Array} p2\n         * @param {JXG.Point|JXG.Coords|Array} p3\n         *\n         * @returns {Number}\n         */\n        signedTriangle: function (p1, p2, p3) {\n            var A = Expect.coordsArray(p1),\n                B = Expect.coordsArray(p2),\n                C = Expect.coordsArray(p3);\n\n            return 0.5 * ((B[1] - A[1]) * (C[2] - A[2]) - (B[2] - A[2]) * (C[1] - A[1]));\n        },\n\n        /**\n         * Determine the signed area of a non-selfintersecting polygon.\n         * Surveyor's Formula\n         *\n         * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n         * @param {Boolean} [sort=true]\n         *\n         * @returns {Number}\n         */\n        signedPolygon: function (p, sort) {\n            var i,\n                N,\n                A = 0,\n                ps = Expect.each(p, Expect.coordsArray);\n\n            if (sort === undefined) {\n                sort = true;\n            }\n\n            if (!sort) {\n                ps = this.sortVertices(ps);\n            } else {\n                // Make sure the polygon is closed. If it is already closed this won't change the sum because the last\n                // summand will be 0.\n                ps.unshift(ps[ps.length - 1]);\n            }\n\n            N = ps.length;\n\n            for (i = 1; i < N; i++) {\n                A += ps[i - 1][1] * ps[i][2] - ps[i][1] * ps[i - 1][2];\n            }\n\n            return 0.5 * A;\n        },\n\n        /**\n         * Calculate the complex hull of a point cloud.\n         *\n         * @param {Array} points An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n         *\n         * @returns {Array}\n         */\n        GrahamScan: function (points) {\n            var i,\n                M = 1,\n                ps = Expect.each(points, Expect.coordsArray),\n                N = ps.length;\n\n            ps = this.sortVertices(ps);\n            N = ps.length;\n\n            for (i = 2; i < N; i++) {\n                while (this.signedTriangle(ps[M - 1], ps[M], ps[i]) <= 0) {\n                    if (M > 1) {\n                        M -= 1;\n                    } else if (i === N - 1) {\n                        break;\n                    }\n                    i += 1;\n                }\n\n                M += 1;\n                ps = Type.swap(ps, M, i);\n            }\n\n            return ps.slice(0, M);\n        },\n\n        /**\n         * A line can be a segment, a straight, or a ray. So it is not always delimited by point1 and point2\n         * calcStraight determines the visual start point and end point of the line. A segment is only drawn\n         * from start to end point, a straight line is drawn until it meets the boards boundaries.\n         * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.\n         * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and\n         * set by this method.\n         * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set\n         * by this method.\n         * @param {Number} margin Optional margin, to avoid the display of the small sides of lines.\n         * @returns null\n         * @see Line\n         * @see JXG.Line\n         */\n        calcStraight: function (el, point1, point2, margin) {\n            var takePoint1,\n                takePoint2,\n                intersection,\n                intersect1,\n                intersect2,\n                straightFirst,\n                straightLast,\n                c,\n                p1,\n                p2;\n\n            if (!Type.exists(margin)) {\n                // Enlarge the drawable region slightly. This hides the small sides\n                // of thick lines in most cases.\n                margin = 10;\n            }\n\n            straightFirst = Type.evaluate(el.visProp.straightfirst);\n            straightLast = Type.evaluate(el.visProp.straightlast);\n\n            // If one of the point is an ideal point in homogeneous coordinates\n            // drawing of line segments or rays are not possible.\n            if (Math.abs(point1.scrCoords[0]) < Mat.eps) {\n                straightFirst = true;\n            }\n            if (Math.abs(point2.scrCoords[0]) < Mat.eps) {\n                straightLast = true;\n            }\n\n            // Do nothing in case of line segments (inside or outside of the board)\n            if (!straightFirst && !straightLast) {\n                return;\n            }\n\n            // Compute the stdform of the line in screen coordinates.\n            c = [];\n            c[0] =\n                el.stdform[0] -\n                (el.stdform[1] * el.board.origin.scrCoords[1]) / el.board.unitX +\n                (el.stdform[2] * el.board.origin.scrCoords[2]) / el.board.unitY;\n            c[1] = el.stdform[1] / el.board.unitX;\n            c[2] = -el.stdform[2] / el.board.unitY;\n\n            // p1=p2\n            if (isNaN(c[0] + c[1] + c[2])) {\n                return;\n            }\n\n            takePoint1 = false;\n            takePoint2 = false;\n\n            // Line starts at point1 and point1 is inside the board\n            takePoint1 =\n                !straightFirst &&\n                Math.abs(point1.usrCoords[0]) >= Mat.eps &&\n                point1.scrCoords[1] >= 0.0 &&\n                point1.scrCoords[1] <= el.board.canvasWidth &&\n                point1.scrCoords[2] >= 0.0 &&\n                point1.scrCoords[2] <= el.board.canvasHeight;\n\n            // Line ends at point2 and point2 is inside the board\n            takePoint2 =\n                !straightLast &&\n                Math.abs(point2.usrCoords[0]) >= Mat.eps &&\n                point2.scrCoords[1] >= 0.0 &&\n                point2.scrCoords[1] <= el.board.canvasWidth &&\n                point2.scrCoords[2] >= 0.0 &&\n                point2.scrCoords[2] <= el.board.canvasHeight;\n\n            // Intersect the line with the four borders of the board.\n            intersection = this.meetLineBoard(c, el.board, margin);\n            intersect1 = intersection[0];\n            intersect2 = intersection[1];\n\n            /**\n             * At this point we have four points:\n             * point1 and point2 are the first and the second defining point on the line,\n             * intersect1, intersect2 are the intersections of the line with border around the board.\n             */\n\n            /*\n             * Here we handle rays where both defining points are outside of the board.\n             */\n            // If both points are outside and the complete ray is outside we do nothing\n            if (!takePoint1 && !takePoint2) {\n                // Ray starting at point 1\n                if (\n                    !straightFirst &&\n                    straightLast &&\n                    !this.isSameDirection(point1, point2, intersect1) &&\n                    !this.isSameDirection(point1, point2, intersect2)\n                ) {\n                    return;\n                }\n\n                // Ray starting at point 2\n                if (\n                    straightFirst &&\n                    !straightLast &&\n                    !this.isSameDirection(point2, point1, intersect1) &&\n                    !this.isSameDirection(point2, point1, intersect2)\n                ) {\n                    return;\n                }\n            }\n\n            /*\n             * If at least one of the defining points is outside of the board\n             * we take intersect1 or intersect2 as one of the end points\n             * The order is also important for arrows of axes\n             */\n            if (!takePoint1) {\n                if (!takePoint2) {\n                    // Two border intersection points are used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p1 = intersect1;\n                        p2 = intersect2;\n                    } else {\n                        p2 = intersect1;\n                        p1 = intersect2;\n                    }\n                } else {\n                    // One border intersection points is used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p1 = intersect1;\n                    } else {\n                        p1 = intersect2;\n                    }\n                }\n            } else {\n                if (!takePoint2) {\n                    // One border intersection points is used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p2 = intersect2;\n                    } else {\n                        p2 = intersect1;\n                    }\n                }\n            }\n\n            if (p1) {\n                //point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords.slice(1));\n                point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords);\n            }\n\n            if (p2) {\n                //point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords.slice(1));\n                point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords);\n            }\n        },\n\n        /**\n         * A line can be a segment, a straight, or a ray. so it is not always delimited by point1 and point2.\n         *\n         * This method adjusts the line's delimiting points taking into account its nature, the viewport defined\n         * by the board.\n         *\n         * A segment is delimited by start and end point, a straight line or ray is delimited until it meets the\n         * boards boundaries. However, if the line has infinite ticks, it will be delimited by the projection of\n         * the boards vertices onto itself.\n         *\n         * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.\n         * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and\n         * set by this method.\n         * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set\n         * by this method.\n         * @see Line\n         * @see JXG.Line\n         */\n        calcLineDelimitingPoints: function (el, point1, point2) {\n            var distP1P2,\n                boundingBox,\n                lineSlope,\n                intersect1,\n                intersect2,\n                straightFirst,\n                straightLast,\n                c,\n                p1,\n                p2,\n                takePoint1 = false,\n                takePoint2 = false;\n\n            straightFirst = Type.evaluate(el.visProp.straightfirst);\n            straightLast = Type.evaluate(el.visProp.straightlast);\n\n            // If one of the point is an ideal point in homogeneous coordinates\n            // drawing of line segments or rays are not possible.\n            if (Math.abs(point1.scrCoords[0]) < Mat.eps) {\n                straightFirst = true;\n            }\n            if (Math.abs(point2.scrCoords[0]) < Mat.eps) {\n                straightLast = true;\n            }\n\n            // Compute the stdform of the line in screen coordinates.\n            c = [];\n            c[0] =\n                el.stdform[0] -\n                (el.stdform[1] * el.board.origin.scrCoords[1]) / el.board.unitX +\n                (el.stdform[2] * el.board.origin.scrCoords[2]) / el.board.unitY;\n            c[1] = el.stdform[1] / el.board.unitX;\n            c[2] = -el.stdform[2] / el.board.unitY;\n\n            // p1=p2\n            if (isNaN(c[0] + c[1] + c[2])) {\n                return;\n            }\n\n            takePoint1 = !straightFirst;\n            takePoint2 = !straightLast;\n            // Intersect the board vertices on the line to establish the available visual space for the infinite ticks\n            // Based on the slope of the line we can optimise and only project the two outer vertices\n\n            // boundingBox = [x1, y1, x2, y2] upper left, lower right vertices\n            boundingBox = el.board.getBoundingBox();\n            lineSlope = el.getSlope();\n            if (lineSlope >= 0) {\n                // project vertices (x2,y1) (x1, y2)\n                intersect1 = this.projectPointToLine(\n                    { coords: { usrCoords: [1, boundingBox[2], boundingBox[1]] } },\n                    el,\n                    el.board\n                );\n                intersect2 = this.projectPointToLine(\n                    { coords: { usrCoords: [1, boundingBox[0], boundingBox[3]] } },\n                    el,\n                    el.board\n                );\n            } else {\n                // project vertices (x1, y1) (x2, y2)\n                intersect1 = this.projectPointToLine(\n                    { coords: { usrCoords: [1, boundingBox[0], boundingBox[1]] } },\n                    el,\n                    el.board\n                );\n                intersect2 = this.projectPointToLine(\n                    { coords: { usrCoords: [1, boundingBox[2], boundingBox[3]] } },\n                    el,\n                    el.board\n                );\n            }\n\n            /**\n             * we have four points:\n             * point1 and point2 are the first and the second defining point on the line,\n             * intersect1, intersect2 are the intersections of the line with border around the board.\n             */\n\n            /*\n             * Here we handle rays/segments where both defining points are outside of the board.\n             */\n            if (!takePoint1 && !takePoint2) {\n                // Segment, if segment does not cross the board, do nothing\n                if (!straightFirst && !straightLast) {\n                    distP1P2 = point1.distance(Const.COORDS_BY_USER, point2);\n                    // if  intersect1 not between point1 and point2\n                    if (\n                        Math.abs(\n                            point1.distance(Const.COORDS_BY_USER, intersect1) +\n                                intersect1.distance(Const.COORDS_BY_USER, point2) -\n                                distP1P2\n                        ) > Mat.eps\n                    ) {\n                        return;\n                    }\n                    // if insersect2 not between point1 and point2\n                    if (\n                        Math.abs(\n                            point1.distance(Const.COORDS_BY_USER, intersect2) +\n                                intersect2.distance(Const.COORDS_BY_USER, point2) -\n                                distP1P2\n                        ) > Mat.eps\n                    ) {\n                        return;\n                    }\n                }\n\n                // If both points are outside and the complete ray is outside we do nothing\n                // Ray starting at point 1\n                if (\n                    !straightFirst &&\n                    straightLast &&\n                    !this.isSameDirection(point1, point2, intersect1) &&\n                    !this.isSameDirection(point1, point2, intersect2)\n                ) {\n                    return;\n                }\n\n                // Ray starting at point 2\n                if (\n                    straightFirst &&\n                    !straightLast &&\n                    !this.isSameDirection(point2, point1, intersect1) &&\n                    !this.isSameDirection(point2, point1, intersect2)\n                ) {\n                    return;\n                }\n            }\n\n            /*\n             * If at least one of the defining points is outside of the board\n             * we take intersect1 or intersect2 as one of the end points\n             * The order is also important for arrows of axes\n             */\n            if (!takePoint1) {\n                if (!takePoint2) {\n                    // Two border intersection points are used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p1 = intersect1;\n                        p2 = intersect2;\n                    } else {\n                        p2 = intersect1;\n                        p1 = intersect2;\n                    }\n                } else {\n                    // One border intersection points is used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p1 = intersect1;\n                    } else {\n                        p1 = intersect2;\n                    }\n                }\n            } else {\n                if (!takePoint2) {\n                    // One border intersection points is used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p2 = intersect2;\n                    } else {\n                        p2 = intersect1;\n                    }\n                }\n            }\n\n            if (p1) {\n                //point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords.slice(1));\n                point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords);\n            }\n\n            if (p2) {\n                //point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords.slice(1));\n                point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords);\n            }\n        },\n\n        /**\n         * Calculates the visProp.position corresponding to a given angle.\n         * @param {number} angle angle in radians. Must be in range (-2pi,2pi).\n         */\n        calcLabelQuadrant: function (angle) {\n            var q;\n            if (angle < 0) {\n                angle += 2 * Math.PI;\n            }\n            q = Math.floor((angle + Math.PI / 8) / (Math.PI / 4)) % 8;\n            return [\"rt\", \"urt\", \"top\", \"ulft\", \"lft\", \"llft\", \"lrt\"][q];\n        },\n\n        /**\n         * The vectors <tt>p2-p1</tt> and <tt>i2-i1</tt> are supposed to be collinear. If their cosine is positive\n         * they point into the same direction otherwise they point in opposite direction.\n         * @param {JXG.Coords} p1\n         * @param {JXG.Coords} p2\n         * @param {JXG.Coords} i1\n         * @param {JXG.Coords} i2\n         * @returns {Boolean} True, if <tt>p2-p1</tt> and <tt>i2-i1</tt> point into the same direction\n         */\n        isSameDir: function (p1, p2, i1, i2) {\n            var dpx = p2.usrCoords[1] - p1.usrCoords[1],\n                dpy = p2.usrCoords[2] - p1.usrCoords[2],\n                dix = i2.usrCoords[1] - i1.usrCoords[1],\n                diy = i2.usrCoords[2] - i1.usrCoords[2];\n\n            if (Math.abs(p2.usrCoords[0]) < Mat.eps) {\n                dpx = p2.usrCoords[1];\n                dpy = p2.usrCoords[2];\n            }\n\n            if (Math.abs(p1.usrCoords[0]) < Mat.eps) {\n                dpx = -p1.usrCoords[1];\n                dpy = -p1.usrCoords[2];\n            }\n\n            return dpx * dix + dpy * diy >= 0;\n        },\n\n        /**\n         * If you're looking from point \"start\" towards point \"s\" and you can see the point \"p\", return true.\n         * Otherwise return false.\n         * @param {JXG.Coords} start The point you're standing on.\n         * @param {JXG.Coords} p The point in which direction you're looking.\n         * @param {JXG.Coords} s The point that should be visible.\n         * @returns {Boolean} True, if from start the point p is in the same direction as s is, that means s-start = k*(p-start) with k>=0.\n         */\n        isSameDirection: function (start, p, s) {\n            var dx,\n                dy,\n                sx,\n                sy,\n                r = false;\n\n            dx = p.usrCoords[1] - start.usrCoords[1];\n            dy = p.usrCoords[2] - start.usrCoords[2];\n\n            sx = s.usrCoords[1] - start.usrCoords[1];\n            sy = s.usrCoords[2] - start.usrCoords[2];\n\n            if (Math.abs(dx) < Mat.eps) {\n                dx = 0;\n            }\n\n            if (Math.abs(dy) < Mat.eps) {\n                dy = 0;\n            }\n\n            if (Math.abs(sx) < Mat.eps) {\n                sx = 0;\n            }\n\n            if (Math.abs(sy) < Mat.eps) {\n                sy = 0;\n            }\n\n            if (dx >= 0 && sx >= 0) {\n                r = (dy >= 0 && sy >= 0) || (dy <= 0 && sy <= 0);\n            } else if (dx <= 0 && sx <= 0) {\n                r = (dy >= 0 && sy >= 0) || (dy <= 0 && sy <= 0);\n            }\n\n            return r;\n        },\n\n        /**\n         * Determinant of three points in the Euclidean plane.\n         * Zero, if the points are collinear. Used to determine of a point q is left or\n         * right to a segment defined by points p1 and p2.\n         *\n         * @param  {Array} p1 Coordinates of the first point of the segment. Array of length 3. First coordinate is equal to 1.\n         * @param  {Array} p2 Coordinates of the second point of the segment. Array of length 3. First coordinate is equal to 1.\n         * @param  {Array} q Coordinates of the point. Array of length 3. First coordinate is equal to 1.\n         * @return {Number} Signed area of the triangle formed by these three points.\n         *\n         * @see #windingNumber\n         */\n        det3p: function (p1, p2, q) {\n            return (p1[1] - q[1]) * (p2[2] - q[2]) - (p2[1] - q[1]) * (p1[2] - q[2]);\n        },\n\n        /**\n         * Winding number of a point in respect to a polygon path.\n         *\n         * The point is regarded outside if the winding number is zero,\n         * inside otherwise. The algorithm tries to find degenerate cases, i.e.\n         * if the point is on the path. This is regarded as \"outside\".\n         * If the point is a vertex of the path, it is regarded as \"inside\".\n         *\n         * Implementation of algorithm 7 from \"The point in polygon problem for\n         * arbitrary polygons\" by Kai Hormann and Alexander Agathos, Computational Geometry,\n         * Volume 20, Issue 3, November 2001, Pages 131-144.\n         *\n         * @param  {Array} usrCoords Homogenous coordinates of the point\n         * @param  {Array} path      Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements\n         * do not have to be full points, but have to have a subobject \"coords\" or should be of type JXG.Coords.\n         * @param  {Boolean} [doNotClosePath=false] If true the last point of the path is not connected to the first point.\n         * This is necessary if the path consists of two or more closed subpaths, e.g. if the figure has a hole.\n         *\n         * @return {Number}          Winding number of the point. The point is\n         *                           regarded outside if the winding number is zero,\n         *                           inside otherwise.\n         */\n        windingNumber: function (usrCoords, path, doNotClosePath) {\n            var wn = 0,\n                le = path.length,\n                x = usrCoords[1],\n                y = usrCoords[2],\n                p0,\n                p1,\n                p2,\n                d,\n                sign,\n                i,\n                off = 0;\n\n            if (le === 0) {\n                return 0;\n            }\n\n            doNotClosePath = doNotClosePath || false;\n            if (doNotClosePath) {\n                off = 1;\n            }\n\n            // Infinite points are declared outside\n            if (isNaN(x) || isNaN(y)) {\n                return 1;\n            }\n\n            if (Type.exists(path[0].coords)) {\n                p0 = path[0].coords;\n                p1 = path[le - 1].coords;\n            } else {\n                p0 = path[0];\n                p1 = path[le - 1];\n            }\n            // Handle the case if the point is the first vertex of the path, i.e. inside.\n            if (p0.usrCoords[1] === x && p0.usrCoords[2] === y) {\n                return 1;\n            }\n\n            for (i = 0; i < le - off; i++) {\n                // Consider the edge from p1 = path[i] to p2 = path[i+1]isClosedPath\n                if (Type.exists(path[i].coords)) {\n                    p1 = path[i].coords.usrCoords;\n                    p2 = path[(i + 1) % le].coords.usrCoords;\n                } else {\n                    p1 = path[i].usrCoords;\n                    p2 = path[(i + 1) % le].usrCoords;\n                }\n\n                // If one of the two points p1, p2 is undefined or infinite,\n                // move on.\n                if (\n                    p1[0] === 0 ||\n                    p2[0] === 0 ||\n                    isNaN(p1[1]) ||\n                    isNaN(p2[1]) ||\n                    isNaN(p1[2]) ||\n                    isNaN(p2[2])\n                ) {\n                    continue;\n                }\n\n                if (p2[2] === y) {\n                    if (p2[1] === x) {\n                        return 1;\n                    }\n                    if (p1[2] === y && p2[1] > x === p1[1] < x) {\n                        return 0;\n                    }\n                }\n\n                if (p1[2] < y !== p2[2] < y) {\n                    // Crossing\n                    sign = 2 * (p2[2] > p1[2] ? 1 : 0) - 1;\n                    if (p1[1] >= x) {\n                        if (p2[1] > x) {\n                            wn += sign;\n                        } else {\n                            d = this.det3p(p1, p2, usrCoords);\n                            if (d === 0) {\n                                // Point is on line, i.e. outside\n                                return 0;\n                            }\n                            if (d > 0 + Mat.eps === p2[2] > p1[2]) {\n                                // Right crossing\n                                wn += sign;\n                            }\n                        }\n                    } else {\n                        if (p2[1] > x) {\n                            d = this.det3p(p1, p2, usrCoords);\n                            if (d > 0 + Mat.eps === p2[2] > p1[2]) {\n                                // Right crossing\n                                wn += sign;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return wn;\n        },\n\n        /**\n         * Decides if a point (x,y) is inside of a path / polygon.\n         * Does not work correct if the path has hole. In this case, windingNumber is the preferred method.\n         * Implements W. Randolf Franklin's pnpoly method.\n         *\n         * See <a href=\"https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\">https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html</a>.\n         *\n         * @param {Number} x_in x-coordinate (screen or user coordinates)\n         * @param {Number} y_in y-coordinate (screen or user coordinates)\n         * @param  {Array} path  Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements\n         * do not have to be full points, but have to have a subobject \"coords\" or should be of type JXG.Coords.\n         * @param {Number} [coord_type=JXG.COORDS_BY_SCREEN] Type of coordinates used here.\n         *   Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.\n         *   Default value is JXG.COORDS_BY_SCREEN.\n         *\n         * @returns {Boolean} if (x_in, y_in) is inside of the polygon.\n         * @see JXG.Polygon.hasPoint\n         * @see JXG.Polygon.pnpoly\n         * @see #windingNumber\n         *\n         * @example\n         * var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);\n         * var p = board.create('point', [4, 3]);\n         * var txt = board.create('text', [-1, 0.5, function() {\n         *   return 'Point A is inside of the polygon = ' +\n         *     JXG.Math.Geometry.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER, pol.vertices);\n         * }]);\n         *\n         * </pre><div id=\"JXG4656ed42-f965-4e35-bb66-c334a4529683\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG4656ed42-f965-4e35-bb66-c334a4529683',\n         *             {boundingbox: [-2, 5, 5,-2], axis: true, showcopyright: false, shownavigation: false});\n         *     var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);\n         *     var p = board.create('point', [4, 3]);\n         *     var txt = board.create('text', [-1, 0.5, function() {\n         *     \t\treturn 'Point A is inside of the polygon = ' + JXG.Math.Geometry.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER, pol.vertices);\n         *     }]);\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        pnpoly: function (x_in, y_in, path, coord_type) {\n            var i,\n                j,\n                len,\n                x,\n                y,\n                crds,\n                v = path,\n                vi,\n                vj,\n                isIn = false;\n\n            if (coord_type === Const.COORDS_BY_USER) {\n                crds = new Coords(Const.COORDS_BY_USER, [x_in, y_in], this.board);\n                x = crds.scrCoords[1];\n                y = crds.scrCoords[2];\n            } else {\n                x = x_in;\n                y = y_in;\n            }\n\n            len = path.length;\n            for (i = 0, j = len - 2; i < len - 1; j = i++) {\n                vi = Type.exists(v[i].coords) ? v[i].coords : v[i];\n                vj = Type.exists(v[j].coords) ? v[j].coords : v[j];\n\n                if (\n                    vi.scrCoords[2] > y !== vj.scrCoords[2] > y &&\n                    x <\n                        ((vj.scrCoords[1] - vi.scrCoords[1]) * (y - vi.scrCoords[2])) /\n                            (vj.scrCoords[2] - vi.scrCoords[2]) +\n                            vi.scrCoords[1]\n                ) {\n                    isIn = !isIn;\n                }\n            }\n\n            return isIn;\n        },\n\n        /****************************************/\n        /****          INTERSECTIONS         ****/\n        /****************************************/\n\n        /**\n         * Generate the function which computes the coordinates of the intersection point.\n         * Primarily used in {@link JXG.Point#createIntersectionPoint}.\n         * @param {JXG.Board} board object\n         * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number} el1,el2,i The result will be a intersection point on el1 and el2.\n         * i determines the intersection point if two points are available: <ul>\n         *   <li>i==0: use the positive square root,</li>\n         *   <li>i==1: use the negative square root.</li></ul>\n         * See further {@link JXG.Point#createIntersectionPoint}.\n         * @param {Boolean} alwaysintersect. Flag that determines if segments and arc can have an outer intersection point\n         * on their defining line or circle.\n         * @returns {Function} Function returning a {@link JXG.Coords} object that determines\n         * the intersection point.\n         */\n        intersectionFunction: function (board, el1, el2, i, j, alwaysintersect) {\n            var func,\n                that = this,\n                el1_isArcType = false,\n                el2_isArcType = false;\n\n            el1_isArcType =\n                el1.elementClass === Const.OBJECT_CLASS_CURVE &&\n                (el1.type === Const.OBJECT_TYPE_ARC || el1.type === Const.OBJECT_TYPE_SECTOR)\n                    ? true\n                    : false;\n            el2_isArcType =\n                el2.elementClass === Const.OBJECT_CLASS_CURVE &&\n                (el2.type === Const.OBJECT_TYPE_ARC || el2.type === Const.OBJECT_TYPE_SECTOR)\n                    ? true\n                    : false;\n\n            if (\n                (el1.elementClass === Const.OBJECT_CLASS_CURVE ||\n                    el2.elementClass === Const.OBJECT_CLASS_CURVE) &&\n                (el1.elementClass === Const.OBJECT_CLASS_CURVE ||\n                    el1.elementClass === Const.OBJECT_CLASS_CIRCLE) &&\n                (el2.elementClass === Const.OBJECT_CLASS_CURVE ||\n                    el2.elementClass === Const.OBJECT_CLASS_CIRCLE) /*&&\n                !(el1_isArcType && el2_isArcType)*/\n            ) {\n                // curve - curve\n                // with the exception that both elements are arc types\n                /** @ignore */\n                func = function () {\n                    return that.meetCurveCurve(el1, el2, i, j, el1.board);\n                };\n            } else if (\n                (el1.elementClass === Const.OBJECT_CLASS_CURVE &&\n                    !el1_isArcType &&\n                    el2.elementClass === Const.OBJECT_CLASS_LINE) ||\n                (el2.elementClass === Const.OBJECT_CLASS_CURVE &&\n                    !el2_isArcType &&\n                    el1.elementClass === Const.OBJECT_CLASS_LINE)\n            ) {\n                // curve - line (this includes intersections between conic sections and lines)\n                // with the exception that the curve is of arc type\n                /** @ignore */\n                func = function () {\n                    return that.meetCurveLine(el1, el2, i, el1.board, alwaysintersect);\n                };\n            } else if (\n                el1.type === Const.OBJECT_TYPE_POLYGON ||\n                el2.type === Const.OBJECT_TYPE_POLYGON\n            ) {\n                // polygon - other\n                // Uses the Greiner-Hormann clipping algorithm\n                // Not implemented: polygon - point\n\n                if (el1.elementClass === Const.OBJECT_CLASS_LINE) {\n                    // line - path\n                    /** @ignore */\n                    func = function () {\n                        return that.meetPolygonLine(el2, el1, i, el1.board, alwaysintersect);\n                    };\n                } else if (el2.elementClass === Const.OBJECT_CLASS_LINE) {\n                    // path - line\n                    func = function () {\n                        return that.meetPolygonLine(el1, el2, i, el1.board, alwaysintersect);\n                    };\n                } else {\n                    // path - path\n                    /** @ignore */\n                    func = function () {\n                        return that.meetPathPath(el1, el2, i, el1.board);\n                    };\n                }\n            } else if (\n                el1.elementClass === Const.OBJECT_CLASS_LINE &&\n                el2.elementClass === Const.OBJECT_CLASS_LINE\n            ) {\n                // line - line, lines may also be segments.\n                /** @ignore */\n                func = function () {\n                    var res,\n                        c,\n                        first1 = Type.evaluate(el1.visProp.straightfirst),\n                        last1 = Type.evaluate(el1.visProp.straightlast),\n                        first2 = Type.evaluate(el2.visProp.straightfirst),\n                        last2 = Type.evaluate(el2.visProp.straightlast);\n\n                    /**\n                     * If one of the lines is a segment or ray and\n                     * the intersection point should disappear if outside\n                     * of the segment or ray we call\n                     * meetSegmentSegment\n                     */\n                    if (\n                        !Type.evaluate(alwaysintersect) &&\n                        (!first1 || !last1 || !first2 || !last2)\n                    ) {\n                        res = that.meetSegmentSegment(\n                            el1.point1.coords.usrCoords,\n                            el1.point2.coords.usrCoords,\n                            el2.point1.coords.usrCoords,\n                            el2.point2.coords.usrCoords\n                        );\n\n                        if (\n                            (!first1 && res[1] < 0) ||\n                            (!last1 && res[1] > 1) ||\n                            (!first2 && res[2] < 0) ||\n                            (!last2 && res[2] > 1)\n                        ) {\n                            // Non-existent\n                            c = [0, NaN, NaN];\n                        } else {\n                            c = res[0];\n                        }\n\n                        return new Coords(Const.COORDS_BY_USER, c, el1.board);\n                    }\n\n                    return that.meet(el1.stdform, el2.stdform, i, el1.board);\n                };\n            } else {\n                // All other combinations of circles and lines,\n                // Arc types are treated as circles.\n                /** @ignore */\n                func = function () {\n                    var res = that.meet(el1.stdform, el2.stdform, i, el1.board),\n                        has = true,\n                        first,\n                        last,\n                        r,\n                        dx;\n\n                    if (alwaysintersect) {\n                        return res;\n                    }\n                    if (el1.elementClass === Const.OBJECT_CLASS_LINE) {\n                        first = Type.evaluate(el1.visProp.straightfirst);\n                        last = Type.evaluate(el1.visProp.straightlast);\n                        if (!first || !last) {\n                            r = that.affineRatio(el1.point1.coords, el1.point2.coords, res);\n                            if ((!last && r > 1 + Mat.eps) || (!first && r < 0 - Mat.eps)) {\n                                return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n                            }\n                        }\n                    }\n                    if (el2.elementClass === Const.OBJECT_CLASS_LINE) {\n                        first = Type.evaluate(el2.visProp.straightfirst);\n                        last = Type.evaluate(el2.visProp.straightlast);\n                        if (!first || !last) {\n                            r = that.affineRatio(el2.point1.coords, el2.point2.coords, res);\n                            if ((!last && r > 1 + Mat.eps) || (!first && r < 0 - Mat.eps)) {\n                                return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n                            }\n                        }\n                    }\n                    if (el1_isArcType) {\n                        has = that.coordsOnArc(el1, res);\n                        if (has && el2_isArcType) {\n                            has = that.coordsOnArc(el2, res);\n                        }\n                        if (!has) {\n                            return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n                        }\n                    }\n                    return res;\n                };\n            }\n\n            return func;\n        },\n\n        /**\n         * Returns true if the coordinates are on the arc element,\n         * false otherwise. Usually, coords is an intersection\n         * on the circle line. Now it is decided if coords are on the\n         * circle restricted to the arc line.\n         * @param  {Arc} arc arc or sector element\n         * @param  {JXG.Coords} coords Coords object of an intersection\n         * @returns {Boolean}\n         * @private\n         */\n        coordsOnArc: function (arc, coords) {\n            var angle = this.rad(arc.radiuspoint, arc.center, coords.usrCoords.slice(1)),\n                alpha = 0.0,\n                beta = this.rad(arc.radiuspoint, arc.center, arc.anglepoint),\n                ev_s = Type.evaluate(arc.visProp.selection);\n\n            if ((ev_s === \"minor\" && beta > Math.PI) || (ev_s === \"major\" && beta < Math.PI)) {\n                alpha = beta;\n                beta = 2 * Math.PI;\n            }\n            if (angle < alpha || angle > beta) {\n                return false;\n            }\n            return true;\n        },\n\n        /**\n         * Computes the intersection of a pair of lines, circles or both.\n         * It uses the internal data array stdform of these elements.\n         * @param {Array} el1 stdform of the first element (line or circle)\n         * @param {Array} el2 stdform of the second element (line or circle)\n         * @param {Number} i Index of the intersection point that should be returned.\n         * @param board Reference to the board.\n         * @returns {JXG.Coords} Coordinates of one of the possible two or more intersection points.\n         * Which point will be returned is determined by i.\n         */\n        meet: function (el1, el2, i, board) {\n            var result,\n                eps = Mat.eps;\n\n            // line line\n            if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) < eps) {\n                result = this.meetLineLine(el1, el2, i, board);\n                // circle line\n            } else if (Math.abs(el1[3]) >= eps && Math.abs(el2[3]) < eps) {\n                result = this.meetLineCircle(el2, el1, i, board);\n                // line circle\n            } else if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) >= eps) {\n                result = this.meetLineCircle(el1, el2, i, board);\n                // circle circle\n            } else {\n                result = this.meetCircleCircle(el1, el2, i, board);\n            }\n\n            return result;\n        },\n\n        /**\n         * Intersection of the line with the board\n         * @param  {Array}     line   stdform of the line in screen coordinates\n         * @param  {JXG.Board} board  reference to a board.\n         * @param  {Number}    margin optional margin, to avoid the display of the small sides of lines.\n         * @returns {Array}            [intersection coords 1, intersection coords 2]\n         */\n        meetLineBoard: function (line, board, margin) {\n            // Intersect the line with the four borders of the board.\n            var s = [],\n                intersect1,\n                intersect2,\n                i,\n                j;\n\n            if (!Type.exists(margin)) {\n                margin = 0;\n            }\n\n            // top\n            s[0] = Mat.crossProduct(line, [margin, 0, 1]);\n            // left\n            s[1] = Mat.crossProduct(line, [margin, 1, 0]);\n            // bottom\n            s[2] = Mat.crossProduct(line, [-margin - board.canvasHeight, 0, 1]);\n            // right\n            s[3] = Mat.crossProduct(line, [-margin - board.canvasWidth, 1, 0]);\n\n            // Normalize the intersections\n            for (i = 0; i < 4; i++) {\n                if (Math.abs(s[i][0]) > Mat.eps) {\n                    for (j = 2; j > 0; j--) {\n                        s[i][j] /= s[i][0];\n                    }\n                    s[i][0] = 1.0;\n                }\n            }\n\n            // line is parallel to \"left\", take \"top\" and \"bottom\"\n            if (Math.abs(s[1][0]) < Mat.eps) {\n                intersect1 = s[0]; // top\n                intersect2 = s[2]; // bottom\n                // line is parallel to \"top\", take \"left\" and \"right\"\n            } else if (Math.abs(s[0][0]) < Mat.eps) {\n                intersect1 = s[1]; // left\n                intersect2 = s[3]; // right\n                // left intersection out of board (above)\n            } else if (s[1][2] < 0) {\n                intersect1 = s[0]; // top\n\n                // right intersection out of board (below)\n                if (s[3][2] > board.canvasHeight) {\n                    intersect2 = s[2]; // bottom\n                } else {\n                    intersect2 = s[3]; // right\n                }\n                // left intersection out of board (below)\n            } else if (s[1][2] > board.canvasHeight) {\n                intersect1 = s[2]; // bottom\n\n                // right intersection out of board (above)\n                if (s[3][2] < 0) {\n                    intersect2 = s[0]; // top\n                } else {\n                    intersect2 = s[3]; // right\n                }\n            } else {\n                intersect1 = s[1]; // left\n\n                // right intersection out of board (above)\n                if (s[3][2] < 0) {\n                    intersect2 = s[0]; // top\n                    // right intersection out of board (below)\n                } else if (s[3][2] > board.canvasHeight) {\n                    intersect2 = s[2]; // bottom\n                } else {\n                    intersect2 = s[3]; // right\n                }\n            }\n\n            intersect1 = new Coords(Const.COORDS_BY_SCREEN, intersect1.slice(1), board);\n            intersect2 = new Coords(Const.COORDS_BY_SCREEN, intersect2.slice(1), board);\n            return [intersect1, intersect2];\n        },\n\n        /**\n         * Intersection of two lines.\n         * @param {Array} l1 stdform of the first line\n         * @param {Array} l2 stdform of the second line\n         * @param {number} i unused\n         * @param {JXG.Board} board Reference to the board.\n         * @returns {JXG.Coords} Coordinates of the intersection point.\n         */\n        meetLineLine: function (l1, l2, i, board) {\n            /*\n            var s = Mat.crossProduct(l1, l2);\n\n            if (Math.abs(s[0]) > Mat.eps) {\n                s[1] /= s[0];\n                s[2] /= s[0];\n                s[0] = 1.0;\n            }\n            */\n            var s = isNaN(l1[5] + l2[5]) ? [0, 0, 0] : Mat.crossProduct(l1, l2);\n            return new Coords(Const.COORDS_BY_USER, s, board);\n        },\n\n        /**\n         * Intersection of line and circle.\n         * @param {Array} lin stdform of the line\n         * @param {Array} circ stdform of the circle\n         * @param {number} i number of the returned intersection point.\n         *   i==0: use the positive square root,\n         *   i==1: use the negative square root.\n         * @param {JXG.Board} board Reference to a board.\n         * @returns {JXG.Coords} Coordinates of the intersection point\n         */\n        meetLineCircle: function (lin, circ, i, board) {\n            var a, b, c, d, n, A, B, C, k, t;\n\n            // Radius is zero, return center of circle\n            if (circ[4] < Mat.eps) {\n                if (Math.abs(Mat.innerProduct([1, circ[6], circ[7]], lin, 3)) < Mat.eps) {\n                    return new Coords(Const.COORDS_BY_USER, circ.slice(6, 8), board);\n                }\n\n                return new Coords(Const.COORDS_BY_USER, [NaN, NaN], board);\n            }\n            c = circ[0];\n            b = circ.slice(1, 3);\n            a = circ[3];\n            d = lin[0];\n            n = lin.slice(1, 3);\n\n            // Line is assumed to be normalized. Therefore, nn==1 and we can skip some operations:\n            /*\n             var nn = n[0]*n[0]+n[1]*n[1];\n             A = a*nn;\n             B = (b[0]*n[1]-b[1]*n[0])*nn;\n             C = a*d*d - (b[0]*n[0]+b[1]*n[1])*d + c*nn;\n             */\n            A = a;\n            B = b[0] * n[1] - b[1] * n[0];\n            C = a * d * d - (b[0] * n[0] + b[1] * n[1]) * d + c;\n\n            k = B * B - 4 * A * C;\n            if (k > -Mat.eps * Mat.eps) {\n                k = Math.sqrt(Math.abs(k));\n                t = [(-B + k) / (2 * A), (-B - k) / (2 * A)];\n\n                return i === 0\n                    ? new Coords(\n                          Const.COORDS_BY_USER,\n                          [-t[0] * -n[1] - d * n[0], -t[0] * n[0] - d * n[1]],\n                          board\n                      )\n                    : new Coords(\n                          Const.COORDS_BY_USER,\n                          [-t[1] * -n[1] - d * n[0], -t[1] * n[0] - d * n[1]],\n                          board\n                      );\n            }\n\n            return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n        },\n\n        /**\n         * Intersection of two circles.\n         * @param {Array} circ1 stdform of the first circle\n         * @param {Array} circ2 stdform of the second circle\n         * @param {number} i number of the returned intersection point.\n         *   i==0: use the positive square root,\n         *   i==1: use the negative square root.\n         * @param {JXG.Board} board Reference to the board.\n         * @returns {JXG.Coords} Coordinates of the intersection point\n         */\n        meetCircleCircle: function (circ1, circ2, i, board) {\n            var radicalAxis;\n\n            // Radius is zero, return center of circle, if on other circle\n            if (circ1[4] < Mat.eps) {\n                if (\n                    Math.abs(this.distance(circ1.slice(6, 2), circ2.slice(6, 8)) - circ2[4]) <\n                    Mat.eps\n                ) {\n                    return new Coords(Const.COORDS_BY_USER, circ1.slice(6, 8), board);\n                }\n\n                return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n            }\n\n            // Radius is zero, return center of circle, if on other circle\n            if (circ2[4] < Mat.eps) {\n                if (\n                    Math.abs(this.distance(circ2.slice(6, 2), circ1.slice(6, 8)) - circ1[4]) <\n                    Mat.eps\n                ) {\n                    return new Coords(Const.COORDS_BY_USER, circ2.slice(6, 8), board);\n                }\n\n                return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n            }\n\n            radicalAxis = [\n                circ2[3] * circ1[0] - circ1[3] * circ2[0],\n                circ2[3] * circ1[1] - circ1[3] * circ2[1],\n                circ2[3] * circ1[2] - circ1[3] * circ2[2],\n                0,\n                1,\n                Infinity,\n                Infinity,\n                Infinity\n            ];\n            radicalAxis = Mat.normalize(radicalAxis);\n\n            return this.meetLineCircle(radicalAxis, circ1, i, board);\n        },\n\n        /**\n         * Compute an intersection of the curves c1 and c2.\n         * We want to find values t1, t2 such that\n         * c1(t1) = c2(t2), i.e. (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).\n         *\n         * Methods: segment-wise intersections (default) or generalized Newton method.\n         * @param {JXG.Curve} c1 Curve, Line or Circle\n         * @param {JXG.Curve} c2 Curve, Line or Circle\n         * @param {Number} nr the nr-th intersection point will be returned.\n         * @param {Number} t2ini not longer used.\n         * @param {JXG.Board} [board=c1.board] Reference to a board object.\n         * @param {String} [method='segment'] Intersection method, possible values are 'newton' and 'segment'.\n         * @returns {JXG.Coords} intersection point\n         */\n        meetCurveCurve: function (c1, c2, nr, t2ini, board, method) {\n            var co;\n\n            if (Type.exists(method) && method === \"newton\") {\n                co = Numerics.generalizedNewton(c1, c2, nr, t2ini);\n            } else {\n                if (c1.bezierDegree === 3 || c2.bezierDegree === 3) {\n                    co = this.meetBezierCurveRedBlueSegments(c1, c2, nr);\n                } else {\n                    co = this.meetCurveRedBlueSegments(c1, c2, nr);\n                }\n            }\n\n            return new Coords(Const.COORDS_BY_USER, co, board);\n        },\n\n        /**\n         * Intersection of curve with line,\n         * Order of input does not matter for el1 and el2.\n         * From version 0.99.7 on this method calls\n         * {@link JXG.Math.Geometry.meetCurveLineDiscrete}.\n         * If higher precision is needed, {@link JXG.Math.Geometry.meetCurveLineContinuous}\n         * has to be used.\n         *\n         * @param {JXG.Curve,JXG.Line} el1 Curve or Line\n         * @param {JXG.Curve,JXG.Line} el2 Curve or Line\n         * @param {Number} nr the nr-th intersection point will be returned.\n         * @param {JXG.Board} [board=el1.board] Reference to a board object.\n         * @param {Boolean} alwaysIntersect If false just the segment between the two defining points are tested for intersection\n         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n         * the ideal point [0,1,0] is returned.\n         */\n        meetCurveLine: function (el1, el2, nr, board, alwaysIntersect) {\n            var v = [0, NaN, NaN],\n                cu,\n                li;\n\n            if (!Type.exists(board)) {\n                board = el1.board;\n            }\n\n            if (el1.elementClass === Const.OBJECT_CLASS_CURVE) {\n                cu = el1;\n                li = el2;\n            } else {\n                cu = el2;\n                li = el1;\n            }\n\n            v = this.meetCurveLineDiscrete(cu, li, nr, board, !alwaysIntersect);\n\n            return v;\n        },\n\n        /**\n         * Intersection of line and curve, continuous case.\n         * Finds the nr-the intersection point\n         * Uses {@link JXG.Math.Geometry.meetCurveLineDiscrete} as a first approximation.\n         * A more exact solution is then found with {@link JXG.Math.Numerics.root}.\n         *\n         * @param {JXG.Curve} cu Curve\n         * @param {JXG.Line} li Line\n         * @param {Number} nr Will return the nr-th intersection point.\n         * @param {JXG.Board} board\n         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the\n         * line defined by the segment\n         * @returns {JXG.Coords} Coords object containing the intersection.\n         */\n        meetCurveLineContinuous: function (cu, li, nr, board, testSegment) {\n            var t,\n                func0,\n                func1,\n                v,\n                x,\n                y,\n                z,\n                eps = Mat.eps,\n                epsLow = Mat.eps,\n                steps,\n                delta,\n                tnew,\n                i,\n                tmin,\n                fmin,\n                ft;\n\n            v = this.meetCurveLineDiscrete(cu, li, nr, board, testSegment);\n            x = v.usrCoords[1];\n            y = v.usrCoords[2];\n\n            func0 = function (t) {\n                var c1, c2;\n\n                if (t > cu.maxX() || t < cu.minX()) {\n                    return Infinity;\n                }\n                c1 = x - cu.X(t);\n                c2 = y - cu.Y(t);\n                return c1 * c1 + c2 * c2;\n            };\n\n            func1 = function (t) {\n                var v = li.stdform[0] + li.stdform[1] * cu.X(t) + li.stdform[2] * cu.Y(t);\n                return v * v;\n            };\n\n            // Find t\n            steps = 50;\n            delta = (cu.maxX() - cu.minX()) / steps;\n            tnew = cu.minX();\n\n            fmin = 0.0001; //eps;\n            tmin = NaN;\n            for (i = 0; i < steps; i++) {\n                t = Numerics.root(func0, [\n                    Math.max(tnew, cu.minX()),\n                    Math.min(tnew + delta, cu.maxX())\n                ]);\n                ft = Math.abs(func0(t));\n                if (ft <= fmin) {\n                    fmin = ft;\n                    tmin = t;\n                    if (fmin < eps) {\n                        break;\n                    }\n                }\n\n                tnew += delta;\n            }\n            t = tmin;\n            // Compute \"exact\" t\n            t = Numerics.root(func1, [\n                Math.max(t - delta, cu.minX()),\n                Math.min(t + delta, cu.maxX())\n            ]);\n\n            ft = func1(t);\n            // Is the point on the line?\n            if (isNaN(ft) || Math.abs(ft) > epsLow) {\n                z = 0.0; //NaN;\n            } else {\n                z = 1.0;\n            }\n\n            return new Coords(Const.COORDS_BY_USER, [z, cu.X(t), cu.Y(t)], board);\n        },\n\n        /**\n         * Intersection of line and curve, discrete case.\n         * Segments are treated as lines.\n         * Finding the nr-th intersection point should work for all nr.\n         * @param {JXG.Curve} cu\n         * @param {JXG.Line} li\n         * @param {Number} nr\n         * @param {JXG.Board} board\n         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the\n         * line defined by the segment\n         *\n         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n         * the ideal point [0,1,0] is returned.\n         */\n        meetCurveLineDiscrete: function (cu, li, nr, board, testSegment) {\n            var i,\n                j,\n                p1,\n                p2,\n                p,\n                q,\n                lip1 = li.point1.coords.usrCoords,\n                lip2 = li.point2.coords.usrCoords,\n                d,\n                res,\n                cnt = 0,\n                len = cu.numberPoints,\n                ev_sf = Type.evaluate(li.visProp.straightfirst),\n                ev_sl = Type.evaluate(li.visProp.straightlast);\n\n            // In case, no intersection will be found we will take this\n            q = new Coords(Const.COORDS_BY_USER, [0, NaN, NaN], board);\n\n            if (lip1[0] === 0.0) {\n                lip1 = [1, lip2[1] + li.stdform[2], lip2[2] - li.stdform[1]];\n            } else if (lip2[0] === 0.0) {\n                lip2 = [1, lip1[1] + li.stdform[2], lip1[2] - li.stdform[1]];\n            }\n\n            p2 = cu.points[0].usrCoords;\n            for (i = 1; i < len; i += cu.bezierDegree) {\n                p1 = p2.slice(0);\n                p2 = cu.points[i].usrCoords;\n                d = this.distance(p1, p2);\n\n                // The defining points are not identical\n                if (d > Mat.eps) {\n                    if (cu.bezierDegree === 3) {\n                        res = this.meetBeziersegmentBeziersegment(\n                            [\n                                cu.points[i - 1].usrCoords.slice(1),\n                                cu.points[i].usrCoords.slice(1),\n                                cu.points[i + 1].usrCoords.slice(1),\n                                cu.points[i + 2].usrCoords.slice(1)\n                            ],\n                            [lip1.slice(1), lip2.slice(1)],\n                            testSegment\n                        );\n                    } else {\n                        res = [this.meetSegmentSegment(p1, p2, lip1, lip2)];\n                    }\n\n                    for (j = 0; j < res.length; j++) {\n                        p = res[j];\n                        if (0 <= p[1] && p[1] <= 1) {\n                            if (cnt === nr) {\n                                /**\n                                 * If the intersection point is not part of the segment,\n                                 * this intersection point is set to non-existent.\n                                 * This prevents jumping behavior of the intersection points.\n                                 * But it may be discussed if it is the desired behavior.\n                                 */\n                                if (\n                                    testSegment &&\n                                    ((!ev_sf && p[2] < 0) || (!ev_sl && p[2] > 1))\n                                ) {\n                                    return q; // break;\n                                }\n\n                                q = new Coords(Const.COORDS_BY_USER, p[0], board);\n                                return q; // break;\n                            }\n                            cnt += 1;\n                        }\n                    }\n                }\n            }\n\n            return q;\n        },\n\n        /**\n         * Find the n-th intersection point of two curves named red (first parameter) and blue (second parameter).\n         * We go through each segment of the red curve and search if there is an intersection with a segemnt of the blue curve.\n         * This double loop, i.e. the outer loop runs along the red curve and the inner loop runs along the blue curve, defines\n         * the n-th intersection point. The segments are either line segments or Bezier curves of degree 3. This depends on\n         * the property bezierDegree of the curves.\n         * <p>\n         * This method works also for transformed curves, since only the already\n         * transformed points are used.\n         *\n         * @param {JXG.Curve} red\n         * @param {JXG.Curve} blue\n         * @param {Number} nr\n         */\n        meetCurveRedBlueSegments: function (red, blue, nr) {\n            var i,\n                j,\n                red1,\n                red2,\n                blue1,\n                blue2,\n                m,\n                minX,\n                maxX,\n                iFound = 0,\n                lenBlue = blue.numberPoints, //points.length,\n                lenRed = red.numberPoints; //points.length;\n\n            if (lenBlue <= 1 || lenRed <= 1) {\n                return [0, NaN, NaN];\n            }\n\n            for (i = 1; i < lenRed; i++) {\n                red1 = red.points[i - 1].usrCoords;\n                red2 = red.points[i].usrCoords;\n                minX = Math.min(red1[1], red2[1]);\n                maxX = Math.max(red1[1], red2[1]);\n\n                blue2 = blue.points[0].usrCoords;\n                for (j = 1; j < lenBlue; j++) {\n                    blue1 = blue2;\n                    blue2 = blue.points[j].usrCoords;\n\n                    if (\n                        Math.min(blue1[1], blue2[1]) < maxX &&\n                        Math.max(blue1[1], blue2[1]) > minX\n                    ) {\n                        m = this.meetSegmentSegment(red1, red2, blue1, blue2);\n                        if (\n                            m[1] >= 0.0 &&\n                            m[2] >= 0.0 &&\n                            // The two segments meet in the interior or at the start points\n                            ((m[1] < 1.0 && m[2] < 1.0) ||\n                                // One of the curve is intersected in the very last point\n                                (i === lenRed - 1 && m[1] === 1.0) ||\n                                (j === lenBlue - 1 && m[2] === 1.0))\n                        ) {\n                            if (iFound === nr) {\n                                return m[0];\n                            }\n\n                            iFound++;\n                        }\n                    }\n                }\n            }\n\n            return [0, NaN, NaN];\n        },\n\n        /**\n         * (Virtual) Intersection of two segments.\n         * @param {Array} p1 First point of segment 1 using normalized homogeneous coordinates [1,x,y]\n         * @param {Array} p2 Second point or direction of segment 1 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively\n         * @param {Array} q1 First point of segment 2 using normalized homogeneous coordinates [1,x,y]\n         * @param {Array} q2 Second point or direction of segment 2 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively\n         * @returns {Array} [Intersection point, t, u] The first entry contains the homogeneous coordinates\n         * of the intersection point. The second and third entry give the position of the intersection with respect\n         * to the definiting parameters. For example, the second entry t is defined by: intersection point = p1 + t * deltaP, where\n         * deltaP = (p2 - p1) when both parameters are coordinates, and deltaP = p2 if p2 is a point at infinity.\n         * If the two segments are collinear, [[0,0,0], Infinity, Infinity] is returned.\n         **/\n        meetSegmentSegment: function (p1, p2, q1, q2) {\n            var t,\n                u,\n                i,\n                d,\n                li1 = Mat.crossProduct(p1, p2),\n                li2 = Mat.crossProduct(q1, q2),\n                c = Mat.crossProduct(li1, li2);\n\n            if (Math.abs(c[0]) < Mat.eps) {\n                return [c, Infinity, Infinity];\n            }\n\n            // Normalize the intersection coordinates\n            c[1] /= c[0];\n            c[2] /= c[0];\n            c[0] /= c[0];\n\n            // Now compute in principle:\n            //    t = dist(c - p1) / dist(p2 - p1) and\n            //    u = dist(c - q1) / dist(q2 - q1)\n            // However: the points q1, q2, p1, p2 might be ideal points - or in general - the\n            // coordinates might be not normalized.\n            // Note that the z-coordinates of p2 and q2 are used to determine whether it should be interpreted\n            // as a segment coordinate or a direction.\n            i = Math.abs(p2[1] - p2[0] * p1[1]) < Mat.eps ? 2 : 1;\n            d = p1[i] / p1[0];\n            t = (c[i] - d) / (p2[0] !== 0 ? p2[i] / p2[0] - d : p2[i]);\n\n            i = Math.abs(q2[1] - q2[0] * q1[1]) < Mat.eps ? 2 : 1;\n            d = q1[i] / q1[0];\n            u = (c[i] - d) / (q2[0] !== 0 ? q2[i] / q2[0] - d : q2[i]);\n\n            return [c, t, u];\n        },\n\n        /**\n         * Find the n-th intersection point of two pathes, usually given by polygons. Uses parts of the\n         * Greiner-Hormann algorithm in JXG.Math.Clip.\n         *\n         * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path1\n         * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path2\n         * @param {Number} n\n         * @param {JXG.Board} board\n         *\n         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n         * the ideal point [0,0,0] is returned.\n         *\n         */\n        meetPathPath: function (path1, path2, nr, board) {\n            var S, C, len, intersections;\n\n            S = JXG.Math.Clip._getPath(path1, board);\n            len = S.length;\n            if (\n                len > 0 &&\n                this.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < Mat.eps\n            ) {\n                S.pop();\n            }\n\n            C = JXG.Math.Clip._getPath(path2, board);\n            len = C.length;\n            if (\n                len > 0 &&\n                this.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) <\n                    Mat.eps * Mat.eps\n            ) {\n                C.pop();\n            }\n\n            // Handle cases where at least one of the paths is empty\n            if (nr < 0 || JXG.Math.Clip.isEmptyCase(S, C, \"intersection\")) {\n                return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n            }\n\n            JXG.Math.Clip.makeDoublyLinkedList(S);\n            JXG.Math.Clip.makeDoublyLinkedList(C);\n\n            intersections = JXG.Math.Clip.findIntersections(S, C, board)[0];\n            if (nr < intersections.length) {\n                return intersections[nr].coords;\n            }\n            return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n        },\n\n        /**\n         * Find the n-th intersection point between a polygon and a line.\n         * @param {JXG.Polygon} path\n         * @param {JXG.Line} line\n         * @param {Number} nr\n         * @param {JXG.Board} board\n         * @param {Boolean} alwaysIntersect If false just the segment between the two defining points of the line are tested for intersection.\n         *\n         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n         * the ideal point [0,0,0] is returned.\n         */\n        meetPolygonLine: function (path, line, nr, board, alwaysIntersect) {\n            var i,\n                res,\n                border,\n                crds = [0, 0, 0],\n                len = path.borders.length,\n                intersections = [];\n\n            for (i = 0; i < len; i++) {\n                border = path.borders[i];\n                res = this.meetSegmentSegment(\n                    border.point1.coords.usrCoords,\n                    border.point2.coords.usrCoords,\n                    line.point1.coords.usrCoords,\n                    line.point2.coords.usrCoords\n                );\n\n                if (\n                    (!alwaysIntersect || (res[2] >= 0 && res[2] < 1)) &&\n                    res[1] >= 0 &&\n                    res[1] < 1\n                ) {\n                    intersections.push(res[0]);\n                }\n            }\n\n            if (nr >= 0 && nr < intersections.length) {\n                crds = intersections[nr];\n            }\n            return new Coords(Const.COORDS_BY_USER, crds, board);\n        },\n\n        /****************************************/\n        /****   BEZIER CURVE ALGORITHMS      ****/\n        /****************************************/\n\n        /**\n         * Splits a Bezier curve segment defined by four points into\n         * two Bezier curve segments. Dissection point is t=1/2.\n         * @param {Array} curve Array of four coordinate arrays of length 2 defining a\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @returns {Array} Array consisting of two coordinate arrays for Bezier curves.\n         */\n        _bezierSplit: function (curve) {\n            var p0, p1, p2, p00, p22, p000;\n\n            p0 = [(curve[0][0] + curve[1][0]) * 0.5, (curve[0][1] + curve[1][1]) * 0.5];\n            p1 = [(curve[1][0] + curve[2][0]) * 0.5, (curve[1][1] + curve[2][1]) * 0.5];\n            p2 = [(curve[2][0] + curve[3][0]) * 0.5, (curve[2][1] + curve[3][1]) * 0.5];\n\n            p00 = [(p0[0] + p1[0]) * 0.5, (p0[1] + p1[1]) * 0.5];\n            p22 = [(p1[0] + p2[0]) * 0.5, (p1[1] + p2[1]) * 0.5];\n\n            p000 = [(p00[0] + p22[0]) * 0.5, (p00[1] + p22[1]) * 0.5];\n\n            return [\n                [curve[0], p0, p00, p000],\n                [p000, p22, p2, curve[3]]\n            ];\n        },\n\n        /**\n         * Computes the bounding box [minX, maxY, maxX, minY] of a Bezier curve segment\n         * from its control points.\n         * @param {Array} curve Array of four coordinate arrays of length 2 defining a\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @returns {Array} Bounding box [minX, maxY, maxX, minY]\n         */\n        _bezierBbox: function (curve) {\n            var bb = [];\n\n            if (curve.length === 4) {\n                // bezierDegree == 3\n                bb[0] = Math.min(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // minX\n                bb[1] = Math.max(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // maxY\n                bb[2] = Math.max(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // maxX\n                bb[3] = Math.min(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // minY\n            } else {\n                // bezierDegree == 1\n                bb[0] = Math.min(curve[0][0], curve[1][0]); // minX\n                bb[1] = Math.max(curve[0][1], curve[1][1]); // maxY\n                bb[2] = Math.max(curve[0][0], curve[1][0]); // maxX\n                bb[3] = Math.min(curve[0][1], curve[1][1]); // minY\n            }\n\n            return bb;\n        },\n\n        /**\n         * Decide if two Bezier curve segments overlap by comparing their bounding boxes.\n         * @param {Array} bb1 Bounding box of the first Bezier curve segment\n         * @param {Array} bb2 Bounding box of the second Bezier curve segment\n         * @returns {Boolean} true if the bounding boxes overlap, false otherwise.\n         */\n        _bezierOverlap: function (bb1, bb2) {\n            return bb1[2] >= bb2[0] && bb1[0] <= bb2[2] && bb1[1] >= bb2[3] && bb1[3] <= bb2[1];\n        },\n\n        /**\n         * Append list of intersection points to a list.\n         * @private\n         */\n        _bezierListConcat: function (L, Lnew, t1, t2) {\n            var i,\n                t2exists = Type.exists(t2),\n                start = 0,\n                len = Lnew.length,\n                le = L.length;\n\n            if (\n                le > 0 &&\n                len > 0 &&\n                ((L[le - 1][1] === 1 && Lnew[0][1] === 0) ||\n                    (t2exists && L[le - 1][2] === 1 && Lnew[0][2] === 0))\n            ) {\n                start = 1;\n            }\n\n            for (i = start; i < len; i++) {\n                if (t2exists) {\n                    Lnew[i][2] *= 0.5;\n                    Lnew[i][2] += t2;\n                }\n\n                Lnew[i][1] *= 0.5;\n                Lnew[i][1] += t1;\n\n                L.push(Lnew[i]);\n            }\n        },\n\n        /**\n         * Find intersections of two Bezier curve segments by recursive subdivision.\n         * Below maxlevel determine intersections by intersection line segments.\n         * @param {Array} red Array of four coordinate arrays of length 2 defining the first\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @param {Array} blue Array of four coordinate arrays of length 2 defining the second\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @param {Number} level Recursion level\n         * @returns {Array} List of intersection points (up to nine). Each intersection point is an\n         * array of length three (homogeneous coordinates) plus preimages.\n         */\n        _bezierMeetSubdivision: function (red, blue, level) {\n            var bbb,\n                bbr,\n                ar,\n                b0,\n                b1,\n                r0,\n                r1,\n                m,\n                p0,\n                p1,\n                q0,\n                q1,\n                L = [],\n                maxLev = 5; // Maximum recursion level\n\n            bbr = this._bezierBbox(blue);\n            bbb = this._bezierBbox(red);\n\n            if (!this._bezierOverlap(bbr, bbb)) {\n                return [];\n            }\n\n            if (level < maxLev) {\n                ar = this._bezierSplit(red);\n                r0 = ar[0];\n                r1 = ar[1];\n\n                ar = this._bezierSplit(blue);\n                b0 = ar[0];\n                b1 = ar[1];\n\n                this._bezierListConcat(\n                    L,\n                    this._bezierMeetSubdivision(r0, b0, level + 1),\n                    0.0,\n                    0.0\n                );\n                this._bezierListConcat(\n                    L,\n                    this._bezierMeetSubdivision(r0, b1, level + 1),\n                    0,\n                    0.5\n                );\n                this._bezierListConcat(\n                    L,\n                    this._bezierMeetSubdivision(r1, b0, level + 1),\n                    0.5,\n                    0.0\n                );\n                this._bezierListConcat(\n                    L,\n                    this._bezierMeetSubdivision(r1, b1, level + 1),\n                    0.5,\n                    0.5\n                );\n\n                return L;\n            }\n\n            // Make homogeneous coordinates\n            q0 = [1].concat(red[0]);\n            q1 = [1].concat(red[3]);\n            p0 = [1].concat(blue[0]);\n            p1 = [1].concat(blue[3]);\n\n            m = this.meetSegmentSegment(q0, q1, p0, p1);\n\n            if (m[1] >= 0.0 && m[2] >= 0.0 && m[1] <= 1.0 && m[2] <= 1.0) {\n                return [m];\n            }\n\n            return [];\n        },\n\n        /**\n         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment\n         */\n        _bezierLineMeetSubdivision: function (red, blue, level, testSegment) {\n            var bbb,\n                bbr,\n                ar,\n                r0,\n                r1,\n                m,\n                p0,\n                p1,\n                q0,\n                q1,\n                L = [],\n                maxLev = 5; // Maximum recursion level\n\n            bbb = this._bezierBbox(blue);\n            bbr = this._bezierBbox(red);\n\n            if (testSegment && !this._bezierOverlap(bbr, bbb)) {\n                return [];\n            }\n\n            if (level < maxLev) {\n                ar = this._bezierSplit(red);\n                r0 = ar[0];\n                r1 = ar[1];\n\n                this._bezierListConcat(\n                    L,\n                    this._bezierLineMeetSubdivision(r0, blue, level + 1),\n                    0.0\n                );\n                this._bezierListConcat(\n                    L,\n                    this._bezierLineMeetSubdivision(r1, blue, level + 1),\n                    0.5\n                );\n\n                return L;\n            }\n\n            // Make homogeneous coordinates\n            q0 = [1].concat(red[0]);\n            q1 = [1].concat(red[3]);\n            p0 = [1].concat(blue[0]);\n            p1 = [1].concat(blue[1]);\n\n            m = this.meetSegmentSegment(q0, q1, p0, p1);\n\n            if (m[1] >= 0.0 && m[1] <= 1.0) {\n                if (!testSegment || (m[2] >= 0.0 && m[2] <= 1.0)) {\n                    return [m];\n                }\n            }\n\n            return [];\n        },\n\n        /**\n         * Find the nr-th intersection point of two Bezier curve segments.\n         * @param {Array} red Array of four coordinate arrays of length 2 defining the first\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @param {Array} blue Array of four coordinate arrays of length 2 defining the second\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment\n         * @returns {Array} Array containing the list of all intersection points as homogeneous coordinate arrays plus\n         * preimages [x,y], t_1, t_2] of the two Bezier curve segments.\n         *\n         */\n        meetBeziersegmentBeziersegment: function (red, blue, testSegment) {\n            var L, L2, i;\n\n            if (red.length === 4 && blue.length === 4) {\n                L = this._bezierMeetSubdivision(red, blue, 0);\n            } else {\n                L = this._bezierLineMeetSubdivision(red, blue, 0, testSegment);\n            }\n\n            L.sort(function (a, b) {\n                return (a[1] - b[1]) * 10000000.0 + (a[2] - b[2]);\n            });\n\n            L2 = [];\n            for (i = 0; i < L.length; i++) {\n                // Only push entries different from their predecessor\n                if (i === 0 || L[i][1] !== L[i - 1][1] || L[i][2] !== L[i - 1][2]) {\n                    L2.push(L[i]);\n                }\n            }\n            return L2;\n        },\n\n        /**\n         * Find the nr-th intersection point of two Bezier curves, i.e. curves with bezierDegree == 3.\n         * @param {JXG.Curve} red Curve with bezierDegree == 3\n         * @param {JXG.Curve} blue Curve with bezierDegree == 3\n         * @param {Number} nr The number of the intersection point which should be returned.\n         * @returns {Array} The homogeneous coordinates of the nr-th intersection point.\n         */\n        meetBezierCurveRedBlueSegments: function (red, blue, nr) {\n            var p,\n                i,\n                j,\n                k,\n                po,\n                redArr,\n                blueArr,\n                bbr,\n                bbb,\n                intersections,\n                startRed = 0,\n                startBlue = 0,\n                lenBlue = blue.numberPoints,\n                lenRed = red.numberPoints,\n                L = [];\n\n            if (lenBlue < blue.bezierDegree + 1 || lenRed < red.bezierDegree + 1) {\n                return [0, NaN, NaN];\n            }\n            lenBlue -= blue.bezierDegree;\n            lenRed -= red.bezierDegree;\n\n            // For sectors, we ignore the \"legs\"\n            if (red.type === Const.OBJECT_TYPE_SECTOR) {\n                startRed = 3;\n                lenRed -= 3;\n            }\n            if (blue.type === Const.OBJECT_TYPE_SECTOR) {\n                startBlue = 3;\n                lenBlue -= 3;\n            }\n\n            for (i = startRed; i < lenRed; i += red.bezierDegree) {\n                p = red.points;\n                redArr = [p[i].usrCoords.slice(1), p[i + 1].usrCoords.slice(1)];\n                if (red.bezierDegree === 3) {\n                    redArr[2] = p[i + 2].usrCoords.slice(1);\n                    redArr[3] = p[i + 3].usrCoords.slice(1);\n                }\n\n                bbr = this._bezierBbox(redArr);\n\n                for (j = startBlue; j < lenBlue; j += blue.bezierDegree) {\n                    p = blue.points;\n                    blueArr = [p[j].usrCoords.slice(1), p[j + 1].usrCoords.slice(1)];\n                    if (blue.bezierDegree === 3) {\n                        blueArr[2] = p[j + 2].usrCoords.slice(1);\n                        blueArr[3] = p[j + 3].usrCoords.slice(1);\n                    }\n\n                    bbb = this._bezierBbox(blueArr);\n                    if (this._bezierOverlap(bbr, bbb)) {\n                        intersections = this.meetBeziersegmentBeziersegment(redArr, blueArr);\n                        if (intersections.length === 0) {\n                            continue;\n                        }\n                        for (k = 0; k < intersections.length; k++) {\n                            po = intersections[k];\n                            if (\n                                po[1] < -Mat.eps ||\n                                po[1] > 1 + Mat.eps ||\n                                po[2] < -Mat.eps ||\n                                po[2] > 1 + Mat.eps\n                            ) {\n                                continue;\n                            }\n                            L.push(po);\n                        }\n                        if (L.length > nr) {\n                            return L[nr][0];\n                        }\n                    }\n                }\n            }\n            if (L.length > nr) {\n                return L[nr][0];\n            }\n\n            return [0, NaN, NaN];\n        },\n\n        bezierSegmentEval: function (t, curve) {\n            var f,\n                x,\n                y,\n                t1 = 1.0 - t;\n\n            x = 0;\n            y = 0;\n\n            f = t1 * t1 * t1;\n            x += f * curve[0][0];\n            y += f * curve[0][1];\n\n            f = 3.0 * t * t1 * t1;\n            x += f * curve[1][0];\n            y += f * curve[1][1];\n\n            f = 3.0 * t * t * t1;\n            x += f * curve[2][0];\n            y += f * curve[2][1];\n\n            f = t * t * t;\n            x += f * curve[3][0];\n            y += f * curve[3][1];\n\n            return [1.0, x, y];\n        },\n\n        /**\n         * Generate the defining points of a 3rd degree bezier curve that approximates\n         * a circle sector defined by three coordinate points A, B, C, each defined by an array of length three.\n         * The coordinate arrays are given in homogeneous coordinates.\n         * @param {Array} A First point\n         * @param {Array} B Second point (intersection point)\n         * @param {Array} C Third point\n         * @param {Boolean} withLegs Flag. If true the legs to the intersection point are part of the curve.\n         * @param {Number} sgn Wither 1 or -1. Needed for minor and major arcs. In case of doubt, use 1.\n         */\n        bezierArc: function (A, B, C, withLegs, sgn) {\n            var p1,\n                p2,\n                p3,\n                p4,\n                r,\n                phi,\n                beta,\n                PI2 = Math.PI * 0.5,\n                x = B[1],\n                y = B[2],\n                z = B[0],\n                dataX = [],\n                dataY = [],\n                co,\n                si,\n                ax,\n                ay,\n                bx,\n                by,\n                k,\n                v,\n                d,\n                matrix;\n\n            r = this.distance(B, A);\n\n            // x,y, z is intersection point. Normalize it.\n            x /= z;\n            y /= z;\n\n            phi = this.rad(A.slice(1), B.slice(1), C.slice(1));\n            if (sgn === -1) {\n                phi = 2 * Math.PI - phi;\n            }\n\n            p1 = A;\n            p1[1] /= p1[0];\n            p1[2] /= p1[0];\n            p1[0] /= p1[0];\n\n            p4 = p1.slice(0);\n\n            if (withLegs) {\n                dataX = [x, x + 0.333 * (p1[1] - x), x + 0.666 * (p1[1] - x), p1[1]];\n                dataY = [y, y + 0.333 * (p1[2] - y), y + 0.666 * (p1[2] - y), p1[2]];\n            } else {\n                dataX = [p1[1]];\n                dataY = [p1[2]];\n            }\n\n            while (phi > Mat.eps) {\n                if (phi > PI2) {\n                    beta = PI2;\n                    phi -= PI2;\n                } else {\n                    beta = phi;\n                    phi = 0;\n                }\n\n                co = Math.cos(sgn * beta);\n                si = Math.sin(sgn * beta);\n\n                matrix = [\n                    [1, 0, 0],\n                    [x * (1 - co) + y * si, co, -si],\n                    [y * (1 - co) - x * si, si, co]\n                ];\n                v = Mat.matVecMult(matrix, p1);\n                p4 = [v[0] / v[0], v[1] / v[0], v[2] / v[0]];\n\n                ax = p1[1] - x;\n                ay = p1[2] - y;\n                bx = p4[1] - x;\n                by = p4[2] - y;\n\n                d = Math.sqrt((ax + bx) * (ax + bx) + (ay + by) * (ay + by));\n\n                if (Math.abs(by - ay) > Mat.eps) {\n                    k = ((((ax + bx) * (r / d - 0.5)) / (by - ay)) * 8) / 3;\n                } else {\n                    k = ((((ay + by) * (r / d - 0.5)) / (ax - bx)) * 8) / 3;\n                }\n\n                p2 = [1, p1[1] - k * ay, p1[2] + k * ax];\n                p3 = [1, p4[1] + k * by, p4[2] - k * bx];\n\n                dataX = dataX.concat([p2[1], p3[1], p4[1]]);\n                dataY = dataY.concat([p2[2], p3[2], p4[2]]);\n                p1 = p4.slice(0);\n            }\n\n            if (withLegs) {\n                dataX = dataX.concat([\n                    p4[1] + 0.333 * (x - p4[1]),\n                    p4[1] + 0.666 * (x - p4[1]),\n                    x\n                ]);\n                dataY = dataY.concat([\n                    p4[2] + 0.333 * (y - p4[2]),\n                    p4[2] + 0.666 * (y - p4[2]),\n                    y\n                ]);\n            }\n\n            return [dataX, dataY];\n        },\n\n        /****************************************/\n        /****           PROJECTIONS          ****/\n        /****************************************/\n\n        /**\n         * Calculates the coordinates of the projection of a given point on a given circle. I.o.w. the\n         * nearest one of the two intersection points of the line through the given point and the circles\n         * center.\n         * @param {JXG.Point,JXG.Coords} point Point to project or coords object to project.\n         * @param {JXG.Circle} circle Circle on that the point is projected.\n         * @param {JXG.Board} [board=point.board] Reference to the board\n         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.\n         */\n        projectPointToCircle: function (point, circle, board) {\n            var dist,\n                P,\n                x,\n                y,\n                factor,\n                M = circle.center.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            // gave us a point\n            if (Type.isPoint(point)) {\n                dist = point.coords.distance(Const.COORDS_BY_USER, circle.center.coords);\n                P = point.coords.usrCoords;\n                // gave us coords\n            } else {\n                dist = point.distance(Const.COORDS_BY_USER, circle.center.coords);\n                P = point.usrCoords;\n            }\n\n            if (Math.abs(dist) < Mat.eps) {\n                dist = Mat.eps;\n            }\n\n            factor = circle.Radius() / dist;\n            x = M[1] + factor * (P[1] - M[1]);\n            y = M[2] + factor * (P[2] - M[2]);\n\n            return new Coords(Const.COORDS_BY_USER, [x, y], board);\n        },\n\n        /**\n         * Calculates the coordinates of the orthogonal projection of a given point on a given line. I.o.w. the\n         * intersection point of the given line and its perpendicular through the given point.\n         * @param {JXG.Point|JXG.Coords} point Point to project.\n         * @param {JXG.Line} line Line on that the point is projected.\n         * @param {JXG.Board} [board=point.board|board=line.board] Reference to a board.\n         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given line.\n         */\n        projectPointToLine: function (point, line, board) {\n            var v = [0, line.stdform[1], line.stdform[2]],\n                coords;\n\n            if (!Type.exists(board)) {\n                if (Type.exists(point.coords)) {\n                    board = point.board;\n                } else {\n                    board = line.board;\n                }\n            }\n\n            if (Type.exists(point.coords)) {\n                coords = point.coords.usrCoords;\n            } else {\n                coords = point.usrCoords;\n            }\n\n            v = Mat.crossProduct(v, coords);\n            return new Coords(Const.COORDS_BY_USER, Mat.crossProduct(v, line.stdform), board);\n        },\n\n        /**\n         * Calculates the coordinates of the orthogonal projection of a given coordinate array on a given line\n         * segment defined by two coordinate arrays.\n         * @param {Array} p Point to project.\n         * @param {Array} q1 Start point of the line segment on that the point is projected.\n         * @param {Array} q2 End point of the line segment on that the point is projected.\n         * @returns {Array} The coordinates of the projection of the given point on the given segment\n         * and the factor that determines the projected point as a convex combination of the\n         * two endpoints q1 and q2 of the segment.\n         */\n        projectCoordsToSegment: function (p, q1, q2) {\n            var t,\n                denom,\n                s = [q2[1] - q1[1], q2[2] - q1[2]],\n                v = [p[1] - q1[1], p[2] - q1[2]];\n\n            /**\n             * If the segment has length 0, i.e. is a point,\n             * the projection is equal to that point.\n             */\n            if (Math.abs(s[0]) < Mat.eps && Math.abs(s[1]) < Mat.eps) {\n                return [q1, 0];\n            }\n\n            t = Mat.innerProduct(v, s);\n            denom = Mat.innerProduct(s, s);\n            t /= denom;\n\n            return [[1, t * s[0] + q1[1], t * s[1] + q1[2]], t];\n        },\n\n        /**\n         * Finds the coordinates of the closest point on a Bezier segment of a\n         * {@link JXG.Curve} to a given coordinate array.\n         * @param {Array} pos Point to project in homogeneous coordinates.\n         * @param {JXG.Curve} curve Curve of type \"plot\" having Bezier degree 3.\n         * @param {Number} start Number of the Bezier segment of the curve.\n         * @returns {Array} The coordinates of the projection of the given point\n         * on the given Bezier segment and the preimage of the curve which\n         * determines the closest point.\n         */\n        projectCoordsToBeziersegment: function (pos, curve, start) {\n            var t0,\n                /** @ignore */\n                minfunc = function (t) {\n                    var z = [1, curve.X(start + t), curve.Y(start + t)];\n\n                    z[1] -= pos[1];\n                    z[2] -= pos[2];\n\n                    return z[1] * z[1] + z[2] * z[2];\n                };\n\n            t0 = JXG.Math.Numerics.fminbr(minfunc, [0.0, 1.0]);\n\n            return [[1, curve.X(t0 + start), curve.Y(t0 + start)], t0];\n        },\n\n        /**\n         * Calculates the coordinates of the projection of a given point on a given curve.\n         * Uses {@link JXG.Math.Geometry.projectCoordsToCurve}.\n         *\n         * @param {JXG.Point} point Point to project.\n         * @param {JXG.Curve} curve Curve on that the point is projected.\n         * @param {JXG.Board} [board=point.board] Reference to a board.\n         * @see #projectCoordsToCurve\n         * @returns {Array} [JXG.Coords, position] The coordinates of the projection of the given\n         * point on the given graph and the relative position on the curve (real number).\n         */\n        projectPointToCurve: function (point, curve, board) {\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            var x = point.X(),\n                y = point.Y(),\n                t = point.position || 0.0,\n                result = this.projectCoordsToCurve(x, y, t, curve, board);\n\n            // point.position = result[1];\n\n            return result;\n        },\n\n        /**\n         * Calculates the coordinates of the projection of a coordinates pair on a given curve. In case of\n         * function graphs this is the\n         * intersection point of the curve and the parallel to y-axis through the given point.\n         * @param {Number} x coordinate to project.\n         * @param {Number} y coordinate to project.\n         * @param {Number} t start value for newtons method\n         * @param {JXG.Curve} curve Curve on that the point is projected.\n         * @param {JXG.Board} [board=curve.board] Reference to a board.\n         * @see #projectPointToCurve\n         * @returns {JXG.Coords} Array containing the coordinates of the projection of the given point on the given curve and\n         * the position on the curve.\n         */\n        projectCoordsToCurve: function (x, y, t, curve, board) {\n            var newCoords,\n                newCoordsObj,\n                i,\n                j,\n                mindist,\n                dist,\n                lbda,\n                v,\n                coords,\n                d,\n                p1,\n                p2,\n                res,\n                minfunc,\n                t_new,\n                f_new,\n                f_old,\n                delta,\n                steps,\n                minX,\n                maxX,\n                infty = Number.POSITIVE_INFINITY;\n\n            if (!Type.exists(board)) {\n                board = curve.board;\n            }\n\n            if (Type.evaluate(curve.visProp.curvetype) === \"plot\") {\n                t = 0;\n                mindist = infty;\n                if (curve.numberPoints === 0) {\n                    newCoords = [0, 1, 1];\n                } else {\n                    newCoords = [curve.Z(0), curve.X(0), curve.Y(0)];\n                }\n\n                if (curve.numberPoints > 1) {\n                    v = [1, x, y];\n                    if (curve.bezierDegree === 3) {\n                        j = 0;\n                    } else {\n                        p1 = [curve.Z(0), curve.X(0), curve.Y(0)];\n                    }\n                    for (i = 0; i < curve.numberPoints - 1; i++) {\n                        if (curve.bezierDegree === 3) {\n                            res = this.projectCoordsToBeziersegment(v, curve, j);\n                        } else {\n                            p2 = [curve.Z(i + 1), curve.X(i + 1), curve.Y(i + 1)];\n                            res = this.projectCoordsToSegment(v, p1, p2);\n                        }\n                        lbda = res[1];\n                        coords = res[0];\n\n                        if (0.0 <= lbda && lbda <= 1.0) {\n                            dist = this.distance(coords, v);\n                            d = i + lbda;\n                        } else if (lbda < 0.0) {\n                            coords = p1;\n                            dist = this.distance(p1, v);\n                            d = i;\n                        } else if (lbda > 1.0 && i === curve.numberPoints - 2) {\n                            coords = p2;\n                            dist = this.distance(coords, v);\n                            d = curve.numberPoints - 1;\n                        }\n\n                        if (dist < mindist) {\n                            mindist = dist;\n                            t = d;\n                            newCoords = coords;\n                        }\n\n                        if (curve.bezierDegree === 3) {\n                            j++;\n                            i += 2;\n                        } else {\n                            p1 = p2;\n                        }\n                    }\n                }\n\n                newCoordsObj = new Coords(Const.COORDS_BY_USER, newCoords, board);\n            } else {\n                // 'parameter', 'polar', 'functiongraph'\n                /** @ignore */\n                minfunc = function (t) {\n                    var dx, dy;\n                    if (t < curve.minX() || t > curve.maxX()) {\n                        return Infinity;\n                    }\n                    dx = x - curve.X(t);\n                    dy = y - curve.Y(t);\n                    return dx * dx + dy * dy;\n                };\n\n                f_old = minfunc(t);\n                steps = 50;\n                minX = curve.minX();\n                maxX = curve.maxX();\n\n                delta = (maxX - minX) / steps;\n                t_new = minX;\n\n                for (i = 0; i < steps; i++) {\n                    f_new = minfunc(t_new);\n\n                    if (f_new < f_old || f_old === Infinity || isNaN(f_old)) {\n                        t = t_new;\n                        f_old = f_new;\n                    }\n\n                    t_new += delta;\n                }\n\n                //t = Numerics.root(Numerics.D(minfunc), t);\n                t = Numerics.fminbr(minfunc, [\n                    Math.max(t - delta, minX),\n                    Math.min(t + delta, maxX)\n                ]);\n\n                // Distinction between closed and open curves is not necessary.\n                // If closed, the cyclic projection shift will work anyhow\n                // if (Math.abs(curve.X(minX) - curve.X(maxX)) < Mat.eps &&\n                //     Math.abs(curve.Y(minX) - curve.Y(maxX)) < Mat.eps) {\n                //     // Cyclically\n                //     if (t < minX) {\n                //         t = maxX + t - minX;\n                //     }\n                //     if (t > maxX) {\n                //         t = minX + t - maxX;\n                //     }\n                // } else {\n                t = t < minX ? minX : t;\n                t = t > maxX ? maxX : t;\n                // }\n\n                newCoordsObj = new Coords(\n                    Const.COORDS_BY_USER,\n                    [curve.X(t), curve.Y(t)],\n                    board\n                );\n            }\n\n            return [curve.updateTransform(newCoordsObj), t];\n        },\n\n        /**\n         * Calculates the coordinates of the closest orthogonal projection of a given coordinate array onto the\n         * border of a polygon.\n         * @param {Array} p Point to project.\n         * @param {JXG.Polygon} pol Polygon element\n         * @returns {Array} The coordinates of the closest projection of the given point to the border of the polygon.\n         */\n        projectCoordsToPolygon: function (p, pol) {\n            var i,\n                len = pol.vertices.length,\n                d_best = Infinity,\n                d,\n                projection,\n                proj,\n                bestprojection;\n\n            for (i = 0; i < len - 1; i++) {\n                projection = JXG.Math.Geometry.projectCoordsToSegment(\n                    p,\n                    pol.vertices[i].coords.usrCoords,\n                    pol.vertices[i + 1].coords.usrCoords\n                );\n\n                if (0 <= projection[1] && projection[1] <= 1) {\n                    d = JXG.Math.Geometry.distance(projection[0], p, 3);\n                    proj = projection[0];\n                } else if (projection[1] < 0) {\n                    d = JXG.Math.Geometry.distance(pol.vertices[i].coords.usrCoords, p, 3);\n                    proj = pol.vertices[i].coords.usrCoords;\n                } else {\n                    d = JXG.Math.Geometry.distance(pol.vertices[i + 1].coords.usrCoords, p, 3);\n                    proj = pol.vertices[i + 1].coords.usrCoords;\n                }\n                if (d < d_best) {\n                    bestprojection = proj.slice(0);\n                    d_best = d;\n                }\n            }\n            return bestprojection;\n        },\n\n        /**\n         * Calculates the coordinates of the projection of a given point on a given turtle. A turtle consists of\n         * one or more curves of curveType 'plot'. Uses {@link JXG.Math.Geometry.projectPointToCurve}.\n         * @param {JXG.Point} point Point to project.\n         * @param {JXG.Turtle} turtle on that the point is projected.\n         * @param {JXG.Board} [board=point.board] Reference to a board.\n         * @returns {Array} [JXG.Coords, position] Array containing the coordinates of the projection of the given point on the turtle and\n         * the position on the turtle.\n         */\n        projectPointToTurtle: function (point, turtle, board) {\n            var newCoords,\n                t,\n                x,\n                y,\n                i,\n                dist,\n                el,\n                minEl,\n                res,\n                newPos,\n                np = 0,\n                npmin = 0,\n                mindist = Number.POSITIVE_INFINITY,\n                len = turtle.objects.length;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            // run through all curves of this turtle\n            for (i = 0; i < len; i++) {\n                el = turtle.objects[i];\n\n                if (el.elementClass === Const.OBJECT_CLASS_CURVE) {\n                    res = this.projectPointToCurve(point, el);\n                    newCoords = res[0];\n                    newPos = res[1];\n                    dist = this.distance(newCoords.usrCoords, point.coords.usrCoords);\n\n                    if (dist < mindist) {\n                        x = newCoords.usrCoords[1];\n                        y = newCoords.usrCoords[2];\n                        t = newPos;\n                        mindist = dist;\n                        minEl = el;\n                        npmin = np;\n                    }\n                    np += el.numberPoints;\n                }\n            }\n\n            newCoords = new Coords(Const.COORDS_BY_USER, [x, y], board);\n            // point.position = t + npmin;\n            // return minEl.updateTransform(newCoords);\n            return [minEl.updateTransform(newCoords), t + npmin];\n        },\n\n        /**\n         * Trivial projection of a point to another point.\n         * @param {JXG.Point} point Point to project (not used).\n         * @param {JXG.Point} dest Point on that the point is projected.\n         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.\n         */\n        projectPointToPoint: function (point, dest) {\n            return dest.coords;\n        },\n\n        /**\n         *\n         * @param {JXG.Point|JXG.Coords} point\n         * @param {JXG.Board} [board]\n         */\n        projectPointToBoard: function (point, board) {\n            var i,\n                l,\n                c,\n                brd = board || point.board,\n                // comparison factor, point coord idx, bbox idx, 1st bbox corner x & y idx, 2nd bbox corner x & y idx\n                config = [\n                    // left\n                    [1, 1, 0, 0, 3, 0, 1],\n                    // top\n                    [-1, 2, 1, 0, 1, 2, 1],\n                    // right\n                    [-1, 1, 2, 2, 1, 2, 3],\n                    // bottom\n                    [1, 2, 3, 0, 3, 2, 3]\n                ],\n                coords = point.coords || point,\n                bbox = brd.getBoundingBox();\n\n            for (i = 0; i < 4; i++) {\n                c = config[i];\n                if (c[0] * coords.usrCoords[c[1]] < c[0] * bbox[c[2]]) {\n                    // define border\n                    l = Mat.crossProduct(\n                        [1, bbox[c[3]], bbox[c[4]]],\n                        [1, bbox[c[5]], bbox[c[6]]]\n                    );\n                    l[3] = 0;\n                    l = Mat.normalize(l);\n\n                    // project point\n                    coords = this.projectPointToLine({ coords: coords }, { stdform: l }, brd);\n                }\n            }\n\n            return coords;\n        },\n\n        /**\n         * Calculates the distance of a point to a line. The point and the line are given by homogeneous\n         * coordinates. For lines this can be line.stdform.\n         * @param {Array} point Homogeneous coordinates of a point.\n         * @param {Array} line Homogeneous coordinates of a line ([C,A,B] where A*x+B*y+C*z=0).\n         * @returns {Number} Distance of the point to the line.\n         */\n        distPointLine: function (point, line) {\n            var a = line[1],\n                b = line[2],\n                c = line[0],\n                nom;\n\n            if (Math.abs(a) + Math.abs(b) < Mat.eps) {\n                return Number.POSITIVE_INFINITY;\n            }\n\n            nom = a * point[1] + b * point[2] + c;\n            a *= a;\n            b *= b;\n\n            return Math.abs(nom) / Math.sqrt(a + b);\n        },\n\n        /**\n         * Helper function to create curve which displays a Reuleaux polygons.\n         * @param {Array} points Array of points which should be the vertices of the Reuleaux polygon. Typically,\n         * these point list is the array vertices of a regular polygon.\n         * @param {Number} nr Number of vertices\n         * @returns {Array} An array containing the two functions defining the Reuleaux polygon and the two values\n         * for the start and the end of the paramtric curve. array may be used as parent array of a\n         * {@link JXG.Curve}.\n         *\n         * @example\n         * var A = brd.create('point',[-2,-2]);\n         * var B = brd.create('point',[0,1]);\n         * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});\n         * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),\n         *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});\n         *\n         * </pre><div class=\"jxgbox\" id=\"JXG2543a843-46a9-4372-abc1-94d9ad2db7ac\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         * var brd = JXG.JSXGraph.initBoard('JXG2543a843-46a9-4372-abc1-94d9ad2db7ac', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright:false, shownavigation: false});\n         * var A = brd.create('point',[-2,-2]);\n         * var B = brd.create('point',[0,1]);\n         * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});\n         * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),\n         *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});\n         * </script><pre>\n         */\n        reuleauxPolygon: function (points, nr) {\n            var beta,\n                pi2 = Math.PI * 2,\n                pi2_n = pi2 / nr,\n                diag = (nr - 1) / 2,\n                d = 0,\n                makeFct = function (which, trig) {\n                    return function (t, suspendUpdate) {\n                        var t1 = ((t % pi2) + pi2) % pi2,\n                            j = Math.floor(t1 / pi2_n) % nr;\n\n                        if (!suspendUpdate) {\n                            d = points[0].Dist(points[diag]);\n                            beta = Mat.Geometry.rad(\n                                [points[0].X() + 1, points[0].Y()],\n                                points[0],\n                                points[diag % nr]\n                            );\n                        }\n\n                        if (isNaN(j)) {\n                            return j;\n                        }\n\n                        t1 = t1 * 0.5 + j * pi2_n * 0.5 + beta;\n\n                        return points[j][which]() + d * Math[trig](t1);\n                    };\n                };\n\n            return [makeFct(\"X\", \"cos\"), makeFct(\"Y\", \"sin\"), 0, pi2];\n        },\n\n        meet3Planes: function (n1, d1, n2, d2, n3, d3) {\n            var p = [0, 0, 0],\n                n31,\n                n12,\n                n23,\n                denom,\n                i;\n\n            n31 = Mat.crossProduct(n3, n1);\n            n12 = Mat.crossProduct(n1, n2);\n            n23 = Mat.crossProduct(n2, n3);\n            denom = Mat.innerProduct(n1, n23, 3);\n            for (i = 0; i < 3; i++) {\n                p[i] = (d1 * n23[i] + d2 * n31[i] + d3 * n12[i]) / denom;\n            }\n            return p;\n        },\n\n        meetPlanePlane: function (v11, v12, v21, v22) {\n            var i,\n                no1,\n                no2,\n                v = [0, 0, 0],\n                w = [0, 0, 0];\n\n            for (i = 0; i < 3; i++) {\n                v[i] = Type.evaluate(v11[i]);\n                w[i] = Type.evaluate(v12[i]);\n            }\n            no1 = Mat.crossProduct(v, w);\n\n            for (i = 0; i < 3; i++) {\n                v[i] = Type.evaluate(v21[i]);\n                w[i] = Type.evaluate(v22[i]);\n            }\n            no2 = Mat.crossProduct(v, w);\n\n            return Mat.crossProduct(no1, no2);\n        },\n\n        project3DTo3DPlane: function (point, normal, foot) {\n            // TODO: homogeneous 3D coordinates\n            var sol = [0, 0, 0],\n                le,\n                d1,\n                d2,\n                lbda;\n\n            foot = foot || [0, 0, 0];\n\n            le = Mat.norm(normal);\n            d1 = Mat.innerProduct(point, normal, 3);\n            d2 = Mat.innerProduct(foot, normal, 3);\n            // (point - lbda * normal / le) * normal / le == foot * normal / le\n            // => (point * normal - foot * normal) ==  lbda * le\n            lbda = (d1 - d2) / le;\n            sol = Mat.axpy(-lbda, normal, point);\n\n            return sol;\n        },\n\n        getPlaneBounds: function (v1, v2, q, s, e) {\n            var s1, s2, e1, e2, mat, rhs, sol;\n\n            if (v1[2] + v2[0] !== 0) {\n                mat = [\n                    [v1[0], v2[0]],\n                    [v1[1], v2[1]]\n                ];\n                rhs = [s - q[0], s - q[1]];\n\n                sol = Numerics.Gauss(mat, rhs);\n                s1 = sol[0];\n                s2 = sol[1];\n\n                rhs = [e - q[0], e - q[1]];\n                sol = Numerics.Gauss(mat, rhs);\n                e1 = sol[0];\n                e2 = sol[1];\n                return [s1, e1, s2, e2];\n            }\n            return null;\n        }\n    }\n);\n\nexport default Mat.Geometry;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Mat from \"./math\";\nimport Type from \"../utils/type\";\n\nJXG.Math.DoubleBits = function () {\n    var hasTypedArrays = false,\n        DOUBLE_VIEW = new Float64Array(1),\n        UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer),\n        doubleBitsLE,\n        toDoubleLE,\n        lowUintLE,\n        highUintLE,\n        doubleBitsBE,\n        toDoubleBE,\n        lowUintBE,\n        highUintBE,\n        doubleBits,\n        toDouble,\n        lowUint,\n        highUint;\n\n    if (Float64Array !== undefined) {\n        DOUBLE_VIEW[0] = 1.0;\n        hasTypedArrays = true;\n        if (UINT_VIEW[1] === 0x3ff00000) {\n            // Use little endian\n            doubleBitsLE = function (n) {\n                DOUBLE_VIEW[0] = n;\n                return [UINT_VIEW[0], UINT_VIEW[1]];\n            };\n            toDoubleLE = function (lo, hi) {\n                UINT_VIEW[0] = lo;\n                UINT_VIEW[1] = hi;\n                return DOUBLE_VIEW[0];\n            };\n\n            lowUintLE = function (n) {\n                DOUBLE_VIEW[0] = n;\n                return UINT_VIEW[0];\n            };\n\n            highUintLE = function (n) {\n                DOUBLE_VIEW[0] = n;\n                return UINT_VIEW[1];\n            };\n\n            this.doubleBits = doubleBitsLE;\n            this.pack = toDoubleLE;\n            this.lo = lowUintLE;\n            this.hi = highUintLE;\n        } else if (UINT_VIEW[0] === 0x3ff00000) {\n            //Use big endian\n            doubleBitsBE = function (n) {\n                DOUBLE_VIEW[0] = n;\n                return [UINT_VIEW[1], UINT_VIEW[0]];\n            };\n\n            toDoubleBE = function (lo, hi) {\n                UINT_VIEW[1] = lo;\n                UINT_VIEW[0] = hi;\n                return DOUBLE_VIEW[0];\n            };\n\n            lowUintBE = function (n) {\n                DOUBLE_VIEW[0] = n;\n                return UINT_VIEW[1];\n            };\n\n            highUintBE = function (n) {\n                DOUBLE_VIEW[0] = n;\n                return UINT_VIEW[0];\n            };\n\n            this.doubleBits = doubleBitsBE;\n            this.pack = toDoubleBE;\n            this.lo = lowUintBE;\n            this.hi = highUintBE;\n        } else {\n            hasTypedArrays = false;\n        }\n    }\n\n    // if (!hasTypedArrays) {\n    //     var buffer = new Buffer(8)\n    //     doubleBits = function(n) {\n    //         buffer.writeDoubleLE(n, 0, true);\n    //         return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];\n    //     };\n\n    //     toDouble = function(lo, hi) {\n    //         buffer.writeUInt32LE(lo, 0, true);\n    //         buffer.writeUInt32LE(hi, 4, true);\n    //         return buffer.readDoubleLE(0, true);\n    //     };\n    //     lowUint = function(n) {\n    //         buffer.writeDoubleLE(n, 0, true);\n    //         return buffer.readUInt32LE(0, true);\n    //     };\n\n    //     highUint = function(n) {\n    //         buffer.writeDoubleLE(n, 0, true);\n    //         return buffer.readUInt32LE(4, true);\n    //     };\n\n    //     this.doubleBits = doubleBits;\n    //     this.pack = toDouble;\n    //     this.lo = lowUint;\n    //     this.hi = highUint;\n    // }\n};\n\nJXG.extend(\n    JXG.Math.DoubleBits.prototype,\n    /** @lends JXG.Math.DoubleBits.prototype */ {\n        sign: function (n) {\n            return this.hi(n) >>> 31;\n        },\n\n        exponent: function (n) {\n            var b = this.hi(n);\n            return ((b << 1) >>> 21) - 1023;\n        },\n\n        fraction: function (n) {\n            var lo = this.lo(n),\n                hi = this.hi(n),\n                b = hi & ((1 << 20) - 1);\n\n            if (hi & 0x7ff00000) {\n                b += 1 << 20;\n            }\n            return [lo, b];\n        },\n\n        denormalized: function (n) {\n            var hi = this.hi(n);\n            return !(hi & 0x7ff00000);\n        }\n    }\n);\n\nvar doubleBits = new JXG.Math.DoubleBits(),\n    /**\n     * Interval for interval arithmetics. Consists of the properties\n     * <ul>\n     *  <li>lo\n     *  <li>hi\n     * </ul>\n     * @name JXG.Math.Interval\n     * @type Object\n     */\n    MatInterval = function (lo, hi) {\n        if (lo !== undefined && hi !== undefined) {\n            // possible cases:\n            // - Interval(1, 2)\n            // - Interval(Interval(1, 1), Interval(2, 2))     // singletons are required\n            if (Mat.IntervalArithmetic.isInterval(lo)) {\n                if (!Mat.IntervalArithmetic.isSingleton(lo)) {\n                    throw new TypeError(\n                        \"JXG.Math.IntervalArithmetic: interval `lo` must be a singleton\"\n                    );\n                }\n                this.lo = lo.lo;\n            } else {\n                this.lo = lo;\n            }\n            if (Mat.IntervalArithmetic.isInterval(hi)) {\n                if (!Mat.IntervalArithmetic.isSingleton(hi)) {\n                    throw new TypeError(\n                        \"JXG.Math.IntervalArithmetic: interval `hi` must be a singleton\"\n                    );\n                }\n                this.hi = hi.hi;\n            } else {\n                this.hi = hi;\n            }\n        } else if (lo !== undefined) {\n            // possible cases:\n            // - Interval([1, 2])\n            // - Interval([Interval(1, 1), Interval(2, 2)])\n            if (Array.isArray(lo)) {\n                return new MatInterval(lo[0], lo[1]);\n            }\n            // - Interval(1)\n            return new MatInterval(lo, lo);\n        } else {\n            // This else is necessary even if jslint declares it as redundant\n            // possible cases:\n            // - Interval()\n            this.lo = this.hi = 0;\n        }\n    };\n\nJXG.extend(MatInterval.prototype, {\n    print: function () {\n        console.log(\"[\", this.lo, this.hi, \"]\");\n    },\n\n    set: function (lo, hi) {\n        this.lo = lo;\n        this.hi = hi;\n        return this;\n    },\n\n    bounded: function (lo, hi) {\n        return this.set(Mat.IntervalArithmetic.prev(lo), Mat.IntervalArithmetic.next(hi));\n    },\n\n    boundedSingleton: function (v) {\n        return this.bounded(v, v);\n    },\n\n    assign: function (lo, hi) {\n        if (typeof lo !== \"number\" || typeof hi !== \"number\") {\n            throw new TypeError(\"JXG.Math.Interval#assign: arguments must be numbers\");\n        }\n        if (isNaN(lo) || isNaN(hi) || lo > hi) {\n            return this.setEmpty();\n        }\n        return this.set(lo, hi);\n    },\n\n    setEmpty: function () {\n        return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);\n    },\n\n    setWhole: function () {\n        return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\n    },\n\n    open: function (lo, hi) {\n        return this.assign(Mat.IntervalArithmetic.next(lo), Mat.IntervalArithmetic.prev(hi));\n    },\n\n    halfOpenLeft: function (lo, hi) {\n        return this.assign(Mat.IntervalArithmetic.next(lo), hi);\n    },\n\n    halfOpenRight: function (lo, hi) {\n        return this.assign(lo, Mat.IntervalArithmetic.prev(hi));\n    },\n\n    toArray: function () {\n        return [this.lo, this.hi];\n    },\n\n    clone: function () {\n        return new MatInterval().set(this.lo, this.hi);\n    }\n});\n\n/**\n * Object for interval arithmetics.\n * @name JXG.Math.IntervalArithmetic\n * @namespace\n */\nJXG.Math.IntervalArithmetic = {\n    Interval: function (lo, hi) {\n        return new MatInterval(lo, hi);\n    },\n\n    isInterval: function (i) {\n        return (\n            i !== null &&\n            typeof i === \"object\" &&\n            typeof i.lo === \"number\" &&\n            typeof i.hi === \"number\"\n        );\n    },\n\n    isSingleton: function (i) {\n        return i.lo === i.hi;\n    },\n\n    /*\n     * Arithmetics\n     */\n\n    /**\n     * Addition\n     *\n     * @param {JXG.Math.Interval|Number} x\n     * @param {JXG.Math.Interval|Number} y\n     * @returns JXG.Math.Interval\n     */\n    add: function (x, y) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n        return new MatInterval(this.addLo(x.lo, y.lo), this.addHi(x.hi, y.hi));\n    },\n\n    /**\n     * Subtraction\n     *\n     * @param {JXG.Math.Interval|Number} x\n     * @param {JXG.Math.Interval|Number} y\n     * @returns JXG.Math.Interval\n     */\n    sub: function (x, y) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n        return new MatInterval(this.subLo(x.lo, y.hi), this.subHi(x.hi, y.lo));\n    },\n\n    /**\n     * Multiplication\n     *\n     * @param {JXG.Math.Interval|Number} x\n     * @param {JXG.Math.Interval|Number} y\n     * @returns JXG.Math.Interval\n     */\n    mul: function (x, y) {\n        var xl, xh, yl, yh, out;\n\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return this.EMPTY.clone();\n        }\n        xl = x.lo;\n        xh = x.hi;\n        yl = y.lo;\n        yh = y.hi;\n        out = new MatInterval();\n\n        if (xl < 0) {\n            if (xh > 0) {\n                if (yl < 0) {\n                    if (yh > 0) {\n                        // mixed * mixed\n                        out.lo = Math.min(this.mulLo(xl, yh), this.mulLo(xh, yl));\n                        out.hi = Math.max(this.mulHi(xl, yl), this.mulHi(xh, yh));\n                    } else {\n                        // mixed * negative\n                        out.lo = this.mulLo(xh, yl);\n                        out.hi = this.mulHi(xl, yl);\n                    }\n                } else {\n                    if (yh > 0) {\n                        // mixed * positive\n                        out.lo = this.mulLo(xl, yh);\n                        out.hi = this.mulHi(xh, yh);\n                    } else {\n                        // mixed * zero\n                        out.lo = 0;\n                        out.hi = 0;\n                    }\n                }\n            } else {\n                if (yl < 0) {\n                    if (yh > 0) {\n                        // negative * mixed\n                        out.lo = this.mulLo(xl, yh);\n                        out.hi = this.mulHi(xl, yl);\n                    } else {\n                        // negative * negative\n                        out.lo = this.mulLo(xh, yh);\n                        out.hi = this.mulHi(xl, yl);\n                    }\n                } else {\n                    if (yh > 0) {\n                        // negative * positive\n                        out.lo = this.mulLo(xl, yh);\n                        out.hi = this.mulHi(xh, yl);\n                    } else {\n                        // negative * zero\n                        out.lo = 0;\n                        out.hi = 0;\n                    }\n                }\n            }\n        } else {\n            if (xh > 0) {\n                if (yl < 0) {\n                    if (yh > 0) {\n                        // positive * mixed\n                        out.lo = this.mulLo(xh, yl);\n                        out.hi = this.mulHi(xh, yh);\n                    } else {\n                        // positive * negative\n                        out.lo = this.mulLo(xh, yl);\n                        out.hi = this.mulHi(xl, yh);\n                    }\n                } else {\n                    if (yh > 0) {\n                        // positive * positive\n                        out.lo = this.mulLo(xl, yl);\n                        out.hi = this.mulHi(xh, yh);\n                    } else {\n                        // positive * zero\n                        out.lo = 0;\n                        out.hi = 0;\n                    }\n                }\n            } else {\n                // zero * any other value\n                out.lo = 0;\n                out.hi = 0;\n            }\n        }\n        return out;\n    },\n\n    /**\n     * Division\n     *\n     * @param {JXG.Math.Interval|Number} x\n     * @param {JXG.Math.Interval|Number} y\n     * @returns JXG.Math.Interval\n     */\n    div: function (x, y) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return this.EMPTY.clone();\n        }\n        if (this.zeroIn(y)) {\n            if (y.lo !== 0) {\n                if (y.hi !== 0) {\n                    return this.divZero(x);\n                }\n                return this.divNegative(x, y.lo);\n            }\n            if (y.hi !== 0) {\n                return this.divPositive(x, y.hi);\n            }\n            return this.EMPTY.clone();\n        }\n        return this.divNonZero(x, y);\n    },\n\n    /**\n     * Return +x (i.e. identity)\n     *\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    positive: function (x) {\n        return new MatInterval(x.lo, x.hi);\n    },\n\n    /**\n     * Return -x\n     *\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    negative: function (x) {\n        if (Type.isNumber(x)) {\n            return new MatInterval(-x);\n        }\n        return new MatInterval(-x.hi, -x.lo);\n    },\n\n    /*\n     * Utils\n     */\n\n    /**\n     * Test if interval is empty set.\n     * @param {JXG.Math.Interval} i\n     * @returns Boolean\n     */\n    isEmpty: function (i) {\n        return i.lo > i.hi;\n    },\n\n    /**\n     * Test if interval is (-Infinity, Infinity).\n     * @param {JXG.Math.Interval} i\n     * @returns Boolean\n     */\n    isWhole: function (i) {\n        return i.lo === -Infinity && i.hi === Infinity;\n    },\n\n    /**\n     * Test if interval contains 0.\n     * @param {JXG.Math.Interval} i\n     * @returns Boolean\n     */\n    zeroIn: function (i) {\n        return this.hasValue(i, 0);\n    },\n\n    /**\n     * Test if interval contains a specific value.\n     * @param {JXG.Math.Interval} i\n     * @param {Number} value\n     * @returns Boolean\n     */\n    hasValue: function (i, value) {\n        if (this.isEmpty(i)) {\n            return false;\n        }\n        return i.lo <= value && value <= i.hi;\n    },\n\n    /**\n     * Test if interval x contains interval y.\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns Boolean\n     */\n    hasInterval: function (x, y) {\n        if (this.isEmpty(x)) {\n            return true;\n        }\n        return !this.isEmpty(y) && y.lo <= x.lo && x.hi <= y.hi;\n    },\n\n    /**\n     * Test if intervals x and y have non-zero intersection.\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns Boolean\n     */\n    intervalsOverlap: function (x, y) {\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return false;\n        }\n        return (x.lo <= y.lo && y.lo <= x.hi) || (y.lo <= x.lo && x.lo <= y.hi);\n    },\n\n    /*\n     * Division\n     */\n    /**\n     * @private\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    divNonZero: function (x, y) {\n        var xl = x.lo,\n            xh = x.hi,\n            yl = y.lo,\n            yh = y.hi,\n            out = new MatInterval();\n\n        if (xh < 0) {\n            if (yh < 0) {\n                out.lo = this.divLo(xh, yl);\n                out.hi = this.divHi(xl, yh);\n            } else {\n                out.lo = this.divLo(xl, yl);\n                out.hi = this.divHi(xh, yh);\n            }\n        } else if (xl < 0) {\n            if (yh < 0) {\n                out.lo = this.divLo(xh, yh);\n                out.hi = this.divHi(xl, yh);\n            } else {\n                out.lo = this.divLo(xl, yl);\n                out.hi = this.divHi(xh, yl);\n            }\n        } else {\n            if (yh < 0) {\n                out.lo = this.divLo(xh, yh);\n                out.hi = this.divHi(xl, yl);\n            } else {\n                out.lo = this.divLo(xl, yh);\n                out.hi = this.divHi(xh, yl);\n            }\n        }\n        return out;\n    },\n\n    /**\n     * @private\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    divPositive: function (x, v) {\n        if (x.lo === 0 && x.hi === 0) {\n            return x;\n        }\n\n        if (this.zeroIn(x)) {\n            // mixed considering zero in both ends\n            return this.WHOLE;\n        }\n\n        if (x.hi < 0) {\n            // negative / v\n            return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(x.hi, v));\n        }\n        // positive / v\n        return new MatInterval(this.divLo(x.lo, v), Number.POSITIVE_INFINITY);\n    },\n\n    /**\n     * @private\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    divNegative: function (x, v) {\n        if (x.lo === 0 && x.hi === 0) {\n            return x;\n        }\n\n        if (this.zeroIn(x)) {\n            // mixed considering zero in both ends\n            return this.WHOLE;\n        }\n\n        if (x.hi < 0) {\n            // negative / v\n            return new MatInterval(this.divLo(x.hi, v), Number.POSITIVE_INFINITY);\n        }\n        // positive / v\n        return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(x.lo, v));\n    },\n\n    /**\n     * @private\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    divZero: function (x) {\n        if (x.lo === 0 && x.hi === 0) {\n            return x;\n        }\n        return this.WHOLE;\n    },\n\n    /*\n     * Algebra\n     */\n    /**\n     * x mod y:  x - n * y\n     * @param {JXG.Math.Interval|Number} x\n     * @param {JXG.Math.Interval|Number} y\n     * @returns JXG.Math.Interval\n     */\n    fmod: function (x, y) {\n        var yb, n;\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return this.EMPTY.clone();\n        }\n        yb = x.lo < 0 ? y.lo : y.hi;\n        n = x.lo / yb;\n        if (n < 0) {\n            n = Math.ceil(n);\n        } else {\n            n = Math.floor(n);\n        }\n        // x mod y = x - n * y\n        return this.sub(x, this.mul(y, new MatInterval(n)));\n    },\n\n    /**\n     * 1 / x\n     * @param {JXG.Math.Interval|Number} x\n     * @returns JXG.Math.Interval\n     */\n    multiplicativeInverse: function (x) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        if (this.zeroIn(x)) {\n            if (x.lo !== 0) {\n                if (x.hi !== 0) {\n                    // [negative, positive]\n                    return this.WHOLE;\n                }\n                // [negative, zero]\n                return new MatInterval(Number.NEGATIVE_INFINITY, this.divHi(1, x.lo));\n            }\n            if (x.hi !== 0) {\n                // [zero, positive]\n                return new MatInterval(this.divLo(1, x.hi), Number.POSITIVE_INFINITY);\n            }\n            // [zero, zero]\n            return this.EMPTY.clone();\n        }\n        // [positive, positive]\n        return new MatInterval(this.divLo(1, x.hi), this.divHi(1, x.lo));\n    },\n\n    /**\n     * x<sup>power</sup>\n     * @param {JXG.Math.Interval|Number} x\n     * @param {JXG.Math.Interval|Number} power\n     * @returns JXG.Math.Interval\n     */\n    pow: function (x, power) {\n        var yl, yh;\n\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        if (this.isInterval(power)) {\n            if (!this.isSingleton(power)) {\n                return this.EMPTY.clone();\n            }\n            power = power.lo;\n        }\n\n        if (power === 0) {\n            if (x.lo === 0 && x.hi === 0) {\n                // 0^0\n                return this.EMPTY.clone();\n            }\n            // x^0\n            return this.ONE.clone();\n        }\n        if (power < 0) {\n            // compute [1 / x]^-power if power is negative\n            return this.pow(this.multiplicativeInverse(x), -power);\n        }\n\n        // power > 0\n        if (power % 1 === 0) {\n            // isSafeInteger(power) as boolean) {\n            // power is integer\n            if (x.hi < 0) {\n                // [negative, negative]\n                // assume that power is even so the operation will yield a positive interval\n                // if not then just switch the sign and order of the interval bounds\n                yl = this.powLo(-x.hi, power);\n                yh = this.powHi(-x.lo, power);\n                if ((power & 1) === 1) {\n                    // odd power\n                    return new MatInterval(-yh, -yl);\n                }\n                // even power\n                return new MatInterval(yl, yh);\n            }\n            if (x.lo < 0) {\n                // [negative, positive]\n                if ((power & 1) === 1) {\n                    return new MatInterval(-this.powLo(-x.lo, power), this.powHi(x.hi, power));\n                }\n                // even power means that any negative number will be zero (min value = 0)\n                // and the max value will be the max of x.lo^power, x.hi^power\n                return new MatInterval(0, this.powHi(Math.max(-x.lo, x.hi), power));\n            }\n            // [positive, positive]\n            return new MatInterval(this.powLo(x.lo, power), this.powHi(x.hi, power));\n        }\n        console.warn(\n            \"power is not an integer, you should use nth-root instead, returning an empty interval\"\n        );\n        return this.EMPTY.clone();\n    },\n\n    /**\n     * sqrt(x)\n     * @param {JXG.Math.Interval|Number} x\n     * @returns JXG.Math.Interval\n     */\n    sqrt: function (x) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        return this.nthRoot(x, 2);\n    },\n\n    /**\n     * x<sup>1/n</sup>\n     * @param {JXG.Math.Interval|Number} x\n     * @param {Number} n\n     * @returns JXG.Math.Interval\n     */\n    nthRoot: function (x, n) {\n        var power, yl, yh, yp, yn;\n\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (this.isEmpty(x) || n < 0) {\n            // compute 1 / x^-power if power is negative\n            return this.EMPTY.clone();\n        }\n\n        // singleton interval check\n        if (this.isInterval(n)) {\n            if (!this.isSingleton(n)) {\n                return this.EMPTY.clone();\n            }\n            n = n.lo;\n        }\n\n        power = 1 / n;\n        if (x.hi < 0) {\n            // [negative, negative]\n            //if ((isSafeInteger(n) as boolean) && (n & 1) === 1) {\n            if (n % 1 === 0 && (n & 1) === 1) {\n                // when n is odd we can always take the nth root\n                yl = this.powHi(-x.lo, power);\n                yh = this.powLo(-x.hi, power);\n                return new MatInterval(-yl, -yh);\n            }\n\n            // n is not odd therefore there's no nth root\n            return this.EMPTY.clone();\n        }\n        if (x.lo < 0) {\n            // [negative, positive]\n            yp = this.powHi(x.hi, power);\n            // if ((isSafeInteger(n) as boolean) && (n & 1) === 1) {\n            if (n % 1 === 0 && (n & 1) === 1) {\n                // nth root of x.lo is possible (n is odd)\n                yn = -this.powHi(-x.lo, power);\n                return new MatInterval(yn, yp);\n            }\n            return new MatInterval(0, yp);\n        }\n        // [positive, positive]\n        return new MatInterval(this.powLo(x.lo, power), this.powHi(x.hi, power));\n    },\n\n    /*\n     * Misc\n     */\n    /**\n     *\n     * @param {JXG.Math.Interval|Number} x\n     * @returns JXG.Math.Interval\n     */\n    exp: function (x) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        return new MatInterval(this.expLo(x.lo), this.expHi(x.hi));\n    },\n\n    /**\n     * Natural log\n     * @param {JXG.Math.Interval|Number} x\n     * @returns JXG.Math.Interval\n     */\n    log: function (x) {\n        var l;\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        l = x.lo <= 0 ? Number.NEGATIVE_INFINITY : this.logLo(x.lo);\n        return new MatInterval(l, this.logHi(x.hi));\n    },\n\n    /**\n     * Natural log, alias for {@link JXG.Math.IntervalArithmetic#log}.\n     * @param {JXG.Math.Interval|Number} x\n     * @returns JXG.Math.Interval\n     */\n    ln: function (x) {\n        return this.log(x);\n    },\n\n    // export const LOG_EXP_10 = this.log(new MatInterval(10, 10))\n    // export const LOG_EXP_2 = log(new MatInterval(2, 2))\n    /**\n     * Logarithm to base 10.\n     * @param {JXG.Math.Interval|Number} x\n     * @returns JXG.Math.Interval\n     */\n    log10: function (x) {\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        return this.div(this.log(x), this.log(new MatInterval(10, 10)));\n    },\n\n    /**\n     * Logarithm to base 2.\n     * @param {JXG.Math.Interval|Number} x\n     * @returns JXG.Math.Interval\n     */\n    log2: function (x) {\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        return this.div(this.log(x), this.log(new MatInterval(2, 2)));\n    },\n\n    /**\n     * Hull of intervals x and y\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    hull: function (x, y) {\n        var badX = this.isEmpty(x),\n            badY = this.isEmpty(y);\n        if (badX && badY) {\n            return this.EMPTY.clone();\n        }\n        if (badX) {\n            return y.clone();\n        }\n        if (badY) {\n            return x.clone();\n        }\n        return new MatInterval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));\n    },\n\n    /**\n     * Intersection of intervals x and y\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    intersection: function (x, y) {\n        var lo, hi;\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return this.EMPTY.clone();\n        }\n        lo = Math.max(x.lo, y.lo);\n        hi = Math.min(x.hi, y.hi);\n        if (lo <= hi) {\n            return new MatInterval(lo, hi);\n        }\n        return this.EMPTY.clone();\n    },\n\n    /**\n     * Union of overlapping intervals x and y\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    union: function (x, y) {\n        if (!this.intervalsOverlap(x, y)) {\n            throw new Error(\"Interval#unions do not overlap\");\n        }\n        return new MatInterval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));\n    },\n\n    /**\n     * Difference of overlapping intervals x and y\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    difference: function (x, y) {\n        if (this.isEmpty(x) || this.isWhole(y)) {\n            return this.EMPTY.clone();\n        }\n        if (this.intervalsOverlap(x, y)) {\n            if (x.lo < y.lo && y.hi < x.hi) {\n                // difference creates multiple subsets\n                throw new Error(\"Interval.difference: difference creates multiple intervals\");\n            }\n\n            // handle corner cases first\n            if ((y.lo <= x.lo && y.hi === Infinity) || (y.hi >= x.hi && y.lo === -Infinity)) {\n                return this.EMPTY.clone();\n            }\n\n            // NOTE: empty interval is handled automatically\n            // e.g.\n            //\n            //    n = difference([0,1], [0,1]) // n = Interval(next(1), 1) = EMPTY\n            //    isEmpty(n) === true\n            //\n            if (y.lo <= x.lo) {\n                return new MatInterval().halfOpenLeft(y.hi, x.hi);\n            }\n\n            // y.hi >= x.hi\n            return new MatInterval().halfOpenRight(x.lo, y.lo);\n        }\n        return x.clone();\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    width: function (x) {\n        if (this.isEmpty(x)) {\n            return 0;\n        }\n        return this.subHi(x.hi, x.lo);\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    abs: function (x) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        if (x.lo >= 0) {\n            return x.clone();\n        }\n        if (x.hi <= 0) {\n            return this.negative(x);\n        }\n        return new MatInterval(0, Math.max(-x.lo, x.hi));\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    max: function (x, y) {\n        var badX = this.isEmpty(x),\n            badY = this.isEmpty(y);\n        if (badX && badY) {\n            return this.EMPTY.clone();\n        }\n        if (badX) {\n            return y.clone();\n        }\n        if (badY) {\n            return x.clone();\n        }\n        return new MatInterval(Math.max(x.lo, y.lo), Math.max(x.hi, y.hi));\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns JXG.Math.Interval\n     */\n    min: function (x, y) {\n        var badX = this.isEmpty(x),\n            badY = this.isEmpty(y);\n        if (badX && badY) {\n            return this.EMPTY.clone();\n        }\n        if (badX) {\n            return y.clone();\n        }\n        if (badY) {\n            return x.clone();\n        }\n        return new MatInterval(Math.min(x.lo, y.lo), Math.min(x.hi, y.hi));\n    },\n\n    /*\n     * Trigonometric\n     */\n    onlyInfinity: function (x) {\n        return !isFinite(x.lo) && x.lo === x.hi;\n    },\n\n    _handleNegative: function (interval) {\n        var n;\n        if (interval.lo < 0) {\n            if (interval.lo === -Infinity) {\n                interval.lo = 0;\n                interval.hi = Infinity;\n            } else {\n                n = Math.ceil(-interval.lo / this.piTwiceLow);\n                interval.lo += this.piTwiceLow * n;\n                interval.hi += this.piTwiceLow * n;\n            }\n        }\n        return interval;\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    cos: function (x) {\n        var cache, pi2, t, cosv, lo, hi, rlo, rhi;\n\n        if (this.isEmpty(x) || this.onlyInfinity(x)) {\n            return this.EMPTY.clone();\n        }\n\n        // create a clone of `x` because the clone is going to be modified\n        cache = new MatInterval().set(x.lo, x.hi);\n        this._handleNegative(cache);\n\n        pi2 = this.PI_TWICE;\n        t = this.fmod(cache, pi2);\n        if (this.width(t) >= pi2.lo) {\n            return new MatInterval(-1, 1);\n        }\n\n        // when t.lo > pi it's the same as\n        // -cos(t - pi)\n        if (t.lo >= this.piHigh) {\n            cosv = this.cos(this.sub(t, this.PI));\n            return this.negative(cosv);\n        }\n\n        lo = t.lo;\n        hi = t.hi;\n        rlo = this.cosLo(hi);\n        rhi = this.cosHi(lo);\n        // it's ensured that t.lo < pi and that t.lo >= 0\n        if (hi <= this.piLow) {\n            // when t.hi < pi\n            // [cos(t.lo), cos(t.hi)]\n            return new MatInterval(rlo, rhi);\n        }\n        if (hi <= pi2.lo) {\n            // when t.hi < 2pi\n            // [-1, max(cos(t.lo), cos(t.hi))]\n            return new MatInterval(-1, Math.max(rlo, rhi));\n        }\n        // t.lo < pi and t.hi > 2pi\n        return new MatInterval(-1, 1);\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    sin: function (x) {\n        if (this.isEmpty(x) || this.onlyInfinity(x)) {\n            return this.EMPTY.clone();\n        }\n        return this.cos(this.sub(x, this.PI_HALF));\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    tan: function (x) {\n        var cache, t, pi;\n        if (this.isEmpty(x) || this.onlyInfinity(x)) {\n            return this.EMPTY.clone();\n        }\n\n        // create a clone of `x` because the clone is going to be modified\n        cache = new MatInterval().set(x.lo, x.hi);\n        this._handleNegative(cache);\n\n        pi = this.PI;\n        t = this.fmod(cache, pi);\n        if (t.lo >= this.piHalfLow) {\n            t = this.sub(t, pi);\n        }\n        if (t.lo <= -this.piHalfLow || t.hi >= this.piHalfLow) {\n            return this.WHOLE.clone();\n        }\n        return new MatInterval(this.tanLo(t.lo), this.tanHi(t.hi));\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    asin: function (x) {\n        var lo, hi;\n        if (this.isEmpty(x) || x.hi < -1 || x.lo > 1) {\n            return this.EMPTY.clone();\n        }\n        lo = x.lo <= -1 ? -this.piHalfHigh : this.asinLo(x.lo);\n        hi = x.hi >= 1 ? this.piHalfHigh : this.asinHi(x.hi);\n        return new MatInterval(lo, hi);\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    acos: function (x) {\n        var lo, hi;\n        if (this.isEmpty(x) || x.hi < -1 || x.lo > 1) {\n            return this.EMPTY.clone();\n        }\n        lo = x.hi >= 1 ? 0 : this.acosLo(x.hi);\n        hi = x.lo <= -1 ? this.piHigh : this.acosHi(x.lo);\n        return new MatInterval(lo, hi);\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    atan: function (x) {\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        return new MatInterval(this.atanLo(x.lo), this.atanHi(x.hi));\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    sinh: function (x) {\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        return new MatInterval(this.sinhLo(x.lo), this.sinhHi(x.hi));\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    cosh: function (x) {\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        if (x.hi < 0) {\n            return new MatInterval(this.coshLo(x.hi), this.coshHi(x.lo));\n        }\n        if (x.lo >= 0) {\n            return new MatInterval(this.coshLo(x.lo), this.coshHi(x.hi));\n        }\n        return new MatInterval(1, this.coshHi(-x.lo > x.hi ? x.lo : x.hi));\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @returns JXG.Math.Interval\n     */\n    tanh: function (x) {\n        if (this.isEmpty(x)) {\n            return this.EMPTY.clone();\n        }\n        return new MatInterval(this.tanhLo(x.lo), this.tanhHi(x.hi));\n    },\n\n    /*\n     * Relational\n     */\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns Boolean\n     */\n    equal: function (x, y) {\n        if (this.isEmpty(x)) {\n            return this.isEmpty(y);\n        }\n        return !this.isEmpty(y) && x.lo === y.lo && x.hi === y.hi;\n    },\n\n    // almostEqual: function(x, y): void {\n    //     x = Array.isArray(x) ? x : x.toArray();\n    //     y = Array.isArray(y) ? y : y.toArray();\n    //     assertEps(x[0], y[0])\n    //     assertEps(x[1], y[1])\n    // },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns Boolean\n     */\n    notEqual: function (x, y) {\n        if (this.isEmpty(x)) {\n            return !this.isEmpty(y);\n        }\n        return this.isEmpty(y) || x.hi < y.lo || x.lo > y.hi;\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns Boolean\n     */\n    lt: function (x, y) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return false;\n        }\n        return x.hi < y.lo;\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns Boolean\n     */\n    gt: function (x, y) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return false;\n        }\n        return x.lo > y.hi;\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns Boolean\n     */\n    leq: function (x, y) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return false;\n        }\n        return x.hi <= y.lo;\n    },\n\n    /**\n     * @param {JXG.Math.Interval} x\n     * @param {JXG.Math.Interval} y\n     * @returns Boolean\n     */\n    geq: function (x, y) {\n        if (Type.isNumber(x)) {\n            x = this.Interval(x);\n        }\n        if (Type.isNumber(y)) {\n            y = this.Interval(y);\n        }\n        if (this.isEmpty(x) || this.isEmpty(y)) {\n            return false;\n        }\n        return x.lo >= y.hi;\n    },\n\n    /*\n     * Constants\n     */\n    piLow: (3373259426.0 + 273688.0 / (1 << 21)) / (1 << 30),\n    piHigh: (3373259426.0 + 273689.0 / (1 << 21)) / (1 << 30),\n    piHalfLow: ((3373259426.0 + 273688.0 / (1 << 21)) / (1 << 30)) * 0.5,\n    piHalfHigh: ((3373259426.0 + 273689.0 / (1 << 21)) / (1 << 30)) * 0.5,\n    piTwiceLow: ((3373259426.0 + 273688.0 / (1 << 21)) / (1 << 30)) * 2,\n    piTwiceHigh: ((3373259426.0 + 273689.0 / (1 << 21)) / (1 << 30)) * 2,\n\n    /*\n     * Round\n     * Rounding functions for numbers\n     */\n    identity: function (v) {\n        return v;\n    },\n\n    _prev: function (v) {\n        if (v === Infinity) {\n            return v;\n        }\n        return this.nextafter(v, -Infinity);\n    },\n\n    _next: function (v) {\n        if (v === -Infinity) {\n            return v;\n        }\n        return this.nextafter(v, Infinity);\n    },\n\n    prev: function (v) {\n        return this._prev(v);\n    },\n\n    next: function (v) {\n        return this._next(v);\n    },\n\n    toInteger: function (x) {\n        return x < 0 ? Math.ceil(x) : Math.floor(x);\n    },\n\n    addLo: function (x, y) {\n        return this.prev(x + y);\n    },\n    addHi: function (x, y) {\n        return this.next(x + y);\n    },\n    subLo: function (x, y) {\n        return this.prev(x - y);\n    },\n    subHi: function (x, y) {\n        return this.next(x - y);\n    },\n    mulLo: function (x, y) {\n        return this.prev(x * y);\n    },\n    mulHi: function (x, y) {\n        return this.next(x * y);\n    },\n    divLo: function (x, y) {\n        return this.prev(x / y);\n    },\n    divHi: function (x, y) {\n        return this.next(x / y);\n    },\n    intLo: function (x) {\n        return this.toInteger(this.prev(x));\n    },\n    intHi: function (x) {\n        return this.toInteger(this.next(x));\n    },\n    logLo: function (x) {\n        return this.prev(Math.log(x));\n    },\n    logHi: function (x) {\n        return this.next(Math.log(x));\n    },\n    expLo: function (x) {\n        return this.prev(Math.exp(x));\n    },\n    expHi: function (x) {\n        return this.next(Math.exp(x));\n    },\n    sinLo: function (x) {\n        return this.prev(Math.sin(x));\n    },\n    sinHi: function (x) {\n        return this.next(Math.sin(x));\n    },\n    cosLo: function (x) {\n        return this.prev(Math.cos(x));\n    },\n    cosHi: function (x) {\n        return this.next(Math.cos(x));\n    },\n    tanLo: function (x) {\n        return this.prev(Math.tan(x));\n    },\n    tanHi: function (x) {\n        return this.next(Math.tan(x));\n    },\n    asinLo: function (x) {\n        return this.prev(Math.asin(x));\n    },\n    asinHi: function (x) {\n        return this.next(Math.asin(x));\n    },\n    acosLo: function (x) {\n        return this.prev(Math.acos(x));\n    },\n    acosHi: function (x) {\n        return this.next(Math.acos(x));\n    },\n    atanLo: function (x) {\n        return this.prev(Math.atan(x));\n    },\n    atanHi: function (x) {\n        return this.next(Math.atan(x));\n    },\n    sinhLo: function (x) {\n        return this.prev(Mat.sinh(x));\n    },\n    sinhHi: function (x) {\n        return this.next(Mat.sinh(x));\n    },\n    coshLo: function (x) {\n        return this.prev(Mat.cosh(x));\n    },\n    coshHi: function (x) {\n        return this.next(Mat.cosh(x));\n    },\n    tanhLo: function (x) {\n        return this.prev(Mat.tanh(x));\n    },\n    tanhHi: function (x) {\n        return this.next(Mat.tanh(x));\n    },\n    sqrtLo: function (x) {\n        return this.prev(Math.sqrt(x));\n    },\n    sqrtHi: function (x) {\n        return this.next(Math.sqrt(x));\n    },\n\n    powLo: function (x, power) {\n        var y;\n        if (power % 1 !== 0) {\n            // power has decimals\n            return this.prev(Math.pow(x, power));\n        }\n\n        y = (power & 1) === 1 ? x : 1;\n        power >>= 1;\n        while (power > 0) {\n            x = this.mulLo(x, x);\n            if ((power & 1) === 1) {\n                y = this.mulLo(x, y);\n            }\n            power >>= 1;\n        }\n        return y;\n    },\n\n    powHi: function (x, power) {\n        var y;\n        if (power % 1 !== 0) {\n            // power has decimals\n            return this.next(Math.pow(x, power));\n        }\n\n        y = (power & 1) === 1 ? x : 1;\n        power >>= 1;\n        while (power > 0) {\n            x = this.mulHi(x, x);\n            if ((power & 1) === 1) {\n                y = this.mulHi(x, y);\n            }\n            power >>= 1;\n        }\n        return y;\n    },\n\n    /**\n     * @ignore\n     * @private\n     */\n    disable: function () {\n        this.next = this.prev = this.identity;\n    },\n\n    /**\n     * @ignore\n     * @private\n     */\n    enable: function () {\n        this.prev = function (v) {\n            return this._prev(v);\n        };\n\n        this.next = function (v) {\n            return this._next(v);\n        };\n    },\n\n    /*\n     * nextafter\n     */\n    SMALLEST_DENORM: Math.pow(2, -1074),\n    UINT_MAX: -1 >>> 0,\n\n    nextafter: function (x, y) {\n        var lo, hi;\n\n        if (isNaN(x) || isNaN(y)) {\n            return NaN;\n        }\n        if (x === y) {\n            return x;\n        }\n        if (x === 0) {\n            if (y < 0) {\n                return -this.SMALLEST_DENORM;\n            }\n            return this.SMALLEST_DENORM;\n        }\n        hi = doubleBits.hi(x);\n        lo = doubleBits.lo(x);\n        if (y > x === x > 0) {\n            if (lo === this.UINT_MAX) {\n                hi += 1;\n                lo = 0;\n            } else {\n                lo += 1;\n            }\n        } else {\n            if (lo === 0) {\n                lo = this.UINT_MAX;\n                hi -= 1;\n            } else {\n                lo -= 1;\n            }\n        }\n        return doubleBits.pack(lo, hi);\n    }\n};\n\nJXG.Math.IntervalArithmetic.PI = new MatInterval(\n    Mat.IntervalArithmetic.piLow,\n    Mat.IntervalArithmetic.piHigh\n);\nJXG.Math.IntervalArithmetic.PI_HALF = new MatInterval(\n    Mat.IntervalArithmetic.piHalfLow,\n    Mat.IntervalArithmetic.piHalfHigh\n);\nJXG.Math.IntervalArithmetic.PI_TWICE = new MatInterval(\n    Mat.IntervalArithmetic.piTwiceLow,\n    Mat.IntervalArithmetic.piTwiceHigh\n);\nJXG.Math.IntervalArithmetic.ZERO = new MatInterval(0);\nJXG.Math.IntervalArithmetic.ONE = new MatInterval(1);\nJXG.Math.IntervalArithmetic.WHOLE = new MatInterval().setWhole();\nJXG.Math.IntervalArithmetic.EMPTY = new MatInterval().setEmpty();\n\nexport default JXG.Math.IntervalArithmetic;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, Float32Array: true */\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\n/**\n * @fileoverview In this file the namespace JXG.Math is defined, which is the base namespace\n * for namespaces like JXG.Math.Numerics, JXG.Math.Plot, JXG.Math.Statistics, JXG.Math.Clip etc.\n */\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n\nvar undef,\n    /*\n     * Dynamic programming approach for recursive functions.\n     * From \"Speed up your JavaScript, Part 3\" by Nicholas C. Zakas.\n     * @see JXG.Math.factorial\n     * @see JXG.Math.binomial\n     * http://blog.thejit.org/2008/09/05/memoization-in-javascript/\n     *\n     * This method is hidden, because it is only used in JXG.Math. If someone wants\n     * to use it in JSXGraph outside of JXG.Math, it should be moved to jsxgraph.js\n     */\n    memoizer = function (f) {\n        var cache, join;\n\n        if (f.memo) {\n            return f.memo;\n        }\n\n        cache = {};\n        join = Array.prototype.join;\n\n        f.memo = function () {\n            var key = join.call(arguments);\n\n            // Seems to be a bit faster than \"if (a in b)\"\n            return cache[key] !== undef ? cache[key] : (cache[key] = f.apply(this, arguments));\n        };\n\n        return f.memo;\n    };\n\n/**\n * Math namespace.\n * @namespace\n */\nJXG.Math = {\n    /**\n     * eps defines the closeness to zero. If the absolute value of a given number is smaller\n     * than eps, it is considered to be equal to zero.\n     * @type Number\n     */\n    eps: 0.000001,\n\n    /**\n     * Determine the relative difference between two numbers.\n     * @param  {Number} a First number\n     * @param  {Number} b Second number\n     * @returns {Number}  Relative difference between a and b: |a-b| / max(|a|, |b|)\n     */\n    relDif: function (a, b) {\n        var c = Math.abs(a),\n            d = Math.abs(b);\n\n        d = Math.max(c, d);\n\n        return d === 0.0 ? 0.0 : Math.abs(a - b) / d;\n    },\n\n    /**\n     * The JavaScript implementation of the % operator returns the symmetric modulo.\n     * mod and \"%\" are both identical if a >= 0 and m >= 0 but the results differ if a or m < 0.\n     * @param {Number} a\n     * @param {Number} m\n     * @returns {Number} Mathematical modulo <tt>a mod m</tt>\n     */\n    mod: function (a, m) {\n        return a - Math.floor(a / m) * m;\n    },\n\n    /**\n     * Initializes a vector as an array with the coefficients set to the given value resp. zero.\n     * @param {Number} n Length of the vector\n     * @param {Number} [init=0] Initial value for each coefficient\n     * @returns {Array} A <tt>n</tt> times <tt>m</tt>-matrix represented by a\n     * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.\n     */\n    vector: function (n, init) {\n        var r, i;\n\n        init = init || 0;\n        r = [];\n\n        for (i = 0; i < n; i++) {\n            r[i] = init;\n        }\n\n        return r;\n    },\n\n    /**\n     * Initializes a matrix as an array of rows with the given value.\n     * @param {Number} n Number of rows\n     * @param {Number} [m=n] Number of columns\n     * @param {Number} [init=0] Initial value for each coefficient\n     * @returns {Array} A <tt>n</tt> times <tt>m</tt>-matrix represented by a\n     * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.\n     */\n    matrix: function (n, m, init) {\n        var r, i, j;\n\n        init = init || 0;\n        m = m || n;\n        r = [];\n\n        for (i = 0; i < n; i++) {\n            r[i] = [];\n\n            for (j = 0; j < m; j++) {\n                r[i][j] = init;\n            }\n        }\n\n        return r;\n    },\n\n    /**\n     * Generates an identity matrix. If n is a number and m is undefined or not a number, a square matrix is generated,\n     * if n and m are both numbers, an nxm matrix is generated.\n     * @param {Number} n Number of rows\n     * @param {Number} [m=n] Number of columns\n     * @returns {Array} A square matrix of length <tt>n</tt> with all coefficients equal to 0 except a_(i,i), i out of (1, ..., n), if <tt>m</tt> is undefined or not a number\n     * or a <tt>n</tt> times <tt>m</tt>-matrix with a_(i,j) = 0 and a_(i,i) = 1 if m is a number.\n     */\n    identity: function (n, m) {\n        var r, i;\n\n        if (m === undef && typeof m !== \"number\") {\n            m = n;\n        }\n\n        r = this.matrix(n, m);\n\n        for (i = 0; i < Math.min(n, m); i++) {\n            r[i][i] = 1;\n        }\n\n        return r;\n    },\n\n    /**\n     * Generates a 4x4 matrix for 3D to 2D projections.\n     * @param {Number} l Left\n     * @param {Number} r Right\n     * @param {Number} t Top\n     * @param {Number} b Bottom\n     * @param {Number} n Near\n     * @param {Number} f Far\n     * @returns {Array} 4x4 Matrix\n     */\n    frustum: function (l, r, b, t, n, f) {\n        var ret = this.matrix(4, 4);\n\n        ret[0][0] = (n * 2) / (r - l);\n        ret[0][1] = 0;\n        ret[0][2] = (r + l) / (r - l);\n        ret[0][3] = 0;\n\n        ret[1][0] = 0;\n        ret[1][1] = (n * 2) / (t - b);\n        ret[1][2] = (t + b) / (t - b);\n        ret[1][3] = 0;\n\n        ret[2][0] = 0;\n        ret[2][1] = 0;\n        ret[2][2] = -(f + n) / (f - n);\n        ret[2][3] = -(f * n * 2) / (f - n);\n\n        ret[3][0] = 0;\n        ret[3][1] = 0;\n        ret[3][2] = -1;\n        ret[3][3] = 0;\n\n        return ret;\n    },\n\n    /**\n     * Generates a 4x4 matrix for 3D to 2D projections.\n     * @param {Number} fov Field of view in vertical direction, given in rad.\n     * @param {Number} ratio Aspect ratio of the projection plane.\n     * @param {Number} n Near\n     * @param {Number} f Far\n     * @returns {Array} 4x4 Projection Matrix\n     */\n    projection: function (fov, ratio, n, f) {\n        var t = n * Math.tan(fov / 2),\n            r = t * ratio;\n\n        return this.frustum(-r, r, -t, t, n, f);\n    },\n\n    /**\n     * Multiplies a vector vec to a matrix mat: mat * vec. The matrix is interpreted by this function as an array of rows. Please note: This\n     * function does not check if the dimensions match.\n     * @param {Array} mat Two dimensional array of numbers. The inner arrays describe the columns, the outer ones the matrix' rows.\n     * @param {Array} vec Array of numbers\n     * @returns {Array} Array of numbers containing the result\n     * @example\n     * var A = [[2, 1],\n     *          [1, 3]],\n     *     b = [4, 5],\n     *     c;\n     * c = JXG.Math.matVecMult(A, b)\n     * // c === [13, 19];\n     */\n    matVecMult: function (mat, vec) {\n        var i,\n            s,\n            k,\n            m = mat.length,\n            n = vec.length,\n            res = [];\n\n        if (n === 3) {\n            for (i = 0; i < m; i++) {\n                res[i] = mat[i][0] * vec[0] + mat[i][1] * vec[1] + mat[i][2] * vec[2];\n            }\n        } else {\n            for (i = 0; i < m; i++) {\n                s = 0;\n                for (k = 0; k < n; k++) {\n                    s += mat[i][k] * vec[k];\n                }\n                res[i] = s;\n            }\n        }\n        return res;\n    },\n\n    /**\n     * Computes the product of the two matrices mat1*mat2.\n     * @param {Array} mat1 Two dimensional array of numbers\n     * @param {Array} mat2 Two dimensional array of numbers\n     * @returns {Array} Two dimensional Array of numbers containing result\n     */\n    matMatMult: function (mat1, mat2) {\n        var i,\n            j,\n            s,\n            k,\n            m = mat1.length,\n            n = m > 0 ? mat2[0].length : 0,\n            m2 = mat2.length,\n            res = this.matrix(m, n);\n\n        for (i = 0; i < m; i++) {\n            for (j = 0; j < n; j++) {\n                s = 0;\n                for (k = 0; k < m2; k++) {\n                    s += mat1[i][k] * mat2[k][j];\n                }\n                res[i][j] = s;\n            }\n        }\n        return res;\n    },\n\n    /**\n     * Transposes a matrix given as a two dimensional array.\n     * @param {Array} M The matrix to be transposed\n     * @returns {Array} The transpose of M\n     */\n    transpose: function (M) {\n        var MT, i, j, m, n;\n\n        // number of rows of M\n        m = M.length;\n        // number of columns of M\n        n = M.length > 0 ? M[0].length : 0;\n        MT = this.matrix(n, m);\n\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < m; j++) {\n                MT[i][j] = M[j][i];\n            }\n        }\n\n        return MT;\n    },\n\n    /**\n     * Compute the inverse of an nxn matrix with Gauss elimination.\n     * @param {Array} Ain\n     * @returns {Array} Inverse matrix of Ain\n     */\n    inverse: function (Ain) {\n        var i,\n            j,\n            k,\n            s,\n            ma,\n            r,\n            swp,\n            n = Ain.length,\n            A = [],\n            p = [],\n            hv = [];\n\n        for (i = 0; i < n; i++) {\n            A[i] = [];\n            for (j = 0; j < n; j++) {\n                A[i][j] = Ain[i][j];\n            }\n            p[i] = i;\n        }\n\n        for (j = 0; j < n; j++) {\n            // pivot search:\n            ma = Math.abs(A[j][j]);\n            r = j;\n\n            for (i = j + 1; i < n; i++) {\n                if (Math.abs(A[i][j]) > ma) {\n                    ma = Math.abs(A[i][j]);\n                    r = i;\n                }\n            }\n\n            // Singular matrix\n            if (ma <= this.eps) {\n                return [];\n            }\n\n            // swap rows:\n            if (r > j) {\n                for (k = 0; k < n; k++) {\n                    swp = A[j][k];\n                    A[j][k] = A[r][k];\n                    A[r][k] = swp;\n                }\n\n                swp = p[j];\n                p[j] = p[r];\n                p[r] = swp;\n            }\n\n            // transformation:\n            s = 1.0 / A[j][j];\n            for (i = 0; i < n; i++) {\n                A[i][j] *= s;\n            }\n            A[j][j] = s;\n\n            for (k = 0; k < n; k++) {\n                if (k !== j) {\n                    for (i = 0; i < n; i++) {\n                        if (i !== j) {\n                            A[i][k] -= A[i][j] * A[j][k];\n                        }\n                    }\n                    A[j][k] = -s * A[j][k];\n                }\n            }\n        }\n\n        // swap columns:\n        for (i = 0; i < n; i++) {\n            for (k = 0; k < n; k++) {\n                hv[p[k]] = A[i][k];\n            }\n            for (k = 0; k < n; k++) {\n                A[i][k] = hv[k];\n            }\n        }\n\n        return A;\n    },\n\n    /**\n     * Inner product of two vectors a and b. n is the length of the vectors.\n     * @param {Array} a Vector\n     * @param {Array} b Vector\n     * @param {Number} [n] Length of the Vectors. If not given the length of the first vector is taken.\n     * @returns {Number} The inner product of a and b.\n     */\n    innerProduct: function (a, b, n) {\n        var i,\n            s = 0;\n\n        if (n === undef || !Type.isNumber(n)) {\n            n = a.length;\n        }\n\n        for (i = 0; i < n; i++) {\n            s += a[i] * b[i];\n        }\n\n        return s;\n    },\n\n    /**\n     * Calculates the cross product of two vectors both of length three.\n     * In case of homogeneous coordinates this is either\n     * <ul>\n     * <li>the intersection of two lines</li>\n     * <li>the line through two points</li>\n     * </ul>\n     * @param {Array} c1 Homogeneous coordinates of line or point 1\n     * @param {Array} c2 Homogeneous coordinates of line or point 2\n     * @returns {Array} vector of length 3: homogeneous coordinates of the resulting point / line.\n     */\n    crossProduct: function (c1, c2) {\n        return [\n            c1[1] * c2[2] - c1[2] * c2[1],\n            c1[2] * c2[0] - c1[0] * c2[2],\n            c1[0] * c2[1] - c1[1] * c2[0]\n        ];\n    },\n\n    /**\n     * Euclidean norm of a vector.\n     *\n     * @param {Array} a Array containing a vector.\n     * @param {Number} n (Optional) length of the array.\n     * @returns {Number} Euclidean norm of the vector.\n     */\n    norm: function (a, n) {\n        var i,\n            sum = 0.0;\n\n        if (n === undef || !Type.isNumber(n)) {\n            n = a.length;\n        }\n\n        for (i = 0; i < n; i++) {\n            sum += a[i] * a[i];\n        }\n\n        return Math.sqrt(sum);\n    },\n\n    axpy: function (a, x, y) {\n        var i,\n            le = x.length,\n            p = [];\n        for (i = 0; i < le; i++) {\n            p[i] = a * x[i] + y[i];\n        }\n        return p;\n    },\n\n    /**\n     * Compute the factorial of a positive integer. If a non-integer value\n     * is given, the fraction will be ignored.\n     * @function\n     * @param {Number} n\n     * @returns {Number} n! = n*(n-1)*...*2*1\n     */\n    factorial: memoizer(function (n) {\n        if (n < 0) {\n            return NaN;\n        }\n\n        n = Math.floor(n);\n\n        if (n === 0 || n === 1) {\n            return 1;\n        }\n\n        return n * this.factorial(n - 1);\n    }),\n\n    /**\n     * Computes the binomial coefficient n over k.\n     * @function\n     * @param {Number} n Fraction will be ignored\n     * @param {Number} k Fraction will be ignored\n     * @returns {Number} The binomial coefficient n over k\n     */\n    binomial: memoizer(function (n, k) {\n        var b, i;\n\n        if (k > n || k < 0) {\n            return NaN;\n        }\n\n        k = Math.round(k);\n        n = Math.round(n);\n\n        if (k === 0 || k === n) {\n            return 1;\n        }\n\n        b = 1;\n\n        for (i = 0; i < k; i++) {\n            b *= n - i;\n            b /= i + 1;\n        }\n\n        return b;\n    }),\n\n    /**\n     * Calculates the cosine hyperbolicus of x.\n     * @function\n     * @param {Number} x The number the cosine hyperbolicus will be calculated of.\n     * @returns {Number} Cosine hyperbolicus of the given value.\n     */\n    cosh:\n        Math.cosh ||\n        function (x) {\n            return (Math.exp(x) + Math.exp(-x)) * 0.5;\n        },\n\n    /**\n     * Sine hyperbolicus of x.\n     * @function\n     * @param {Number} x The number the sine hyperbolicus will be calculated of.\n     * @returns {Number} Sine hyperbolicus of the given value.\n     */\n    sinh:\n        Math.sinh ||\n        function (x) {\n            return (Math.exp(x) - Math.exp(-x)) * 0.5;\n        },\n\n    /**\n     * Hyperbolic arc-cosine of a number.\n     *\n     * @param {Number} x\n     * @returns {Number}\n     */\n    acosh:\n        Math.acosh ||\n        function (x) {\n            return Math.log(x + Math.sqrt(x * x - 1));\n        },\n\n    /**\n     * Hyperbolic arcsine of a number\n     * @param {Number} x\n     * @returns {Number}\n     */\n    asinh:\n        Math.asinh ||\n        function (x) {\n            if (x === -Infinity) {\n                return x;\n            }\n            return Math.log(x + Math.sqrt(x * x + 1));\n        },\n\n    /**\n     * Computes the cotangent of x.\n     * @function\n     * @param {Number} x The number the cotangent will be calculated of.\n     * @returns {Number} Cotangent of the given value.\n     */\n    cot: function (x) {\n        return 1 / Math.tan(x);\n    },\n\n    /**\n     * Computes the inverse cotangent of x.\n     * @param {Number} x The number the inverse cotangent will be calculated of.\n     * @returns {Number} Inverse cotangent of the given value.\n     */\n    acot: function (x) {\n        return (x >= 0 ? 0.5 : -0.5) * Math.PI - Math.atan(x);\n    },\n\n    /**\n     * Compute n-th real root of a real number. n must be strictly positive integer.\n     * If n is odd, the real n-th root exists and is negative.\n     * For n even, for negative valuees of x NaN is returned\n     * @param  {Number} x radicand. Must be non-negative, if n even.\n     * @param  {Number} n index of the root. must be strictly positive integer.\n     * @returns {Number} returns real root or NaN\n     *\n     * @example\n     * nthroot(16, 4): 2\n     * nthroot(-27, 3): -3\n     * nthroot(-4, 2): NaN\n     */\n    nthroot: function (x, n) {\n        var inv = 1 / n;\n\n        if (n <= 0 || Math.floor(n) !== n) {\n            return NaN;\n        }\n\n        if (x === 0.0) {\n            return 0.0;\n        }\n\n        if (x > 0) {\n            return Math.exp(inv * Math.log(x));\n        }\n\n        // From here on, x is negative\n        if (n % 2 === 1) {\n            return -Math.exp(inv * Math.log(-x));\n        }\n\n        // x negative, even root\n        return NaN;\n    },\n\n    /**\n     * Computes cube root of real number\n     * Polyfill for Math.cbrt().\n     *\n     * @function\n     * @param  {Number} x Radicand\n     * @returns {Number} Cube root of x.\n     */\n    cbrt:\n        Math.cbrt ||\n        function (x) {\n            return this.nthroot(x, 3);\n        },\n\n    /**\n     * Compute base to the power of exponent.\n     * @param {Number} base\n     * @param {Number} exponent\n     * @returns {Number} base to the power of exponent.\n     */\n    pow: function (base, exponent) {\n        if (base === 0) {\n            if (exponent === 0) {\n                return 1;\n            }\n            return 0;\n        }\n\n        // exponent is an integer\n        if (Math.floor(exponent) === exponent) {\n            return Math.pow(base, exponent);\n        }\n\n        // exponent is not an integer\n        if (base > 0) {\n            return Math.exp(exponent * Math.log(base));\n        }\n\n        return NaN;\n    },\n\n    /**\n     * Compute base to the power of the rational exponent m / n.\n     * This function first reduces the fraction m/n and then computes\n     * JXG.Math.pow(base, m/n).\n     *\n     * This function is necessary to have the same results for e.g.\n     * (-8)^(1/3) = (-8)^(2/6) = -2\n     * @param {Number} base\n     * @param {Number} m numerator of exponent\n     * @param {Number} n denominator of exponent\n     * @returns {Number} base to the power of exponent.\n     */\n    ratpow: function (base, m, n) {\n        var g;\n        if (m === 0) {\n            return 1;\n        }\n        if (n === 0) {\n            return NaN;\n        }\n\n        g = this.gcd(m, n);\n        return this.nthroot(this.pow(base, m / g), n / g);\n    },\n\n    /**\n     * Logarithm to base 10.\n     * @param {Number} x\n     * @returns {Number} log10(x) Logarithm of x to base 10.\n     */\n    log10: function (x) {\n        return Math.log(x) / Math.log(10.0);\n    },\n\n    /**\n     * Logarithm to base 2.\n     * @param {Number} x\n     * @returns {Number} log2(x) Logarithm of x to base 2.\n     */\n    log2: function (x) {\n        return Math.log(x) / Math.log(2.0);\n    },\n\n    /**\n     * Logarithm to arbitrary base b. If b is not given, natural log is taken, i.e. b = e.\n     * @param {Number} x\n     * @param {Number} b base\n     * @returns {Number} log(x, b) Logarithm of x to base b, that is log(x)/log(b).\n     */\n    log: function (x, b) {\n        if (b !== undefined && Type.isNumber(b)) {\n            return Math.log(x) / Math.log(b);\n        }\n\n        return Math.log(x);\n    },\n\n    /**\n     * The sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.\n     *\n     * @function\n     * @param  {Number} x A Number\n     * @returns {[type]}  This function has 5 kinds of return values,\n     *    1, -1, 0, -0, NaN, which represent \"positive number\", \"negative number\", \"positive zero\", \"negative zero\"\n     *    and NaN respectively.\n     */\n    sign:\n        Math.sign ||\n        function (x) {\n            x = +x; // convert to a number\n            if (x === 0 || isNaN(x)) {\n                return x;\n            }\n            return x > 0 ? 1 : -1;\n        },\n\n    /**\n     * A square & multiply algorithm to compute base to the power of exponent.\n     * Implementated by Wolfgang Riedl.\n     *\n     * @param {Number} base\n     * @param {Number} exponent\n     * @returns {Number} Base to the power of exponent\n     */\n    squampow: function (base, exponent) {\n        var result;\n\n        if (Math.floor(exponent) === exponent) {\n            // exponent is integer (could be zero)\n            result = 1;\n\n            if (exponent < 0) {\n                // invert: base\n                base = 1.0 / base;\n                exponent *= -1;\n            }\n\n            while (exponent !== 0) {\n                if (exponent & 1) {\n                    result *= base;\n                }\n\n                exponent >>= 1;\n                base *= base;\n            }\n            return result;\n        }\n\n        return this.pow(base, exponent);\n    },\n\n    /**\n     * Greatest common divisor (gcd) of two numbers.\n     * @see <a href=\"http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript\">rosettacode.org</a>\n     *\n     * @param  {Number} a First number\n     * @param  {Number} b Second number\n     * @returns {Number}   gcd(a, b) if a and b are numbers, NaN else.\n     */\n    gcd: function (a, b) {\n        var tmp,\n            endless = true;\n\n        a = Math.abs(a);\n        b = Math.abs(b);\n\n        if (!(Type.isNumber(a) && Type.isNumber(b))) {\n            return NaN;\n        }\n        if (b > a) {\n            tmp = a;\n            a = b;\n            b = tmp;\n        }\n\n        while (endless) {\n            a %= b;\n            if (a === 0) {\n                return b;\n            }\n            b %= a;\n            if (b === 0) {\n                return a;\n            }\n        }\n    },\n\n    /**\n     * Least common multiple (lcm) of two numbers.\n     *\n     * @param  {Number} a First number\n     * @param  {Number} b Second number\n     * @returns {Number}   lcm(a, b) if a and b are numbers, NaN else.\n     */\n    lcm: function (a, b) {\n        var ret;\n\n        if (!(Type.isNumber(a) && Type.isNumber(b))) {\n            return NaN;\n        }\n\n        ret = a * b;\n        if (ret !== 0) {\n            return ret / this.gcd(a, b);\n        }\n\n        return 0;\n    },\n\n    /**\n     *  Error function, see {@link https://en.wikipedia.org/wiki/Error_function}.\n     *\n     * @see JXG.Math.PropFunc.erf\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    erf: function (x) {\n        return this.ProbFuncs.erf(x);\n    },\n\n    /**\n     * Complementary error function, i.e. 1 - erf(x).\n     *\n     * @see JXG.Math.erf\n     * @see JXG.Math.PropFunc.erfc\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    erfc: function (x) {\n        return this.ProbFuncs.erfc(x);\n    },\n\n    /**\n     * Inverse of error function\n     *\n     * @see JXG.Math.erf\n     * @see JXG.Math.PropFunc.erfi\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    erfi: function (x) {\n        return this.ProbFuncs.erfi(x);\n    },\n\n    /**\n     * Normal distribution function\n     *\n     * @see JXG.Math.PropFunc.ndtr\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    ndtr: function (x) {\n        return this.ProbFuncs.ndtr(x);\n    },\n\n    /**\n     * Inverse of normal distribution function\n     *\n     * @see JXG.Math.ndtr\n     * @see JXG.Math.PropFunc.ndtri\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    ndtri: function (x) {\n        return this.ProbFuncs.ndtri(x);\n    },\n\n    /* ********************  Comparisons and logical operators ************** */\n\n    /**\n     * Logical test: a < b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    lt: function (a, b) {\n        return a < b;\n    },\n\n    /**\n     * Logical test: a <= b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    leq: function (a, b) {\n        return a <= b;\n    },\n\n    /**\n     * Logical test: a > b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    gt: function (a, b) {\n        return a > b;\n    },\n\n    /**\n     * Logical test: a >= b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    geq: function (a, b) {\n        return a >= b;\n    },\n\n    /**\n     * Logical test: a === b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    eq: function (a, b) {\n        return a === b;\n    },\n\n    /**\n     * Logical test: a !== b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    neq: function (a, b) {\n        return a !== b;\n    },\n\n    /**\n     * Logical operator: a && b?\n     *\n     * @param {Boolean} a\n     * @param {Boolean} b\n     * @returns {Boolean}\n     */\n    and: function (a, b) {\n        return a && b;\n    },\n\n    /**\n     * Logical operator: !a?\n     *\n     * @param {Boolean} a\n     * @returns {Boolean}\n     */\n    not: function (a) {\n        return !a;\n    },\n\n    /**\n     * Logical operator: a || b?\n     *\n     * @param {Boolean} a\n     * @param {Boolean} b\n     * @returns {Boolean}\n     */\n    or: function (a, b) {\n        return a || b;\n    },\n\n    /**\n     * Logical operator: either a or b?\n     *\n     * @param {Boolean} a\n     * @param {Boolean} b\n     * @returns {Boolean}\n     */\n    xor: function (a, b) {\n        return (a || b) && !(a && b);\n    },\n\n    /* *************************** Normalize *************************** */\n\n    /**\n     * Normalize the standard form [c, b0, b1, a, k, r, q0, q1].\n     * @private\n     * @param {Array} stdform The standard form to be normalized.\n     * @returns {Array} The normalized standard form.\n     */\n    normalize: function (stdform) {\n        var n,\n            signr,\n            a2 = 2 * stdform[3],\n            r = stdform[4] / a2;\n\n        stdform[5] = r;\n        stdform[6] = -stdform[1] / a2;\n        stdform[7] = -stdform[2] / a2;\n\n        if (!isFinite(r)) {\n            n = Math.sqrt(stdform[1] * stdform[1] + stdform[2] * stdform[2]);\n\n            stdform[0] /= n;\n            stdform[1] /= n;\n            stdform[2] /= n;\n            stdform[3] = 0;\n            stdform[4] = 1;\n        } else if (Math.abs(r) >= 1) {\n            stdform[0] = (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) / (2 * r);\n            stdform[1] = -stdform[6] / r;\n            stdform[2] = -stdform[7] / r;\n            stdform[3] = 1 / (2 * r);\n            stdform[4] = 1;\n        } else {\n            signr = r <= 0 ? -1 : 1;\n            stdform[0] =\n                signr * (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) * 0.5;\n            stdform[1] = -signr * stdform[6];\n            stdform[2] = -signr * stdform[7];\n            stdform[3] = signr / 2;\n            stdform[4] = signr * r;\n        }\n\n        return stdform;\n    },\n\n    /**\n     * Converts a two dimensional array to a one dimensional Float32Array that can be processed by WebGL.\n     * @param {Array} m A matrix in a two dimensional array.\n     * @returns {Float32Array} A one dimensional array containing the matrix in column wise notation. Provides a fall\n     * back to the default JavaScript Array if Float32Array is not available.\n     */\n    toGL: function (m) {\n        var v, i, j;\n\n        if (typeof Float32Array === \"function\") {\n            v = new Float32Array(16);\n        } else {\n            v = new Array(16);\n        }\n\n        if (m.length !== 4 && m[0].length !== 4) {\n            return v;\n        }\n\n        for (i = 0; i < 4; i++) {\n            for (j = 0; j < 4; j++) {\n                v[i + 4 * j] = m[i][j];\n            }\n        }\n\n        return v;\n    },\n\n    /**\n     * Theorem of Vieta: Given a set of simple zeroes x_0, ..., x_n\n     * of a polynomial f, compute the coefficients s_k, (k=0,...,n-1)\n     * of the polynomial of the form. See {@link https://de.wikipedia.org/wiki/Elementarsymmetrisches_Polynom}.\n     * <p>\n     *  f(x) = (x-x_0)*...*(x-x_n) =\n     *  x^n + sum_{k=1}^{n} (-1)^(k) s_{k-1} x^(n-k)\n     * </p>\n     * @param {Array} x Simple zeroes of the polynomial.\n     * @returns {Array} Coefficients of the polynomial.\n     *\n     */\n    Vieta: function (x) {\n        var n = x.length,\n            s = [],\n            m,\n            k,\n            y;\n\n        s = x.slice();\n        for (m = 1; m < n; ++m) {\n            y = s[m];\n            s[m] *= s[m - 1];\n            for (k = m - 1; k >= 1; --k) {\n                s[k] += s[k - 1] * y;\n            }\n            s[0] += y;\n        }\n        return s;\n    }\n};\n\nexport default JXG.Math;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n/*eslint no-loss-of-precision: off */\n\n/**\n * @fileoverview In this file the namespace Math.Numerics is defined, which holds numerical\n * algorithms for solving linear equations etc.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\nimport Env from \"../utils/env\";\nimport Mat from \"./math\";\n\n// Predefined butcher tableaus for the common Runge-Kutta method (fourth order), Heun method (second order), and Euler method (first order).\nvar predefinedButcher = {\n    rk4: {\n        s: 4,\n        A: [\n            [0, 0, 0, 0],\n            [0.5, 0, 0, 0],\n            [0, 0.5, 0, 0],\n            [0, 0, 1, 0]\n        ],\n        b: [1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0],\n        c: [0, 0.5, 0.5, 1]\n    },\n    heun: {\n        s: 2,\n        A: [\n            [0, 0],\n            [1, 0]\n        ],\n        b: [0.5, 0.5],\n        c: [0, 1]\n    },\n    euler: {\n        s: 1,\n        A: [[0]],\n        b: [1],\n        c: [0]\n    }\n};\n\n/**\n * The JXG.Math.Numerics namespace holds numerical algorithms, constants, and variables.\n * @name JXG.Math.Numerics\n * @exports Mat.Numerics as JXG.Math.Numerics\n * @namespace\n */\nMat.Numerics = {\n    //JXG.extend(Mat.Numerics, /** @lends JXG.Math.Numerics */ {\n    /**\n     * Solves a system of linear equations given by A and b using the Gauss-Jordan-elimination.\n     * The algorithm runs in-place. I.e. the entries of A and b are changed.\n     * @param {Array} A Square matrix represented by an array of rows, containing the coefficients of the lineare equation system.\n     * @param {Array} b A vector containing the linear equation system's right hand side.\n     * @throws {Error} If a non-square-matrix is given or if b has not the right length or A's rank is not full.\n     * @returns {Array} A vector that solves the linear equation system.\n     * @memberof JXG.Math.Numerics\n     */\n    Gauss: function (A, b) {\n        var i,\n            j,\n            k,\n            // copy the matrix to prevent changes in the original\n            Acopy,\n            // solution vector, to prevent changing b\n            x,\n            eps = Mat.eps,\n            // number of columns of A\n            n = A.length > 0 ? A[0].length : 0;\n\n        if (n !== b.length || n !== A.length) {\n            throw new Error(\n                \"JXG.Math.Numerics.Gauss: Dimensions don't match. A must be a square matrix and b must be of the same length as A.\"\n            );\n        }\n\n        // initialize solution vector\n        Acopy = [];\n        x = b.slice(0, n);\n\n        for (i = 0; i < n; i++) {\n            Acopy[i] = A[i].slice(0, n);\n        }\n\n        // Gauss-Jordan-elimination\n        for (j = 0; j < n; j++) {\n            for (i = n - 1; i > j; i--) {\n                // Is the element which is to eliminate greater than zero?\n                if (Math.abs(Acopy[i][j]) > eps) {\n                    // Equals pivot element zero?\n                    if (Math.abs(Acopy[j][j]) < eps) {\n                        // At least numerically, so we have to exchange the rows\n                        Type.swap(Acopy, i, j);\n                        Type.swap(x, i, j);\n                    } else {\n                        // Saves the L matrix of the LR-decomposition. unnecessary.\n                        Acopy[i][j] /= Acopy[j][j];\n                        // Transform right-hand-side b\n                        x[i] -= Acopy[i][j] * x[j];\n\n                        // subtract the multiple of A[i][j] / A[j][j] of the j-th row from the i-th.\n                        for (k = j + 1; k < n; k++) {\n                            Acopy[i][k] -= Acopy[i][j] * Acopy[j][k];\n                        }\n                    }\n                }\n            }\n\n            // The absolute values of all coefficients below the j-th row in the j-th column are smaller than JXG.Math.eps.\n            if (Math.abs(Acopy[j][j]) < eps) {\n                throw new Error(\n                    \"JXG.Math.Numerics.Gauss(): The given matrix seems to be singular.\"\n                );\n            }\n        }\n\n        this.backwardSolve(Acopy, x, true);\n\n        return x;\n    },\n\n    /**\n     * Solves a system of linear equations given by the right triangular matrix R and vector b.\n     * @param {Array} R Right triangular matrix represented by an array of rows. All entries a_(i,j) with i &lt; j are ignored.\n     * @param {Array} b Right hand side of the linear equation system.\n     * @param {Boolean} [canModify=false] If true, the right hand side vector is allowed to be changed by this method.\n     * @returns {Array} An array representing a vector that solves the system of linear equations.\n     * @memberof JXG.Math.Numerics\n     */\n    backwardSolve: function (R, b, canModify) {\n        var x, m, n, i, j;\n\n        if (canModify) {\n            x = b;\n        } else {\n            x = b.slice(0, b.length);\n        }\n\n        // m: number of rows of R\n        // n: number of columns of R\n        m = R.length;\n        n = R.length > 0 ? R[0].length : 0;\n\n        for (i = m - 1; i >= 0; i--) {\n            for (j = n - 1; j > i; j--) {\n                x[i] -= R[i][j] * x[j];\n            }\n            x[i] /= R[i][i];\n        }\n\n        return x;\n    },\n\n    /**\n     * @private\n     * Gauss-Bareiss algorithm to compute the\n     * determinant of matrix without fractions.\n     * See Henri Cohen, \"A Course in Computational\n     * Algebraic Number Theory (Graduate texts\n     * in mathematics; 138)\", Springer-Verlag,\n     * ISBN 3-540-55640-0 / 0-387-55640-0\n     * Third, Corrected Printing 1996\n     * \"Algorithm 2.2.6\", pg. 52-53\n     * @memberof JXG.Math.Numerics\n     */\n    gaussBareiss: function (mat) {\n        var k,\n            c,\n            s,\n            i,\n            j,\n            p,\n            n,\n            M,\n            t,\n            eps = Mat.eps;\n\n        n = mat.length;\n\n        if (n <= 0) {\n            return 0;\n        }\n\n        if (mat[0].length < n) {\n            n = mat[0].length;\n        }\n\n        // Copy the input matrix to M\n        M = [];\n\n        for (i = 0; i < n; i++) {\n            M[i] = mat[i].slice(0, n);\n        }\n\n        c = 1;\n        s = 1;\n\n        for (k = 0; k < n - 1; k++) {\n            p = M[k][k];\n\n            // Pivot step\n            if (Math.abs(p) < eps) {\n                for (i = k + 1; i < n; i++) {\n                    if (Math.abs(M[i][k]) >= eps) {\n                        break;\n                    }\n                }\n\n                // No nonzero entry found in column k -> det(M) = 0\n                if (i === n) {\n                    return 0.0;\n                }\n\n                // swap row i and k partially\n                for (j = k; j < n; j++) {\n                    t = M[i][j];\n                    M[i][j] = M[k][j];\n                    M[k][j] = t;\n                }\n                s = -s;\n                p = M[k][k];\n            }\n\n            // Main step\n            for (i = k + 1; i < n; i++) {\n                for (j = k + 1; j < n; j++) {\n                    t = p * M[i][j] - M[i][k] * M[k][j];\n                    M[i][j] = t / c;\n                }\n            }\n\n            c = p;\n        }\n\n        return s * M[n - 1][n - 1];\n    },\n\n    /**\n     * Computes the determinant of a square nxn matrix with the\n     * Gauss-Bareiss algorithm.\n     * @param {Array} mat Matrix.\n     * @returns {Number} The determinant pf the matrix mat.\n     *                   The empty matrix returns 0.\n     * @memberof JXG.Math.Numerics\n     */\n    det: function (mat) {\n        var n = mat.length;\n\n        if (n === 2 && mat[0].length === 2) {\n            return mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];\n        }\n\n        return this.gaussBareiss(mat);\n    },\n\n    /**\n     * Compute the Eigenvalues and Eigenvectors of a symmetric 3x3 matrix with the Jacobi method\n     * Adaption of a FORTRAN program by Ed Wilson, Dec. 25, 1990\n     * @param {Array} Ain A symmetric 3x3 matrix.\n     * @returns {Array} [A,V] the matrices A and V. The diagonal of A contains the Eigenvalues, V contains the Eigenvectors.\n     * @memberof JXG.Math.Numerics\n     */\n    Jacobi: function (Ain) {\n        var i,\n            j,\n            k,\n            aa,\n            si,\n            co,\n            tt,\n            ssum,\n            amax,\n            eps = Mat.eps * Mat.eps,\n            sum = 0.0,\n            n = Ain.length,\n            V = [\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ],\n            A = [\n                [0, 0, 0],\n                [0, 0, 0],\n                [0, 0, 0]\n            ],\n            nloops = 0;\n\n        // Initialization. Set initial Eigenvectors.\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = 0.0;\n                A[i][j] = Ain[i][j];\n                sum += Math.abs(A[i][j]);\n            }\n            V[i][i] = 1.0;\n        }\n\n        // Trivial problems\n        if (n === 1) {\n            return [A, V];\n        }\n\n        if (sum <= 0.0) {\n            return [A, V];\n        }\n\n        sum /= n * n;\n\n        // Reduce matrix to diagonal\n        do {\n            ssum = 0.0;\n            amax = 0.0;\n            for (j = 1; j < n; j++) {\n                for (i = 0; i < j; i++) {\n                    // Check if A[i][j] is to be reduced\n                    aa = Math.abs(A[i][j]);\n\n                    if (aa > amax) {\n                        amax = aa;\n                    }\n\n                    ssum += aa;\n\n                    if (aa >= eps) {\n                        // calculate rotation angle\n                        aa = Math.atan2(2.0 * A[i][j], A[i][i] - A[j][j]) * 0.5;\n                        si = Math.sin(aa);\n                        co = Math.cos(aa);\n\n                        // Modify 'i' and 'j' columns\n                        for (k = 0; k < n; k++) {\n                            tt = A[k][i];\n                            A[k][i] = co * tt + si * A[k][j];\n                            A[k][j] = -si * tt + co * A[k][j];\n                            tt = V[k][i];\n                            V[k][i] = co * tt + si * V[k][j];\n                            V[k][j] = -si * tt + co * V[k][j];\n                        }\n\n                        // Modify diagonal terms\n                        A[i][i] = co * A[i][i] + si * A[j][i];\n                        A[j][j] = -si * A[i][j] + co * A[j][j];\n                        A[i][j] = 0.0;\n\n                        // Make 'A' matrix symmetrical\n                        for (k = 0; k < n; k++) {\n                            A[i][k] = A[k][i];\n                            A[j][k] = A[k][j];\n                        }\n                        // A[i][j] made zero by rotation\n                    }\n                }\n            }\n            nloops += 1;\n        } while (Math.abs(ssum) / sum > eps && nloops < 2000);\n\n        return [A, V];\n    },\n\n    /**\n     * Calculates the integral of function f over interval using Newton-Cotes-algorithm.\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @param {Object} [config] The algorithm setup. Accepted properties are number_of_nodes of type number and integration_type\n     * with value being either 'trapez', 'simpson', or 'milne'.\n     * @param {Number} [config.number_of_nodes=28]\n     * @param {String} [config.integration_type='milne'] Possible values are 'milne', 'simpson', 'trapez'\n     * @returns {Number} Integral value of f over interval\n     * @throws {Error} If config.number_of_nodes doesn't match config.integration_type an exception is thrown. If you want to use\n     * simpson rule respectively milne rule config.number_of_nodes must be dividable by 2 respectively 4.\n     * @example\n     * function f(x) {\n     *   return x*x;\n     * }\n     *\n     * // calculates integral of <tt>f</tt> from 0 to 2.\n     * var area1 = JXG.Math.Numerics.NewtonCotes([0, 2], f);\n     *\n     * // the same with an anonymous function\n     * var area2 = JXG.Math.Numerics.NewtonCotes([0, 2], function (x) { return x*x; });\n     *\n     * // use trapez rule with 16 nodes\n     * var area3 = JXG.Math.Numerics.NewtonCotes([0, 2], f,\n     *                                   {number_of_nodes: 16, integration_type: 'trapez'});\n     * @memberof JXG.Math.Numerics\n     */\n    NewtonCotes: function (interval, f, config) {\n        var evaluation_point,\n            i,\n            number_of_intervals,\n            integral_value = 0.0,\n            number_of_nodes =\n                config && Type.isNumber(config.number_of_nodes) ? config.number_of_nodes : 28,\n            available_types = { trapez: true, simpson: true, milne: true },\n            integration_type =\n                config &&\n                config.integration_type &&\n                available_types.hasOwnProperty(config.integration_type) &&\n                available_types[config.integration_type]\n                    ? config.integration_type\n                    : \"milne\",\n            step_size = (interval[1] - interval[0]) / number_of_nodes;\n\n        switch (integration_type) {\n            case \"trapez\":\n                integral_value = (f(interval[0]) + f(interval[1])) * 0.5;\n                evaluation_point = interval[0];\n\n                for (i = 0; i < number_of_nodes - 1; i++) {\n                    evaluation_point += step_size;\n                    integral_value += f(evaluation_point);\n                }\n\n                integral_value *= step_size;\n                break;\n            case \"simpson\":\n                if (number_of_nodes % 2 > 0) {\n                    throw new Error(\n                        \"JSXGraph:  INT_SIMPSON requires config.number_of_nodes dividable by 2.\"\n                    );\n                }\n\n                number_of_intervals = number_of_nodes / 2.0;\n                integral_value = f(interval[0]) + f(interval[1]);\n                evaluation_point = interval[0];\n\n                for (i = 0; i < number_of_intervals - 1; i++) {\n                    evaluation_point += 2.0 * step_size;\n                    integral_value += 2.0 * f(evaluation_point);\n                }\n\n                evaluation_point = interval[0] - step_size;\n\n                for (i = 0; i < number_of_intervals; i++) {\n                    evaluation_point += 2.0 * step_size;\n                    integral_value += 4.0 * f(evaluation_point);\n                }\n\n                integral_value *= step_size / 3.0;\n                break;\n            default:\n                if (number_of_nodes % 4 > 0) {\n                    throw new Error(\n                        \"JSXGraph: Error in INT_MILNE: config.number_of_nodes must be a multiple of 4\"\n                    );\n                }\n\n                number_of_intervals = number_of_nodes * 0.25;\n                integral_value = 7.0 * (f(interval[0]) + f(interval[1]));\n                evaluation_point = interval[0];\n\n                for (i = 0; i < number_of_intervals - 1; i++) {\n                    evaluation_point += 4.0 * step_size;\n                    integral_value += 14.0 * f(evaluation_point);\n                }\n\n                evaluation_point = interval[0] - 3.0 * step_size;\n\n                for (i = 0; i < number_of_intervals; i++) {\n                    evaluation_point += 4.0 * step_size;\n                    integral_value +=\n                        32.0 * (f(evaluation_point) + f(evaluation_point + 2 * step_size));\n                }\n\n                evaluation_point = interval[0] - 2.0 * step_size;\n\n                for (i = 0; i < number_of_intervals; i++) {\n                    evaluation_point += 4.0 * step_size;\n                    integral_value += 12.0 * f(evaluation_point);\n                }\n\n                integral_value *= (2.0 * step_size) / 45.0;\n        }\n        return integral_value;\n    },\n\n    /**\n     * Calculates the integral of function f over interval using Romberg iteration.\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @param {Object} [config] The algorithm setup. Accepted properties are max_iterations of type number and precision eps.\n     * @param {Number} [config.max_iterations=20]\n     * @param {Number} [config.eps=0.0000001]\n     * @returns {Number} Integral value of f over interval\n     * @example\n     * function f(x) {\n     *   return x*x;\n     * }\n     *\n     * // calculates integral of <tt>f</tt> from 0 to 2.\n     * var area1 = JXG.Math.Numerics.Romberg([0, 2], f);\n     *\n     * // the same with an anonymous function\n     * var area2 = JXG.Math.Numerics.Romberg([0, 2], function (x) { return x*x; });\n     *\n     * // use trapez rule with maximum of 16 iterations or stop if the precision 0.0001 has been reached.\n     * var area3 = JXG.Math.Numerics.Romberg([0, 2], f,\n     *                                   {max_iterations: 16, eps: 0.0001});\n     * @memberof JXG.Math.Numerics\n     */\n    Romberg: function (interval, f, config) {\n        var a,\n            b,\n            h,\n            s,\n            n,\n            k,\n            i,\n            q,\n            p = [],\n            integral = 0.0,\n            last = Infinity,\n            m = config && Type.isNumber(config.max_iterations) ? config.max_iterations : 20,\n            eps = config && Type.isNumber(config.eps) ? config.eps : config.eps || 0.0000001;\n\n        a = interval[0];\n        b = interval[1];\n        h = b - a;\n        n = 1;\n\n        p[0] = 0.5 * h * (f(a) + f(b));\n\n        for (k = 0; k < m; ++k) {\n            s = 0;\n            h *= 0.5;\n            n *= 2;\n            q = 1;\n\n            for (i = 1; i < n; i += 2) {\n                s += f(a + i * h);\n            }\n\n            p[k + 1] = 0.5 * p[k] + s * h;\n\n            integral = p[k + 1];\n            for (i = k - 1; i >= 0; --i) {\n                q *= 4;\n                p[i] = p[i + 1] + (p[i + 1] - p[i]) / (q - 1.0);\n                integral = p[i];\n            }\n\n            if (Math.abs(integral - last) < eps * Math.abs(integral)) {\n                break;\n            }\n            last = integral;\n        }\n\n        return integral;\n    },\n\n    /**\n     * Calculates the integral of function f over interval using Gauss-Legendre quadrature.\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @param {Object} [config] The algorithm setup. Accepted property is the order n of type number. n is allowed to take\n     * values between 2 and 18, default value is 12.\n     * @param {Number} [config.n=16]\n     * @returns {Number} Integral value of f over interval\n     * @example\n     * function f(x) {\n     *   return x*x;\n     * }\n     *\n     * // calculates integral of <tt>f</tt> from 0 to 2.\n     * var area1 = JXG.Math.Numerics.GaussLegendre([0, 2], f);\n     *\n     * // the same with an anonymous function\n     * var area2 = JXG.Math.Numerics.GaussLegendre([0, 2], function (x) { return x*x; });\n     *\n     * // use 16 point Gauss-Legendre rule.\n     * var area3 = JXG.Math.Numerics.GaussLegendre([0, 2], f,\n     *                                   {n: 16});\n     * @memberof JXG.Math.Numerics\n     */\n    GaussLegendre: function (interval, f, config) {\n        var a,\n            b,\n            i,\n            m,\n            xp,\n            xm,\n            result = 0.0,\n            table_xi = [],\n            table_w = [],\n            xi,\n            w,\n            n = config && Type.isNumber(config.n) ? config.n : 12;\n\n        if (n > 18) {\n            n = 18;\n        }\n\n        /* n = 2 */\n        table_xi[2] = [0.5773502691896257645091488];\n        table_w[2] = [1.0];\n\n        /* n = 4 */\n        table_xi[4] = [0.3399810435848562648026658, 0.8611363115940525752239465];\n        table_w[4] = [0.6521451548625461426269361, 0.3478548451374538573730639];\n\n        /* n = 6 */\n        table_xi[6] = [\n            0.2386191860831969086305017, 0.6612093864662645136613996,\n            0.9324695142031520278123016\n        ];\n        table_w[6] = [\n            0.4679139345726910473898703, 0.3607615730481386075698335,\n            0.1713244923791703450402961\n        ];\n\n        /* n = 8 */\n        table_xi[8] = [\n            0.1834346424956498049394761, 0.525532409916328985817739,\n            0.7966664774136267395915539, 0.9602898564975362316835609\n        ];\n        table_w[8] = [\n            0.3626837833783619829651504, 0.3137066458778872873379622,\n            0.222381034453374470544356, 0.1012285362903762591525314\n        ];\n\n        /* n = 10 */\n        table_xi[10] = [\n            0.148874338981631210884826, 0.4333953941292471907992659,\n            0.6794095682990244062343274, 0.8650633666889845107320967, 0.973906528517171720077964\n        ];\n        table_w[10] = [\n            0.295524224714752870173893, 0.2692667193099963550912269,\n            0.2190863625159820439955349, 0.1494513491505805931457763,\n            0.0666713443086881375935688\n        ];\n\n        /* n = 12 */\n        table_xi[12] = [\n            0.1252334085114689154724414, 0.3678314989981801937526915,\n            0.5873179542866174472967024, 0.7699026741943046870368938,\n            0.9041172563704748566784659, 0.9815606342467192506905491\n        ];\n        table_w[12] = [\n            0.2491470458134027850005624, 0.2334925365383548087608499,\n            0.2031674267230659217490645, 0.1600783285433462263346525,\n            0.1069393259953184309602547, 0.047175336386511827194616\n        ];\n\n        /* n = 14 */\n        table_xi[14] = [\n            0.1080549487073436620662447, 0.3191123689278897604356718,\n            0.5152486363581540919652907, 0.6872929048116854701480198,\n            0.8272013150697649931897947, 0.9284348836635735173363911,\n            0.9862838086968123388415973\n        ];\n        table_w[14] = [\n            0.2152638534631577901958764, 0.2051984637212956039659241,\n            0.1855383974779378137417166, 0.1572031671581935345696019,\n            0.1215185706879031846894148, 0.0801580871597602098056333,\n            0.0351194603317518630318329\n        ];\n\n        /* n = 16 */\n        table_xi[16] = [\n            0.0950125098376374401853193, 0.2816035507792589132304605,\n            0.4580167776572273863424194, 0.6178762444026437484466718,\n            0.7554044083550030338951012, 0.8656312023878317438804679,\n            0.9445750230732325760779884, 0.9894009349916499325961542\n        ];\n        table_w[16] = [\n            0.1894506104550684962853967, 0.1826034150449235888667637,\n            0.1691565193950025381893121, 0.1495959888165767320815017,\n            0.1246289712555338720524763, 0.0951585116824927848099251,\n            0.0622535239386478928628438, 0.0271524594117540948517806\n        ];\n\n        /* n = 18 */\n        table_xi[18] = [\n            0.0847750130417353012422619, 0.2518862256915055095889729,\n            0.4117511614628426460359318, 0.5597708310739475346078715,\n            0.6916870430603532078748911, 0.8037049589725231156824175,\n            0.8926024664975557392060606, 0.9558239495713977551811959, 0.991565168420930946730016\n        ];\n        table_w[18] = [\n            0.1691423829631435918406565, 0.1642764837458327229860538,\n            0.154684675126265244925418, 0.1406429146706506512047313,\n            0.1225552067114784601845191, 0.100942044106287165562814,\n            0.0764257302548890565291297, 0.0497145488949697964533349,\n            0.0216160135264833103133427\n        ];\n\n        /* n = 3 */\n        table_xi[3] = [0.0, 0.7745966692414833770358531];\n        table_w[3] = [0.8888888888888888888888889, 0.5555555555555555555555556];\n\n        /* n = 5 */\n        table_xi[5] = [0.0, 0.5384693101056830910363144, 0.9061798459386639927976269];\n        table_w[5] = [\n            0.5688888888888888888888889, 0.4786286704993664680412915, 0.236926885056189087514264\n        ];\n\n        /* n = 7 */\n        table_xi[7] = [\n            0.0, 0.4058451513773971669066064, 0.7415311855993944398638648,\n            0.9491079123427585245261897\n        ];\n        table_w[7] = [\n            0.417959183673469387755102, 0.3818300505051189449503698,\n            0.2797053914892766679014678, 0.1294849661688696932706114\n        ];\n\n        /* n = 9 */\n        table_xi[9] = [\n            0.0, 0.324253423403808929038538, 0.613371432700590397308702,\n            0.8360311073266357942994298, 0.9681602395076260898355762\n        ];\n        table_w[9] = [\n            0.3302393550012597631645251, 0.3123470770400028400686304,\n            0.2606106964029354623187429, 0.180648160694857404058472, 0.0812743883615744119718922\n        ];\n\n        /* n = 11 */\n        table_xi[11] = [\n            0.0, 0.269543155952344972331532, 0.5190961292068118159257257,\n            0.7301520055740493240934163, 0.8870625997680952990751578, 0.978228658146056992803938\n        ];\n        table_w[11] = [\n            0.2729250867779006307144835, 0.2628045445102466621806889,\n            0.2331937645919904799185237, 0.1862902109277342514260976,\n            0.1255803694649046246346943, 0.0556685671161736664827537\n        ];\n\n        /* n = 13 */\n        table_xi[13] = [\n            0.0, 0.2304583159551347940655281, 0.4484927510364468528779129,\n            0.6423493394403402206439846, 0.8015780907333099127942065,\n            0.9175983992229779652065478, 0.9841830547185881494728294\n        ];\n        table_w[13] = [\n            0.2325515532308739101945895, 0.2262831802628972384120902,\n            0.2078160475368885023125232, 0.1781459807619457382800467,\n            0.1388735102197872384636018, 0.0921214998377284479144218,\n            0.0404840047653158795200216\n        ];\n\n        /* n = 15 */\n        table_xi[15] = [\n            0.0, 0.2011940939974345223006283, 0.3941513470775633698972074,\n            0.5709721726085388475372267, 0.7244177313601700474161861,\n            0.8482065834104272162006483, 0.9372733924007059043077589,\n            0.9879925180204854284895657\n        ];\n        table_w[15] = [\n            0.2025782419255612728806202, 0.1984314853271115764561183,\n            0.1861610000155622110268006, 0.1662692058169939335532009,\n            0.1395706779261543144478048, 0.1071592204671719350118695,\n            0.0703660474881081247092674, 0.0307532419961172683546284\n        ];\n\n        /* n = 17 */\n        table_xi[17] = [\n            0.0, 0.1784841814958478558506775, 0.3512317634538763152971855,\n            0.5126905370864769678862466, 0.6576711592166907658503022,\n            0.7815140038968014069252301, 0.8802391537269859021229557,\n            0.950675521768767761222717, 0.990575475314417335675434\n        ];\n        table_w[17] = [\n            0.1794464703562065254582656, 0.176562705366992646325271,\n            0.1680041021564500445099707, 0.1540457610768102880814316, 0.13513636846852547328632,\n            0.1118838471934039710947884, 0.0850361483171791808835354,\n            0.0554595293739872011294402, 0.02414830286854793196011\n        ];\n\n        a = interval[0];\n        b = interval[1];\n\n        //m = Math.ceil(n * 0.5);\n        m = (n + 1) >> 1;\n\n        xi = table_xi[n];\n        w = table_w[n];\n\n        xm = 0.5 * (b - a);\n        xp = 0.5 * (b + a);\n\n        if (n & (1 === 1)) {\n            // n odd\n            result = w[0] * f(xp);\n            for (i = 1; i < m; ++i) {\n                result += w[i] * (f(xp + xm * xi[i]) + f(xp - xm * xi[i]));\n            }\n        } else {\n            // n even\n            result = 0.0;\n            for (i = 0; i < m; ++i) {\n                result += w[i] * (f(xp + xm * xi[i]) + f(xp - xm * xi[i]));\n            }\n        }\n\n        return xm * result;\n    },\n\n    /**\n     * Scale error in Gauss Kronrod quadrature.\n     * Internal method used in {@link JXG.Math.Numerics._gaussKronrod}.\n     * @private\n     */\n    _rescale_error: function (err, result_abs, result_asc) {\n        var scale,\n            min_err,\n            DBL_MIN = 2.2250738585072014e-308,\n            DBL_EPS = 2.2204460492503131e-16;\n\n        err = Math.abs(err);\n        if (result_asc !== 0 && err !== 0) {\n            scale = Math.pow((200 * err) / result_asc, 1.5);\n\n            if (scale < 1.0) {\n                err = result_asc * scale;\n            } else {\n                err = result_asc;\n            }\n        }\n        if (result_abs > DBL_MIN / (50 * DBL_EPS)) {\n            min_err = 50 * DBL_EPS * result_abs;\n\n            if (min_err > err) {\n                err = min_err;\n            }\n        }\n\n        return err;\n    },\n\n    /**\n     * Generic Gauss-Kronrod quadrature algorithm.\n     * Internal method used in {@link JXG.Math.Numerics.GaussKronrod15},\n     * {@link JXG.Math.Numerics.GaussKronrod21},\n     * {@link JXG.Math.Numerics.GaussKronrod31}.\n     * Taken from QUADPACK.\n     *\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @param {Number} n order\n     * @param {Array} xgk Kronrod quadrature abscissae\n     * @param {Array} wg Weights of the Gauss rule\n     * @param {Array} wgk Weights of the Kronrod rule\n     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc.\n     * See the library QUADPACK for an explanation.\n     *\n     * @returns {Number} Integral value of f over interval\n     *\n     * @private\n     */\n    _gaussKronrod: function (interval, f, n, xgk, wg, wgk, resultObj) {\n        var a = interval[0],\n            b = interval[1],\n            up,\n            result,\n            center = 0.5 * (a + b),\n            half_length = 0.5 * (b - a),\n            abs_half_length = Math.abs(half_length),\n            f_center = f(center),\n            result_gauss = 0.0,\n            result_kronrod = f_center * wgk[n - 1],\n            result_abs = Math.abs(result_kronrod),\n            result_asc = 0.0,\n            mean = 0.0,\n            err = 0.0,\n            j,\n            jtw,\n            abscissa,\n            fval1,\n            fval2,\n            fsum,\n            jtwm1,\n            fv1 = [],\n            fv2 = [];\n\n        if (n % 2 === 0) {\n            result_gauss = f_center * wg[n / 2 - 1];\n        }\n\n        up = Math.floor((n - 1) / 2);\n        for (j = 0; j < up; j++) {\n            jtw = j * 2 + 1; // in original fortran j=1,2,3 jtw=2,4,6\n            abscissa = half_length * xgk[jtw];\n            fval1 = f(center - abscissa);\n            fval2 = f(center + abscissa);\n            fsum = fval1 + fval2;\n            fv1[jtw] = fval1;\n            fv2[jtw] = fval2;\n            result_gauss += wg[j] * fsum;\n            result_kronrod += wgk[jtw] * fsum;\n            result_abs += wgk[jtw] * (Math.abs(fval1) + Math.abs(fval2));\n        }\n\n        up = Math.floor(n / 2);\n        for (j = 0; j < up; j++) {\n            jtwm1 = j * 2;\n            abscissa = half_length * xgk[jtwm1];\n            fval1 = f(center - abscissa);\n            fval2 = f(center + abscissa);\n            fv1[jtwm1] = fval1;\n            fv2[jtwm1] = fval2;\n            result_kronrod += wgk[jtwm1] * (fval1 + fval2);\n            result_abs += wgk[jtwm1] * (Math.abs(fval1) + Math.abs(fval2));\n        }\n\n        mean = result_kronrod * 0.5;\n        result_asc = wgk[n - 1] * Math.abs(f_center - mean);\n\n        for (j = 0; j < n - 1; j++) {\n            result_asc += wgk[j] * (Math.abs(fv1[j] - mean) + Math.abs(fv2[j] - mean));\n        }\n\n        // scale by the width of the integration region\n        err = (result_kronrod - result_gauss) * half_length;\n\n        result_kronrod *= half_length;\n        result_abs *= abs_half_length;\n        result_asc *= abs_half_length;\n        result = result_kronrod;\n\n        resultObj.abserr = this._rescale_error(err, result_abs, result_asc);\n        resultObj.resabs = result_abs;\n        resultObj.resasc = result_asc;\n\n        return result;\n    },\n\n    /**\n     * 15 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library\n     *  QUADPACK for an explanation.\n     *\n     * @returns {Number} Integral value of f over interval\n     *\n     * @memberof JXG.Math.Numerics\n     */\n    GaussKronrod15: function (interval, f, resultObj) {\n        /* Gauss quadrature weights and kronrod quadrature abscissae and\n                weights as evaluated with 80 decimal digit arithmetic by\n                L. W. Fullerton, Bell Labs, Nov. 1981. */\n\n        var xgk =\n                /* abscissae of the 15-point kronrod rule */\n                [\n                    0.991455371120812639206854697526329, 0.949107912342758524526189684047851,\n                    0.864864423359769072789712788640926, 0.741531185599394439863864773280788,\n                    0.58608723546769113029414483825873, 0.405845151377397166906606412076961,\n                    0.207784955007898467600689403773245, 0.0\n                ],\n            /* xgk[1], xgk[3], ... abscissae of the 7-point gauss rule.\n                xgk[0], xgk[2], ... abscissae to optimally extend the 7-point gauss rule */\n\n            wg =\n                /* weights of the 7-point gauss rule */\n                [\n                    0.129484966168869693270611432679082, 0.27970539148927666790146777142378,\n                    0.381830050505118944950369775488975, 0.417959183673469387755102040816327\n                ],\n            wgk =\n                /* weights of the 15-point kronrod rule */\n                [\n                    0.02293532201052922496373200805897, 0.063092092629978553290700663189204,\n                    0.104790010322250183839876322541518, 0.140653259715525918745189590510238,\n                    0.16900472663926790282658342659855, 0.190350578064785409913256402421014,\n                    0.204432940075298892414161999234649, 0.209482141084727828012999174891714\n                ];\n\n        return this._gaussKronrod(interval, f, 8, xgk, wg, wgk, resultObj);\n    },\n\n    /**\n     * 21 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library\n     *  QUADPACK for an explanation.\n     *\n     * @returns {Number} Integral value of f over interval\n     *\n     * @memberof JXG.Math.Numerics\n     */\n    GaussKronrod21: function (interval, f, resultObj) {\n        /* Gauss quadrature weights and kronrod quadrature abscissae and\n                weights as evaluated with 80 decimal digit arithmetic by\n                L. W. Fullerton, Bell Labs, Nov. 1981. */\n\n        var xgk =\n                /* abscissae of the 21-point kronrod rule */\n                [\n                    0.995657163025808080735527280689003, 0.973906528517171720077964012084452,\n                    0.930157491355708226001207180059508, 0.865063366688984510732096688423493,\n                    0.780817726586416897063717578345042, 0.679409568299024406234327365114874,\n                    0.562757134668604683339000099272694, 0.433395394129247190799265943165784,\n                    0.294392862701460198131126603103866, 0.14887433898163121088482600112972, 0.0\n                ],\n            /* xgk[1], xgk[3], ... abscissae of the 10-point gauss rule.\n                xgk[0], xgk[2], ... abscissae to optimally extend the 10-point gauss rule */\n            wg =\n                /* weights of the 10-point gauss rule */\n                [\n                    0.066671344308688137593568809893332, 0.149451349150580593145776339657697,\n                    0.219086362515982043995534934228163, 0.269266719309996355091226921569469,\n                    0.295524224714752870173892994651338\n                ],\n            wgk =\n                /* weights of the 21-point kronrod rule */\n                [\n                    0.011694638867371874278064396062192, 0.03255816230796472747881897245939,\n                    0.05475589657435199603138130024458, 0.07503967481091995276704314091619,\n                    0.093125454583697605535065465083366, 0.109387158802297641899210590325805,\n                    0.123491976262065851077958109831074, 0.134709217311473325928054001771707,\n                    0.142775938577060080797094273138717, 0.147739104901338491374841515972068,\n                    0.149445554002916905664936468389821\n                ];\n\n        return this._gaussKronrod(interval, f, 11, xgk, wg, wgk, resultObj);\n    },\n\n    /**\n     * 31 point Gauss-Kronrod quadrature algorithm, see the library QUADPACK\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @param {Object} resultObj Object returning resultObj.abserr, resultObj.resabs, resultObj.resasc. See the library\n     *  QUADPACK for an explanation.\n     *\n     * @returns {Number} Integral value of f over interval\n     *\n     * @memberof JXG.Math.Numerics\n     */\n    GaussKronrod31: function (interval, f, resultObj) {\n        /* Gauss quadrature weights and kronrod quadrature abscissae and\n                weights as evaluated with 80 decimal digit arithmetic by\n                L. W. Fullerton, Bell Labs, Nov. 1981. */\n\n        var xgk =\n                /* abscissae of the 21-point kronrod rule */\n                [\n                    0.998002298693397060285172840152271, 0.987992518020485428489565718586613,\n                    0.967739075679139134257347978784337, 0.937273392400705904307758947710209,\n                    0.897264532344081900882509656454496, 0.848206583410427216200648320774217,\n                    0.790418501442465932967649294817947, 0.724417731360170047416186054613938,\n                    0.650996741297416970533735895313275, 0.570972172608538847537226737253911,\n                    0.485081863640239680693655740232351, 0.394151347077563369897207370981045,\n                    0.299180007153168812166780024266389, 0.201194093997434522300628303394596,\n                    0.101142066918717499027074231447392, 0.0\n                ],\n            /* xgk[1], xgk[3], ... abscissae of the 10-point gauss rule.\n                xgk[0], xgk[2], ... abscissae to optimally extend the 10-point gauss rule */\n            wg =\n                /* weights of the 10-point gauss rule */\n                [\n                    0.030753241996117268354628393577204, 0.070366047488108124709267416450667,\n                    0.107159220467171935011869546685869, 0.139570677926154314447804794511028,\n                    0.166269205816993933553200860481209, 0.186161000015562211026800561866423,\n                    0.198431485327111576456118326443839, 0.202578241925561272880620199967519\n                ],\n            wgk =\n                /* weights of the 21-point kronrod rule */\n                [\n                    0.005377479872923348987792051430128, 0.015007947329316122538374763075807,\n                    0.025460847326715320186874001019653, 0.03534636079137584622203794847836,\n                    0.04458975132476487660822729937328, 0.05348152469092808726534314723943,\n                    0.062009567800670640285139230960803, 0.069854121318728258709520077099147,\n                    0.076849680757720378894432777482659, 0.083080502823133021038289247286104,\n                    0.088564443056211770647275443693774, 0.093126598170825321225486872747346,\n                    0.096642726983623678505179907627589, 0.099173598721791959332393173484603,\n                    0.10076984552387559504494666261757, 0.101330007014791549017374792767493\n                ];\n\n        return this._gaussKronrod(interval, f, 16, xgk, wg, wgk, resultObj);\n    },\n\n    /**\n     * Generate workspace object for {@link JXG.Math.Numerics.Qag}.\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {Number} n Max. limit\n     * @returns {Object} Workspace object\n     *\n     * @private\n     * @memberof JXG.Math.Numerics\n     */\n    _workspace: function (interval, n) {\n        return {\n            limit: n,\n            size: 0,\n            nrmax: 0,\n            i: 0,\n            alist: [interval[0]],\n            blist: [interval[1]],\n            rlist: [0.0],\n            elist: [0.0],\n            order: [0],\n            level: [0],\n\n            qpsrt: function () {\n                var last = this.size - 1,\n                    limit = this.limit,\n                    errmax,\n                    errmin,\n                    i,\n                    k,\n                    top,\n                    i_nrmax = this.nrmax,\n                    i_maxerr = this.order[i_nrmax];\n\n                /* Check whether the list contains more than two error estimates */\n                if (last < 2) {\n                    this.order[0] = 0;\n                    this.order[1] = 1;\n                    this.i = i_maxerr;\n                    return;\n                }\n\n                errmax = this.elist[i_maxerr];\n\n                /* This part of the routine is only executed if, due to a difficult\n                        integrand, subdivision increased the error estimate. In the normal\n                        case the insert procedure should start after the nrmax-th largest\n                        error estimate. */\n                while (i_nrmax > 0 && errmax > this.elist[this.order[i_nrmax - 1]]) {\n                    this.order[i_nrmax] = this.order[i_nrmax - 1];\n                    i_nrmax--;\n                }\n\n                /* Compute the number of elements in the list to be maintained in\n                        descending order. This number depends on the number of\n                        subdivisions still allowed. */\n                if (last < limit / 2 + 2) {\n                    top = last;\n                } else {\n                    top = limit - last + 1;\n                }\n\n                /* Insert errmax by traversing the list top-down, starting\n                        comparison from the element elist(order(i_nrmax+1)). */\n                i = i_nrmax + 1;\n\n                /* The order of the tests in the following line is important to\n                        prevent a segmentation fault */\n                while (i < top && errmax < this.elist[this.order[i]]) {\n                    this.order[i - 1] = this.order[i];\n                    i++;\n                }\n\n                this.order[i - 1] = i_maxerr;\n\n                /* Insert errmin by traversing the list bottom-up */\n                errmin = this.elist[last];\n                k = top - 1;\n\n                while (k > i - 2 && errmin >= this.elist[this.order[k]]) {\n                    this.order[k + 1] = this.order[k];\n                    k--;\n                }\n\n                this.order[k + 1] = last;\n\n                /* Set i_max and e_max */\n                i_maxerr = this.order[i_nrmax];\n                this.i = i_maxerr;\n                this.nrmax = i_nrmax;\n            },\n\n            set_initial_result: function (result, error) {\n                this.size = 1;\n                this.rlist[0] = result;\n                this.elist[0] = error;\n            },\n\n            update: function (a1, b1, area1, error1, a2, b2, area2, error2) {\n                var i_max = this.i,\n                    i_new = this.size,\n                    new_level = this.level[this.i] + 1;\n\n                /* append the newly-created intervals to the list */\n\n                if (error2 > error1) {\n                    this.alist[i_max] = a2; /* blist[maxerr] is already == b2 */\n                    this.rlist[i_max] = area2;\n                    this.elist[i_max] = error2;\n                    this.level[i_max] = new_level;\n\n                    this.alist[i_new] = a1;\n                    this.blist[i_new] = b1;\n                    this.rlist[i_new] = area1;\n                    this.elist[i_new] = error1;\n                    this.level[i_new] = new_level;\n                } else {\n                    this.blist[i_max] = b1; /* alist[maxerr] is already == a1 */\n                    this.rlist[i_max] = area1;\n                    this.elist[i_max] = error1;\n                    this.level[i_max] = new_level;\n\n                    this.alist[i_new] = a2;\n                    this.blist[i_new] = b2;\n                    this.rlist[i_new] = area2;\n                    this.elist[i_new] = error2;\n                    this.level[i_new] = new_level;\n                }\n\n                this.size++;\n\n                if (new_level > this.maximum_level) {\n                    this.maximum_level = new_level;\n                }\n\n                this.qpsrt();\n            },\n\n            retrieve: function () {\n                var i = this.i;\n                return {\n                    a: this.alist[i],\n                    b: this.blist[i],\n                    r: this.rlist[i],\n                    e: this.elist[i]\n                };\n            },\n\n            sum_results: function () {\n                var nn = this.size,\n                    k,\n                    result_sum = 0.0;\n\n                for (k = 0; k < nn; k++) {\n                    result_sum += this.rlist[k];\n                }\n\n                return result_sum;\n            },\n\n            subinterval_too_small: function (a1, a2, b2) {\n                var e = 2.2204460492503131e-16,\n                    u = 2.2250738585072014e-308,\n                    tmp = (1 + 100 * e) * (Math.abs(a2) + 1000 * u);\n\n                return Math.abs(a1) <= tmp && Math.abs(b2) <= tmp;\n            }\n        };\n    },\n\n    /**\n     * Quadrature algorithm qag from QUADPACK.\n     * Internal method used in {@link JXG.Math.Numerics.GaussKronrod15},\n     * {@link JXG.Math.Numerics.GaussKronrod21},\n     * {@link JXG.Math.Numerics.GaussKronrod31}.\n     *\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @param {Object} [config] The algorithm setup. Accepted propert are max. recursion limit of type number,\n     * and epsrel and epsabs, the relative and absolute required precision of type number. Further,\n     * q the internal quadrature sub-algorithm of type function.\n     * @param {Number} [config.limit=15]\n     * @param {Number} [config.epsrel=0.0000001]\n     * @param {Number} [config.epsabs=0.0000001]\n     * @param {Number} [config.q=JXG.Math.Numerics.GaussKronrod15]\n     * @returns {Number} Integral value of f over interval\n     *\n     * @example\n     * function f(x) {\n     *   return x*x;\n     * }\n     *\n     * // calculates integral of <tt>f</tt> from 0 to 2.\n     * var area1 = JXG.Math.Numerics.Qag([0, 2], f);\n     *\n     * // the same with an anonymous function\n     * var area2 = JXG.Math.Numerics.Qag([0, 2], function (x) { return x*x; });\n     *\n     * // use JXG.Math.Numerics.GaussKronrod31 rule as sub-algorithm.\n     * var area3 = JXG.Math.Numerics.Quag([0, 2], f,\n     *                                   {q: JXG.Math.Numerics.GaussKronrod31});\n     * @memberof JXG.Math.Numerics\n     */\n    Qag: function (interval, f, config) {\n        var DBL_EPS = 2.2204460492503131e-16,\n            ws = this._workspace(interval, 1000),\n            limit = config && Type.isNumber(config.limit) ? config.limit : 15,\n            epsrel = config && Type.isNumber(config.epsrel) ? config.epsrel : 0.0000001,\n            epsabs = config && Type.isNumber(config.epsabs) ? config.epsabs : 0.0000001,\n            q = config && Type.isFunction(config.q) ? config.q : this.GaussKronrod15,\n            resultObj = {},\n            area,\n            errsum,\n            result0,\n            abserr0,\n            resabs0,\n            resasc0,\n            result,\n            tolerance,\n            iteration = 0,\n            roundoff_type1 = 0,\n            roundoff_type2 = 0,\n            error_type = 0,\n            round_off,\n            a1,\n            b1,\n            a2,\n            b2,\n            a_i,\n            b_i,\n            r_i,\n            e_i,\n            area1 = 0,\n            area2 = 0,\n            area12 = 0,\n            error1 = 0,\n            error2 = 0,\n            error12 = 0,\n            resasc1,\n            resasc2,\n            // resabs1, resabs2,\n            wsObj,\n            delta;\n\n        if (limit > ws.limit) {\n            JXG.warn(\"iteration limit exceeds available workspace\");\n        }\n        if (epsabs <= 0 && (epsrel < 50 * Mat.eps || epsrel < 0.5e-28)) {\n            JXG.warn(\"tolerance cannot be acheived with given epsabs and epsrel\");\n        }\n\n        result0 = q.apply(this, [interval, f, resultObj]);\n        abserr0 = resultObj.abserr;\n        resabs0 = resultObj.resabs;\n        resasc0 = resultObj.resasc;\n\n        ws.set_initial_result(result0, abserr0);\n        tolerance = Math.max(epsabs, epsrel * Math.abs(result0));\n        round_off = 50 * DBL_EPS * resabs0;\n\n        if (abserr0 <= round_off && abserr0 > tolerance) {\n            result = result0;\n            // abserr = abserr0;\n\n            JXG.warn(\"cannot reach tolerance because of roundoff error on first attempt\");\n            return -Infinity;\n        }\n\n        if ((abserr0 <= tolerance && abserr0 !== resasc0) || abserr0 === 0.0) {\n            result = result0;\n            // abserr = abserr0;\n\n            return result;\n        }\n\n        if (limit === 1) {\n            result = result0;\n            // abserr = abserr0;\n\n            JXG.warn(\"a maximum of one iteration was insufficient\");\n            return -Infinity;\n        }\n\n        area = result0;\n        errsum = abserr0;\n        iteration = 1;\n\n        do {\n            area1 = 0;\n            area2 = 0;\n            area12 = 0;\n            error1 = 0;\n            error2 = 0;\n            error12 = 0;\n\n            /* Bisect the subinterval with the largest error estimate */\n            wsObj = ws.retrieve();\n            a_i = wsObj.a;\n            b_i = wsObj.b;\n            r_i = wsObj.r;\n            e_i = wsObj.e;\n\n            a1 = a_i;\n            b1 = 0.5 * (a_i + b_i);\n            a2 = b1;\n            b2 = b_i;\n\n            area1 = q.apply(this, [[a1, b1], f, resultObj]);\n            error1 = resultObj.abserr;\n            // resabs1 = resultObj.resabs;\n            resasc1 = resultObj.resasc;\n\n            area2 = q.apply(this, [[a2, b2], f, resultObj]);\n            error2 = resultObj.abserr;\n            // resabs2 = resultObj.resabs;\n            resasc2 = resultObj.resasc;\n\n            area12 = area1 + area2;\n            error12 = error1 + error2;\n\n            errsum += error12 - e_i;\n            area += area12 - r_i;\n\n            if (resasc1 !== error1 && resasc2 !== error2) {\n                delta = r_i - area12;\n                if (Math.abs(delta) <= 1.0e-5 * Math.abs(area12) && error12 >= 0.99 * e_i) {\n                    roundoff_type1++;\n                }\n                if (iteration >= 10 && error12 > e_i) {\n                    roundoff_type2++;\n                }\n            }\n\n            tolerance = Math.max(epsabs, epsrel * Math.abs(area));\n\n            if (errsum > tolerance) {\n                if (roundoff_type1 >= 6 || roundoff_type2 >= 20) {\n                    error_type = 2; /* round off error */\n                }\n\n                /* set error flag in the case of bad integrand behaviour at\n                    a point of the integration range */\n\n                if (ws.subinterval_too_small(a1, a2, b2)) {\n                    error_type = 3;\n                }\n            }\n\n            ws.update(a1, b1, area1, error1, a2, b2, area2, error2);\n            wsObj = ws.retrieve();\n            a_i = wsObj.a_i;\n            b_i = wsObj.b_i;\n            r_i = wsObj.r_i;\n            e_i = wsObj.e_i;\n\n            iteration++;\n        } while (iteration < limit && !error_type && errsum > tolerance);\n\n        result = ws.sum_results();\n        // abserr = errsum;\n        /*\n  if (errsum <= tolerance)\n    {\n      return GSL_SUCCESS;\n    }\n  else if (error_type == 2)\n    {\n      GSL_ERROR (\"roundoff error prevents tolerance from being achieved\",\n                 GSL_EROUND);\n    }\n  else if (error_type == 3)\n    {\n      GSL_ERROR (\"bad integrand behavior found in the integration interval\",\n                 GSL_ESING);\n    }\n  else if (iteration == limit)\n    {\n      GSL_ERROR (\"maximum number of subdivisions reached\", GSL_EMAXITER);\n    }\n  else\n    {\n      GSL_ERROR (\"could not integrate function\", GSL_EFAILED);\n    }\n*/\n\n        return result;\n    },\n\n    /**\n     * Integral of function f over interval.\n     * @param {Array} interval The integration interval, e.g. [0, 3].\n     * @param {function} f A function which takes one argument of type number and returns a number.\n     * @returns {Number} The value of the integral of f over interval\n     * @see JXG.Math.Numerics.NewtonCotes\n     * @see JXG.Math.Numerics.Romberg\n     * @see JXG.Math.Numerics.Qag\n     * @memberof JXG.Math.Numerics\n     */\n    I: function (interval, f) {\n        // return this.NewtonCotes(interval, f, {number_of_nodes: 16, integration_type: 'milne'});\n        // return this.Romberg(interval, f, {max_iterations: 20, eps: 0.0000001});\n        return this.Qag(interval, f, {\n            q: this.GaussKronrod15,\n            limit: 15,\n            epsrel: 0.0000001,\n            epsabs: 0.0000001\n        });\n    },\n\n    /**\n     * Newton's method to find roots of a funtion in one variable.\n     * @param {function} f We search for a solution of f(x)=0.\n     * @param {Number} x initial guess for the root, i.e. start value.\n     * @param {Object} context optional object that is treated as \"this\" in the function body. This is useful if\n     * the function is a method of an object and contains a reference to its parent object via \"this\".\n     * @returns {Number} A root of the function f.\n     * @memberof JXG.Math.Numerics\n     */\n    Newton: function (f, x, context) {\n        var df,\n            i = 0,\n            h = Mat.eps,\n            newf = f.apply(context, [x]);\n        // nfev = 1;\n\n        // For compatibility\n        if (Type.isArray(x)) {\n            x = x[0];\n        }\n\n        while (i < 50 && Math.abs(newf) > h) {\n            df = this.D(f, context)(x);\n            // nfev += 2;\n\n            if (Math.abs(df) > h) {\n                x -= newf / df;\n            } else {\n                x += Math.random() * 0.2 - 1.0;\n            }\n\n            newf = f.apply(context, [x]);\n            // nfev += 1;\n            i += 1;\n        }\n\n        return x;\n    },\n\n    /**\n     * Abstract method to find roots of univariate functions, which - for the time being -\n     * is an alias for {@link JXG.Math.Numerics.chandrupatla}.\n     * @param {function} f We search for a solution of f(x)=0.\n     * @param {Number|Array} x initial guess for the root, i.e. starting value, or start interval enclosing the root.\n     * @param {Object} context optional object that is treated as \"this\" in the function body. This is useful if\n     * the function is a method of an object and contains a reference to its parent object via \"this\".\n     * @returns {Number} A root of the function f.\n     *\n     * @see JXG.Math.Numerics.chandrupatla\n     * @see JXG.Math.Numerics.fzero\n     * @memberof JXG.Math.Numerics\n     */\n    root: function (f, x, context) {\n        //return this.fzero(f, x, context);\n        return this.chandrupatla(f, x, context);\n    },\n\n    /**\n     * Compute an intersection of the curves c1 and c2\n     * with a generalized Newton method.\n     * We want to find values t1, t2 such that\n     * c1(t1) = c2(t2), i.e.\n     * (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).\n     * We set\n     * (e,f) := (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2))\n     *\n     * The Jacobian J is defined by\n     * J = (a, b)\n     *     (c, d)\n     * where\n     * a = c1_x'(t1)\n     * b = -c2_x'(t2)\n     * c = c1_y'(t1)\n     * d = -c2_y'(t2)\n     *\n     * The inverse J^(-1) of J is equal to\n     *  (d, -b)/\n     *  (-c, a) / (ad-bc)\n     *\n     * Then, (t1new, t2new) := (t1,t2) - J^(-1)*(e,f).\n     * If the function meetCurveCurve possesses the properties\n     * t1memo and t2memo then these are taken as start values\n     * for the Newton algorithm.\n     * After stopping of the Newton algorithm the values of t1 and t2 are stored in\n     * t1memo and t2memo.\n     *\n     * @param {JXG.Curve} c1 Curve, Line or Circle\n     * @param {JXG.Curve} c2 Curve, Line or Circle\n     * @param {Number} t1ini start value for t1\n     * @param {Number} t2ini start value for t2\n     * @returns {JXG.Coords} intersection point\n     * @memberof JXG.Math.Numerics\n     */\n    generalizedNewton: function (c1, c2, t1ini, t2ini) {\n        var t1,\n            t2,\n            a,\n            b,\n            c,\n            d,\n            disc,\n            e,\n            f,\n            F,\n            D00,\n            D01,\n            D10,\n            D11,\n            count = 0;\n\n        if (this.generalizedNewton.t1memo) {\n            t1 = this.generalizedNewton.t1memo;\n            t2 = this.generalizedNewton.t2memo;\n        } else {\n            t1 = t1ini;\n            t2 = t2ini;\n        }\n\n        e = c1.X(t1) - c2.X(t2);\n        f = c1.Y(t1) - c2.Y(t2);\n        F = e * e + f * f;\n\n        D00 = this.D(c1.X, c1);\n        D01 = this.D(c2.X, c2);\n        D10 = this.D(c1.Y, c1);\n        D11 = this.D(c2.Y, c2);\n\n        while (F > Mat.eps && count < 10) {\n            a = D00(t1);\n            b = -D01(t2);\n            c = D10(t1);\n            d = -D11(t2);\n            disc = a * d - b * c;\n            t1 -= (d * e - b * f) / disc;\n            t2 -= (a * f - c * e) / disc;\n            e = c1.X(t1) - c2.X(t2);\n            f = c1.Y(t1) - c2.Y(t2);\n            F = e * e + f * f;\n            count += 1;\n        }\n\n        this.generalizedNewton.t1memo = t1;\n        this.generalizedNewton.t2memo = t2;\n\n        if (Math.abs(t1) < Math.abs(t2)) {\n            return [c1.X(t1), c1.Y(t1)];\n        }\n\n        return [c2.X(t2), c2.Y(t2)];\n    },\n\n    /**\n     * Returns the Lagrange polynomials for curves with equidistant nodes, see\n     * Jean-Paul Berrut, Lloyd N. Trefethen: Barycentric Lagrange Interpolation,\n     * SIAM Review, Vol 46, No 3, (2004) 501-517.\n     * The graph of the parametric curve [x(t),y(t)] runs through the given points.\n     * @param {Array} p Array of JXG.Points\n     * @returns {Array} An array consisting of two functions x(t), y(t) which define a parametric curve\n     * f(t) = (x(t), y(t)), a number x1 (which equals 0) and a function x2 defining the curve's domain.\n     * That means the curve is defined between x1 and x2(). x2 returns the (length of array p minus one).\n     * @memberof JXG.Math.Numerics\n     *\n     * @example\n     * var p = [];\n     *\n     * p[0] = board.create('point', [0, -2], {size:2, name: 'C(a)'});\n     * p[1] = board.create('point', [-1.5, 5], {size:2, name: ''});\n     * p[2] = board.create('point', [1, 4], {size:2, name: ''});\n     * p[3] = board.create('point', [3, 3], {size:2, name: 'C(b)'});\n     *\n     * // Curve\n     * var fg = JXG.Math.Numerics.Neville(p);\n     * var graph = board.create('curve', fg, {strokeWidth:3, strokeOpacity:0.5});\n     *\n     * </pre><div id=\"JXG88a8b3a8-6561-44f5-a678-76bca13fd484\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG88a8b3a8-6561-44f5-a678-76bca13fd484',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var p = [];\n     *\n     *     p[0] = board.create('point', [0, -2], {size:2, name: 'C(a)'});\n     *     p[1] = board.create('point', [-1.5, 5], {size:2, name: ''});\n     *     p[2] = board.create('point', [1, 4], {size:2, name: ''});\n     *     p[3] = board.create('point', [3, 3], {size:2, name: 'C(b)'});\n     *\n     *     // Curve\n     *     var fg = JXG.Math.Numerics.Neville(p);\n     *     var graph = board.create('curve', fg, {strokeWidth:3, strokeOpacity:0.5});\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    Neville: function (p) {\n        var w = [],\n            /** @ignore */\n            makeFct = function (fun) {\n                return function (t, suspendedUpdate) {\n                    var i,\n                        d,\n                        s,\n                        bin = Mat.binomial,\n                        len = p.length,\n                        len1 = len - 1,\n                        num = 0.0,\n                        denom = 0.0;\n\n                    if (!suspendedUpdate) {\n                        s = 1;\n                        for (i = 0; i < len; i++) {\n                            w[i] = bin(len1, i) * s;\n                            s *= -1;\n                        }\n                    }\n\n                    d = t;\n\n                    for (i = 0; i < len; i++) {\n                        if (d === 0) {\n                            return p[i][fun]();\n                        }\n                        s = w[i] / d;\n                        d -= 1;\n                        num += p[i][fun]() * s;\n                        denom += s;\n                    }\n                    return num / denom;\n                };\n            },\n            xfct = makeFct(\"X\"),\n            yfct = makeFct(\"Y\");\n\n        return [\n            xfct,\n            yfct,\n            0,\n            function () {\n                return p.length - 1;\n            }\n        ];\n    },\n\n    /**\n     * Calculates second derivatives at the given knots.\n     * @param {Array} x x values of knots\n     * @param {Array} y y values of knots\n     * @returns {Array} Second derivatives of the interpolated function at the knots.\n     * @see #splineEval\n     * @memberof JXG.Math.Numerics\n     */\n    splineDef: function (x, y) {\n        var pair,\n            i,\n            l,\n            n = Math.min(x.length, y.length),\n            diag = [],\n            z = [],\n            data = [],\n            dx = [],\n            delta = [],\n            F = [];\n\n        if (n === 2) {\n            return [0, 0];\n        }\n\n        for (i = 0; i < n; i++) {\n            pair = { X: x[i], Y: y[i] };\n            data.push(pair);\n        }\n        data.sort(function (a, b) {\n            return a.X - b.X;\n        });\n        for (i = 0; i < n; i++) {\n            x[i] = data[i].X;\n            y[i] = data[i].Y;\n        }\n\n        for (i = 0; i < n - 1; i++) {\n            dx.push(x[i + 1] - x[i]);\n        }\n        for (i = 0; i < n - 2; i++) {\n            delta.push(\n                (6 * (y[i + 2] - y[i + 1])) / dx[i + 1] - (6 * (y[i + 1] - y[i])) / dx[i]\n            );\n        }\n\n        // ForwardSolve\n        diag.push(2 * (dx[0] + dx[1]));\n        z.push(delta[0]);\n\n        for (i = 0; i < n - 3; i++) {\n            l = dx[i + 1] / diag[i];\n            diag.push(2 * (dx[i + 1] + dx[i + 2]) - l * dx[i + 1]);\n            z.push(delta[i + 1] - l * z[i]);\n        }\n\n        // BackwardSolve\n        F[n - 3] = z[n - 3] / diag[n - 3];\n        for (i = n - 4; i >= 0; i--) {\n            F[i] = (z[i] - dx[i + 1] * F[i + 1]) / diag[i];\n        }\n\n        // Generate f''-Vector\n        for (i = n - 3; i >= 0; i--) {\n            F[i + 1] = F[i];\n        }\n\n        // natural cubic spline\n        F[0] = 0;\n        F[n - 1] = 0;\n\n        return F;\n    },\n\n    /**\n     * Evaluate points on spline.\n     * @param {Number,Array} x0 A single float value or an array of values to evaluate\n     * @param {Array} x x values of knots\n     * @param {Array} y y values of knots\n     * @param {Array} F Second derivatives at knots, calculated by {@link JXG.Math.Numerics.splineDef}\n     * @see #splineDef\n     * @returns {Number,Array} A single value or an array, depending on what is given as x0.\n     * @memberof JXG.Math.Numerics\n     */\n    splineEval: function (x0, x, y, F) {\n        var i,\n            j,\n            a,\n            b,\n            c,\n            d,\n            x_,\n            n = Math.min(x.length, y.length),\n            l = 1,\n            asArray = false,\n            y0 = [];\n\n        // number of points to be evaluated\n        if (Type.isArray(x0)) {\n            l = x0.length;\n            asArray = true;\n        } else {\n            x0 = [x0];\n        }\n\n        for (i = 0; i < l; i++) {\n            // is x0 in defining interval?\n            if (x0[i] < x[0] || x[i] > x[n - 1]) {\n                return NaN;\n            }\n\n            // determine part of spline in which x0 lies\n            for (j = 1; j < n; j++) {\n                if (x0[i] <= x[j]) {\n                    break;\n                }\n            }\n\n            j -= 1;\n\n            // we're now in the j-th partial interval, i.e. x[j] < x0[i] <= x[j+1];\n            // determine the coefficients of the polynomial in this interval\n            a = y[j];\n            b =\n                (y[j + 1] - y[j]) / (x[j + 1] - x[j]) -\n                ((x[j + 1] - x[j]) / 6) * (F[j + 1] + 2 * F[j]);\n            c = F[j] / 2;\n            d = (F[j + 1] - F[j]) / (6 * (x[j + 1] - x[j]));\n            // evaluate x0[i]\n            x_ = x0[i] - x[j];\n            //y0.push(a + b*x_ + c*x_*x_ + d*x_*x_*x_);\n            y0.push(a + (b + (c + d * x_) * x_) * x_);\n        }\n\n        if (asArray) {\n            return y0;\n        }\n\n        return y0[0];\n    },\n\n    /**\n     * Generate a string containing the function term of a polynomial.\n     * @param {Array} coeffs Coefficients of the polynomial. The position i belongs to x^i.\n     * @param {Number} deg Degree of the polynomial\n     * @param {String} varname Name of the variable (usually 'x')\n     * @param {Number} prec Precision\n     * @returns {String} A string containg the function term of the polynomial.\n     * @memberof JXG.Math.Numerics\n     */\n    generatePolynomialTerm: function (coeffs, deg, varname, prec) {\n        var i,\n            t = [];\n\n        for (i = deg; i >= 0; i--) {\n            t = t.concat([\"(\", coeffs[i].toPrecision(prec), \")\"]);\n\n            if (i > 1) {\n                t = t.concat([\"*\", varname, \"<sup>\", i, \"<\", \"/sup> + \"]);\n            } else if (i === 1) {\n                t = t.concat([\"*\", varname, \" + \"]);\n            }\n        }\n\n        return t.join(\"\");\n    },\n\n    /**\n     * Computes the polynomial through a given set of coordinates in Lagrange form.\n     * Returns the Lagrange polynomials, see\n     * Jean-Paul Berrut, Lloyd N. Trefethen: Barycentric Lagrange Interpolation,\n     * SIAM Review, Vol 46, No 3, (2004) 501-517.\n     * <p>\n     * It possesses the method getTerm() which returns the string containing the function term of the polynomial.\n     * @param {Array} p Array of JXG.Points\n     * @returns {function} A function of one parameter which returns the value of the polynomial, whose graph runs through the given points.\n     * @memberof JXG.Math.Numerics\n     *\n     * @example\n     * var p = [];\n     * p[0] = board.create('point', [-1,2], {size:4});\n     * p[1] = board.create('point', [0,3], {size:4});\n     * p[2] = board.create('point', [1,1], {size:4});\n     * p[3] = board.create('point', [3,-1], {size:4});\n     * var f = JXG.Math.Numerics.lagrangePolynomial(p);\n     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});\n     *\n     * </pre><div id=\"JXGc058aa6b-74d4-41e1-af94-df06169a2d89\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXGc058aa6b-74d4-41e1-af94-df06169a2d89',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var p = [];\n     *     p[0] = board.create('point', [-1,2], {size:4});\n     *     p[1] = board.create('point', [0,3], {size:4});\n     *     p[2] = board.create('point', [1,1], {size:4});\n     *     p[3] = board.create('point', [3,-1], {size:4});\n     *     var f = JXG.Math.Numerics.lagrangePolynomial(p);\n     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     * @example\n     * var points = [];\n     * points[0] = board.create('point', [-1,2], {size:4});\n     * points[1] = board.create('point', [0, 0], {size:4});\n     * points[2] = board.create('point', [2, 1], {size:4});\n     *\n     * var f = JXG.Math.Numerics.lagrangePolynomial(points);\n     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});\n     * var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});\n     *\n     * </pre><div id=\"JXG73fdaf12-e257-4374-b488-ae063e4eecbb\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG73fdaf12-e257-4374-b488-ae063e4eecbb',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var points = [];\n     *     points[0] = board.create('point', [-1,2], {size:4});\n     *     points[1] = board.create('point', [0, 0], {size:4});\n     *     points[2] = board.create('point', [2, 1], {size:4});\n     *\n     *     var f = JXG.Math.Numerics.lagrangePolynomial(points);\n     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});\n     *     var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    lagrangePolynomial: function (p) {\n        var w = [],\n            that = this,\n            /** @ignore */\n            fct = function (x, suspendedUpdate) {\n                var i, // j,\n                    k,\n                    xi,\n                    s, //M,\n                    len = p.length,\n                    num = 0,\n                    denom = 0;\n\n                if (!suspendedUpdate) {\n                    for (i = 0; i < len; i++) {\n                        w[i] = 1.0;\n                        xi = p[i].X();\n\n                        for (k = 0; k < len; k++) {\n                            if (k !== i) {\n                                w[i] *= xi - p[k].X();\n                            }\n                        }\n\n                        w[i] = 1 / w[i];\n                    }\n\n                    // M = [];\n                    // for (k = 0; k < len; k++) {\n                    //     M.push([1]);\n                    // }\n                }\n\n                for (i = 0; i < len; i++) {\n                    xi = p[i].X();\n\n                    if (x === xi) {\n                        return p[i].Y();\n                    }\n\n                    s = w[i] / (x - xi);\n                    denom += s;\n                    num += s * p[i].Y();\n                }\n\n                return num / denom;\n            };\n\n        /**\n         * Get the term of the Lagrange polynomial as string.\n         * Calls {@link JXG.Math.Numerics#lagrangePolynomialTerm}.\n         *\n         * @name JXG.Math.Numerics#lagrangePolynomial.getTerm\n         * @param {Number} digits Number of digits of the coefficients\n         * @param {String} param Variable name\n         * @param {String} dot Dot symbol\n         * @returns {String} containing the term of Lagrange polynomial as string.\n         * @see JXG.Math.Numerics#lagrangePolynomialTerm\n         * @example\n         * var points = [];\n         * points[0] = board.create('point', [-1,2], {size:4});\n         * points[1] = board.create('point', [0, 0], {size:4});\n         * points[2] = board.create('point', [2, 1], {size:4});\n         *\n         * var f = JXG.Math.Numerics.lagrangePolynomial(points);\n         * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});\n         * var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});\n         *\n         * </pre><div id=\"JXG73fdaf12-e257-4374-b488-ae063e4eeccf\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG73fdaf12-e257-4374-b488-ae063e4eeccf',\n         *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n         *     var points = [];\n         *     points[0] = board.create('point', [-1,2], {size:4});\n         *     points[1] = board.create('point', [0, 0], {size:4});\n         *     points[2] = board.create('point', [2, 1], {size:4});\n         *\n         *     var f = JXG.Math.Numerics.lagrangePolynomial(points);\n         *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});\n         *     var txt = board.create('text', [-3, -4,  () => f.getTerm(2, 't', ' * ')], {fontSize: 16});\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        fct.getTerm = function (digits, param, dot) {\n            return that.lagrangePolynomialTerm(p, digits, param, dot)();\n        };\n\n        return fct;\n    },\n    // fct.getTerm = that.lagrangePolynomialTerm(p, 2, 'x');\n\n    /**\n     * Determine the Lagrange polynomial through an array of points and\n     * return the term of the polynomial as string.\n     *\n     * @param {Array} points Array of JXG.Points\n     * @param {Number} digits Number of decimal digits of the coefficients\n     * @param {String} param Name of the parameter. Default: 'x'.\n     * @param {String} dot Multiplication symbol. Default: ' * '.\n     * @returns {Function} returning the Lagrange polynomial through\n     *    the supplied points.\n     * @memberof JXG.Math.Numerics\n     *\n     * @example\n     * var points = [];\n     * points[0] = board.create('point', [-1,2], {size:4});\n     * points[1] = board.create('point', [0, 0], {size:4});\n     * points[2] = board.create('point', [2, 1], {size:4});\n     *\n     * var f = JXG.Math.Numerics.lagrangePolynomial(points);\n     * var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});\n     *\n     * var f_txt = JXG.Math.Numerics.lagrangePolynomialTerm(points, 2, 't', ' * ');\n     * var txt = board.create('text', [-3, -4, f_txt], {fontSize: 16});\n     *\n     * </pre><div id=\"JXGd45e9e96-7526-486d-aa43-e1178d5f2baa\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXGd45e9e96-7526-486d-aa43-e1178d5f2baa',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var points = [];\n     *     points[0] = board.create('point', [-1,2], {size:4});\n     *     points[1] = board.create('point', [0, 0], {size:4});\n     *     points[2] = board.create('point', [2, 1], {size:4});\n     *\n     *     var f = JXG.Math.Numerics.lagrangePolynomial(points);\n     *     var graph = board.create('functiongraph', [f,-10, 10], {strokeWidth:3});\n     *\n     *     var f_txt = JXG.Math.Numerics.lagrangePolynomialTerm(points, 2, 't', ' * ');\n     *     var txt = board.create('text', [-3, -4, f_txt], {fontSize: 16});\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    lagrangePolynomialTerm: function (points, digits, param, dot) {\n        return function () {\n            var len = points.length,\n                zeroes = [],\n                coeffs = [],\n                coeffs_sum = [],\n                isLeading = true,\n                n,\n                t,\n                i,\n                j,\n                c,\n                p;\n\n            param = param || \"x\";\n            if (dot === undefined) {\n                dot = \" * \";\n            }\n\n            n = len - 1; // (Max) degree of the polynomial\n            for (j = 0; j < len; j++) {\n                coeffs_sum[j] = 0;\n            }\n\n            for (i = 0; i < len; i++) {\n                c = points[i].Y();\n                p = points[i].X();\n                zeroes = [];\n                for (j = 0; j < len; j++) {\n                    if (j !== i) {\n                        c /= p - points[j].X();\n                        zeroes.push(points[j].X());\n                    }\n                }\n                coeffs = [1].concat(Mat.Vieta(zeroes));\n                for (j = 0; j < coeffs.length; j++) {\n                    coeffs_sum[j] += (j % 2 === 1 ? -1 : 1) * coeffs[j] * c;\n                }\n            }\n\n            t = \"\";\n            for (j = 0; j < coeffs_sum.length; j++) {\n                c = coeffs_sum[j];\n                if (Math.abs(c) < Mat.eps) {\n                    continue;\n                }\n                if (JXG.exists(digits)) {\n                    c = Env._round10(c, -digits);\n                }\n                if (isLeading) {\n                    t += c > 0 ? c : \"-\" + -c;\n                    isLeading = false;\n                } else {\n                    t += c > 0 ? \" + \" + c : \" - \" + -c;\n                }\n\n                if (n - j > 1) {\n                    t += dot + param + \"^\" + (n - j);\n                } else if (n - j === 1) {\n                    t += dot + param;\n                }\n            }\n            return t; // board.jc.manipulate('f = map(x) -> ' + t + ';');\n        };\n    },\n\n    /**\n     * Determine the coefficients of a cardinal spline polynom, See\n     * http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections\n     * @param  {Number} x1 point 1\n     * @param  {Number} x2 point 2\n     * @param  {Number} t1 tangent slope 1\n     * @param  {Number} t2 tangent slope 2\n     * @return {Array}    coefficents array c for the polynomial t maps to\n     * c[0] + c[1]*t + c[2]*t*t + c[3]*t*t*t\n     */\n    _initCubicPoly: function (x1, x2, t1, t2) {\n        return [x1, t1, -3 * x1 + 3 * x2 - 2 * t1 - t2, 2 * x1 - 2 * x2 + t1 + t2];\n    },\n\n    /**\n     * Computes the cubic cardinal spline curve through a given set of points. The curve\n     * is uniformly parametrized.\n     * Two artificial control points at the beginning and the end are added.\n     *\n     * The implementation (especially  the centripetal parametrization) is from\n     * http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections .\n     * @param {Array} points Array consisting of JXG.Points.\n     * @param {Number|Function} tau The tension parameter, either a constant number or a function returning a number. This number is between 0 and 1.\n     * tau=1/2 give Catmull-Rom splines.\n     * @param {String} type (Optional) parameter which allows to choose between \"uniform\" (default) and\n     * \"centripetal\" parameterization. Thus the two possible values are \"uniform\" or \"centripetal\".\n     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t\n     * which return the x resp. y coordinates of the Catmull-Rom-spline curve in t, a zero value,\n     * and a function simply returning the length of the points array\n     * minus three.\n     * @memberof JXG.Math.Numerics\n     */\n    CardinalSpline: function (points, tau_param, type) {\n        var p,\n            coeffs = [],\n            makeFct,\n            tau,\n            _tau,\n            that = this;\n\n        if (Type.isFunction(tau_param)) {\n            _tau = tau_param;\n        } else {\n            _tau = function () {\n                return tau_param;\n            };\n        }\n\n        if (type === undefined) {\n            type = \"uniform\";\n        }\n\n        /** @ignore */\n        makeFct = function (which) {\n            return function (t, suspendedUpdate) {\n                var s,\n                    c,\n                    // control point at the beginning and at the end\n                    first,\n                    last,\n                    t1,\n                    t2,\n                    dt0,\n                    dt1,\n                    dt2,\n                    // dx, dy,\n                    len;\n\n                if (points.length < 2) {\n                    return NaN;\n                }\n\n                if (!suspendedUpdate) {\n                    tau = _tau();\n\n                    // New point list p: [first, points ..., last]\n                    first = {\n                        X: function () {\n                            return 2 * points[0].X() - points[1].X();\n                        },\n                        Y: function () {\n                            return 2 * points[0].Y() - points[1].Y();\n                        },\n                        Dist: function (p) {\n                            var dx = this.X() - p.X(),\n                                dy = this.Y() - p.Y();\n                            return Math.sqrt(dx * dx + dy * dy);\n                        }\n                    };\n\n                    last = {\n                        X: function () {\n                            return (\n                                2 * points[points.length - 1].X() -\n                                points[points.length - 2].X()\n                            );\n                        },\n                        Y: function () {\n                            return (\n                                2 * points[points.length - 1].Y() -\n                                points[points.length - 2].Y()\n                            );\n                        },\n                        Dist: function (p) {\n                            var dx = this.X() - p.X(),\n                                dy = this.Y() - p.Y();\n                            return Math.sqrt(dx * dx + dy * dy);\n                        }\n                    };\n\n                    p = [first].concat(points, [last]);\n                    len = p.length;\n\n                    coeffs[which] = [];\n\n                    for (s = 0; s < len - 3; s++) {\n                        if (type === \"centripetal\") {\n                            // The order is important, since p[0].coords === undefined\n                            dt0 = p[s].Dist(p[s + 1]);\n                            dt1 = p[s + 2].Dist(p[s + 1]);\n                            dt2 = p[s + 3].Dist(p[s + 2]);\n\n                            dt0 = Math.sqrt(dt0);\n                            dt1 = Math.sqrt(dt1);\n                            dt2 = Math.sqrt(dt2);\n\n                            if (dt1 < Mat.eps) {\n                                dt1 = 1.0;\n                            }\n                            if (dt0 < Mat.eps) {\n                                dt0 = dt1;\n                            }\n                            if (dt2 < Mat.eps) {\n                                dt2 = dt1;\n                            }\n\n                            t1 =\n                                (p[s + 1][which]() - p[s][which]()) / dt0 -\n                                (p[s + 2][which]() - p[s][which]()) / (dt1 + dt0) +\n                                (p[s + 2][which]() - p[s + 1][which]()) / dt1;\n\n                            t2 =\n                                (p[s + 2][which]() - p[s + 1][which]()) / dt1 -\n                                (p[s + 3][which]() - p[s + 1][which]()) / (dt2 + dt1) +\n                                (p[s + 3][which]() - p[s + 2][which]()) / dt2;\n\n                            t1 *= dt1;\n                            t2 *= dt1;\n\n                            coeffs[which][s] = that._initCubicPoly(\n                                p[s + 1][which](),\n                                p[s + 2][which](),\n                                tau * t1,\n                                tau * t2\n                            );\n                        } else {\n                            coeffs[which][s] = that._initCubicPoly(\n                                p[s + 1][which](),\n                                p[s + 2][which](),\n                                tau * (p[s + 2][which]() - p[s][which]()),\n                                tau * (p[s + 3][which]() - p[s + 1][which]())\n                            );\n                        }\n                    }\n                }\n\n                if (isNaN(t)) {\n                    return NaN;\n                }\n\n                len = points.length;\n                // This is necessary for our advanced plotting algorithm:\n                if (t <= 0.0) {\n                    return points[0][which]();\n                }\n                if (t >= len) {\n                    return points[len - 1][which]();\n                }\n\n                s = Math.floor(t);\n                if (s === t) {\n                    return points[s][which]();\n                }\n\n                t -= s;\n                c = coeffs[which][s];\n                if (c === undefined) {\n                    return NaN;\n                }\n\n                return ((c[3] * t + c[2]) * t + c[1]) * t + c[0];\n            };\n        };\n\n        return [\n            makeFct(\"X\"),\n            makeFct(\"Y\"),\n            0,\n            function () {\n                return points.length - 1;\n            }\n        ];\n    },\n\n    /**\n     * Computes the cubic Catmull-Rom spline curve through a given set of points. The curve\n     * is uniformly parametrized. The curve is the cardinal spline curve for tau=0.5.\n     * Two artificial control points at the beginning and the end are added.\n     * @param {Array} points Array consisting of JXG.Points.\n     * @param {String} type (Optional) parameter which allows to choose between \"uniform\" (default) and\n     * \"centripetal\" parameterization. Thus the two possible values are \"uniform\" or \"centripetal\".\n     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t\n     * which return the x resp. y coordinates of the Catmull-Rom-spline curve in t, a zero value, and a function simply\n     * returning the length of the points array minus three.\n     * @memberof JXG.Math.Numerics\n     */\n    CatmullRomSpline: function (points, type) {\n        return this.CardinalSpline(points, 0.5, type);\n    },\n\n    /**\n     * Computes the regression polynomial of a given degree through a given set of coordinates.\n     * Returns the regression polynomial function.\n     * @param {Number,function,Slider} degree number, function or slider.\n     * Either\n     * @param {Array} dataX Array containing either the x-coordinates of the data set or both coordinates in\n     * an array of {@link JXG.Point}s or {@link JXG.Coords}.\n     * In the latter case, the <tt>dataY</tt> parameter will be ignored.\n     * @param {Array} dataY Array containing the y-coordinates of the data set,\n     * @returns {function} A function of one parameter which returns the value of the regression polynomial of the given degree.\n     * It possesses the method getTerm() which returns the string containing the function term of the polynomial.\n     * @memberof JXG.Math.Numerics\n     */\n    regressionPolynomial: function (degree, dataX, dataY) {\n        var coeffs,\n            deg,\n            dX,\n            dY,\n            inputType,\n            fct,\n            term = \"\";\n\n        // Slider\n        if (Type.isPoint(degree) && Type.isFunction(degree.Value)) {\n            /** @ignore */\n            deg = function () {\n                return degree.Value();\n            };\n            // function\n        } else if (Type.isFunction(degree)) {\n            deg = degree;\n            // number\n        } else if (Type.isNumber(degree)) {\n            /** @ignore */\n            deg = function () {\n                return degree;\n            };\n        } else {\n            throw new Error(\n                \"JSXGraph: Can't create regressionPolynomial from degree of type'\" +\n                    typeof degree +\n                    \"'.\"\n            );\n        }\n\n        // Parameters degree, dataX, dataY\n        if (arguments.length === 3 && Type.isArray(dataX) && Type.isArray(dataY)) {\n            inputType = 0;\n            // Parameters degree, point array\n        } else if (\n            arguments.length === 2 &&\n            Type.isArray(dataX) &&\n            dataX.length > 0 &&\n            Type.isPoint(dataX[0])\n        ) {\n            inputType = 1;\n        } else if (\n            arguments.length === 2 &&\n            Type.isArray(dataX) &&\n            dataX.length > 0 &&\n            dataX[0].usrCoords &&\n            dataX[0].scrCoords\n        ) {\n            inputType = 2;\n        } else {\n            throw new Error(\"JSXGraph: Can't create regressionPolynomial. Wrong parameters.\");\n        }\n\n        /** @ignore */\n        fct = function (x, suspendedUpdate) {\n            var i,\n                j,\n                M,\n                MT,\n                y,\n                B,\n                c,\n                s,\n                d,\n                // input data\n                len = dataX.length;\n\n            d = Math.floor(deg());\n\n            if (!suspendedUpdate) {\n                // point list as input\n                if (inputType === 1) {\n                    dX = [];\n                    dY = [];\n\n                    for (i = 0; i < len; i++) {\n                        dX[i] = dataX[i].X();\n                        dY[i] = dataX[i].Y();\n                    }\n                }\n\n                if (inputType === 2) {\n                    dX = [];\n                    dY = [];\n\n                    for (i = 0; i < len; i++) {\n                        dX[i] = dataX[i].usrCoords[1];\n                        dY[i] = dataX[i].usrCoords[2];\n                    }\n                }\n\n                // check for functions\n                if (inputType === 0) {\n                    dX = [];\n                    dY = [];\n\n                    for (i = 0; i < len; i++) {\n                        if (Type.isFunction(dataX[i])) {\n                            dX.push(dataX[i]());\n                        } else {\n                            dX.push(dataX[i]);\n                        }\n\n                        if (Type.isFunction(dataY[i])) {\n                            dY.push(dataY[i]());\n                        } else {\n                            dY.push(dataY[i]);\n                        }\n                    }\n                }\n\n                M = [];\n\n                for (j = 0; j < len; j++) {\n                    M.push([1]);\n                }\n\n                for (i = 1; i <= d; i++) {\n                    for (j = 0; j < len; j++) {\n                        M[j][i] = M[j][i - 1] * dX[j];\n                    }\n                }\n\n                y = dY;\n                MT = Mat.transpose(M);\n                B = Mat.matMatMult(MT, M);\n                c = Mat.matVecMult(MT, y);\n                coeffs = Mat.Numerics.Gauss(B, c);\n                term = Mat.Numerics.generatePolynomialTerm(coeffs, d, \"x\", 3);\n            }\n\n            // Horner's scheme to evaluate polynomial\n            s = coeffs[d];\n\n            for (i = d - 1; i >= 0; i--) {\n                s = s * x + coeffs[i];\n            }\n\n            return s;\n        };\n\n        fct.getTerm = function () {\n            return term;\n        };\n\n        return fct;\n    },\n\n    /**\n     * Computes the cubic Bezier curve through a given set of points.\n     * @param {Array} points Array consisting of 3*k+1 {@link JXG.Points}.\n     * The points at position k with k mod 3 = 0 are the data points,\n     * points at position k with k mod 3 = 1 or 2 are the control points.\n     * @returns {Array} An array consisting of two functions of one parameter t which return the\n     * x resp. y coordinates of the Bezier curve in t, one zero value, and a third function accepting\n     * no parameters and returning one third of the length of the points.\n     * @memberof JXG.Math.Numerics\n     */\n    bezier: function (points) {\n        var len,\n            flen,\n            /** @ignore */\n            makeFct = function (which) {\n                return function (t, suspendedUpdate) {\n                    var z = Math.floor(t) * 3,\n                        t0 = t % 1,\n                        t1 = 1 - t0;\n\n                    if (!suspendedUpdate) {\n                        flen = 3 * Math.floor((points.length - 1) / 3);\n                        len = Math.floor(flen / 3);\n                    }\n\n                    if (t < 0) {\n                        return points[0][which]();\n                    }\n\n                    if (t >= len) {\n                        return points[flen][which]();\n                    }\n\n                    if (isNaN(t)) {\n                        return NaN;\n                    }\n\n                    return (\n                        t1 * t1 * (t1 * points[z][which]() + 3 * t0 * points[z + 1][which]()) +\n                        (3 * t1 * points[z + 2][which]() + t0 * points[z + 3][which]()) *\n                            t0 *\n                            t0\n                    );\n                };\n            };\n\n        return [\n            makeFct(\"X\"),\n            makeFct(\"Y\"),\n            0,\n            function () {\n                return Math.floor(points.length / 3);\n            }\n        ];\n    },\n\n    /**\n     * Computes the B-spline curve of order k (order = degree+1) through a given set of points.\n     * @param {Array} points Array consisting of JXG.Points.\n     * @param {Number} order Order of the B-spline curve.\n     * @returns {Array} An Array consisting of four components: Two functions each of one parameter t\n     * which return the x resp. y coordinates of the B-spline curve in t, a zero value, and a function simply\n     * returning the length of the points array minus one.\n     * @memberof JXG.Math.Numerics\n     */\n    bspline: function (points, order) {\n        var knots,\n            _knotVector = function (n, k) {\n                var j,\n                    kn = [];\n\n                for (j = 0; j < n + k + 1; j++) {\n                    if (j < k) {\n                        kn[j] = 0.0;\n                    } else if (j <= n) {\n                        kn[j] = j - k + 1;\n                    } else {\n                        kn[j] = n - k + 2;\n                    }\n                }\n\n                return kn;\n            },\n            _evalBasisFuncs = function (t, kn, k, s) {\n                var i,\n                    j,\n                    a,\n                    b,\n                    den,\n                    N = [];\n\n                if (kn[s] <= t && t < kn[s + 1]) {\n                    N[s] = 1;\n                } else {\n                    N[s] = 0;\n                }\n\n                for (i = 2; i <= k; i++) {\n                    for (j = s - i + 1; j <= s; j++) {\n                        if (j <= s - i + 1 || j < 0) {\n                            a = 0.0;\n                        } else {\n                            a = N[j];\n                        }\n\n                        if (j >= s) {\n                            b = 0.0;\n                        } else {\n                            b = N[j + 1];\n                        }\n\n                        den = kn[j + i - 1] - kn[j];\n\n                        if (den === 0) {\n                            N[j] = 0;\n                        } else {\n                            N[j] = ((t - kn[j]) / den) * a;\n                        }\n\n                        den = kn[j + i] - kn[j + 1];\n\n                        if (den !== 0) {\n                            N[j] += ((kn[j + i] - t) / den) * b;\n                        }\n                    }\n                }\n                return N;\n            },\n            /** @ignore */\n            makeFct = function (which) {\n                return function (t, suspendedUpdate) {\n                    var y,\n                        j,\n                        s,\n                        N = [],\n                        len = points.length,\n                        n = len - 1,\n                        k = order;\n\n                    if (n <= 0) {\n                        return NaN;\n                    }\n\n                    if (n + 2 <= k) {\n                        k = n + 1;\n                    }\n\n                    if (t <= 0) {\n                        return points[0][which]();\n                    }\n\n                    if (t >= n - k + 2) {\n                        return points[n][which]();\n                    }\n\n                    s = Math.floor(t) + k - 1;\n                    knots = _knotVector(n, k);\n                    N = _evalBasisFuncs(t, knots, k, s);\n\n                    y = 0.0;\n                    for (j = s - k + 1; j <= s; j++) {\n                        if (j < len && j >= 0) {\n                            y += points[j][which]() * N[j];\n                        }\n                    }\n\n                    return y;\n                };\n            };\n\n        return [\n            makeFct(\"X\"),\n            makeFct(\"Y\"),\n            0,\n            function () {\n                return points.length - 1;\n            }\n        ];\n    },\n\n    /**\n     * Numerical (symmetric) approximation of derivative. suspendUpdate is piped through,\n     * see {@link JXG.Curve#updateCurve}\n     * and {@link JXG.Curve#hasPoint}.\n     * @param {function} f Function in one variable to be differentiated.\n     * @param {object} [obj] Optional object that is treated as \"this\" in the function body. This is useful, if the function is a\n     * method of an object and contains a reference to its parent object via \"this\".\n     * @returns {function} Derivative function of a given function f.\n     * @memberof JXG.Math.Numerics\n     */\n    D: function (f, obj) {\n        if (!Type.exists(obj)) {\n            return function (x, suspendedUpdate) {\n                var h = 0.00001,\n                    h2 = h * 2.0;\n\n                // Experiments with Richardsons rule\n                /*\n                    var phi = (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;\n                    var phi2;\n                    h *= 0.5;\n                    h2 *= 0.5;\n                    phi2 = (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;\n\n                    return phi2 + (phi2 - phi) / 3.0;\n                    */\n                return (f(x + h, suspendedUpdate) - f(x - h, suspendedUpdate)) / h2;\n            };\n        }\n\n        return function (x, suspendedUpdate) {\n            var h = 0.00001,\n                h2 = h * 2.0;\n\n            return (\n                (f.apply(obj, [x + h, suspendedUpdate]) -\n                    f.apply(obj, [x - h, suspendedUpdate])) /\n                h2\n            );\n        };\n    },\n\n    /**\n     * Evaluate the function term for {@see #riemann}.\n     * @private\n     * @param {Number} x function argument\n     * @param {function} f JavaScript function returning a number\n     * @param {String} type Name of the Riemann sum type, e.g. 'lower', see {@see #riemann}.\n     * @param {Number} delta Width of the bars in user coordinates\n     * @returns {Number} Upper (delta > 0) or lower (delta < 0) value of the bar containing x of the Riemann sum.\n     *\n     * @memberof JXG.Math.Numerics\n     */\n    _riemannValue: function (x, f, type, delta) {\n        var y, y1, x1, delta1;\n\n        if (delta < 0) {\n            // delta is negative if the lower function term is evaluated\n            if (type !== \"trapezoidal\") {\n                x = x + delta;\n            }\n            delta *= -1;\n            if (type === \"lower\") {\n                type = \"upper\";\n            } else if (type === \"upper\") {\n                type = \"lower\";\n            }\n        }\n\n        delta1 = delta * 0.01; // for 'lower' and 'upper'\n\n        if (type === \"right\") {\n            y = f(x + delta);\n        } else if (type === \"middle\") {\n            y = f(x + delta * 0.5);\n        } else if (type === \"left\" || type === \"trapezoidal\") {\n            y = f(x);\n        } else if (type === \"lower\") {\n            y = f(x);\n\n            for (x1 = x + delta1; x1 <= x + delta; x1 += delta1) {\n                y1 = f(x1);\n\n                if (y1 < y) {\n                    y = y1;\n                }\n            }\n\n            y1 = f(x + delta);\n            if (y1 < y) {\n                y = y1;\n            }\n        } else if (type === \"upper\") {\n            y = f(x);\n\n            for (x1 = x + delta1; x1 <= x + delta; x1 += delta1) {\n                y1 = f(x1);\n                if (y1 > y) {\n                    y = y1;\n                }\n            }\n\n            y1 = f(x + delta);\n            if (y1 > y) {\n                y = y1;\n            }\n        } else if (type === \"random\") {\n            y = f(x + delta * Math.random());\n        } else if (type === \"simpson\") {\n            y = (f(x) + 4 * f(x + delta * 0.5) + f(x + delta)) / 6.0;\n        } else {\n            y = f(x); // default is lower\n        }\n\n        return y;\n    },\n\n    /**\n     * Helper function to create curve which displays Riemann sums.\n     * Compute coordinates for the rectangles showing the Riemann sum.\n     * @param {Function,Array} f Function or array of two functions.\n     * If f is a function the integral of this function is approximated by the Riemann sum.\n     * If f is an array consisting of two functions the area between the two functions is filled\n     * by the Riemann sum bars.\n     * @param {Number} n number of rectangles.\n     * @param {String} type Type of approximation. Possible values are: 'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson', or 'trapezoidal'.\n     * @param {Number} start Left border of the approximation interval\n     * @param {Number} end Right border of the approximation interval\n     * @returns {Array} An array of two arrays containing the x and y coordinates for the rectangles showing the Riemann sum. This\n     * array may be used as parent array of a {@link JXG.Curve}. The third parameteris the riemann sum, i.e. the sum of the volumes of all\n     * rectangles.\n     * @memberof JXG.Math.Numerics\n     */\n    riemann: function (gf, n, type, start, end) {\n        var i,\n            delta,\n            xarr = [],\n            yarr = [],\n            j = 0,\n            x = start,\n            y,\n            sum = 0,\n            f,\n            g,\n            ylow,\n            yup;\n\n        if (Type.isArray(gf)) {\n            g = gf[0];\n            f = gf[1];\n        } else {\n            f = gf;\n        }\n\n        n = Math.floor(n);\n\n        if (n <= 0) {\n            return [xarr, yarr, sum];\n        }\n\n        delta = (end - start) / n;\n\n        // Upper bar ends\n        for (i = 0; i < n; i++) {\n            y = this._riemannValue(x, f, type, delta);\n            xarr[j] = x;\n            yarr[j] = y;\n\n            j += 1;\n            x += delta;\n            if (type === \"trapezoidal\") {\n                y = f(x);\n            }\n            xarr[j] = x;\n            yarr[j] = y;\n\n            j += 1;\n        }\n\n        // Lower bar ends\n        for (i = 0; i < n; i++) {\n            if (g) {\n                y = this._riemannValue(x, g, type, -delta);\n            } else {\n                y = 0.0;\n            }\n            xarr[j] = x;\n            yarr[j] = y;\n\n            j += 1;\n            x -= delta;\n            if (type === \"trapezoidal\" && g) {\n                y = g(x);\n            }\n            xarr[j] = x;\n            yarr[j] = y;\n\n            // Add the area of the bar to 'sum'\n            if (type !== \"trapezoidal\") {\n                ylow = y;\n                yup = yarr[2 * (n - 1) - 2 * i];\n            } else {\n                yup = 0.5 * (f(x + delta) + f(x));\n                if (g) {\n                    ylow = 0.5 * (g(x + delta) + g(x));\n                } else {\n                    ylow = 0.0;\n                }\n            }\n            sum += (yup - ylow) * delta;\n\n            // Draw the vertical lines\n            j += 1;\n            xarr[j] = x;\n            yarr[j] = yarr[2 * (n - 1) - 2 * i];\n\n            j += 1;\n        }\n\n        return [xarr, yarr, sum];\n    },\n\n    /**\n     * Approximate the integral by Riemann sums.\n     * Compute the area described by the riemann sum rectangles.\n     *\n     * If there is an element of type {@link Riemannsum}, then it is more efficient\n     * to use the method JXG.Curve.Value() of this element instead.\n     *\n     * @param {Function_Array} f Function or array of two functions.\n     * If f is a function the integral of this function is approximated by the Riemann sum.\n     * If f is an array consisting of two functions the area between the two functions is approximated\n     * by the Riemann sum.\n     * @param {Number} n number of rectangles.\n     * @param {String} type Type of approximation. Possible values are: 'left', 'right', 'middle', 'lower', 'upper', 'random', 'simpson' or 'trapezoidal'.\n     *\n     * @param {Number} start Left border of the approximation interval\n     * @param {Number} end Right border of the approximation interval\n     * @returns {Number} The sum of the areas of the rectangles.\n     * @memberof JXG.Math.Numerics\n     */\n    riemannsum: function (f, n, type, start, end) {\n        JXG.deprecated(\"Numerics.riemannsum()\", \"Numerics.riemann()\");\n        return this.riemann(f, n, type, start, end)[2];\n    },\n\n    /**\n     * Solve initial value problems numerically using Runge-Kutta-methods.\n     * See {@link http://en.wikipedia.org/wiki/Runge-Kutta_methods} for more information on the algorithm.\n     * @param {object,String} butcher Butcher tableau describing the Runge-Kutta method to use. This can be either a string describing\n     * a Runge-Kutta method with a Butcher tableau predefined in JSXGraph like 'euler', 'heun', 'rk4' or an object providing the structure\n     * <pre>\n     * {\n     *     s: &lt;Number&gt;,\n     *     A: &lt;matrix&gt;,\n     *     b: &lt;Array&gt;,\n     *     c: &lt;Array&gt;\n     * }\n     * </pre>\n     * which corresponds to the Butcher tableau structure shown here: http://en.wikipedia.org/w/index.php?title=List_of_Runge%E2%80%93Kutta_methods&oldid=357796696\n     * @param {Array} x0 Initial value vector. If the problem is of one-dimensional, the initial value also has to be given in an array.\n     * @param {Array} I Interval on which to integrate.\n     * @param {Number} N Number of evaluation points.\n     * @param {function} f Function describing the right hand side of the first order ordinary differential equation, i.e. if the ode\n     * is given by the equation <pre>dx/dt = f(t, x(t)).</pre> So f has to take two parameters, a number <tt>t</tt> and a\n     * vector <tt>x</tt>, and has to return a vector of the same dimension as <tt>x</tt> has.\n     * @returns {Array} An array of vectors describing the solution of the ode on the given interval I.\n     * @example\n     * // A very simple autonomous system dx(t)/dt = x(t);\n     * function f(t, x) {\n     *     return x;\n     * }\n     *\n     * // Solve it with initial value x(0) = 1 on the interval [0, 2]\n     * // with 20 evaluation points.\n     * var data = JXG.Math.Numerics.rungeKutta('heun', [1], [0, 2], 20, f);\n     *\n     * // Prepare data for plotting the solution of the ode using a curve.\n     * var dataX = [];\n     * var dataY = [];\n     * var h = 0.1;        // (I[1] - I[0])/N  = (2-0)/20\n     * for(var i=0; i&lt;data.length; i++) {\n     *     dataX[i] = i*h;\n     *     dataY[i] = data[i][0];\n     * }\n     * var g = board.create('curve', [dataX, dataY], {strokeWidth:'2px'});\n     * </pre><div class=\"jxgbox\" id=\"JXGd2432d04-4ef7-4159-a90b-a2eb8d38c4f6\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     * var board = JXG.JSXGraph.initBoard('JXGd2432d04-4ef7-4159-a90b-a2eb8d38c4f6', {boundingbox: [-1, 5, 5, -1], axis: true, showcopyright: false, shownavigation: false});\n     * function f(t, x) {\n     *     // we have to copy the value.\n     *     // return x; would just return the reference.\n     *     return [x[0]];\n     * }\n     * var data = JXG.Math.Numerics.rungeKutta('heun', [1], [0, 2], 20, f);\n     * var dataX = [];\n     * var dataY = [];\n     * var h = 0.1;\n     * for(var i=0; i<data.length; i++) {\n     *     dataX[i] = i*h;\n     *     dataY[i] = data[i][0];\n     * }\n     * var g = board.create('curve', [dataX, dataY], {strokeColor:'red', strokeWidth:'2px'});\n     * </script><pre>\n     * @memberof JXG.Math.Numerics\n     */\n    rungeKutta: function (butcher, x0, I, N, f) {\n        var e,\n            i,\n            j,\n            k,\n            l,\n            s,\n            x = [],\n            y = [],\n            h = (I[1] - I[0]) / N,\n            t = I[0],\n            dim = x0.length,\n            result = [],\n            r = 0;\n\n        if (Type.isString(butcher)) {\n            butcher = predefinedButcher[butcher] || predefinedButcher.euler;\n        }\n        s = butcher.s;\n\n        // don't change x0, so copy it\n        for (e = 0; e < dim; e++) {\n            x[e] = x0[e];\n        }\n\n        for (i = 0; i < N; i++) {\n            // Optimization doesn't work for ODEs plotted using time\n            //        if((i % quotient == 0) || (i == N-1)) {\n            result[r] = [];\n            for (e = 0; e < dim; e++) {\n                result[r][e] = x[e];\n            }\n\n            r += 1;\n            k = [];\n\n            for (j = 0; j < s; j++) {\n                // init y = 0\n                for (e = 0; e < dim; e++) {\n                    y[e] = 0.0;\n                }\n\n                // Calculate linear combination of former k's and save it in y\n                for (l = 0; l < j; l++) {\n                    for (e = 0; e < dim; e++) {\n                        y[e] += butcher.A[j][l] * h * k[l][e];\n                    }\n                }\n\n                // add x(t) to y\n                for (e = 0; e < dim; e++) {\n                    y[e] += x[e];\n                }\n\n                // calculate new k and add it to the k matrix\n                k.push(f(t + butcher.c[j] * h, y));\n            }\n\n            // init y = 0\n            for (e = 0; e < dim; e++) {\n                y[e] = 0.0;\n            }\n\n            for (l = 0; l < s; l++) {\n                for (e = 0; e < dim; e++) {\n                    y[e] += butcher.b[l] * k[l][e];\n                }\n            }\n\n            for (e = 0; e < dim; e++) {\n                x[e] = x[e] + h * y[e];\n            }\n\n            t += h;\n        }\n\n        return result;\n    },\n\n    /**\n     * Maximum number of iterations in {@link JXG.Math.Numerics.fzero} and\n     * {@link JXG.Math.Numerics.chandrupatla}\n     * @type Number\n     * @default 80\n     * @memberof JXG.Math.Numerics\n     */\n    maxIterationsRoot: 80,\n\n    /**\n     * Maximum number of iterations in {@link JXG.Math.Numerics.fminbr}\n     * @type Number\n     * @default 500\n     * @memberof JXG.Math.Numerics\n     */\n    maxIterationsMinimize: 500,\n\n    /**\n     * Given a value x_0, this function tries to find a second value x_1 such that\n     * the function f has opposite signs at x_0 and x_1.\n     * The return values have to be tested if the method succeeded.\n     *\n     * @param {Function} f Function, whose root is to be found\n     * @param {Number} x0 Start value\n     * @param {Object} object Parent object in case f is method of it\n     * @returns {Array} [x_0, f(x_0), x_1, f(x_1)]\n     *\n     * @see JXG.Math.Numerics.fzero\n     * @see JXG.Math.Numerics.chandrupatla\n     *\n     * @memberof JXG.Math.Numerics\n     */\n    findBracket: function (f, x0, object) {\n        var a, aa, fa, blist, b, fb, u, fu, i, len;\n\n        if (Type.isArray(x0)) {\n            return x0;\n        }\n\n        a = x0;\n        fa = f.call(object, a);\n        // nfev += 1;\n\n        // Try to get b, by trying several values related to a\n        aa = a === 0 ? 1 : a;\n        blist = [\n            a - 0.1 * aa,\n            a + 0.1 * aa,\n            a - 1,\n            a + 1,\n            a - 0.5 * aa,\n            a + 0.5 * aa,\n            a - 0.6 * aa,\n            a + 0.6 * aa,\n            a - 1 * aa,\n            a + 1 * aa,\n            a - 2 * aa,\n            a + 2 * aa,\n            a - 5 * aa,\n            a + 5 * aa,\n            a - 10 * aa,\n            a + 10 * aa,\n            a - 50 * aa,\n            a + 50 * aa,\n            a - 100 * aa,\n            a + 100 * aa\n        ];\n        len = blist.length;\n\n        for (i = 0; i < len; i++) {\n            b = blist[i];\n            fb = f.call(object, b);\n            // nfev += 1;\n\n            if (fa * fb <= 0) {\n                break;\n            }\n        }\n        if (b < a) {\n            u = a;\n            a = b;\n            b = u;\n\n            fu = fa;\n            fa = fb;\n            fb = fu;\n        }\n        return [a, fa, b, fb];\n    },\n\n    /**\n     *\n     * Find zero of an univariate function f.\n     * @param {function} f Function, whose root is to be found\n     * @param {Array,Number} x0  Start value or start interval enclosing the root\n     * @param {Object} object Parent object in case f is method of it\n     * @returns {Number} the approximation of the root\n     * Algorithm:\n     *  Brent's root finder from\n     *  G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical\n     *  computations. M., Mir, 1980, p.180 of the Russian edition\n     *  http://www.netlib.org/c/brent.shar\n     *\n     * If x0 is an array containing lower and upper bound for the zero\n     * algorithm 748 is applied. Otherwise, if x0 is a number,\n     * the algorithm tries to bracket a zero of f starting from x0.\n     * If this fails, we fall back to Newton's method.\n     *\n     * @see JXG.Math.Numerics.chandrupatla\n     * @see JXG.Math.Numerics.root\n     * @memberof JXG.Math.Numerics\n     */\n    fzero: function (f, x0, object) {\n        var a,\n            b,\n            c,\n            d,\n            e,\n            fa,\n            fb,\n            fc,\n            res,\n            prev_step,\n            t1,\n            cb,\n            t2,\n            // Actual tolerance\n            tol_act,\n            // Interpolation step is calculated in the form p/q; division\n            // operations is delayed until the last moment\n            p,\n            q,\n            // Step at this iteration\n            new_step,\n            eps = Mat.eps,\n            maxiter = this.maxIterationsRoot,\n            niter = 0;\n        // nfev = 0;\n\n        if (Type.isArray(x0)) {\n            if (x0.length < 2) {\n                throw new Error(\n                    \"JXG.Math.Numerics.fzero: length of array x0 has to be at least two.\"\n                );\n            }\n\n            a = x0[0];\n            fa = f.call(object, a);\n            // nfev += 1;\n            b = x0[1];\n            fb = f.call(object, b);\n            // nfev += 1;\n        } else {\n            res = this.findBracket(f, x0, object);\n            a = res[0];\n            fa = res[1];\n            b = res[2];\n            fb = res[3];\n        }\n\n        if (Math.abs(fa) <= eps) {\n            return a;\n        }\n        if (Math.abs(fb) <= eps) {\n            return b;\n        }\n\n        if (fa * fb > 0) {\n            // Bracketing not successful, fall back to Newton's method or to fminbr\n            if (Type.isArray(x0)) {\n                return this.fminbr(f, [a, b], object);\n            }\n\n            return this.Newton(f, a, object);\n        }\n\n        // OK, we have enclosed a zero of f.\n        // Now we can start Brent's method\n        c = a;\n        fc = fa;\n\n        // Main iteration loop\n        while (niter < maxiter) {\n            // Distance from the last but one to the last approximation\n            prev_step = b - a;\n\n            // Swap data for b to be the best approximation\n            if (Math.abs(fc) < Math.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n            tol_act = 2 * eps * Math.abs(b) + eps * 0.5;\n            new_step = (c - b) * 0.5;\n\n            if (Math.abs(new_step) <= tol_act || Math.abs(fb) <= eps) {\n                //  Acceptable approx. is found\n                return b;\n            }\n\n            // Decide if the interpolation can be tried\n            // If prev_step was large enough and was in true direction Interpolatiom may be tried\n            if (Math.abs(prev_step) >= tol_act && Math.abs(fa) > Math.abs(fb)) {\n                cb = c - b;\n\n                // If we have only two distinct points linear interpolation can only be applied\n                if (a === c) {\n                    t1 = fb / fa;\n                    p = cb * t1;\n                    q = 1.0 - t1;\n                    // Quadric inverse interpolation\n                } else {\n                    q = fa / fc;\n                    t1 = fb / fc;\n                    t2 = fb / fa;\n\n                    p = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\n                    q = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\n                }\n\n                // p was calculated with the opposite sign; make p positive\n                if (p > 0) {\n                    q = -q;\n                    // and assign possible minus to q\n                } else {\n                    p = -p;\n                }\n\n                // If b+p/q falls in [b,c] and isn't too large it is accepted\n                // If p/q is too large then the bissection procedure can reduce [b,c] range to more extent\n                if (\n                    p < 0.75 * cb * q - Math.abs(tol_act * q) * 0.5 &&\n                    p < Math.abs(prev_step * q * 0.5)\n                ) {\n                    new_step = p / q;\n                }\n            }\n\n            // Adjust the step to be not less than tolerance\n            if (Math.abs(new_step) < tol_act) {\n                new_step = new_step > 0 ? tol_act : -tol_act;\n            }\n\n            // Save the previous approx.\n            a = b;\n            fa = fb;\n            b += new_step;\n            fb = f.call(object, b);\n            // Do step to a new approxim.\n            // nfev += 1;\n\n            // Adjust c for it to have a sign opposite to that of b\n            if ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {\n                c = a;\n                fc = fa;\n            }\n            niter++;\n        } // End while\n\n        return b;\n    },\n\n    /**\n     * Find zero of an univariate function f.\n     * @param {function} f Function, whose root is to be found\n     * @param {Array,Number} x0  Start value or start interval enclosing the root\n     * @param {Object} object Parent object in case f is method of it\n     * @returns {Number} the approximation of the root\n     * Algorithm:\n     * Chandrupatla's method, see\n     * Tirupathi R. Chandrupatla,\n     * \"A new hybrid quadratic/bisection algorithm for finding the zero of a nonlinear function without using derivatives\",\n     * Advances in Engineering Software, Volume 28, Issue 3, April 1997, Pages 145-149.\n     *\n     * If x0 is an array containing lower and upper bound for the zero\n     * algorithm 748 is applied. Otherwise, if x0 is a number,\n     * the algorithm tries to bracket a zero of f starting from x0.\n     * If this fails, we fall back to Newton's method.\n     *\n     * @see JXG.Math.Numerics.root\n     * @see JXG.Math.Numerics.fzero\n     * @memberof JXG.Math.Numerics\n     */\n    chandrupatla: function (f, x0, object) {\n        var a,\n            fa,\n            b,\n            fb,\n            res,\n            niter = 0,\n            maxiter = this.maxIterationsRoot,\n            rand = 1 + Math.random() * 0.001,\n            t = 0.5 * rand,\n            eps = Mat.eps, // 1.e-10,\n            dlt = 0.00001,\n            x1,\n            x2,\n            x3,\n            x,\n            f1,\n            f2,\n            f3,\n            y,\n            xm,\n            fm,\n            tol,\n            tl,\n            xi,\n            ph,\n            fl,\n            fh,\n            AL,\n            A,\n            B,\n            C,\n            D;\n\n        if (Type.isArray(x0)) {\n            if (x0.length < 2) {\n                throw new Error(\n                    \"JXG.Math.Numerics.fzero: length of array x0 has to be at least two.\"\n                );\n            }\n\n            a = x0[0];\n            fa = f.call(object, a);\n            // nfev += 1;\n            b = x0[1];\n            fb = f.call(object, b);\n            // nfev += 1;\n        } else {\n            res = this.findBracket(f, x0, object);\n            a = res[0];\n            fa = res[1];\n            b = res[2];\n            fb = res[3];\n        }\n\n        if (fa * fb > 0) {\n            // Bracketing not successful, fall back to Newton's method or to fminbr\n            if (Type.isArray(x0)) {\n                return this.fminbr(f, [a, b], object);\n            }\n\n            return this.Newton(f, a, object);\n        }\n\n        x1 = a;\n        x2 = b;\n        f1 = fa;\n        f2 = fb;\n        do {\n            x = x1 + t * (x2 - x1);\n            y = f.call(object, x);\n\n            // Arrange 2-1-3: 2-1 interval, 1 middle, 3 discarded point\n            if (Math.sign(y) === Math.sign(f1)) {\n                x3 = x1;\n                x1 = x;\n                f3 = f1;\n                f1 = y;\n            } else {\n                x3 = x2;\n                x2 = x1;\n                f3 = f2;\n                f2 = f1;\n            }\n            x1 = x;\n            f1 = y;\n\n            xm = x1;\n            fm = f1;\n            if (Math.abs(f2) < Math.abs(f1)) {\n                xm = x2;\n                fm = f2;\n            }\n            tol = 2 * eps * Math.abs(xm) + 0.5 * dlt;\n            tl = tol / Math.abs(x2 - x1);\n            if (tl > 0.5 || fm === 0) {\n                break;\n            }\n            // If inverse quadratic interpolation holds, use it\n            xi = (x1 - x2) / (x3 - x2);\n            ph = (f1 - f2) / (f3 - f2);\n            fl = 1 - Math.sqrt(1 - xi);\n            fh = Math.sqrt(xi);\n            if (fl < ph && ph < fh) {\n                AL = (x3 - x1) / (x2 - x1);\n                A = f1 / (f2 - f1);\n                B = f3 / (f2 - f3);\n                C = f1 / (f3 - f1);\n                D = f2 / (f3 - f2);\n                t = A * B + C * D * AL;\n            } else {\n                t = 0.5 * rand;\n            }\n            // Adjust t away from the interval boundary\n            if (t < tl) {\n                t = tl;\n            }\n            if (t > 1 - tl) {\n                t = 1 - tl;\n            }\n            niter++;\n        } while (niter <= maxiter);\n        // console.log(niter);\n\n        return xm;\n    },\n\n    /**\n     *\n     * Find minimum of an univariate function f.\n     * <p>\n     * Algorithm:\n     *  G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical\n     *  computations. M., Mir, 1980, p.180 of the Russian edition\n     *\n     * @param {function} f Function, whose minimum is to be found\n     * @param {Array} x0  Start interval enclosing the minimum\n     * @param {Object} context Parent object in case f is method of it\n     * @returns {Number} the approximation of the minimum value position\n     * @memberof JXG.Math.Numerics\n     **/\n    fminbr: function (f, x0, context) {\n        var a,\n            b,\n            x,\n            v,\n            w,\n            fx,\n            fv,\n            fw,\n            range,\n            middle_range,\n            tol_act,\n            new_step,\n            p,\n            q,\n            t,\n            ft,\n            // Golden section ratio\n            r = (3.0 - Math.sqrt(5.0)) * 0.5,\n            tol = Mat.eps,\n            sqrteps = Mat.eps, //Math.sqrt(Mat.eps),\n            maxiter = this.maxIterationsMinimize,\n            niter = 0;\n        // nfev = 0;\n\n        if (!Type.isArray(x0) || x0.length < 2) {\n            throw new Error(\n                \"JXG.Math.Numerics.fminbr: length of array x0 has to be at least two.\"\n            );\n        }\n\n        a = x0[0];\n        b = x0[1];\n        v = a + r * (b - a);\n        fv = f.call(context, v);\n\n        // First step - always gold section\n        // nfev += 1;\n        x = v;\n        w = v;\n        fx = fv;\n        fw = fv;\n\n        while (niter < maxiter) {\n            // Range over the interval in which we are looking for the minimum\n            range = b - a;\n            middle_range = (a + b) * 0.5;\n\n            // Actual tolerance\n            tol_act = sqrteps * Math.abs(x) + tol / 3.0;\n\n            if (Math.abs(x - middle_range) + range * 0.5 <= 2.0 * tol_act) {\n                // Acceptable approx. is found\n                return x;\n            }\n\n            // Obtain the golden section step\n            new_step = r * (x < middle_range ? b - x : a - x);\n\n            // Decide if the interpolation can be tried. If x and w are distinct interpolatiom may be tried\n            if (Math.abs(x - w) >= tol_act) {\n                // Interpolation step is calculated as p/q;\n                // division operation is delayed until last moment\n                t = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * t;\n                q = 2 * (q - t);\n\n                if (q > 0) {\n                    // q was calculated with the op-\n                    p = -p; // posite sign; make q positive\n                } else {\n                    // and assign possible minus to\n                    q = -q; // p\n                }\n                if (\n                    Math.abs(p) < Math.abs(new_step * q) && // If x+p/q falls in [a,b]\n                    p > q * (a - x + 2 * tol_act) && //  not too close to a and\n                    p < q * (b - x - 2 * tol_act)\n                ) {\n                    // b, and isn't too large\n                    new_step = p / q; // it is accepted\n                }\n                // If p/q is too large then the\n                // golden section procedure can\n                // reduce [a,b] range to more\n                // extent\n            }\n\n            // Adjust the step to be not less than tolerance\n            if (Math.abs(new_step) < tol_act) {\n                if (new_step > 0) {\n                    new_step = tol_act;\n                } else {\n                    new_step = -tol_act;\n                }\n            }\n\n            // Obtain the next approximation to min\n            // and reduce the enveloping range\n\n            // Tentative point for the min\n            t = x + new_step;\n            ft = f.call(context, t);\n            // nfev += 1;\n\n            // t is a better approximation\n            if (ft <= fx) {\n                // Reduce the range so that t would fall within it\n                if (t < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n\n                // Assign the best approx to x\n                v = w;\n                w = x;\n                x = t;\n\n                fv = fw;\n                fw = fx;\n                fx = ft;\n                // x remains the better approx\n            } else {\n                // Reduce the range enclosing x\n                if (t < x) {\n                    a = t;\n                } else {\n                    b = t;\n                }\n\n                if (ft <= fw || w === x) {\n                    v = w;\n                    w = t;\n                    fv = fw;\n                    fw = ft;\n                } else if (ft <= fv || v === x || v === w) {\n                    v = t;\n                    fv = ft;\n                }\n            }\n            niter += 1;\n        }\n\n        return x;\n    },\n\n    /**\n     * Implements the Ramer-Douglas-Peucker algorithm.\n     * It discards points which are not necessary from the polygonal line defined by the point array\n     * pts. The computation is done in screen coordinates.\n     * Average runtime is O(nlog(n)), worst case runtime is O(n^2), where n is the number of points.\n     * @param {Array} pts Array of {@link JXG.Coords}\n     * @param {Number} eps If the absolute value of a given number <tt>x</tt> is smaller than <tt>eps</tt> it is considered to be equal <tt>0</tt>.\n     * @returns {Array} An array containing points which represent an apparently identical curve as the points of pts do, but contains fewer points.\n     * @memberof JXG.Math.Numerics\n     */\n    RamerDouglasPeucker: function (pts, eps) {\n        var allPts = [],\n            newPts = [],\n            i, k, len,\n            endless = true,\n\n            /**\n             * findSplit() is a subroutine of {@link JXG.Math.Numerics.RamerDouglasPeucker}.\n             * It searches for the point between index i and j which\n             * has the largest distance from the line between the points i and j.\n             * @param {Array} pts Array of {@link JXG.Coords}\n             * @param {Number} i Index of a point in pts\n             * @param {Number} j Index of a point in pts\n             * @ignore\n             * @private\n             */\n            findSplit = function (pts, i, j) {\n                var d, k, ci, cj, ck,\n                    x0, y0, x1, y1,\n                    den, lbda,\n                    huge = 10000,\n                    dist = 0,\n                    f = i;\n\n                if (j - i < 2) {\n                    return [-1.0, 0];\n                }\n\n                ci = pts[i].scrCoords;\n                cj = pts[j].scrCoords;\n\n                if (isNaN(ci[1]) || isNaN(ci[2])) {\n                    return [NaN, i];\n                }\n                if (isNaN(cj[1]) || isNaN(cj[2])) {\n                    return [NaN, j];\n                }\n\n                for (k = i + 1; k < j; k++) {\n                    ck = pts[k].scrCoords;\n                    if (isNaN(ck[1]) || isNaN(ck[2])) {\n                        return [NaN, k];\n                    }\n\n                    x0 = ck[1] - ci[1];\n                    y0 = ck[2] - ci[2];\n                    x1 = cj[1] - ci[1];\n                    y1 = cj[2] - ci[2];\n                    x0 = x0 === Infinity ? huge : x0;\n                    y0 = y0 === Infinity ? huge : y0;\n                    x1 = x1 === Infinity ? huge : x1;\n                    y1 = y1 === Infinity ? huge : y1;\n                    x0 = x0 === -Infinity ? -huge : x0;\n                    y0 = y0 === -Infinity ? -huge : y0;\n                    x1 = x1 === -Infinity ? -huge : x1;\n                    y1 = y1 === -Infinity ? -huge : y1;\n                    den = x1 * x1 + y1 * y1;\n\n                    if (den >= Mat.eps) {\n                        lbda = (x0 * x1 + y0 * y1) / den;\n\n                        if (lbda < 0.0) {\n                            lbda = 0.0;\n                        } else if (lbda > 1.0) {\n                            lbda = 1.0;\n                        }\n\n                        x0 = x0 - lbda * x1;\n                        y0 = y0 - lbda * y1;\n                        d = x0 * x0 + y0 * y0;\n                    } else {\n                        lbda = 0.0;\n                        d = x0 * x0 + y0 * y0;\n                    }\n\n                    if (d > dist) {\n                        dist = d;\n                        f = k;\n                    }\n                }\n                return [Math.sqrt(dist), f];\n            },\n            /**\n             * RDP() is a private subroutine of {@link JXG.Math.Numerics.RamerDouglasPeucker}.\n             * It runs recursively through the point set and searches the\n             * point which has the largest distance from the line between the first point and\n             * the last point. If the distance from the line is greater than eps, this point is\n             * included in our new point set otherwise it is discarded.\n             * If it is taken, we recursively apply the subroutine to the point set before\n             * and after the chosen point.\n             * @param {Array} pts Array of {@link JXG.Coords}\n             * @param {Number} i Index of an element of pts\n             * @param {Number} j Index of an element of pts\n             * @param {Number} eps If the absolute value of a given number <tt>x</tt> is smaller than <tt>eps</tt> it is considered to be equal <tt>0</tt>.\n             * @param {Array} newPts Array of {@link JXG.Coords}\n             * @ignore\n             * @private\n             */\n            RDP = function (pts, i, j, eps, newPts) {\n                var result = findSplit(pts, i, j),\n                    k = result[1];\n\n                if (isNaN(result[0])) {\n                    RDP(pts, i, k - 1, eps, newPts);\n                    newPts.push(pts[k]);\n                    do {\n                        ++k;\n                    } while (k <= j && isNaN(pts[k].scrCoords[1] + pts[k].scrCoords[2]));\n                    if (k <= j) {\n                        newPts.push(pts[k]);\n                    }\n                    RDP(pts, k + 1, j, eps, newPts);\n                } else if (result[0] > eps) {\n                    RDP(pts, i, k, eps, newPts);\n                    RDP(pts, k, j, eps, newPts);\n                } else {\n                    newPts.push(pts[j]);\n                }\n            };\n\n        len = pts.length;\n\n        i = 0;\n        while (endless) {\n            // Search for the next point without NaN coordinates\n            while (i < len && isNaN(pts[i].scrCoords[1] + pts[i].scrCoords[2])) {\n                i += 1;\n            }\n            // Search for the next position of a NaN point\n            k = i + 1;\n            while (k < len && !isNaN(pts[k].scrCoords[1] + pts[k].scrCoords[2])) {\n                k += 1;\n            }\n            k--;\n\n            // Only proceed if something is left\n            if (i < len && k > i) {\n                newPts = [];\n                newPts[0] = pts[i];\n                RDP(pts, i, k, eps, newPts);\n                allPts = allPts.concat(newPts);\n            }\n            if (i >= len) {\n                break;\n            }\n            // Push the NaN point\n            if (k < len - 1) {\n                allPts.push(pts[k + 1]);\n            }\n            i = k + 1;\n        }\n\n        return allPts;\n    },\n\n    /**\n     * Old name for the implementation of the Ramer-Douglas-Peucker algorithm.\n     * @deprecated Use {@link JXG.Math.Numerics.RamerDouglasPeucker}\n     * @memberof JXG.Math.Numerics\n     */\n    RamerDouglasPeuker: function (pts, eps) {\n        JXG.deprecated(\"Numerics.RamerDouglasPeuker()\", \"Numerics.RamerDouglasPeucker()\");\n        return this.RamerDouglasPeucker(pts, eps);\n    },\n\n    /**\n     * Implements the Visvalingam-Whyatt algorithm.\n     * See M. Visvalingam, J. D. Whyatt:\n     * \"Line generalisation by repeated elimination of the smallest area\", C.I.S.R.G Discussion paper 10, July 1992\n     *\n     * The algorithm discards points which are not necessary from the polygonal line defined by the point array\n     * pts (consisting of type JXG.Coords).\n     * @param {Array} pts Array of {@link JXG.Coords}\n     * @param {Number} numPoints Number of remaining intermediate points. The first and the last point of the original points will\n     *    be taken in any case.\n     * @returns {Array} An array containing points which approximates the curve defined by pts.\n     * @memberof JXG.Math.Numerics\n     *\n     * @example\n     *     var i, p = [];\n     *     for (i = 0; i < 5; ++i) {\n     *         p.push(board.create('point', [Math.random() * 12 - 6, Math.random() * 12 - 6]));\n     *     }\n     *\n     *     // Plot a cardinal spline curve\n     *     var splineArr = JXG.Math.Numerics.CardinalSpline(p, 0.5);\n     *     var cu1 = board.create('curve', splineArr, {strokeColor: 'green'});\n     *\n     *     var c = board.create('curve', [[0],[0]], {strokeWidth: 2, strokeColor: 'black'});\n     *     c.updateDataArray = function() {\n     *         var i, len, points;\n     *\n     *         // Reduce number of intermediate points with Visvakingam-Whyatt to 6\n     *         points = JXG.Math.Numerics.Visvalingam(cu1.points, 6);\n     *         // Plot the remaining points\n     *         len = points.length;\n     *         this.dataX = [];\n     *         this.dataY = [];\n     *         for (i = 0; i < len; i++) {\n     *             this.dataX.push(points[i].usrCoords[1]);\n     *             this.dataY.push(points[i].usrCoords[2]);\n     *         }\n     *     };\n     *     board.update();\n     *\n     * </pre><div id=\"JXGce0cc55c-b592-11e6-8270-104a7d3be7eb\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXGce0cc55c-b592-11e6-8270-104a7d3be7eb',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *\n     *         var i, p = [];\n     *         for (i = 0; i < 5; ++i) {\n     *             p.push(board.create('point', [Math.random() * 12 - 6, Math.random() * 12 - 6]));\n     *         }\n     *\n     *         // Plot a cardinal spline curve\n     *         var splineArr = JXG.Math.Numerics.CardinalSpline(p, 0.5);\n     *         var cu1 = board.create('curve', splineArr, {strokeColor: 'green'});\n     *\n     *         var c = board.create('curve', [[0],[0]], {strokeWidth: 2, strokeColor: 'black'});\n     *         c.updateDataArray = function() {\n     *             var i, len, points;\n     *\n     *             // Reduce number of intermediate points with Visvakingam-Whyatt to 6\n     *             points = JXG.Math.Numerics.Visvalingam(cu1.points, 6);\n     *             // Plot the remaining points\n     *             len = points.length;\n     *             this.dataX = [];\n     *             this.dataY = [];\n     *             for (i = 0; i < len; i++) {\n     *                 this.dataX.push(points[i].usrCoords[1]);\n     *                 this.dataY.push(points[i].usrCoords[2]);\n     *             }\n     *         };\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    Visvalingam: function (pts, numPoints) {\n        var i,\n            len,\n            vol,\n            lastVol,\n            linkedList = [],\n            heap = [],\n            points = [],\n            lft,\n            rt,\n            lft2,\n            rt2,\n            obj;\n\n        len = pts.length;\n\n        // At least one intermediate point is needed\n        if (len <= 2) {\n            return pts;\n        }\n\n        // Fill the linked list\n        // Add first point to the linked list\n        linkedList[0] = {\n            used: true,\n            lft: null,\n            node: null\n        };\n\n        // Add all intermediate points to the linked list,\n        // whose triangle area is nonzero.\n        lft = 0;\n        for (i = 1; i < len - 1; i++) {\n            vol = Math.abs(\n                JXG.Math.Numerics.det([\n                    pts[i - 1].usrCoords,\n                    pts[i].usrCoords,\n                    pts[i + 1].usrCoords\n                ])\n            );\n            if (!isNaN(vol)) {\n                obj = {\n                    v: vol,\n                    idx: i\n                };\n                heap.push(obj);\n                linkedList[i] = {\n                    used: true,\n                    lft: lft,\n                    node: obj\n                };\n                linkedList[lft].rt = i;\n                lft = i;\n            }\n        }\n\n        // Add last point to the linked list\n        linkedList[len - 1] = {\n            used: true,\n            rt: null,\n            lft: lft,\n            node: null\n        };\n        linkedList[lft].rt = len - 1;\n\n        // Remove points until only numPoints intermediate points remain\n        lastVol = -Infinity;\n        while (heap.length > numPoints) {\n            // Sort the heap with the updated volume values\n            heap.sort(function (a, b) {\n                // descending sort\n                return b.v - a.v;\n            });\n\n            // Remove the point with the smallest triangle\n            i = heap.pop().idx;\n            linkedList[i].used = false;\n            lastVol = linkedList[i].node.v;\n\n            // Update the pointers of the linked list\n            lft = linkedList[i].lft;\n            rt = linkedList[i].rt;\n            linkedList[lft].rt = rt;\n            linkedList[rt].lft = lft;\n\n            // Update the values for the volumes in the linked list\n            lft2 = linkedList[lft].lft;\n            if (lft2 !== null) {\n                vol = Math.abs(\n                    JXG.Math.Numerics.det([\n                        pts[lft2].usrCoords,\n                        pts[lft].usrCoords,\n                        pts[rt].usrCoords\n                    ])\n                );\n\n                linkedList[lft].node.v = vol >= lastVol ? vol : lastVol;\n            }\n            rt2 = linkedList[rt].rt;\n            if (rt2 !== null) {\n                vol = Math.abs(\n                    JXG.Math.Numerics.det([\n                        pts[lft].usrCoords,\n                        pts[rt].usrCoords,\n                        pts[rt2].usrCoords\n                    ])\n                );\n\n                linkedList[rt].node.v = vol >= lastVol ? vol : lastVol;\n            }\n        }\n\n        // Return an array with the remaining points\n        i = 0;\n        points = [pts[i]];\n        do {\n            i = linkedList[i].rt;\n            points.push(pts[i]);\n        } while (linkedList[i].rt !== null);\n\n        return points;\n    }\n};\n\nexport default Mat.Numerics;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Mat from \"./math\";\nimport Type from \"../utils/type\";\n\n/**\n * Functions for mathematical statistics. Most functions are like in the statistics package R.\n * @name JXG.Math.Statistics\n * @exports Mat.Statistics as JXG.Math.Statistics\n * @namespace\n */\nMat.Statistics = {\n    /**\n     * Sums up all elements of the given array.\n     * @param {Array} arr An array of numbers.\n     * @returns {Number}\n     * @memberof JXG.Math.Statistics\n     */\n    sum: function (arr) {\n        var i,\n            len = arr.length,\n            res = 0;\n\n        for (i = 0; i < len; i++) {\n            res += arr[i];\n        }\n        return res;\n    },\n\n    /**\n     * Multiplies all elements of the given array.\n     * @param {Array} arr An array of numbers.\n     * @returns {Number}\n     * @memberof JXG.Math.Statistics\n     */\n    prod: function (arr) {\n        var i,\n            len = arr.length,\n            res = 1;\n\n        for (i = 0; i < len; i++) {\n            res *= arr[i];\n        }\n        return res;\n    },\n\n    /**\n     * Determines the mean value of the values given in an array.\n     * @param {Array} arr\n     * @returns {Number}\n     * @memberof JXG.Math.Statistics\n     */\n    mean: function (arr) {\n        if (arr.length > 0) {\n            return this.sum(arr) / arr.length;\n        }\n\n        return 0.0;\n    },\n\n    /**\n     * The median of a finite set of values is the value that divides the set\n     * into two equal sized subsets.\n     * @param {Array} arr The set of values.\n     * @returns {Number}\n     * @memberof JXG.Math.Statistics\n     */\n    median: function (arr) {\n        var tmp, len;\n\n        if (arr.length > 0) {\n            if (ArrayBuffer.isView(arr)) {\n                tmp = new Float64Array(arr);\n                tmp.sort();\n            } else {\n                tmp = arr.slice(0);\n                tmp.sort(function (a, b) {\n                    return a - b;\n                });\n            }\n            len = tmp.length;\n\n            if (len & 1) {\n                // odd\n                return tmp[parseInt(len * 0.5, 10)];\n            }\n\n            return (tmp[len * 0.5 - 1] + tmp[len * 0.5]) * 0.5;\n        }\n\n        return 0.0;\n    },\n\n    /**\n     * The P-th percentile ( 0 < P ≤ 100 ) of a list of N ordered values (sorted from least to greatest)\n     * is the smallest value in the list such that no more than P percent of the data is strictly less\n     * than the value and at least P percent of the data is less than or equal to that value. See {@link https://en.wikipedia.org/wiki/Percentile}.\n     *\n     * Here, the <i>linear interpolation between closest ranks</i> method is used.\n     * @param {Array} arr The set of values, need not be ordered.\n     * @param {Number|Array} percentile One or several percentiles\n     * @returns {Number|Array} Depending if a number or an array is the input for percentile, a number or an array containing the percentils\n     * is returned.\n     */\n    percentile: function (arr, percentile) {\n        var tmp,\n            len,\n            i,\n            p,\n            res = [],\n            per;\n\n        if (arr.length > 0) {\n            if (ArrayBuffer.isView(arr)) {\n                tmp = new Float64Array(arr);\n                tmp.sort();\n            } else {\n                tmp = arr.slice(0);\n                tmp.sort(function (a, b) {\n                    return a - b;\n                });\n            }\n            len = tmp.length;\n\n            if (Type.isArray(percentile)) {\n                p = percentile;\n            } else {\n                p = [percentile];\n            }\n\n            for (i = 0; i < p.length; i++) {\n                per = len * p[i] * 0.01;\n                if (parseInt(per, 10) === per) {\n                    res.push((tmp[per - 1] + tmp[per]) * 0.5);\n                } else {\n                    res.push(tmp[parseInt(per, 10)]);\n                }\n            }\n\n            if (Type.isArray(percentile)) {\n                return res;\n            } else {\n                return res[0];\n            }\n        }\n\n        return 0.0;\n    },\n\n    /**\n     * Bias-corrected sample variance. A variance is a measure of how far a\n     * set of numbers are spread out from each other.\n     * @param {Array} arr\n     * @returns {Number}\n     * @memberof JXG.Math.Statistics\n     */\n    variance: function (arr) {\n        var m,\n            res,\n            i,\n            len = arr.length;\n\n        if (len > 1) {\n            m = this.mean(arr);\n            res = 0;\n            for (i = 0; i < len; i++) {\n                res += (arr[i] - m) * (arr[i] - m);\n            }\n            return res / (arr.length - 1);\n        }\n\n        return 0.0;\n    },\n\n    /**\n     * Determines the <strong>s</strong>tandard <strong>d</strong>eviation which shows how much\n     * variation there is from the average value of a set of numbers.\n     * @param {Array} arr\n     * @returns {Number}\n     * @memberof JXG.Math.Statistics\n     */\n    sd: function (arr) {\n        return Math.sqrt(this.variance(arr));\n    },\n\n    /**\n     * Weighted mean value is basically the same as {@link JXG.Math.Statistics.mean} but here the values\n     * are weighted, i.e. multiplied with another value called <em>weight</em>. The weight values are given\n     * as a second array with the same length as the value array..\n     * @throws {Error} If the dimensions of the arrays don't match.\n     * @param {Array} arr Set of alues.\n     * @param {Array} w Weight values.\n     * @returns {Number}\n     * @memberof JXG.Math.Statistics\n     */\n    weightedMean: function (arr, w) {\n        if (arr.length !== w.length) {\n            throw new Error(\n                \"JSXGraph error (Math.Statistics.weightedMean): Array dimension mismatch.\"\n            );\n        }\n\n        if (arr.length > 0) {\n            return this.mean(this.multiply(arr, w));\n        }\n\n        return 0.0;\n    },\n\n    /**\n     * Extracts the maximum value from the array.\n     * @param {Array} arr\n     * @returns {Number} The highest number from the array. It returns <tt>NaN</tt> if not every element could be\n     * interpreted as a number and <tt>-Infinity</tt> if an empty array is given or no element could be interpreted\n     * as a number.\n     * @memberof JXG.Math.Statistics\n     */\n    max: function (arr) {\n        return Math.max.apply(this, arr);\n    },\n\n    /**\n     * Extracts the minimum value from the array.\n     * @param {Array} arr\n     * @returns {Number} The lowest number from the array. It returns <tt>NaN</tt> if not every element could be\n     * interpreted as a number and <tt>Infinity</tt> if an empty array is given or no element could be interpreted\n     * as a number.\n     * @memberof JXG.Math.Statistics\n     */\n    min: function (arr) {\n        return Math.min.apply(this, arr);\n    },\n\n    /**\n     * Determines the lowest and the highest value from the given array.\n     * @param {Array} arr\n     * @returns {Array} The minimum value as the first and the maximum value as the second value.\n     * @memberof JXG.Math.Statistics\n     */\n    range: function (arr) {\n        return [this.min(arr), this.max(arr)];\n    },\n\n    /**\n     * Determines the absolute value of every given value.\n     * @param {Array|Number} arr\n     * @returns {Array|Number}\n     * @memberof JXG.Math.Statistics\n     */\n    abs: function (arr) {\n        var i, len, res;\n\n        if (Type.isArray(arr)) {\n            if (arr.map) {\n                res = arr.map(Math.abs);\n            } else {\n                len = arr.length;\n                res = [];\n\n                for (i = 0; i < len; i++) {\n                    res[i] = Math.abs(arr[i]);\n                }\n            }\n        } else if (ArrayBuffer.isView(arr)) {\n            res = arr.map(Math.abs);\n        } else {\n            res = Math.abs(arr);\n        }\n        return res;\n    },\n\n    /**\n     * Adds up two (sequences of) values. If one value is an array and the other one is a number the number\n     * is added to every element of the array. If two arrays are given and the lengths don't match the shortest\n     * length is taken.\n     * @param {Array|Number} arr1\n     * @param {Array|Number} arr2\n     * @returns {Array|Number}\n     * @memberof JXG.Math.Statistics\n     */\n    add: function (arr1, arr2) {\n        var i,\n            len,\n            res = [];\n\n        arr1 = Type.evalSlider(arr1);\n        arr2 = Type.evalSlider(arr2);\n\n        if (Type.isArray(arr1) && Type.isNumber(arr2)) {\n            len = arr1.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1[i] + arr2;\n            }\n        } else if (Type.isNumber(arr1) && Type.isArray(arr2)) {\n            len = arr2.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1 + arr2[i];\n            }\n        } else if (Type.isArray(arr1) && Type.isArray(arr2)) {\n            len = Math.min(arr1.length, arr2.length);\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1[i] + arr2[i];\n            }\n        } else {\n            res = arr1 + arr2;\n        }\n\n        return res;\n    },\n\n    /**\n     * Divides two (sequences of) values. If two arrays are given and the lengths don't match the shortest length\n     * is taken.\n     * @param {Array|Number} arr1 Dividend\n     * @param {Array|Number} arr2 Divisor\n     * @returns {Array|Number}\n     * @memberof JXG.Math.Statistics\n     */\n    div: function (arr1, arr2) {\n        var i,\n            len,\n            res = [];\n\n        arr1 = Type.evalSlider(arr1);\n        arr2 = Type.evalSlider(arr2);\n\n        if (Type.isArray(arr1) && Type.isNumber(arr2)) {\n            len = arr1.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1[i] / arr2;\n            }\n        } else if (Type.isNumber(arr1) && Type.isArray(arr2)) {\n            len = arr2.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1 / arr2[i];\n            }\n        } else if (Type.isArray(arr1) && Type.isArray(arr2)) {\n            len = Math.min(arr1.length, arr2.length);\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1[i] / arr2[i];\n            }\n        } else {\n            res = arr1 / arr2;\n        }\n\n        return res;\n    },\n\n    /**\n     * @function\n     * @deprecated Use {@link JXG.Math.Statistics.div} instead.\n     * @memberof JXG.Math.Statistics\n     */\n    divide: function () {\n        JXG.deprecated(\"Statistics.divide()\", \"Statistics.div()\");\n        Mat.Statistics.div.apply(Mat.Statistics, arguments);\n    },\n\n    /**\n     * Divides two (sequences of) values and returns the remainder. If two arrays are given and the lengths don't\n     * match the shortest length is taken.\n     * @param {Array|Number} arr1 Dividend\n     * @param {Array|Number} arr2 Divisor\n     * @param {Boolean} [math=false] Mathematical mod or symmetric mod? Default is symmetric, the JavaScript <tt>%</tt> operator.\n     * @returns {Array|Number}\n     * @memberof JXG.Math.Statistics\n     */\n    mod: function (arr1, arr2, math) {\n        var i,\n            len,\n            res = [],\n            mod = function (a, m) {\n                return a % m;\n            };\n\n        math = Type.def(math, false);\n\n        if (math) {\n            mod = Mat.mod;\n        }\n\n        arr1 = Type.evalSlider(arr1);\n        arr2 = Type.evalSlider(arr2);\n\n        if (Type.isArray(arr1) && Type.isNumber(arr2)) {\n            len = arr1.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = mod(arr1[i], arr2);\n            }\n        } else if (Type.isNumber(arr1) && Type.isArray(arr2)) {\n            len = arr2.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = mod(arr1, arr2[i]);\n            }\n        } else if (Type.isArray(arr1) && Type.isArray(arr2)) {\n            len = Math.min(arr1.length, arr2.length);\n\n            for (i = 0; i < len; i++) {\n                res[i] = mod(arr1[i], arr2[i]);\n            }\n        } else {\n            res = mod(arr1, arr2);\n        }\n\n        return res;\n    },\n\n    /**\n     * Multiplies two (sequences of) values. If one value is an array and the other one is a number the number\n     * is multiplied to every element of the array. If two arrays are given and the lengths don't match the shortest\n     * length is taken.\n     * @param {Array|Number} arr1\n     * @param {Array|Number} arr2\n     * @returns {Array|Number}\n     * @memberof JXG.Math.Statistics\n     */\n    multiply: function (arr1, arr2) {\n        var i,\n            len,\n            res = [];\n\n        arr1 = Type.evalSlider(arr1);\n        arr2 = Type.evalSlider(arr2);\n\n        if (Type.isArray(arr1) && Type.isNumber(arr2)) {\n            len = arr1.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1[i] * arr2;\n            }\n        } else if (Type.isNumber(arr1) && Type.isArray(arr2)) {\n            len = arr2.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1 * arr2[i];\n            }\n        } else if (Type.isArray(arr1) && Type.isArray(arr2)) {\n            len = Math.min(arr1.length, arr2.length);\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1[i] * arr2[i];\n            }\n        } else {\n            res = arr1 * arr2;\n        }\n\n        return res;\n    },\n\n    /**\n     * Subtracts two (sequences of) values. If two arrays are given and the lengths don't match the shortest\n     * length is taken.\n     * @param {Array|Number} arr1 Minuend\n     * @param {Array|Number} arr2 Subtrahend\n     * @returns {Array|Number}\n     * @memberof JXG.Math.Statistics\n     */\n    subtract: function (arr1, arr2) {\n        var i,\n            len,\n            res = [];\n\n        arr1 = Type.evalSlider(arr1);\n        arr2 = Type.evalSlider(arr2);\n\n        if (Type.isArray(arr1) && Type.isNumber(arr2)) {\n            len = arr1.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1[i] - arr2;\n            }\n        } else if (Type.isNumber(arr1) && Type.isArray(arr2)) {\n            len = arr2.length;\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1 - arr2[i];\n            }\n        } else if (Type.isArray(arr1) && Type.isArray(arr2)) {\n            len = Math.min(arr1.length, arr2.length);\n\n            for (i = 0; i < len; i++) {\n                res[i] = arr1[i] - arr2[i];\n            }\n        } else {\n            res = arr1 - arr2;\n        }\n\n        return res;\n    },\n\n    /**\n     * The Theil-Sen estimator can be used to determine a more robust linear regression of a set of sample\n     * points than least squares regression in {@link JXG.Math.Numerics.regressionPolynomial}.\n     *\n     * If the function should be applied to an array a of points, a the coords array can be generated with\n     * JavaScript array.map:\n     *\n     * <pre>\n     * JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords));\n     * </pre>\n     *\n     * @param {Array} coords Array of {@link JXG.Coords}.\n     * @returns {Array} A stdform array of the regression line.\n     * @memberof JXG.Math.Statistics\n     *\n     * @example\n     * var board = JXG.JSXGraph.initBoard('jxgbox', { boundingbox: [-6,6,6,-6], axis : true });\n     * var a=[];\n     * a[0]=board.create('point', [0,0]);\n     * a[1]=board.create('point', [3,0]);\n     * a[2]=board.create('point', [0,3]);\n     *\n     * board.create('line', [\n     *     () => JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords))\n     *   ],\n     *   {strokeWidth:1, strokeColor:'black'});\n     *\n     * </pre><div id=\"JXG0a28be85-91c5-44d3-aae6-114e81217cf0\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG0a28be85-91c5-44d3-aae6-114e81217cf0',\n     *             {boundingbox: [-6,6,6,-6], axis: true, showcopyright: false, shownavigation: false});\n     *     var a=[];\n     *     a[0]=board.create('point', [0,0]);\n     *     a[1]=board.create('point', [3,0]);\n     *     a[2]=board.create('point', [0,3]);\n     *\n     *     board.create('line', [\n     *         () => JXG.Math.Statistics.TheilSenRegression(a.map(el => el.coords))\n     *       ],\n     *       {strokeWidth:1, strokeColor:'black'});\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    TheilSenRegression: function (coords) {\n        var i,\n            j,\n            slopes = [],\n            tmpslopes = [],\n            yintercepts = [];\n\n        for (i = 0; i < coords.length; i++) {\n            tmpslopes.length = 0;\n\n            for (j = 0; j < coords.length; j++) {\n                if (Math.abs(coords[j].usrCoords[1] - coords[i].usrCoords[1]) > Mat.eps) {\n                    tmpslopes[j] =\n                        (coords[j].usrCoords[2] - coords[i].usrCoords[2]) /\n                        (coords[j].usrCoords[1] - coords[i].usrCoords[1]);\n                }\n            }\n\n            slopes[i] = this.median(tmpslopes);\n            yintercepts.push(coords[i].usrCoords[2] - slopes[i] * coords[i].usrCoords[1]);\n        }\n\n        return [this.median(yintercepts), this.median(slopes), -1];\n    },\n\n    /**\n     * Generate values of a standard normal random variable with the Marsaglia polar method, see\n     * https://en.wikipedia.org/wiki/Marsaglia_polar_method .\n     *\n     * @param {Number} mean mean value of the normal distribution\n     * @param {Number} stdDev standard deviation of the normal distribution\n     * @returns {Number} value of a standard normal random variable\n     */\n    generateGaussian: function (mean, stdDev) {\n        var u, v, s;\n\n        if (this.hasSpare) {\n            this.hasSpare = false;\n            return this.spare * stdDev + mean;\n        }\n\n        do {\n            u = Math.random() * 2 - 1;\n            v = Math.random() * 2 - 1;\n            s = u * u + v * v;\n        } while (s >= 1 || s === 0);\n\n        s = Math.sqrt((-2.0 * Math.log(s)) / s);\n\n        this.spare = v * s;\n        this.hasSpare = true;\n        return mean + stdDev * u * s;\n    }\n};\n\nexport default Mat.Statistics;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG:true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"./jxg\";\nimport Const from \"./base/constants\";\nimport Mat from \"./math/math\";\nimport Color from \"./utils/color\";\nimport Type from \"./utils/type\";\n\n/**\n * Options Namespace\n * @description These are the default options of the board and of all geometry elements.\n * @namespace\n * @name JXG.Options\n */\nJXG.Options = {\n\n        jc: {\n            enabled: true,\n            compile: true\n        },\n\n        /*\n         * Options that are used directly within the board class\n         */\n        board: {\n            /**#@+\n             * @visprop\n             */\n\n            //updateType: 'hierarchical', // 'all'\n\n            /**\n             * Bounding box of the visible area in user coordinates.\n             * It is an array consisting of four values:\n             * [x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>]\n             *\n             * The canvas will be spanned from the upper left corner (<sub>1</sub>, y<sub>1</sub>)\n             * to the lower right corner (x<sub>2</sub>, y<sub>2</sub>).\n             *\n             * @name JXG.Board#boundingbox\n             * @type Array\n             * @default [-5, 5, 5, -5]\n             * @example\n             * var board = JXG.JSXGraph.initBoard('jxgbox', {\n             *         boundingbox: [-5, 5, 5, -5],\n             *         axis: true\n             *     });\n             */\n            boundingBox: [-5, 5, 5, -5],\n\n            /**\n             * Maximal bounding box of the visible area in user coordinates.\n             * It is an array consisting of four values:\n             * [x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>]\n             *\n             * The bounding box of the canvas must be inside of this maximal\n             * boundings box.\n             * @name JXG.Board#maxboundingbox\n             * @type Array\n             * @see JXG.Board#boundingbox\n             * @default [-Infinity, Infinity, Infinity, -Infinity]\n             *\n             * @example\n             * var board = JXG.JSXGraph.initBoard('jxgbox', {\n             *         boundingbox: [-5, 5, 5, -5],\n             *         maxboundingbox: [-8, 8, 8, -8],\n             *         pan: {enabled: true},\n             *         axis: true\n             *     });\n             *\n             * </pre><div id=\"JXG065e2750-217c-48ed-a52b-7d7df6de7055\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG065e2750-217c-48ed-a52b-7d7df6de7055', {\n             *             showcopyright: false, shownavigation: false,\n             *             boundingbox: [-5,5,5,-5],\n             *             maxboundingbox: [-8,8,8,-8],\n             *             pan: {enabled: true},\n             *             axis:true\n             *         });\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             */\n            maxBoundingBox: [-Infinity, Infinity, Infinity, -Infinity],\n\n            /**\n             * Additional zoom factor multiplied to {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY}.\n             *\n             * @name JXG.Board#zoomFactor\n             * @type Number\n             * @default 1.0\n             */\n            zoomFactor: 1,\n\n            /**\n             * Zoom factor in horizontal direction.\n             *\n             * @name JXG.Board#zoomX\n             * @see JXG.Board#zoomY\n             * @type Number\n             * @default 1.0\n             */\n            zoomX: 1,\n\n            /**\n             * Zoom factor in vertical direction.\n             *\n             * @name JXG.Board#zoomY\n             * @see JXG.Board#zoomX\n             * @type Number\n             * @default 1.0\n             */\n            zoomY: 1,\n\n            /**\n             * Title string for the board.\n             * Primarily used in an invisible text element which is adressed by\n             * the attribute 'aria-labelledby' from the JSXGraph container.\n             * JSXGraph creates a new div-element with id \"{containerid}_ARIAlabel\"\n             * containing this string.\n             *\n             * @name JXG.Board#title\n             * @see JXG.Board#description\n             * @type String\n             * @default ''\n             *\n             */\n            title: '',\n\n            /**\n             * Description string for the board.\n             * Primarily used in an invisible text element which is adressed by\n             * the attribute 'aria-describedby' from the JSXGraph container.\n             * JSXGraph creates a new div-element with id \"{containerid}_ARIAdescription\"\n             * containing this string.\n             *\n             * @name JXG.Board#description\n             * @see JXG.Board#title\n             * @type String\n             * @default ''\n             *\n             */\n            description: '',\n\n            /**\n             * Show copyright string in canvas.\n             *\n             * @name JXG.Board#showCopyright\n             * @type Boolean\n             * @default true\n             */\n            showCopyright: true,\n\n            /**\n             * Show default axis.\n             * If shown, the horizontal axis can be accessed via JXG.Board.defaultAxes.x, the\n             * vertical axis can be accessed via JXG.Board.defaultAxes.y.\n             * Both axes have a sub-element \"defaultTicks\".\n             *\n             * Value can be Boolean or an object containing axis attributes.\n             *\n             * @name JXG.Board#axis\n             * @type Boolean\n             * @default false\n             */\n            axis: false,\n\n            /**\n             * Attributes for the default axes in case of the attribute\n             * axis:true in {@link JXG.JSXGraph#initBoard}.\n             *\n             * @name JXG.Board#defaultAxes\n             * @type Object\n             * @default {x: {name:'x'}, y: {name: 'y'}}\n             *\n             */\n            defaultAxes: {\n                x: {\n                    name: 'x',\n                    ticks: {\n                        label: {\n                            visible: 'inherit',\n                            anchorX: 'middle',\n                            anchorY: 'top',\n                            fontSize: 12,\n                            offset: [0, -3]\n                        },\n                        tickEndings: [0, 1],\n                        majorTickEndings: [1, 1],\n                        drawZero: false,\n                        visible: 'inherit'\n                    }\n                },\n                y: {\n                    name: 'y',\n                    ticks: {\n                        label: {\n                            visible: 'inherit',\n                            anchorX: 'right',\n                            anchorY: 'middle',\n                            fontSize: 12,\n                            offset: [-6, 0]\n                        },\n                        tickEndings: [1, 0],\n                        majorTickEndings: [1, 1],\n                        drawZero: false,\n                        visible: 'inherit'\n                    }\n                }\n            },\n\n            /**\n             * Display of navigation arrows and zoom buttons in the navigation bar.\n             *\n             * @name JXG.Board#showNavigation\n             * @type Boolean\n             * @default true\n             * @see JXG.AbstractRenderer#drawZoomBar\n             */\n            showNavigation: true,\n\n            /**\n             * Display of zoom buttons in the navigation bar. To show zoom buttons, additionally\n             * showNavigation has to be set to true.\n             *\n             * @name JXG.Board#showZoom\n             * @type Boolean\n             * @default true\n             * @see JXG.AbstractRenderer#drawZoomBar\n             */\n            showZoom: true,\n\n            /**\n             * Show a button in the navigation bar to force reload of a construction.\n             * Works only with the JessieCode tag.\n             *\n             * @name JXG.Board#showReload\n             * @type Boolean\n             * @default false\n             * @see JXG.AbstractRenderer#drawZoomBar\n             */\n            showReload: false,\n\n            /**\n             * Show a button in the navigation bar to enable screenshots.\n             *\n             * @name JXG.Board#showScreenshot\n             * @type Boolean\n             * @default false\n             * @see JXG.AbstractRenderer#drawZoomBar\n             */\n            showScreenshot: false,\n\n            /**\n             * Attributes to control the screenshot function.\n             * The following attributes can be set:\n             * <ul>\n             *  <li>scale: scaling factor (default=1.0)\n             *  <li>type: format of the screenshot image. Default: png\n             *  <li>symbol: Unicode symbol which is shown in the navigation bar. Default: '\\u2318'\n             *  <li>css: CSS rules to format the div element containing the screen shot image\n             *  <li>cssButton: CSS rules to format the close button of the div element containing the screen shot image\n             * </ul>\n             *\n             * @name JXG.Board#screenshot\n             * @type Object\n             */\n            screenshot: {\n                scale: 1.0,\n                type: 'png',\n                symbol: '\\u2318', //'\\u22b9', //'\\u26f6',\n                css: 'background-color:#eeeeee; opacity:1.0; border:2px solid black; border-radius:10px; text-align:center',\n                cssButton:  'padding: 4px 10px; border: solid #356AA0 1px; border-radius: 5px; position: absolute; right: 2ex; top: 2ex; background-color: rgba(255, 255, 255, 0.3);'\n            },\n\n            /**\n             * Show a button in the navigation bar to start fullscreen mode.\n             *\n             * @name JXG.Board#showFullscreen\n             * @type Boolean\n             * @see JXG.Board#fullscreen\n             * @default false\n             * @see JXG.AbstractRenderer#drawZoomBar\n             * @see JXG.AbstractRenderer#drawZoomBar\n             */\n            showFullscreen: false,\n\n            /**\n             * Attribute(s) to control the fullscreen icon. The attribute \"showFullscreen\"\n             * controls if the icon is shown.\n             * The following attribute(s) can be set:\n             * <ul>\n             *  <li> symbol (String): Unicode symbol which is shown in the navigation bar.  Default: svg code for '\\u26f6', other\n             * possibilities are the unicode symbols '\\u26f6' and '\\u25a1'. However, '\\u26f6' is not supported by MacOS and iOS.\n             *  <li> scale (number between 0 and 1): Relative size of the larger side of the JSXGraph board in the fullscreen window. 1.0 gives full width or height.\n             * Default value is 0.85.\n             *  <li> id (String): Id of the HTML element which is brought to full screen or null if the JSXgraph div is taken.\n             * It may be an outer div element, e.g. if the old aspect ratio trick is used. Default: null, i.e. use the JSXGraph div.\n             * </ul>\n             *\n             * @example\n             * var board = JXG.JSXGraph.initBoard('35bec5a2-fd4d-11e8-ab14-901b0e1b8723',\n             *             {boundingbox: [-8, 8, 8,-8], axis: true,\n             *             showcopyright: false,\n             *             showFullscreen: true,\n             *             fullscreen: {\n             *                  symbol: '\\u22c7'\n             *              }\n             *             });\n             * var pol = board.create('polygon', [[0, 1], [3,4], [1,-4]], {fillColor: 'yellow'});\n             *\n             * </pre><div id=\"JXGa35bec5a2-fd4d-11e8-ab14-901b0e1b8723\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGa35bec5a2-fd4d-11e8-ab14-901b0e1b8723',\n             *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false,\n             *              showFullscreen: true,\n             *              fullscreen: {\n             *                  symbol: '\\u22c7'\n             *                  }\n             *             });\n             *     var pol = board.create('polygon', [[0, 1], [3,4], [1,-4]], {fillColor: 'yellow'});\n             *     })();\n             *\n             * </script><pre>\n             *\n             * @name JXG.Board#fullscreen\n             * @default svg code\n             * @see JXG.Board#showFullscreen\n             * @see JXG.AbstractRenderer#drawZoomBar\n             * @type Object\n             */\n            fullscreen: {\n                symbol: '<svg height=\"1em\" width=\"1em\" version=\"1.1\" viewBox=\"10 10 18 18\"><path fill=\"#666\" d=\"m 10,16 2,0 0,-4 4,0 0,-2 L 10,10 l 0,6 0,0 z\"></path><path fill=\"#666\" d=\"m 20,10 0,2 4,0 0,4 2,0 L 26,10 l -6,0 0,0 z\"></path><path fill=\"#666\" d=\"m 24,24 -4,0 0,2 L 26,26 l 0,-6 -2,0 0,4 0,0 z\"></path><path fill=\"#666\" d=\"M 12,20 10,20 10,26 l 6,0 0,-2 -4,0 0,-4 0,0 z\"></path></svg>',\n                    // '\\u25a1', // '\\u26f6' (not supported by MacOS),\n                scale: 0.85,\n                id: null\n            },\n\n            /**\n             * Show a button which allows to clear all traces of a board.\n             *\n             * @name JXG.Board#showClearTraces\n             * @type Boolean\n             * @default false\n             * @see JXG.AbstractRenderer#drawZoomBar\n             */\n            showClearTraces: false,\n\n            /**\n             * If set to true, the ratio between horizontal and vertical unit sizes\n             * stays constant - independent of size changes of the hosting HTML div element.\n             * <p>\n             * If the aspect ration of the hosting div changes, JSXGraphs will change\n             * the user supplied bounding box accordingly.\n             * This is necessary if circles should look like circles and not\n             * like ellipses. It is recommended to set keepAspectRatio = true\n             * for geometric applets.\n             * <p>\n             * For function plotting keepAspectRatio = false\n             * might be the better choice.\n             *\n             * @name JXG.Board#keepAspectRatio\n             * @see JXG.Board#boundingbox\n             * @see JXG.Board#setBoundingBox\n             * @type Boolean\n             * @default false\n             */\n            keepAspectRatio: false,\n\n            /**\n             * If set true and\n             * hasPoint() is true for both an element and it's label,\n             * the element (and not the label) is taken as drag element.\n             *\n             * If set false and hasPoint() is true for both an element and it's label,\n             * the label is taken (if it is on a higher layer than the element)\n             *\n             * @name JXG.Board#ignoreLabels\n             * @type Booelan\n             * @default true\n             */\n            ignoreLabels: true,\n\n            /**\n             * Maximum number of digits in automatic label generation.\n             * For example, if set to 1 automatic point labels end at \"Z\".\n             * If set to 2, point labels end at \"ZZ\".\n             *\n             * @name JXG.Board#maxNameLength\n             * @see JXG.Board#generateName\n             * @type Number\n             * @default 1\n             */\n            maxNameLength: 1,\n\n            /**\n             * Supply the document object. Defaults to window.document\n             *\n             * @name JXG.Board#document\n             * @type DOM object\n             * @default false (meaning window.document)\n             */\n            document: false,\n\n            /**\n             * If true the first element of the set JXG.board.objects having hasPoint==true is taken as drag element.\n             *\n             * @name JXG.Board#takeFirst\n             * @type Boolean\n             * @default false\n             */\n            takeFirst: false,\n\n            /**\n            * If true, when read from a file or string - the size of the div can be changed by the construction text.\n            *\n            * @name JXG.Board#takeSizeFromFile\n            * @type Boolean\n            * @default false\n            */\n            takeSizeFromFile: false,\n\n            /**\n             * Default rendering engine. Possible values are 'svg', 'canvas', 'vml', 'no', or 'auto'.\n             * If the rendering engine is not available JSXGraph tries to detect a different engine.\n             *\n             * <p>\n             * In case of 'canvas' it is advisable to call 'board.update()' after all elements have been\n             * constructed. This ensures that all elements are drawn with their intended visual appearance.\n             *\n             * @name JXG.Board#renderer\n             * @type String\n             * @default 'auto'\n             */\n            renderer: 'auto',\n\n            /**\n             * Time (in msec) between two animation steps. Used in\n             * {@link JXG.CoordsElement#moveAlong}, {@link JXG.CoordsElement#moveTo} and\n             * {@link JXG.CoordsElement#visit}.\n             *\n             * @name JXG.Board#animationDelay\n             * @type Number\n             * @default 35\n             * @see JXG.CoordsElement#moveAlong\n             * @see JXG.CoordsElement#moveTo\n             * @see JXG.CoordsElement#visit\n             */\n            animationDelay: 35,\n\n            /**\n             * Maximum frame rate of the board, i.e. maximum number of updates per second\n             * triggered by move events.\n             *\n             * @name JXG.Board#maxFrameRate\n             * @type Number\n             * @default 40\n             */\n            maxFrameRate: 40,\n\n            /**\n             * Allow user interaction by registering mouse, pointer and touch events.\n             *\n             * @name JXG.Board#registerEvents\n             * @type Boolean\n             * @default true\n             */\n            registerEvents: true,\n\n            /**\n             * Change redraw strategy in SVG rendering engine.\n             * <p>\n             * This optimization seems to be <b>obsolete</b> in newer browsers (from 2021 on, at least)\n             * and even slow down the constructions. Therefore, the default is set to 'none' since v1.2.4.\n             * <p>\n             * If set to 'svg', before every redrawing of the JSXGraph construction\n             * the SVG sub-tree of the DOM tree is taken out of the DOM.\n             *\n             * If set to 'all', before every redrawing of the JSXGraph construction the\n             * complete DOM tree is taken out of the DOM.\n             * If set to 'none' the redrawing is done in-place.\n             *\n             * Using 'svg' or 'all' speeds up the update process considerably. The risk\n             * is that if there is an exception, only a white div or window is left.\n             *\n             *\n             * @name JXG.Board#minimizeReflow\n             * @type String\n             * @default 'none'\n             */\n            minimizeReflow: 'none',\n\n            /**\n             * A number that will be added to the absolute position of the board used in mouse coordinate\n             * calculations in {@link JXG.Board#getCoordsTopLeftCorner}.\n             *\n             * @name JXG.Board#offsetX\n             * @see JXG.Board#offsetY\n             * @type Number\n             * @default 0\n             */\n            offsetX: 0,\n\n            /**\n             * A number that will be added to the absolute position of the board used in mouse coordinate\n             * calculations in {@link JXG.Board#getCoordsTopLeftCorner}.\n             *\n             * @name JXG.Board#offsetY\n             * @see JXG.Board#offsetX\n             * @type Number\n             * @default 0\n             */\n            offsetY: 0,\n\n            /**\n             * Control the possibilities for zoom interaction.\n             *\n             * Possible sub-attributes with default values are:\n             * <pre>\n             * zoom: {\n             *   factorX: 1.25,  // horizontal zoom factor (multiplied to {@link JXG.Board#zoomX})\n             *   factorY: 1.25,  // vertical zoom factor (multiplied to {@link JXG.Board#zoomY})\n             *   wheel: true,     // allow zooming by mouse wheel or\n             *   \t\t\t\t   // by pinch-to-toom gesture on touch devices\n             *   needShift: true,   // mouse wheel zooming needs pressing of the shift key\n             *   min: 0.001,        // minimal values of {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY}, limits zoomOut\n             *   max: 1000.0,       // maximal values of {@link JXG.Board#zoomX} and {@link JXG.Board#zoomY}, limits zoomIn\n             *\n             *   pinchHorizontal: true, // Allow pinch-to-zoom to zoom only horizontal axis\n             *   pinchVertical: true,   // Allow pinch-to-zoom to zoom only vertical axis\n             *   pinchSensitivity: 7    // Sensitivity (in degrees) for recognizing horizontal or vertical pinch-to-zoom gestures.\n             * }\n             * </pre>\n             *\n             * Deprecated: zoom.eps which is superseded by zoom.min\n             *\n             * @name JXG.Board#zoom\n             * @type Object\n             * @default\n             */\n            zoom: {\n                enabled: true,\n                factorX: 1.25,\n                factorY: 1.25,\n                wheel: true,\n                needShift: true,\n                min: 0.0001,\n                max: 10000.0,\n                pinchHorizontal: true,\n                pinchVertical: true,\n                pinchSensitivity: 7\n            },\n\n            /**\n             * Control the possibilities for panning interaction (i.e. moving the origin).\n             *\n             * Possible sub-attributes with default values are:\n             * <pre>\n             * pan: {\n             *   enabled: true   // Allow panning\n             *   needTwoFingers: false, // panning is done with two fingers on touch devices\n             *   needShift: true, // mouse panning needs pressing of the shift key\n             * }\n             * </pre>\n             *\n             * @name JXG.Board#pan\n             * @see JXG.Board#browserPan\n             *\n             * @type Object\n             */\n            pan: {\n                enabled: true,\n                needShift: true,\n                needTwoFingers: false\n            },\n\n            /**\n             * Enable browser scrolling on touch interfaces if the user double taps into an empty region\n             * of the board.\n             *\n             * <ul>\n             * <li> Implemented for pointer touch devices - not with mouse, pen or old iOS touch.\n             * <li> It only works if browserPan:true\n             * <li> One finger action by the settings \"pan.enabled:true\" and \"pan.needTwoFingers:false\" has priority\n             * </ul>\n             *\n             * @name JXG.Board#browserPan\n             * @see JXG.Board#pan\n             * @type Boolean\n             * @default false\n             *\n             * @example\n             * const board = JXG.JSXGraph.initBoard('jxgbox', {\n             *     boundingbox: [-5, 5, 5, -5], axis: true,\n             *     pan: {\n             *         enabled: true,\n             *         needTwoFingers: true,\n             *     },\n             *     browserPan: true,\n             *     zoom: {\n             *         enabled: false\n             *     }\n             * });\n             *\n             * var p1 = board.create('point', [1, -1]);\n             * var p2 = board.create('point', [2.5, -2]);\n             * var li1 = board.create('line', [p1, p2]);\n             *\n             * </pre><div id=\"JXGcd50c814-be81-4280-9458-d73e50cece8d\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGcd50c814-be81-4280-9458-d73e50cece8d',\n             *             {showcopyright: false, shownavigation: false,\n             *              axis: true,\n             *              pan: {\n             *                enabled: true,\n             *                needTwoFingers: true,\n             *             },\n             *             browserPan: true,\n             *             zoom: {\n             *               enabled: false\n             *             }\n             *          });\n             *\n             *     var p1 = board.create('point', [1, -1]);\n             *     var p2 = board.create('point', [2.5, -2]);\n             *     var li1 = board.create('line', [p1, p2]);\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             *\n             */\n            browserPan: false,\n\n            /**\n             * Control the possibilities for dragging objects.\n             *\n             * Possible sub-attributes with default values are:\n             * <pre>\n             * drag: {\n             *   enabled: true   // Allow dragging\n             * }\n             * </pre>\n             *\n             * @name JXG.Board#drag\n             * @type Object\n             * @default {enabled: true}\n             */\n            drag: {\n                enabled: true\n            },\n\n            /**\n             * Control using the keyboard to change the construction.\n             * <ul>\n             * <li> enabled: true / false\n             * <li> dx: horizontal shift amount per key press\n             * <li> dy: vertical shift amount per key press\n             * <li> panShift: zoom if shift key is pressed\n             * <li> panCtrl: zoom if ctrl key is pressed\n             * </ul>\n             *\n             * @example\n             * var board = JXG.JSXGraph.initBoard(\"jxgbox\", {boundingbox: [-5,5,5,-5],\n             *     axis: true,\n             *     showCopyright:true,\n             *     showNavigation:true,\n             *     keyboard: {\n             *         enabled: true,\n             *         dy: 30,\n             *         panShift: true,\n             *         panCtrl: false\n             *     }\n             * });\n             *\n             * </pre><div id=\"JXGb1d3aab6-ced2-4fe9-8fa5-b0accc8c7266\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGb1d3aab6-ced2-4fe9-8fa5-b0accc8c7266',\n             *             {boundingbox: [-5,5,5,-5],\n             *         axis: true,\n             *         showCopyright:true,\n             *         showNavigation:true,\n             *         keyboard: {\n             *             enabled: true,\n             *             dy: 30,\n             *             panShift: true,\n             *             panCtrl: false\n             *         }\n             *     });\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             *\n             * @see JXG.Board#keyDownListener\n             * @see JXG.Board#keyFocusInListener\n             * @see JXG.Board#keyFocusOutListener\n             *\n             * @name JXG.Board#keyboard\n             * @type Object\n             * @default {enabled: true, dx: 10, dy:10, panShift: true, panCtrl: false}\n             */\n            keyboard: {\n                enabled: true,\n                dx: 10,\n                dy: 10,\n                panShift: true,\n                panCtrl: false\n            },\n\n            /**\n             * Control if JSXGraph reacts to resizing of the JSXGraph container element\n             * by the user / browser.\n             * The attribute \"throttle\" determines the minimal time in msec between to\n             * resize calls.\n             *\n             * @see JXG.Board#startResizeObserver\n             * @see JXG.Board#resizeListener\n             *\n             * @name JXG.Board#resize\n             * @type Object\n             * @default {enabled: true, throttle: 10}\n             *\n             * @example\n             *     var board = JXG.JSXGraph.initBoard('jxgbox', {\n             *         boundingbox: [-5,5,5,-5],\n             *         keepAspectRatio: true,\n             *         axis: true,\n             *         resize: {enabled: true, throttle: 200}\n             *     });\n             *\n             * </pre><div id=\"JXGb55d4608-5d71-4bc3-b332-18c15fbda8c3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGb55d4608-5d71-4bc3-b332-18c15fbda8c3', {\n             *             boundingbox: [-5,5,5,-5],\n             *             keepAspectRatio: true,\n             *             axis: true,\n             *             resize: {enabled: true, throttle: 200}\n             *         });\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             *\n             */\n            resize: {\n                enabled: true,\n                throttle: 10\n            },\n\n            /**\n             * Element which listens to move events of the pointing device.\n             * This allows to drag elements of a JSXGraph construction outside of the board.\n             * Especially, on mobile devices this enhances the user experience.\n             * However, it is recommended to allow dragging outside of the JSXGraph board only\n             * in certain constructions where users may not \"loose\" points outside of the board.\n             * Then points may become unreachable.\n             * <p>\n             * A situation where dragging outside of the board is uncritical is for example if\n             * only sliders are used to interact with the construction.\n             * <p>\n             * Possible values for this attributes are:\n             * <ul>\n             * <li> an element specified by document.getElementById('some id');\n             * <li> null: to use the JSXgraph container div element\n             * <li> document\n             * </ul>\n             *\n             * @name JXG.Board#moveTarget\n             * @type HTML node or document\n             * @default null\n             *\n             * @example\n             *     var board = JXG.JSXGraph.initBoard('jxgbox', {\n             *         boundingbox: [-5,5,5,-5],\n             *         axis: true,\n             *         moveTarget: document\n             *     });\n             *\n             * </pre><div id=\"JXG973457e5-c63f-4516-8570-743f2cc560e1\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG973457e5-c63f-4516-8570-743f2cc560e1',\n             *             {boundingbox: [-5,5,5,-5],\n             *             axis: true,\n             *             moveTarget: document\n             *         });\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             *\n             */\n            moveTarget: null,\n\n            /**\n             * Control the possibilities for a selection rectangle.\n             * Starting a selection event triggers the \"startselecting\" event.\n             * When the mouse pointer is released, the \"stopselecting\" event is fired.\n             * The \"stopselecting\" event must be supplied by the user.\n             * <p>\n             * Possible sub-attributes with default values are:\n             * <pre>\n             * selection: {\n             *   enabled: false,\n             *   name: 'selectionPolygon',\n             *   needShift: false,  // mouse selection needs pressing of the shift key\n             *   needCtrl: true,    // mouse selection needs pressing of the shift key\n             *   withLines: false,  // Selection polygon has border lines\n             *   vertices: {\n             *       visible: false\n             *   },\n             *   fillColor: '#ffff00',\n             *   visible: false      // Initial visibility. Should be set to false always\n             * }\n             * </pre>\n             * <p>\n             * Board events triggered by selection manipulation:\n             * 'startselecting', 'stopselecting', 'mousestartselecting', 'mousestopselecting',\n             * 'pointerstartselecting', 'pointerstopselecting', 'touchstartselecting', 'touchstopselecting'.\n             *\n             * @example\n             * board.on('stopselecting', function(){\n             *     var box = board.stopSelectionMode(),\n             *     // bbox has the coordinates of the selectionr rectangle.\n             *     // Attention: box[i].usrCoords have the form [1, x, y], i.e.\n             *     // are homogeneous coordinates.\n             *     bbox = box[0].usrCoords.slice(1).concat(box[1].usrCoords.slice(1));\n             *     // Set a new bounding box\n             *     board.setBoundingBox(bbox, false);\n             * });\n             *\n             * @name JXG.Board#selection\n             *\n             * @see JXG.Board#startSelectionMode\n             * @see JXG.Board#stopSelectionMode\n             *\n             * @type Object\n             * @default\n             */\n            selection: {\n                enabled: false,\n                name: 'selectionPolygon',\n                needShift: false,\n                needCtrl: true,\n                withLines: false,\n                vertices: {\n                    visible: false\n                },\n                fillColor: '#ffff00',\n                visible: false\n            },\n\n            /**\n             * If true, the infobox is shown on mouse/pen over for all points\n             * which have set their attribute showInfobox to 'inherit'.\n             * If a point has set its attribute showInfobox to false or true,\n             * that value will have priority over this value.\n             *\n             * @name JXG.Board#showInfobox\n             * @see Point#showInfobox\n             * @type Boolean\n             * @default true\n             */\n            showInfobox: true,\n\n            /**\n             * If enabled, user activities are logged in array \"board.userLog\".\n             * \n             * @name JXG.Board#showInfobox\n             * @type Object\n             * @default {enabled: false}\n             * \n             * @example\n             *     var board = JXG.JSXGraph.initBoard('jxgbox', {\n             *         boundingbox: [-5,5,5,-5],\n             *         logging: {enabled: true}\n             *     });\n             * @see JXG.Board#userLog\n             */\n            logging: {\n                enabled: false\n            }\n\n            /**#@-*/\n        },\n\n        /**\n         * Options that are used by the navigation bar.\n         *\n         * Default values are\n         * <pre>\n         * JXG.Option.navbar: {\n         *   strokeColor: '#333333',\n         *   fillColor: 'transparent',\n         *   highlightFillColor: '#aaaaaa',\n         *   padding: '2px',\n         *   position: 'absolute',\n         *   fontSize: '14px',\n         *   cursor: 'pointer',\n         *   zIndex: '100',\n         *   right: '5px',\n         *   bottom: '5px'\n         * },\n         * </pre>\n         * These settings are overruled by the CSS class 'JXG_navigation'.\n         * @deprecated\n         * @type Object\n         * @name JXG.Options#navbar\n         *\n         */\n        navbar: {\n            strokeColor: '#333333', //'#aaaaaa',\n            fillColor: 'transparent', //#f5f5f5',\n            highlightFillColor: '#aaaaaa',\n            padding: '2px',\n            position: 'absolute',\n            fontSize: '14px',\n            cursor: 'pointer',\n            zIndex: '100',\n            right: '5px',\n            bottom: '5px'\n            //border: 'none 1px black',\n            //borderRadius: '4px'\n        },\n\n         /*\n          *  Generic options used by {@link JXG.GeometryElement}\n          */\n        elements: {\n            // the following tag is a meta tag: http://code.google.com/p/jsdoc-toolkit/wiki/MetaTags\n\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * The stroke color of the given geometry element.\n             * @type String\n             * @name JXG.GeometryElement#strokeColor\n             * @see JXG.GeometryElement#highlightStrokeColor\n             * @see JXG.GeometryElement#strokeWidth\n             * @see JXG.GeometryElement#strokeOpacity\n             * @see JXG.GeometryElement#highlightStrokeOpacity\n             * @default {@link JXG.Options.elements.color#strokeColor}\n             */\n            strokeColor: Color.palette.blue,\n\n            /**\n             * The stroke color of the given geometry element when the user moves the mouse over it.\n             * @type String\n             * @name JXG.GeometryElement#highlightStrokeColor\n             * @see JXG.GeometryElement#strokeColor\n             * @see JXG.GeometryElement#strokeWidth\n             * @see JXG.GeometryElement#strokeOpacity\n             * @see JXG.GeometryElement#highlightStrokeOpacity\n             * @default {@link JXG.Options.elements.color#highlightStrokeColor}\n             */\n            highlightStrokeColor: '#c3d9ff',\n\n            /**\n             * The fill color of this geometry element.\n             * @type String\n             * @name JXG.GeometryElement#fillColor\n             * @see JXG.GeometryElement#highlightFillColor\n             * @see JXG.GeometryElement#fillOpacity\n             * @see JXG.GeometryElement#highlightFillOpacity\n             * @default {@link JXG.Options.elements.color#fillColor}\n             */\n            fillColor: Color.palette.red,\n\n            /**\n             * The fill color of the given geometry element when the mouse is pointed over it.\n             * @type String\n             * @name JXG.GeometryElement#highlightFillColor\n             * @see JXG.GeometryElement#fillColor\n             * @see JXG.GeometryElement#fillOpacity\n             * @see JXG.GeometryElement#highlightFillOpacity\n             * @default {@link JXG.Options.elements.color#highlightFillColor}\n             */\n            highlightFillColor: 'none',\n\n            /**\n             * Opacity for element's stroke color.\n             * @type Number\n             * @name JXG.GeometryElement#strokeOpacity\n             * @see JXG.GeometryElement#strokeColor\n             * @see JXG.GeometryElement#highlightStrokeColor\n             * @see JXG.GeometryElement#strokeWidth\n             * @see JXG.GeometryElement#highlightStrokeOpacity\n             * @default {@link JXG.Options.elements#strokeOpacity}\n             */\n            strokeOpacity: 1,\n\n            /**\n             * Opacity for stroke color when the object is highlighted.\n             * @type Number\n             * @name JXG.GeometryElement#highlightStrokeOpacity\n             * @see JXG.GeometryElement#strokeColor\n             * @see JXG.GeometryElement#highlightStrokeColor\n             * @see JXG.GeometryElement#strokeWidth\n             * @see JXG.GeometryElement#strokeOpacity\n             * @default {@link JXG.Options.elements#highlightStrokeOpacity}\n             */\n            highlightStrokeOpacity: 1,\n\n            /**\n             * Opacity for fill color.\n             * @type Number\n             * @name JXG.GeometryElement#fillOpacity\n             * @see JXG.GeometryElement#fillColor\n             * @see JXG.GeometryElement#highlightFillColor\n             * @see JXG.GeometryElement#highlightFillOpacity\n             * @default {@link JXG.Options.elements.color#fillOpacity}\n             */\n            fillOpacity: 1,\n\n            /**\n             * Opacity for fill color when the object is highlighted.\n             * @type Number\n             * @name JXG.GeometryElement#highlightFillOpacity\n             * @see JXG.GeometryElement#fillColor\n             * @see JXG.GeometryElement#highlightFillColor\n             * @see JXG.GeometryElement#fillOpacity\n             * @default {@link JXG.Options.elements.color#highlightFillOpacity}\n             */\n            highlightFillOpacity: 1,\n\n            /**\n             * Gradient type. Possible values are 'linear'. 'radial' or null.\n             *\n             * @example\n             *     var a = board.create('slider', [[0, -0.2], [3.5, -0.2], [0, 0, 2 * Math.PI]], {name: 'angle'});\n             *     var b = board.create('slider', [[0, -0.4], [3.5, -0.4], [0, 0, 1]], {name: 'offset1'});\n             *     var c = board.create('slider', [[0, -0.6], [3.5, -0.6], [0, 1, 1]], {name: 'offset2'});\n             *\n             *     var pol = board.create('polygon', [[0, 0], [4, 0], [4,4], [0,4]], {\n             *                 fillOpacity: 1,\n             *                 fillColor: 'yellow',\n             *                 gradient: 'linear',\n             *                 gradientSecondColor: 'blue',\n             *                 gradientAngle: function() { return a.Value(); },\n             *                 gradientStartOffset: function() { return b.Value(); },\n             *                 gradientEndOffset: function() { return c.Value(); },\n             *                 hasInnerPoints: true\n             *         });\n             *\n             * </pre><div id=\"JXG3d04b5fd-0cd4-4f49-8c05-4e9686cd7ff0\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG3d04b5fd-0cd4-4f49-8c05-4e9686cd7ff0',\n             *             {boundingbox: [-1.5, 4.5, 5, -1.5], axis: true, showcopyright: false, shownavigation: false});\n             *         var a = board.create('slider', [[0, -0.2], [3.5, -0.2], [0, 0, 2 * Math.PI]], {name: 'angle'});\n             *         var b = board.create('slider', [[0, -0.4], [3.5, -0.4], [0, 0, 1]], {name: 'offset1'});\n             *         var c = board.create('slider', [[0, -0.6], [3.5, -0.6], [0, 1, 1]], {name: 'offset2'});\n             *\n             *         var pol = board.create('polygon', [[0, 0], [4, 0], [4,4], [0,4]], {\n             *                     fillOpacity: 1,\n             *                     fillColor: 'yellow',\n             *                     gradient: 'linear',\n             *                     gradientSecondColor: 'blue',\n             *                     gradientAngle: function() { return a.Value(); },\n             *                     gradientStartOffset: function() { return b.Value(); },\n             *                     gradientEndOffset: function() { return c.Value(); },\n             *                     hasInnerPoints: true\n             *             });\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             * @example\n             *     var cx = board.create('slider', [[0, -.2], [3.5, -.2], [0, 0.5, 1]], {name: 'cx, cy'});\n             *     var fx = board.create('slider', [[0, -.4], [3.5, -.4], [0, 0.5, 1]], {name: 'fx, fy'});\n             *     var o1 = board.create('slider', [[0, -.6], [3.5, -.6], [0, 0.0, 1]], {name: 'offset1'});\n             *     var o2 = board.create('slider', [[0, -.8], [3.5, -.8], [0, 1, 1]], {name: 'offset2'});\n             *     var r = board.create('slider', [[0, -1], [3.5, -1], [0, 0.5, 1]], {name: 'r'});\n             *     var fr = board.create('slider', [[0, -1.2], [3.5, -1.2], [0, 0, 1]], {name: 'fr'});\n             *\n             *     var pol = board.create('polygon', [[0, 0], [4, 0], [4,4], [0,4]], {\n             *                 fillOpacity: 1,\n             *                 fillColor: 'yellow',\n             *                 gradient: 'radial',\n             *                 gradientSecondColor: 'blue',\n             *                 gradientCX: function() { return cx.Value(); },\n             *                 gradientCY: function() { return cx.Value(); },\n             *                 gradientR: function() { return r.Value(); },\n             *                 gradientFX: function() { return fx.Value(); },\n             *                 gradientFY: function() { return fx.Value(); },\n             *                 gradientFR: function() { return fr.Value(); },\n             *                 gradientStartOffset: function() { return o1.Value(); },\n             *                 gradientEndOffset: function() { return o2.Value(); },\n             *                 hasInnerPoints: true\n             *     });\n             *\n             * </pre><div id=\"JXG6081ca7f-0d09-4525-87ac-325a02fe2225\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG6081ca7f-0d09-4525-87ac-325a02fe2225',\n             *             {boundingbox: [-1.5, 4.5, 5, -1.5], axis: true, showcopyright: false, shownavigation: false});\n             *         var cx = board.create('slider', [[0, -.2], [3.5, -.2], [0, 0.5, 1]], {name: 'cx, cy'});\n             *         var fx = board.create('slider', [[0, -.4], [3.5, -.4], [0, 0.5, 1]], {name: 'fx, fy'});\n             *         var o1 = board.create('slider', [[0, -.6], [3.5, -.6], [0, 0.0, 1]], {name: 'offset1'});\n             *         var o2 = board.create('slider', [[0, -.8], [3.5, -.8], [0, 1, 1]], {name: 'offset2'});\n             *         var r = board.create('slider', [[0, -1], [3.5, -1], [0, 0.5, 1]], {name: 'r'});\n             *         var fr = board.create('slider', [[0, -1.2], [3.5, -1.2], [0, 0, 1]], {name: 'fr'});\n             *\n             *         var pol = board.create('polygon', [[0, 0], [4, 0], [4,4], [0,4]], {\n             *                     fillOpacity: 1,\n             *                     fillColor: 'yellow',\n             *                     gradient: 'radial',\n             *                     gradientSecondColor: 'blue',\n             *                     gradientCX: function() { return cx.Value(); },\n             *                     gradientCY: function() { return cx.Value(); },\n             *                     gradientR: function() { return r.Value(); },\n             *                     gradientFX: function() { return fx.Value(); },\n             *                     gradientFY: function() { return fx.Value(); },\n             *                     gradientFR: function() { return fr.Value(); },\n             *                     gradientStartOffset: function() { return o1.Value(); },\n             *                     gradientEndOffset: function() { return o2.Value(); },\n             *                     hasInnerPoints: true\n             *         });\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             *\n             * @type String\n             * @name JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientSecondColor\n             * @see JXG.GeometryElement#gradientSecondOpacity\n             * @default null\n             */\n            gradient: null,\n\n            /**\n             * Second color for gradient.\n             * @type String\n             * @name JXG.GeometryElement#gradientSecondColor\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientSecondOpacity\n             * @default '#ffffff'\n             */\n            gradientSecondColor: '#ffffff',\n\n            /**\n             * Opacity of second gradient color. Takes a value between 0 and 1.\n             * @type Number\n             * @name JXG.GeometryElement#gradientSecondOpacity\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientSecondColor\n             * @default 1\n             */\n            gradientSecondOpacity: 1,\n\n            /**\n             * The gradientStartOffset attribute is a number (ranging from 0 to 1) which indicates where the first gradient stop is placed,\n             * see the SVG specification for more information.\n             * For linear gradients, this attribute represents a location along the gradient vector.\n             * For radial gradients, it represents a percentage distance from (fx,fy) to the edge of the outermost/largest circle.\n             * @type Number\n             * @name JXG.GeometryElement#gradientStartOffset\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientEndOffset\n             * @default 0.0\n             */\n            gradientStartOffset: 0.0,\n\n            /**\n             * The gradientEndOffset attribute is a number (ranging from 0 to 1) which indicates where the second gradient stop is placed,\n             * see the SVG specification for more information.\n             * For linear gradients, this attribute represents a location along the gradient vector.\n             * For radial gradients, it represents a percentage distance from (fx,fy) to the edge of the outermost/largest circle.\n             * @type Number\n             * @name JXG.GeometryElement#gradientEndOffset\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientStartOffset\n             * @default 1.0\n             */\n            gradientEndOffset: 1.0,\n\n\n            /**\n             * Angle (in radians) of the gradiant in case the gradient is of type 'linear'.\n             * If the angle is 0, the first color is on the left and the second color is on the right.\n             * If the angle is &pi;/2 the first color is on top and the second color at the\n             * bottom.\n             * @type Number\n             * @name JXG.GeometryElement#gradientAngle\n             * @see JXG.GeometryElement#gradient\n             * @default 0\n             */\n            gradientAngle: 0,\n\n            /**\n             * From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient.\n             * The gradient will be drawn such that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle.\n             * For radial gradients in canvas this is the value 'x1'.\n             * Takes a value between 0 and 1.\n             * @type Number\n             * @name JXG.GeometryElement#gradientCX\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientCY\n             * @see JXG.GeometryElement#gradientR\n             * @default 0.5\n             */\n            gradientCX: 0.5,\n\n            /**\n             * From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient.\n             * The gradient will be drawn such that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle.\n             * For radial gradients in canvas this is the value 'y1'.\n             * Takes a value between 0 and 1.\n             * @type Number\n             * @name JXG.GeometryElement#gradientCY\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientCX\n             * @see JXG.GeometryElement#gradientR\n             * @default 0.5\n             */\n            gradientCY: 0.5,\n\n            /**\n             * From the SVG specification: ‘cx’, ‘cy’ and ‘r’ define the largest (i.e., outermost) circle for the radial gradient.\n             * The gradient will be drawn such that the 100% gradient stop is mapped to the perimeter of this largest (i.e., outermost) circle.\n             * For radial gradients in canvas this is the value 'r1'.\n             * Takes a value between 0 and 1.\n             * @type Number\n             * @name JXG.GeometryElement#gradientR\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientCX\n             * @see JXG.GeometryElement#gradientCY\n             * @default 0.5\n             */\n            gradientR: 0.5,\n\n            /**\n             * ‘fx’ and ‘fy’ define the focal point for the radial gradient.\n             * The gradient will be drawn such that the 0% gradient stop is mapped to (fx, fy).\n             * For radial gradients in canvas this is the value 'x0'.\n             * Takes a value between 0 and 1.\n             * @type Number\n             * @name JXG.GeometryElement#gradientFX\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientFY\n             * @see JXG.GeometryElement#gradientFR\n             * @default 0.5\n             */\n            gradientFX: 0.5,\n\n            /**\n             * y-coordinate of the circle center for the second color in case of gradient 'radial'. (The attribute fy in SVG)\n             * For radial gradients in canvas this is the value 'y0'.\n             * Takes a value between 0 and 1.\n             * @type Number\n             * @name JXG.GeometryElement#gradientFY\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientFX\n             * @see JXG.GeometryElement#gradientFR\n             * @default 0.5\n             */\n            gradientFY: 0.5,\n\n            /**\n             * This attribute defines the radius of the start circle of the radial gradient.\n             * The gradient will be drawn such that the 0% &lt;stop&gt; is mapped to the perimeter of the start circle.\n             * For radial gradients in canvas this is the value 'r0'.\n             * Takes a value between 0 and 1.\n             * @type Number\n             * @name JXG.GeometryElement#gradientFR\n             * @see JXG.GeometryElement#gradient\n             * @see JXG.GeometryElement#gradientFX\n             * @see JXG.GeometryElement#gradientFY\n             * @default 0.0\n             */\n            gradientFR: 0.0,\n\n            /**\n             * Transition duration (in milliseconds) for color and opacity\n             * changes. Works in SVG renderer, only.\n             * @type Number\n             * @name JXG.GeometryElement#transitionDuration\n             * @see JXG.GeometryElement#strokeColor\n             * @see JXG.GeometryElement#highlightStrokeColor\n             * @see JXG.GeometryElement#strokeOpacity\n             * @see JXG.GeometryElement#highlightStrokeOpacity\n             * @see JXG.GeometryElement#fillColor\n             * @see JXG.GeometryElement#highlightFillColor\n             * @see JXG.GeometryElement#fillOpacity\n             * @see JXG.GeometryElement#highlightFillOpacity\n             * @default {@link JXG.Options.elements#transitionDuration}\n             */\n            transitionDuration: 100,\n\n            /**\n             * Width of the element's stroke.\n             * @type Number\n             * @name JXG.GeometryElement#strokeWidth\n             * @see JXG.GeometryElement#strokeColor\n             * @see JXG.GeometryElement#highlightStrokeColor\n             * @see JXG.GeometryElement#strokeOpacity\n             * @see JXG.GeometryElement#highlightStrokeOpacity\n             * @default {@link JXG.Options.elements#strokeWidth}\n             */\n            strokeWidth: 2,\n\n            /**\n             * Width of the element's stroke when the mouse is pointed over it.\n             * @type Number\n             * @name JXG.GeometryElement#highlightStrokeWidth\n             * @see JXG.GeometryElement#strokeColor\n             * @see JXG.GeometryElement#highlightStrokeColor\n             * @see JXG.GeometryElement#strokeOpacity\n             * @see JXG.GeometryElement#highlightStrokeOpacity\n             * @see JXG.GeometryElement#highlightFillColor\n             * @default {@link JXG.Options.elements#strokeWidth}\n             */\n            highlightStrokeWidth: 2,\n\n            /**\n             * If true the element is fixed and can not be dragged around. The element\n             * will be repositioned on zoom and moveOrigin events.\n             * @type Boolean\n             * @default false\n             * @name JXG.GeometryElement#fixed\n             */\n            fixed: false,\n\n            /**\n             * If true the element is fixed and can not be dragged around. The element\n             * will even stay at its position on zoom and moveOrigin events.\n             * Only free elements like points, texts, curves can be frozen.\n             * @type Boolean\n             * @default false\n             * @name JXG.GeometryElement#frozen\n             */\n            frozen: false,\n\n            /**\n             * If true a label will display the element's name.\n             * @type Boolean\n             * @default false\n             * @name JXG.GeometryElement#withLabel\n             */\n            withLabel: false,\n\n            /**\n             * If false the element won't be visible on the board, otherwise it is shown.\n             * @type Boolean\n             * @name JXG.GeometryElement#visible\n             * @see JXG.GeometryElement#hideElement\n             * @see JXG.GeometryElement#showElement\n             * @default true\n             */\n            visible: true,\n\n            /**\n             * A private element will be inaccessible in certain environments, e.g. a graphical user interface.\n             * @default false\n             */\n            priv: false,\n\n            /**\n             * Display layer which will contain the element.\n             * @see JXG.Options#layer\n             * @default See {@link JXG.Options#layer}\n             */\n            layer: 0,\n\n            /**\n             * Determines the elements border-style.\n             * Possible values are:\n             * <ul><li>0 for a solid line</li>\n             * <li>1 for a dotted line</li>\n             * <li>2 for a line with small dashes</li>\n\n\n             * <li>3 for a line with medium dashes</li>\n             * <li>4 for a line with big dashes</li>\n             * <li>5 for a line with alternating medium and big dashes and large gaps</li>\n             * <li>6 for a line with alternating medium and big dashes and small gaps</li></ul>\n             * @type Number\n             * @name JXG.GeometryElement#dash\n             * @default 0\n             */\n            dash: 0,\n\n            /**\n             * If enabled:true the element will get a shadow.\n             *\n             * Customize the shadow of a (stroke) object. If the object's RGB color is [r,g,b], its opacity is op, and\n             * the parameters \"color\" is given as [r', g', b'] and \"opacity\" as op' the shadow will have\n             * RGB color [blend*r + r', blend*g + g', blend*b + b'] and its opacity will be equal to op * op'.\n             * Further, blur and offset can be adjusted.\n             *\n             * Only available with SVG, not with canvas.\n             *\n             * @type Object\n             * @name JXG.GeometryElement#shadow\n             * @default shadow: {\n             *   enabled: false,\n             *   color: [0, 0, 0],\n             *   opacity: 1,\n             *   blur: 3,\n             *   blend: 0.1,\n             *   offset: [5, 5]\n             * }\n             *\n             * @example\n             * board.options.line.strokeWidth = 2\n             * // No shadow\n             * var li1 = board.create('line', [[-2, 5], [2, 6]], {strokeColor: 'red', shadow: false});\n             *\n             * // Default shadow\n             * var li2 = board.create('line', [[-2, 3], [2, 4]], {strokeColor: 'red', shadow: true});\n             *\n             * // No shadow\n             * var li3 = board.create('line', [[-2, 1], [2, 2]], {strokeColor: 'blue', shadow: {enabled: false}});\n             *\n             * // Shadow uses same color as line\n             * var li4 = board.create('line', [[-2, -1], [2, 0]], {strokeColor: 'blue',\n             *             shadow: {enabled: true, color: '#000000', blend: 1}\n             *         });\n             *\n             * // Shadow color as a mixture between black and the line color, additionally set opacity\n             * var li5 = board.create('line', [[-2, -3], [2, -2]], {strokeColor: 'blue',\n             *             shadow: {enabled: true, color: '#000000', blend: 0.5, opacity: 0.5}\n             *         });\n             *\n             * // Use different value for blur and offset [dx, dy]\n             * var li6 = board.create('line', [[-2, -5], [2, -4]], {strokeColor: 'blue',\n             *             shadow: {enabled: true, offset:[0, 25], blur: 6}\n             *         });\n             *\n             * </pre><div id=\"JXG1185a9fa-0fa5-425f-8c15-55b56e1be958\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG1185a9fa-0fa5-425f-8c15-55b56e1be958',\n             *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n             *     board.options.line.strokeWidth = 2\n             *     // No shadow\n             *     var li1 = board.create('line', [[-2, 5], [2, 6]], {strokeColor: 'red', shadow: false});\n             *\n             *     // Default shadow\n             *     var li2 = board.create('line', [[-2, 3], [2, 4]], {strokeColor: 'red', shadow: true});\n             *\n             *     // No shadow\n             *     var li3 = board.create('line', [[-2, 1], [2, 2]], {strokeColor: 'blue', shadow: {enabled: false}});\n             *\n             *     // Shadow uses same color as line\n             *     var li4 = board.create('line', [[-2, -1], [2, 0]], {strokeColor: 'blue',\n             *                 shadow: {enabled: true, color: '#000000', blend: 1}\n             *             });\n             *\n             *     // Shadow color as a mixture between black and the line color, additionally set opacity\n             *     var li5 = board.create('line', [[-2, -3], [2, -2]], {strokeColor: 'blue',\n             *                 shadow: {enabled: true, color: '#000000', blend: 0.5, opacity: 0.5}\n             *             });\n             *\n             *     // Use different value for blur and offset [dx, dy]\n             *     var li6 = board.create('line', [[-2, -5], [2, -4]], {strokeColor: 'blue',\n             *                 shadow: {enabled: true, offset:[0, 25], blur: 6}\n             *             });\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             */\n            shadow: {\n                enabled: false,\n                color: [0, 0, 0],\n                opacity: 1,\n                blur: 3,\n                blend: 0.1,\n                offset: [5, 5]\n            },\n\n            /**\n             * If true the element will be traced, i.e. on every movement the element will be copied\n             * to the background. Use {@link JXG.GeometryElement#clearTrace} to delete the trace elements.\n             *\n             * The calling of element.setAttribute({trace:false}) additionally\n             * deletes all traces of this element. By calling\n             * element.setAttribute({trace:'pause'})\n             * the removal of already existing traces can be prevented.\n             * @see JXG.GeometryElement#clearTrace\n             * @see JXG.GeometryElement#traces\n             * @see JXG.GeometryElement#numTraces\n             * @type Boolean|String\n             * @default false\n             * @name JXG.GeometryElement#trace\n             */\n            trace: false,\n\n            /**\n             * Extra visual properties for traces of an element\n             * @type Object\n             * @see JXG.GeometryElement#trace\n             * @name JXG.GeometryElement#traceAttributes\n             */\n            traceAttributes: {},\n\n            /**\n             *\n             * @type Boolean\n             * @default true\n             * @name JXG.GeometryElement#highlight\n             */\n            highlight: true,\n\n            /**\n             * If this is set to true, the element is updated in every update\n             * call of the board. If set to false, the element is updated only after\n             * zoom events or more generally, when the bounding box has been changed.\n             * Examples for the latter behaviour should be axes.\n             * @type Boolean\n             * @default true\n             * @see JXG.GeometryElement#needsRegularUpdate\n             * @name JXG.GeometryElement#needsRegularUpdate\n             */\n            needsRegularUpdate: true,\n\n            /**\n             * Snaps the element or its parents to the grid. Currently only relevant for points, circles,\n             * and lines. Points are snapped to grid directly, on circles and lines it's only the parent\n             * points that are snapped\n             * @type Boolean\n             * @default false\n             * @name JXG.GeometryElement#snapToGrid\n             */\n            snapToGrid: false,\n\n            /**\n             * Determines whether two-finger manipulation of this object may change its size.\n             * If set to false, the object is only rotated and translated.\n             * <p>\n             * In case the element is a horizontal or vertical line having ticks, \"scalable:true\"\n             * enables zooming of the board by dragging ticks lines. This feature is enabled,\n             * for the ticks element of the line element the attribute \"fixed\" has to be false\n             * and the line element's scalable attribute has to be true.\n             * <p>\n             * In case the element is a polygon or line and it has the attribute \"scalable:false\",\n             * moving the element with two fingers results in a rotation or translation.\n             * <p>\n             * If an element is set to be neither scalable nor rotatable, it can only be translated.\n             *\n             * @type Boolean\n             * @default true\n             * @name JXG.GeometryElement#scalable\n             * @see JXG.Ticks#fixed\n             * @see JXG.GeometryElement#rotatable\n             */\n            scalable: true,\n\n            /**\n             * Determines whether two-finger manipulation may rotate this object.\n             * If set to false, the object can only be scaled and translated.\n             * <p>\n             * In case the element is a polygon or line and it has the attribute \"rotatable:false\",\n             * moving the element with two fingers results in a rotation or translation.\n             * <p>\n             * If an element is set to be neither scalable nor rotatable, it can only be translated.\n             *\n             * @type Boolean\n             * @default true\n             * @name JXG.GeometryElement#rotatable\n             * @see JXG.GeometryElement#scalable\n             */\n            rotatable: true,\n\n            /**\n             * If the element is dragged it will be moved on mousedown or touchstart to the\n             * top of its layer. Works only for SVG renderer and for simple elements\n             * consisting of one SVG node.\n             * @example\n             * var li1 = board.create('line', [1, 1, 1], {strokeWidth: 20, dragToTopOfLayer: true});\n             * var li2 = board.create('line', [1, -1, 1], {strokeWidth: 20, strokeColor: 'red'});\n             *\n             * </pre><div id=\"JXG38449fee-1ab4-44de-b7d1-43caa1f50f86\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG38449fee-1ab4-44de-b7d1-43caa1f50f86',\n             *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n             *     var li1 = board.create('line', [1, 1, 1], {strokeWidth: 20, dragToTopOfLayer: true});\n             *     var li2 = board.create('line', [1, -1, 1], {strokeWidth: 20, strokeColor: 'red'});\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             * @type Boolean\n             * @default false\n             * @name JXG.GeometryElement#dragToTopOfLayer\n             */\n            dragToTopOfLayer: false,\n\n            /**\n             * Precision options for JSXGraph elements.\n             * This attributes takes either the value 'inherit' or an object of the form:\n             * <pre>\n             * precision: {\n             *      touch: 30,\n             *      mouse: 4,\n             *      pen: 4\n             * }\n             * </pre>\n             *\n             * In the first case, the global, JSXGraph-wide values of JXGraph.Options.precision\n             * are taken.\n             *\n             * @type {String|Object}\n             * @name JXG.GeometryElement#precision\n             * @see JXG.Options#precision\n             * @default 'inherit'\n             */\n            precision: 'inherit',\n\n            /*draft options */\n            draft: {\n                /**\n                 * If true the element will be drawn in grey scale colors to visualize that it's only a draft.\n                 * @type Boolean\n                 * @name JXG.GeometryElement#draft\n                 * @default {@link JXG.Options.elements.draft#draft}\n                 */\n                draft: false,\n                strokeColor: '#565656',\n                fillColor: '#565656',\n                strokeOpacity: 0.8,\n                fillOpacity: 0.8,\n                strokeWidth: 1\n            },\n\n            /**\n             * @private\n             * By default, an element is not a label. Do not change this.\n             */\n            isLabel: false,\n\n            /**\n             * Controls if an element can get the focus with the tab key.\n             * tabindex corresponds to the HTML attribute of the same name.\n             * See <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\">descriptiona at MDN</a>.\n             * The additional value null completely disables focus of an element.\n             * The value will be ignored if keyboard control of the board is not enabled or\n             * the element is fixed or not visible.\n             *\n             * @name JXG.GeometryElement#tabindex\n             * @type Number\n             * @default 0\n             * @see JXG.Board#keyboard\n             * @see JXG.GeometryElement#fixed\n             * @see JXG.GeometryElement#visible\n             */\n            tabindex: 0\n\n            // close the meta tag\n            /**#@-*/\n        },\n\n         /*\n          *  Generic options used by {@link JXG.Ticks}\n          */\n        ticks: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * A function that expects two {@link JXG.Coords}, the first one representing the coordinates of the\n             * tick that is to be labeled, the second one the coordinates of the center (the tick with position 0).\n             * The third parameter is a null, number or a string. In the latter two cases, this value is taken.\n             * Returns a string.\n             *\n             * @type function\n             * @name Ticks#generateLabelText\n             */\n            generateLabelText: null,\n\n            /**\n             * A function that expects two {@link JXG.Coords}, the first one representing the coordinates of the\n             * tick that is to be labeled, the second one the coordinates of the center (the tick with position 0).\n             *\n             * @deprecated Use {@link JGX.Options@generateLabelText}\n             * @type function\n             * @name Ticks#generateLabelValue\n             */\n            generateLabelValue: null,\n\n            /**\n             * Draw labels yes/no\n             *\n             * @type Boolean\n             * @name Ticks#drawLabels\n             * @default false\n             */\n            drawLabels: false,\n\n            /**\n             * Attributes for the ticks labels\n             *\n             * @name Ticks#label\n             * @type Object\n             * @default {}\n             *\n             */\n            label: {\n            },\n\n            /**\n            * Format tick labels that were going to have scientific notation\n            * like 5.00e+6 to look like 5•10⁶.\n            *\n            * @example\n            * var board = JXG.JSXGraph.initBoard(\"jxgbox\", {\n            *     boundingbox: [-500000, 500000, 500000, -500000],\n            *     axis: true,\n            *     defaultAxes: {\n            *         x: {\n            *             scalable: true,\n            *             ticks: {\n            *                 beautifulScientificTickLabels: true\n            *           },\n            *         },\n            *         y: {\n            *             scalable: true,\n            *             ticks: {\n            *                 beautifulScientificTickLabels: true\n            *           },\n            *         }\n            *     },\n            * });\n            *\n            * </pre><div id=\"JXGc1e46cd1-e025-4002-80aa-b450869fdaa2\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n            * <script type=\"text/javascript\">\n            *     (function() {\n            *     var board = JXG.JSXGraph.initBoard('JXGc1e46cd1-e025-4002-80aa-b450869fdaa2', {\n            *         boundingbox: [-500000, 500000, 500000, -500000],\n            *         showcopyright: false, shownavigation: false,\n            *         axis: true,\n            *         defaultAxes: {\n            *             x: {\n            *                 scalable: true,\n            *                 ticks: {\n            *                     beautifulScientificTickLabels: true\n            *               },\n            *             },\n            *             y: {\n            *                 scalable: true,\n            *                 ticks: {\n            *                     beautifulScientificTickLabels: true\n            *               },\n            *             }\n            *         },\n            *     });\n            *\n            *     })();\n            *\n            * </script><pre>\n            *\n            * @name Ticks#beautifulScientificTickLabels\n            * @type Boolean\n            * @default false\n            */\n            beautifulScientificTickLabels: false,\n\n            /**\n             * Use the unicode character 0x2212, i.e. the HTML entity &amp;minus; as minus sign.\n             * That is &minus;1 instead of -1.\n             *\n             * @type Boolean\n             * @name Ticks#useUnicodeMinus\n             * @default true\n             */\n            useUnicodeMinus: true,\n\n            /**\n             * Determine the position of the tick with value 0. 'left' means point1 of the line, 'right' means point2,\n             * and 'middle' is equivalent to the midpoint of the defining points. This attribute is ignored if the parent\n             * line is of type axis.\n             *\n             * @type String\n             * @name Ticks#anchor\n             * @default 'left'\n             */\n            anchor: 'left',\n\n            /**\n             * Draw the zero tick, that lies at line.point1?\n             *\n             * @type Boolean\n             * @name Ticks#drawZero\n             * @default false\n             */\n            drawZero: false,\n\n            /**\n             * If the distance between two ticks is too big we could insert new ticks. If insertTicks\n             * is <tt>true</tt>, we'll do so, otherwise we leave the distance as is.\n             * This option is ignored if equidistant is false. In the example below the distance between\n             * two ticks is given as <tt>1</tt> but because insertTicks is set to true many ticks will\n             * be omitted in the rendering process to keep the display clear.\n             *\n             * @type Boolean\n             * @name Ticks#insertTicks\n             * @see Ticks#minTicksDistance\n             * @default false\n             * @example\n             * // Create an axis providing two coord pairs.\n             *   var p1 = board.create('point', [0, 0]);\n             *   var p2 = board.create('point', [50, 25]);\n             *   var l1 = board.create('line', [p1, p2]);\n             *   var t = board.create('ticks', [l1, 1], {\n             *      insertTicks: true,\n             *      majorHeight: -1,\n             *      label: {\n             *          offset: [4, -9]\n             *      },\n             *      drawLabels: true\n             *  });\n             * </pre><div class=\"jxgbox\" id=\"JXG2f6fb842-40bd-4223-aa28-3e9369d2097f\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             * (function () {\n             *   var board = JXG.JSXGraph.initBoard('JXG2f6fb842-40bd-4223-aa28-3e9369d2097f', {boundingbox: [-100, 70, 70, -100], showcopyright: false, shownavigation: false});\n             *   var p1 = board.create('point', [0, 0]);\n             *   var p2 = board.create('point', [50, 25]);\n             *   var l1 = board.create('line', [p1, p2]);\n             *   var t = board.create('ticks', [l1, 1], {insertTicks: true, majorHeight: -1, label: {offset: [4, -9]}, drawLabels: true});\n             * })();\n             * </script><pre>\n             */\n            insertTicks: false,\n\n            /**\n             * Minimum distance in pixel of equidistant ticks in case insertTicks==true.\n             * @name Ticks#minTicksDistance\n             * @type: Number\n             * @default: 10\n             * @see Ticks#insertTicks\n             */\n            minTicksDistance: 10,\n\n            /**\n             * Total height of a minor tick. If negative the full height of the board is taken.\n             *\n             * @type Number\n             * @name Ticks#minorHeight\n             * @default 4\n             */\n            minorHeight: 4,\n\n            /**\n             * Total height of a major tick. If negative the full height of the board is taken.\n             *\n             * @type Number\n             * @name Ticks#majorHeight\n             * @default 10\n             */\n            majorHeight: 10,\n\n            /**\n             * Decides in which direction minor ticks are visible. Possible values are either the constants\n             * 0=false or 1=true or a function returning 0 or 1.\n             *\n             * In case of [0,1] the tick is only visible to the right of the line. In case of\n             * [1,0] the tick is only visible to the left of the line.\n             *\n             * @type Array\n             * @name Ticks#tickEndings\n             * @see Ticks#majorTickEndings\n             * @default [1, 1]\n             */\n            tickEndings: [1, 1],\n\n            /**\n             * Decides in which direction major ticks are visible. Possible values are either the constants\n             * 0=false or 1=true or a function returning 0 or 1.\n             *\n             * In case of [0,1] the tick is only visible to the right of the line. In case of\n             * [1,0] the tick is only visible to the left of the line.\n             *\n             * @type Array\n             * @name Ticks#majorTickEndings\n             * @see Ticks#tickEndings\n             * @default [1, 1]\n             */\n            majorTickEndings: [1, 1],\n\n            /**\n             * If true, ignore the tick endings attribute for infinite (full height) ticks.\n             * This affects major and minor ticks.\n             *\n             * @type Boolean\n             * @name Ticks#ignoreInfiniteTickEndings\n             * @see Ticks#tickEndings\n             * @see Ticks#majorTickEndings\n             * @default true\n             */\n            ignoreInfiniteTickEndings: true,\n\n            /**\n             * The number of minor ticks between two major ticks.\n             * @type Number\n             * @name Ticks#minorTicks\n             * @default 4\n             */\n            minorTicks: 4,\n\n            /**\n             * By default, i.e. if ticksPerLabel==false, labels are generated for major ticks, only.\n             * If ticksPerLabel is set to a(n integer) number, this denotes the number of minor ticks\n             * between two labels.\n             *\n             * @type {Number|Boolean}\n             * @name Ticks#ticksPerLabel\n             * @default false\n             *\n             * @example\n             * const board = JXG.JSXGraph.initBoard('jxgbox', {\n             *     boundingbox: [-4, 4, 4, -4],\n             *     axis: true,\n             *     defaultAxes: {\n             *         x: {\n             *             ticks: {\n             *                 minorTicks: 7,\n             *                 ticksPerLabel: 4,\n             *                 minorHeight: 20,\n             *             }\n             *         },\n             *         y: {\n             *             ticks: {\n             *                 minorTicks: 3,\n             *                 ticksPerLabel: 2,\n             *                 minorHeight: 20\n             *             }\n             *         }\n             *     }\n             * });\n             *\n             * </pre><div id=\"JXGbc45a421-c867-4b0a-9b8d-2b2576020690\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGbc45a421-c867-4b0a-9b8d-2b2576020690',\n             *             {showcopyright: false, shownavigation: false,\n             *              boundingbox: [-4, 4, 4, -4],\n             *         axis: true,\n             *         defaultAxes: {\n             *             x: {\n             *                 ticks: {\n             *                     minorTicks: 7,\n             *                     ticksPerLabel: 4,\n             *                     minorHeight: 20,\n             *                 }\n             *             },\n             *             y: {\n             *                 ticks: {\n             *                     minorTicks: 3,\n             *                     ticksPerLabel: 2,\n             *                     minorHeight: 20\n             *                 }\n             *             }\n             *         }\n             *     });\n             *     })();\n             *\n             * </script><pre>\n             */\n            ticksPerLabel: false,\n\n            /**\n             * Scale the ticks but not the tick labels.\n             * @type Number\n             * @default 1\n             * @name Ticks#scale\n             * @see Ticks#scaleSymbol\n             */\n            scale: 1,\n\n            /**\n             * A string that is appended to every tick, used to represent the scale\n             * factor given in {@link Ticks#scale}.\n             *\n             * @type String\n             * @default ''\n             * @name Ticks#scaleSymbol\n             * @see Ticks#scale\n             */\n            scaleSymbol: '',\n\n            /**\n             * User defined labels for special ticks. Instead of the i-th tick's position, the i-th string stored in this array\n             * is shown. If the number of strings in this array is less than the number of special ticks, the tick's position is\n             * shown as a fallback.\n             *\n             * @type Array\n             * @name Ticks#labels\n             * @default []\n             */\n            labels: [],\n\n            /**\n             * The maximum number of characters a tick label can use.\n             *\n             * @type Number\n             * @name Ticks#maxLabelLength\n             * @see Ticks#precision\n             * @default 5\n             */\n            maxLabelLength: 5,\n\n            /**\n             * If a label exceeds {@link Ticks#maxLabelLength} this determines the precision used to shorten the tick label.\n             * Replaced by the digits attribute.\n             *\n             * @type Number\n             * @name Ticks#precision\n             * @see Ticks#maxLabelLength\n             * @see Ticks#digits\n             * @deprecated\n             * @default 3\n             */\n            precision: 3,\n\n            /**\n             * If a label exceeds {@link Ticks#maxLabelLength} this determines the number of digits used to shorten the tick label.\n             *\n             * @type Number\n             * @name Ticks#digits\n             * @see Ticks#maxLabelLength\n             * @deprecated\n             * @default 3\n             */\n            digits: 3,\n\n            /**\n             * The default distance (in user coordinates, not  pixels) between two ticks. Please be aware that this value does not have\n             * to be used if {@link Ticks#insertTicks} is set to true.\n             *\n             * @type Number\n             * @name Ticks#ticksDistance\n             * @see Ticks#insertTicks\n             * @default 1\n             */\n            ticksDistance: 1,\n\n            /**\n             * Tick face for ticks of finite length.  By default (face: '|') this is a straight line.\n             * Possible other values are '<' and '>'. These faces are used in\n             * {@link JXG.Hatch} for hatch marking parallel lines.\n             * @type String\n             * @name{Ticks#face}\n             * @see hatch\n             * @default '|'\n             * @example\n             *   var p1 = board.create('point', [0, 3]);\n             *   var p2 = board.create('point', [1, 3]);\n             *   var l1 = board.create('line', [p1, p2]);\n             *   var t = board.create('ticks', [l1], {ticksDistance: 2, face: '>'});\n             *\n             * </pre><div id=\"JXG950a568a-1264-4e3a-b61d-b6881feecf4b\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG950a568a-1264-4e3a-b61d-b6881feecf4b',\n             *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n             *       var p1 = board.create('point', [0, 3]);\n             *       var p2 = board.create('point', [1, 3]);\n             *       var l1 = board.create('line', [p1, p2]);\n             *       var t = board.create('ticks', [l1], {ticksDistance: 2, face: '>'});\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             */\n            face: '|',\n\n            strokeOpacity: 1,\n            strokeWidth: 1,\n            strokeColor: '#000000',\n            highlightStrokeColor: '#888888',\n            fillColor: 'none',\n            highlightFillColor: 'none',\n            visible: 'inherit',\n\n            /**\n             * Whether line boundaries should be counted or not in the lower and upper bounds when\n             * creating ticks.\n             *\n             * @type Boolean\n             * @name Ticks#includeBoundaries\n             * @default false\n             */\n            includeBoundaries: false,\n\n            /**\n             * Set the ticks type.\n             * Possible values are 'linear' or 'polar'.\n             *\n             * @type String\n             * @name Ticks#type\n             * @default 'linear'\n             */\n            type: 'linear'\n\n            // close the meta tag\n            /**#@-*/\n        },\n\n         /*\n          *  Generic options used by {@link JXG.Hatch}\n          */\n        hatch: {\n            drawLabels: false,\n            drawZero: true,\n            majorHeight: 20,\n            anchor: 'middle',\n            face: '|',\n            strokeWidth: 2,\n            strokeColor: Color.palette.blue,\n            /**\n             * The default distance (in user coordinates, not  pixels) between two hatch symbols. \n             * \n             * @type Number\n             * @name Hatch#ticksDistance\n             * @default 0.2\n             */\n             ticksDistance: 0.2\n        },\n\n        /**\n         * Precision options, defining how close a pointer device (mouse, finger, pen) has to be\n         * to an object such that the object is highlighted or can be dragged.\n         * These values are board-wide and can be overwritten for individual elements by\n         * changing their precision attribute.\n         *\n         * The default values are\n         * <pre>\n         * JXG.Options.precision: {\n         *   touch: 30,\n         *   touchMax: 100,\n         *   mouse: 4,\n         *   pen: 4,\n         *   epsilon: 0.0001,\n         *   hasPoint: 4\n         * }\n         * </pre>\n         *\n         * @type Object\n         * @name JXG.Options#precision\n         * @see JXG.GeometryElement#precision\n         */\n        precision: {\n            touch: 30,\n            touchMax: 100,\n            mouse: 4,\n            pen: 4,\n            epsilon: 0.0001, // Unused\n            hasPoint: 4\n        },\n\n        /**\n         * Default ordering of the layers.\n         * The numbering starts from 0 and the highest layer number is numlayers-1.\n         *\n         * The default values are\n         * <pre>\n         * JXG.Options.layer: {\n         *   numlayers: 20, // only important in SVG\n         *   text: 9,\n         *   point: 9,\n         *   glider: 9,\n         *   arc: 8,\n         *   line: 7,\n         *   circle: 6,\n         *   curve: 5,\n         *   turtle: 5,\n         *   polygon: 3,\n         *   sector: 3,\n         *   angle: 3,\n         *   integral: 3,\n         *   axis: 2,\n         *   ticks: 2,\n         *   grid: 1,\n         *   image: 0,\n         *   trace: 0\n         * }\n         * </pre>\n         * @type Object\n         * @name JXG.Options#layer\n         */\n        layer: {\n            numlayers: 20, // only important in SVG\n            unused9: 19,\n            unused8: 18,\n            unused7: 17,\n            unused6: 16,\n            unused5: 15,\n            unused4: 14,\n            unused3: 13,\n            unused2: 12,\n            unused1: 11,\n            unused0: 10,\n            text: 9,\n            point: 9,\n            glider: 9,\n            arc: 8,\n            line: 7,\n            circle: 6,\n            curve: 5,\n            turtle: 5,\n            polygon: 3,\n            sector: 3,\n            angle: 3,\n            integral: 3,\n            axis: 2,\n            ticks: 2,\n            grid: 1,\n            image: 0,\n            trace: 0\n        },\n\n        /* special angle options */\n        angle: {\n            /**#@+\n             * @visprop\n             */\n\n            withLabel: true,\n\n            /**\n             * Radius of the sector, displaying the angle.\n             * The radius can be given as number (in user coordinates)\n             * or as string 'auto'. In the latter case, the angle\n             * is set to an value between 20 and 50 px.\n             *\n             * @type {Number|String}\n             * @name Angle#radius\n             * @default 'auto'\n             * @visprop\n             */\n            radius: 'auto',\n\n            /**\n             * Display type of the angle field. Possible values are\n             * 'sector' or 'sectordot' or 'square' or 'none'.\n             *\n             * @type String\n             * @default 'sector'\n             * @name Angle#type\n             * @visprop\n             */\n            type: 'sector',\n\n            /**\n             * Display type of the angle field in case of a right angle. Possible values are\n             * 'sector' or 'sectordot' or 'square' or 'none'.\n             *\n             * @type String\n             * @default square\n             * @name Angle#orthoType\n             * @see Angle#orthoSensitivity\n             * @visprop\n             */\n            orthoType: 'square',\n\n            /**\n             * Sensitivity (in degrees) to declare an angle as right angle.\n             * If the angle measure is inside this distance from a rigth angle, the orthoType\n             * of the angle is used for display.\n             *\n             * @type Number\n             * @default 1.0\n             * @name Angle#orthoSensitivity\n             * @see Angle#orthoType\n             * @visprop\n             */\n            orthoSensitivity: 1.0,\n\n            fillColor: Color.palette.orange,\n            highlightFillColor: Color.palette.orange,\n            strokeColor: Color.palette.orange,\n            // fillColor: '#ff7f00',\n            // highlightFillColor: '#ff7f00',\n            // strokeColor: '#ff7f00',\n\n            fillOpacity: 0.3,\n            highlightFillOpacity: 0.3,\n\n            /**\n             * @deprecated\n             */\n            radiuspoint: {\n                withLabel: false,\n                visible: false,\n                name: ''\n            },\n\n            /**\n             * @deprecated\n             */\n            pointsquare: {\n                withLabel: false,\n                visible: false,\n                name: ''\n            },\n\n            dot: {\n                visible: false,\n                strokeColor: 'none',\n                fillColor: '#000000',\n                size: 2,\n                face: 'o',\n                withLabel: false,\n                name: ''\n            },\n\n            label: {\n                position: 'top',\n                offset: [0, 0],\n                strokeColor: Color.palette.blue\n            },\n\n            /**\n             * Attributes for sub-element arc. In general, the arc will run through the first point and\n             * thus will not have the same radius as the angle sector.\n             *\n             * @type Arc\n             * @name Angle#arc\n             * @default '{visible:false}'\n             */\n            arc: {\n                visible: false,\n                fillColor: 'none'\n            },\n\n            /**#@-*/\n        },\n\n        /* special arc options */\n        arc: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Type of arc. Possible values are 'minor', 'major', and 'auto'.\n             *\n             * @type String\n             * @name Arc#selection\n             * @default 'auto'\n             */\n            selection: 'auto',\n\n            /**\n             * If <tt>true</tt>, moving the mouse over inner points triggers hasPoint.\n             *\n             * @see JXG.GeometryElement#hasPoint\n             * @name Arc#hasInnerPoints\n             * @type Boolean\n             * @default false\n             */\n            hasInnerPoints: false,\n\n            label: {\n                anchorX: 'auto',\n                anchorY: 'auto'\n            },\n            firstArrow: false,\n            lastArrow: false,\n            fillColor: 'none',\n            highlightFillColor: 'none',\n            strokeColor: Color.palette.blue,\n            highlightStrokeColor: '#c3d9ff',\n            useDirection: false,\n\n            /**\n             * Attributes for center point.\n             *\n             * @type Point\n             * @name Arc#center\n             */\n            center: {\n            },\n\n            /**\n             * Attributes for radius point.\n             *\n             * @type Point\n             * @name Arc#radiusPoint\n             */\n            radiusPoint: {\n            },\n\n            /**\n             * Attributes for angle point.\n             *\n             * @type Point\n             * @name Arc#anglePoint\n             */\n            anglePoint: {\n            }\n\n            /**#@-*/\n        },\n\n        /* special arrow options */\n        arrow: {\n            /**#@+\n             * @visprop\n             */\n\n            firstArrow: false,\n\n            lastArrow: {\n                type: 1,\n                highlightSize: 6,\n                size: 6\n            }\n\n            /**#@-*/\n        },\n\n        /* special axis options */\n        axis: {\n            /**#@+\n             * @visprop\n             */\n\n            name: '',                            // By default, do not generate names for axes.\n            needsRegularUpdate: false,           // Axes only updated after zooming and moving of the origin.\n            strokeWidth: 1,\n            lastArrow: {\n                type: 1,\n                highlightSize: 8,\n                size: 8\n            },\n            strokeColor: '#666666',\n            highlightStrokeWidth: 1,\n            highlightStrokeColor: '#888888',\n\n\n            /**\n             * Show / hide ticks.\n             *\n             * Deprecated. Suggested alternative is \"ticks: {visible: false}\"\n             *\n             * @type Boolean\n             * @name Axis#withTicks\n             * @default true\n             * @deprecated\n             */\n            withTicks: true,\n            straightFirst: true,\n            straightLast: true,\n            margin: -4,\n            withLabel: false,\n            scalable: false,\n\n            /**\n             * Attributes for ticks of the axis.\n             *\n             * @type Ticks\n             * @name Axis#ticks\n             */\n            ticks: {\n                label: {\n                    offset: [4, -12 + 3],     // This seems to be a good offset for 12 point fonts\n                    parse: false,\n                    needsRegularUpdate: false,\n                    display: 'internal',\n                    visible: 'inherit',\n                    layer: 9\n                },\n                visible: 'inherit',\n                needsRegularUpdate: false,\n                strokeWidth: 1,\n                strokeColor: '#666666',\n                highlightStrokeColor: '#888888',\n                drawLabels: true,\n                drawZero: false,\n                insertTicks: true,\n                minTicksDistance: 5,\n                minorHeight: 10,          // if <0: full width and height\n                majorHeight: -1,          // if <0: full width and height\n                tickEndings: [0, 1],\n                majorTickEndings: [1, 1],\n                minorTicks: 4,\n                ticksDistance: 1,         // TODO doc\n                strokeOpacity: 0.25\n            },\n\n            /**\n             * Attributes for first point the axis.\n             *\n             * @type Point\n             * @name Axis#point1\n             */\n            point1: {                  // Default values for point1 if created by line\n                needsRegularUpdate: false,\n                visible: false\n            },\n\n            /**\n             * Attributes for second point the axis.\n             *\n             * @type Point\n             * @name Axis#point2\n             */\n            point2: {                  // Default values for point2 if created by line\n                needsRegularUpdate: false,\n                visible: false\n            },\n\n            tabindex: -1,\n\n            /**\n             * Attributes for the axis label.\n             *\n             * @type Label\n             * @name Axis#label\n             */\n            label: {\n                position: 'lft',\n                offset: [10, 10]\n            }\n            /**#@-*/\n        },\n\n        /* special options for angle bisector of 3 points */\n        bisector: {\n            /**#@+\n             * @visprop\n             */\n\n            strokeColor: '#000000', // Bisector line\n\n            /**\n             * Attributes for the helper point of the bisector.\n             *\n             * @type Point\n             * @name Bisector#point\n             */\n            point: {               // Bisector point\n                visible: false,\n                fixed: false,\n                withLabel: false,\n                name: ''\n            }\n\n            /**#@-*/\n        },\n\n        /* special options for the 2 bisectors of 2 lines */\n        bisectorlines: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Attributes for first line.\n             *\n             * @type Line\n             * @name Bisectorlines#line1\n             */\n            line1: {               //\n                strokeColor: '#000000'\n            },\n\n            /**\n             * Attributes for second line.\n             *\n             * @type Line\n             * @name Bisectorlines#line2\n             */\n            line2: {               //\n                strokeColor: '#000000'\n            }\n\n            /**#@-*/\n        },\n\n        /* special options for boxplot curves */\n        boxplot: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             *  Direction of the box plot: 'vertical' or 'horizontal'\n             *\n             * @type String\n             * @name Boxplot#dir\n             * @default: 'vertical'\n             */\n            dir: 'vertical',\n\n            /**\n             * Relative width of the maximum and minimum quantile\n             *\n             * @type Number\n             * @name Boxplot#smallWidth\n             * @default: 0.5\n             */\n            smallWidth: 0.5,\n\n            strokeWidth: 2,\n            strokeColor: Color.palette.blue,\n            fillColor: Color.palette.blue,\n            fillOpacity: 0.2,\n            highlightStrokeWidth: 2,\n            highlightStrokeColor: Color.palette.blue,\n            highlightFillColor: Color.palette.blue,\n            highlightFillOpacity: 0.1\n\n            /**#@-*/\n        },\n\n        /* special button options */\n        button: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Control the attribute \"disabled\" of the HTML button.\n             *\n             * @name disabled\n             * @memberOf Button.prototype\n             *\n             * @type Boolean\n             * @default false\n             */\n            disabled: false,\n\n            display: 'html'\n\n            /**#@-*/\n        },\n\n        /* special cardinal spline options */\n        cardinalspline: {\n            /**#@+\n             * @visprop\n             */\n\n             /**\n              * Controls if the data points of the cardinal spline when given as\n              * arrays should be converted into {@link JXG.Points}.\n              *\n              * @name createPoints\n              * @memberOf Cardinalspline.prototype\n              *\n              * @see Cardinalspline#points\n              *\n              * @type Boolean\n              * @default true\n              */\n            createPoints: true,\n\n            /**\n             * If set to true, the supplied coordinates are interpreted as\n             * [[x_0, y_0], [x_1, y_1], p, ...].\n             * Otherwise, if the data consists of two arrays of equal length,\n             * it is interpreted as\n             * [[x_o x_1, ..., x_n], [y_0, y_1, ..., y_n]]\n             *\n             * @name isArrayOfCoordinates\n             * @memberOf Cardinalspline.prototype\n             * @type Boolean\n             * @default false\n             */\n            isArrayOfCoordinates: false,\n\n            /**\n             * Attributes for the points generated by Cardinalspline in cases\n             * {@link createPoints} is set to true\n             *\n             * @name points\n             * @memberOf Cardinalspline.prototype\n             *\n             * @see Cardinalspline#createPoints\n             * @type Object\n             */\n            points: {\n                strokeOpacity: 0.05,\n                fillOpacity: 0.05,\n                highlightStrokeOpacity: 1.0,\n                highlightFillOpacity: 1.0,\n                withLabel: false,\n                name: '',\n                fixed: false\n            }\n\n            /**#@-*/\n        },\n\n        /* special chart options */\n        chart: {\n            /**#@+\n             * @visprop\n             */\n\n            chartStyle: 'line',\n            colors: ['#B02B2C', '#3F4C6B', '#C79810', '#D15600', '#FFFF88', '#c3d9ff', '#4096EE', '#008C00'],\n            highlightcolors: null,\n            fillcolor: null,\n            highlightonsector: false,\n            highlightbysize: false,\n\n            fillOpacity: 0.6,\n            withLines:  false,\n\n            label: {\n            }\n            /**#@-*/\n        },\n\n        /* special html slider options */\n        checkbox: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Control the attribute \"disabled\" of the HTML checkbox.\n             *\n             * @name disabled\n             * @memberOf Checkbox.prototype\n             *\n             * @type Boolean\n             * @default false\n             */\n            disabled: false,\n\n            /**\n             * Control the attribute \"checked\" of the HTML checkbox.\n             *\n             * @name checked\n             * @memberOf Checkbox.prototype\n             *\n             * @type Boolean\n             * @default false\n             */\n            checked: false,\n\n            display: 'html'\n\n            /**#@-*/\n        },\n\n        /*special circle options */\n        circle: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * If <tt>true</tt>, moving the mouse over inner points triggers hasPoint.\n             *\n             * @see JXG.GeometryElement#hasPoint\n             * @name Circle#hasInnerPoints\n             * @type Boolean\n             * @default false\n             */\n            hasInnerPoints: false,\n\n            fillColor: 'none',\n            highlightFillColor: 'none',\n            strokeColor: Color.palette.blue,\n            highlightStrokeColor: '#c3d9ff',\n\n            /**\n             * Attributes for center point.\n             *\n             * @type Point\n             * @name Circle#center\n             */\n            center: {\n                visible: false,\n                withLabel: false,\n                fixed: false,\n\n                fillColor: Color.palette.red,\n                strokeColor: Color.palette.red,\n                highlightFillColor: '#c3d9ff',\n                highlightStrokeColor: '#c3d9ff',\n\n                name: ''\n            },\n\n            /**\n             * Attributes for center point.\n             *\n             * @type Point\n             * @name Circle#center\n             */\n            point2: {\n                visible: false,\n                withLabel: false,\n                fixed: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for circle label.\n             *\n             * @type Label\n             * @name Circle#label\n             */\n            label: {\n                position: 'urt'\n            }\n            /**#@-*/\n        },\n\n        /* special options for circumcircle of 3 points */\n        circumcircle: {\n            /**#@+\n             * @visprop\n             */\n\n            fillColor: 'none',\n            highlightFillColor: 'none',\n            strokeColor: Color.palette.blue,\n            highlightStrokeColor: '#c3d9ff',\n\n            /**\n             * Attributes for center point.\n             *\n             * @type Point\n             * @name Circumcircle#center\n             */\n            center: {               // center point\n                visible: false,\n                fixed: false,\n                withLabel: false,\n                fillColor: Color.palette.red,\n                strokeColor: Color.palette.red,\n                highlightFillColor: '#c3d9ff',\n                highlightStrokeColor: '#c3d9ff',\n                name: ''\n            }\n            /**#@-*/\n        },\n\n        circumcirclearc: {\n            /**#@+\n             * @visprop\n             */\n\n            fillColor: 'none',\n            highlightFillColor: 'none',\n            strokeColor: Color.palette.blue,\n            highlightStrokeColor: '#c3d9ff',\n\n            /**\n             * Attributes for center point.\n             *\n             * @type Point\n             * @name CircumcircleArc#center\n             */\n            center: {\n                visible: false,\n                withLabel: false,\n                fixed: false,\n                name: ''\n            }\n            /**#@-*/\n        },\n\n        /* special options for circumcircle sector of 3 points */\n        circumcirclesector: {\n            /**#@+\n             * @visprop\n             */\n\n            useDirection: true,\n            fillColor: Color.palette.yellow,\n            highlightFillColor: Color.palette.yellow,\n            fillOpacity: 0.3,\n            highlightFillOpacity: 0.3,\n            strokeColor: Color.palette.blue,\n            highlightStrokeColor: '#c3d9ff',\n\n            /**\n             * Attributes for center point.\n             *\n             * @type Point\n             * @name Circle#point\n             */\n            point: {\n                visible: false,\n                fixed: false,\n                withLabel: false,\n                name: ''\n            }\n            /**#@-*/\n        },\n\n        /* special conic options */\n        conic: {\n            /**#@+\n             * @visprop\n             */\n\n            fillColor: 'none',\n            highlightFillColor: 'none',\n            strokeColor: Color.palette.blue,\n            highlightStrokeColor: '#c3d9ff',\n\n            /**\n             * Attributes for foci points.\n             *\n             * @type Point\n             * @name Conic#foci\n             */\n            foci: {\n                // points\n                fixed: false,\n                visible: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for center point.\n             *\n             * @type Point\n             * @name Conic#center\n             */\n            center: {\n                visible: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for five points defining the conic, if some of them are given as coordinates.\n             *\n             * @type Point\n             * @name Conic#point\n             */\n            point: {\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for parabola line in case the line is given by two\n             * points or coordinate pairs.\n             *\n             * @type Line\n             * @name Conic#line\n             */\n            line: {\n                visible: false\n            }\n\n            /**#@-*/\n        },\n\n        /* special curve options */\n        curve: {\n            strokeWidth: 1,\n            strokeColor: Color.palette.blue,\n            fillColor: 'none',\n            fixed: true,\n\n            useQDT: false,\n\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * The data points of the curve are not connected with straight lines but with bezier curves.\n             * @name Curve#handDrawing\n             * @type Boolean\n             * @default false\n             */\n            handDrawing: false,\n\n            /**\n             * The curveType is set in {@link JXG.Curve#generateTerm} and used in {@link JXG.Curve#updateCurve}.\n             * Possible values are <ul>\n             * <li>'none'</li>\n             * <li>'plot': Data plot</li>\n             * <li>'parameter': we can not distinguish function graphs and parameter curves</li>\n             * <li>'functiongraph': function graph</li>\n             * <li>'polar'</li>\n             * <li>'implicit' (not yet)</li></ul>\n             * Only parameter and plot are set directly. Polar is set with {@link JXG.GeometryElement#setAttribute} only.\n             * @name Curve#curveType\n             * @type String\n             * @default null\n             */\n            curveType: null,\n\n            /**\n             * Apply Ramer-Douglas-Peuker smoothing.\n             *\n             * @type Boolean\n             * @name Curve#RDPsmoothing\n             * @default false\n             */\n            RDPsmoothing: false,     // Apply the Ramer-Douglas-Peuker algorithm\n\n            /**\n             * Number of points used for plotting triggered by up events\n             * (i.e. high quality plotting) in case\n             * {@link Curve#doAdvancedPlot} is false.\n             *\n             * @name Curve#numberPointsHigh\n             * @see Curve#doAdvancedPlot\n             * @type Number\n             * @default 1600\n             */\n            numberPointsHigh: 1600,  // Number of points on curves after mouseUp\n\n            /**\n             * Number of points used for plotting triggered by move events\n             * (i.e. lower quality plotting but fast) in case\n             * {@link Curve#doAdvancedPlot} is false.\n             *\n             * @name Curve#numberPointsLow\n             * @see Curve#doAdvancedPlot\n             * @type Number\n             * @default 400\n             */\n            numberPointsLow: 400,    // Number of points on curves after mousemove\n\n            /**\n             * If true use a recursive bisection algorithm.\n             * It is slower, but usually the result is better. It tries to detect jumps\n             * and singularities.\n             *\n             * @name Curve#doAdvancedPlot\n             * @type Boolean\n             * @default true\n             */\n            doAdvancedPlot: true,\n\n            /**\n             *\n             * Recursion depth used for plotting triggered by up events\n             * (i.e. high quality plotting) in case\n             * {@link Curve#doAdvancedPlot} is true.\n             *\n             * @name Curve#recursionDepthHigh\n             * @see Curve#doAdvancedPlot\n             * @type Number\n             * @default 17\n             */\n             recursionDepthHigh: 17,\n\n            /**\n             * Number of points used for plotting triggered by move events in case\n             * (i.e. lower quality plotting but fast)\n             * {@link Curve#doAdvancedPlot} is true.\n             *\n             * @name Curve#recursionDepthLow\n             * @see Curve#doAdvancedPlot\n             * @type Number\n             * @default 13\n             */\n             recursionDepthLow: 15,\n\n            /**\n             * If true use the algorithm by Gillam and Hohenwarter, which was default until version 0.98.\n             *\n             * @name Curve#doAdvancedPlotOld\n             * @see Curve#doAdvancedPlot\n             * @type Boolean\n             * @default false\n             * @deprecated\n             */\n            doAdvancedPlotOld: false,   // v1\n\n            /**\n             * Select the version of the plot algorithm.\n             * <ul>\n             * <li> Version 1 is very outdated\n             * <li> Version 2 is the default version in JSXGraph v0.99.*, v1.0, and v1.1, v1.2.0\n             * <li> Version 3 is an internal version that was never published in  a stable version.\n             * <li> Version 4 is available since JSXGraph v1.2.0\n             * </ul>\n             * Version 4 plots correctly logarithms if the function term is supplied as string (i.e. as JessieCode)\n             *\n             * @example\n             *   var c = board.create('functiongraph', [\"log(x)\"]);\n             *\n             * @name Curve#plotVersion\n             * @type Number\n             * @default 2\n             */\n            plotVersion: 2,\n\n            /**\n             * Attributes for circle label.\n             *\n             * @type Label\n             * @name Circle#label\n             */\n            label: {\n                position: 'lft'\n            },\n\n            /**\n             * Configure arrow head at the start position for curve.\n             * Recommended arrow head type is 7.\n             *\n             * @name Curve#firstArrow\n             * @type Boolean / Object\n             * @default false\n             * @see Line#firstArrow for options\n             */\n            firstArrow: false,\n\n            /**\n             * Configure arrow head at the end position for curve.\n             * Recommended arrow head type is 7.\n             *\n             * @name Curve#lastArrow\n             * @see Line#lastArrow for options\n             * @type Boolean / Object\n             * @default false\n             */\n            lastArrow: false\n\n            /**#@-*/\n        },\n\n        /* special foreignObject options */\n        foreignobject: {\n\n            /**#@+\n             * @visprop\n             */\n            attractors: [],\n            fixed: true,\n            visible: true\n\n            /**#@-*/\n        },\n\n        glider: {\n            /**#@+\n             * @visprop\n             */\n\n            label: {}\n            /**#@-*/\n        },\n\n        /* special grid options */\n        grid: {\n            /**#@+\n             * @visprop\n             */\n\n            /* grid styles */\n            needsRegularUpdate: false,\n            hasGrid: false,\n            gridX: 1,\n            gridY: 1,\n            //strokeColor: '#c0c0c0',\n            strokeColor: '#c0c0c0',\n            strokeOpacity: 0.5,\n            strokeWidth: 1,\n            dash: 0,    // dashed grids slow down the iPad considerably\n            /* snap to grid options */\n\n            /**\n             * @deprecated\n             */\n            snapToGrid: false,\n            /**\n             * @deprecated\n             */\n            snapSizeX: 10,\n            /**\n             * @deprecated\n             */\n            snapSizeY: 10\n\n            /**#@-*/\n        },\n\n        group: {\n            needsRegularUpdate: true\n        },\n\n        /* special html slider options */\n        htmlslider: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             *\n             * These affect the DOM element input type=\"range\".\n             * The other attributes affect the DOM element div containing the range element.\n             */\n            widthRange: 100,\n            widthOut: 34,\n            step: 0.01,\n\n            frozen: true,\n            isLabel: false,\n            strokeColor: '#000000',\n            display: 'html',\n            anchorX: 'left',\n            anchorY: 'middle',\n            withLabel: false\n\n            /**#@-*/\n        },\n\n        /* special image options */\n        image: {\n            /**#@+\n             * @visprop\n             */\n\n            imageString: null,\n            fillOpacity: 1.0,\n            highlightFillOpacity: 0.6,\n\n\n            /**\n             * Defines the CSS class used by the image. CSS attributes defined in\n             * this class will overwrite the corresponding JSXGraph attributes, e.g.\n             * opacity.\n             * The default CSS class is defined in jsxgraph.css.\n             *\n             * @name Image#cssClass\n             *\n             * @see Image#highlightCssClass\n             * @type String\n             * @default 'JXGimage'\n             */\n            cssClass: 'JXGimage',\n\n            /**\n             * Defines the CSS class used by the image when highlighted.\n             * CSS attributes defined in this class will overwrite the\n             * corresponding JSXGraph attributes, e.g. highlightFillOpacity.\n             * The default CSS class is defined in jsxgraph.css.\n             *\n             * @name Image#highlightCssClass\n             *\n             * @see Image#cssClass\n             * @type String\n             * @default 'JXGimageHighlight'\n             */\n            highlightCssClass: 'JXGimageHighlight',\n\n            /**\n             * Image rotation in degrees.\n             *\n             * @name Image#rotate\n             * @type Number\n             * @default 0\n             */\n            rotate: 0,\n\n            /**\n             * Defines together with {@link Image#snapSizeY} the grid the image snaps on to.\n             * The image will only snap on user coordinates which are\n             * integer multiples to snapSizeX in x and snapSizeY in y direction.\n             * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks\n             * of the default ticks of the default x axes of the board.\n             *\n             * @name Image#snapSizeX\n             *\n             * @see Point#snapToGrid\n             * @see Image#snapSizeY\n             * @see JXG.Board#defaultAxes\n             * @type Number\n             * @default 1\n             */\n            snapSizeX: 1,\n\n            /**\n             * Defines together with {@link Image#snapSizeX} the grid the image snaps on to.\n             * The image will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.\n             * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks\n             * of the default ticks of the default y axes of the board.\n             *\n             * @name Image#snapSizeY\n             *\n             * @see Point#snapToGrid\n             * @see Image#snapSizeX\n             * @see JXG.Board#defaultAxes\n             * @type Number\n             * @default 1\n             */\n            snapSizeY: 1,\n\n            /**\n             * List of attractor elements. If the distance of the image is less than\n             * attractorDistance the image is made to glider of this element.\n             *\n             * @name Image#attractors\n             *\n             * @type Array\n             * @default empty\n             */\n            attractors: []\n\n            /**#@-*/\n        },\n\n        /* special options for incircle of 3 points */\n        incircle: {\n            /**#@+\n             * @visprop\n             */\n\n            fillColor: 'none',\n            highlightFillColor: 'none',\n            strokeColor: Color.palette.blue,\n            highlightStrokeColor: '#c3d9ff',\n\n            /**\n             * Attributes of circle center.\n             *\n             * @type Point\n             * @name Incircle#center\n             */\n            center: {               // center point\n                visible: false,\n                fixed: false,\n                withLabel: false,\n                fillColor: Color.palette.red,\n                strokeColor: Color.palette.red,\n                highlightFillColor: '#c3d9ff',\n                highlightStrokeColor: '#c3d9ff',\n                name: ''\n            }\n            /**#@-*/\n        },\n\n        inequality: {\n            /**#@+\n             * @visprop\n             */\n\n            fillColor: Color.palette.red,\n            fillOpacity: 0.2,\n            strokeColor: 'none',\n\n            /**\n             * By default an inequality is less (or equal) than. Set inverse to <tt>true</tt> will consider the inequality\n             * greater (or equal) than.\n             *\n             * @type Boolean\n             * @default false\n             * @name Inequality#inverse\n             * @visprop\n             */\n            inverse: false\n            /**#@-*/\n        },\n\n        infobox: {\n            /**#@+\n             * @visprop\n             */\n\n            fontSize: 12,\n            isLabel: false,\n            strokeColor: '#bbbbbb',\n            display: 'html',             // 'html' or 'internal'\n            anchorX: 'left',             //  'left', 'middle', or 'right': horizontal alignment\n                                         //  of the text.\n            anchorY: 'middle',           //  'top', 'middle', or 'bottom': vertical alignment\n                                         //  of the text.\n            cssClass: 'JXGinfobox',\n            rotate: 0,                   // works for non-zero values only in combination\n                                         // with display=='internal'\n            visible: true,\n            parse: false,\n            transitionDuration: 0,\n            needsRegularUpdate: false\n\n            /**#@-*/\n        },\n\n        /* special options for integral */\n        integral: {\n            /**#@+\n             * @visprop\n             */\n\n            axis: 'x',        // 'x' or 'y'\n            withLabel: true,    // Show integral value as text\n            fixed: true,\n            strokeWidth: 0,\n            strokeOpacity: 0,\n            fillColor: Color.palette.red,\n            fillOpacity: 0.3,\n            highlightFillColor: Color.palette.red,\n            highlightFillOpacity: 0.2,\n\n            /**\n             * Attributes of the (left) starting point of the integral.\n             *\n             * @type Point\n             * @name Integral#curveLeft\n             * @see Integral#baseLeft\n             */\n            curveLeft: {    // Start point\n                visible: true,\n                withLabel: false,\n                color: Color.palette.red,\n                fillOpacity: 0.8,\n                layer: 9\n            },\n\n            /**\n             * Attributes of the (left) base point of the integral.\n             *\n             * @type Point\n             * @name Integral#baseLeft\n             * @see Integral#curveLeft\n             */\n            baseLeft: {    // Start point\n                visible: false,\n                fixed: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes of the (right) end point of the integral.\n             *\n             * @type Point\n             * @name Integral#curveRight\n             * @see Integral#baseRight\n             */\n            curveRight: {      // End point\n                visible: true,\n                withLabel: false,\n                color: Color.palette.red,\n                fillOpacity: 0.8,\n                layer: 9\n            },\n\n            /**\n             * Attributes of the (right) base point of the integral.\n             *\n             * @type Point\n             * @name Integral#baseRight\n             * @see Integral#curveRight\n             */\n            baseRight: {      // End point\n                visible: false,\n                fixed: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for integral label.\n             *\n             * @type Label\n             * @name Integral#label\n             */\n            label: {\n                fontSize: 20\n            }\n            /**#@-*/\n        },\n\n        /* special input options */\n        input: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Control the attribute \"disabled\" of the HTML input field.\n             *\n             * @name disabled\n             * @memberOf Input.prototype\n             *\n             * @type Boolean\n             * @default false\n             */\n            disabled: false,\n\n            /**\n             * Control the attribute \"maxlength\" of the HTML input field.\n             *\n             * @name maxlength\n             * @memberOf Input.prototype\n             *\n             * @type Number\n             * @default 524288 (as in HTML)\n             */\n            maxlength: 524288,\n\n            display: 'html'\n\n            /**#@-*/\n        },\n\n        /* special intersection point options */\n        intersection: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Used in {@link JXG.Intersection}.\n             * This flag sets the behaviour of intersection points of e.g.\n             * two segments. If true, the intersection is treated as intersection of lines. If false\n             * the intersection point exists if the segments intersect setwise.\n             *\n             * @name Intersection.alwaysIntersect\n             * @type Boolean\n             * @default true\n             */\n            alwaysIntersect: true\n\n            /**#@-*/\n        },\n\n        /* special label options */\n        label: {\n            /**#@+\n             * @visprop\n             */\n\n            visible: 'inherit',\n            strokeColor: '#000000',\n            strokeOpacity: 1,\n            highlightStrokeOpacity: 0.666666,\n            highlightStrokeColor: '#000000',\n\n            fixed: true,\n\n            /**\n             * Possible string values for the position of a label for\n             * label anchor points are:\n             * <ul>\n             * <li> 'lft'\n             * <li> 'rt'\n             * <li> 'top'\n             * <li> 'bot'\n             * <li> 'ulft'\n             * <li> 'urt'\n             * <li> 'llft'\n             * <li> 'lrt'\n             * </ul>\n             * This is relevant for non-points: line, circle, curve.\n             *\n             * The names have been borrowed from <a href=\"https://www.tug.org/metapost.html\">MetaPost</a>.\n             *\n             * @name Label#position\n             * @see Label#offset\n             * @type String\n             * @default 'urt'\n             */\n            position: 'urt',\n\n            /**\n             *  Label offset from label anchor.\n             *  The label anchor is determined by {@link Label#position}\n             *\n             * @name Label#offset\n             * @see Label#position\n             * @type Array\n             * @default [10,10]\n             */\n            offset: [10, 10],\n\n            /**\n             * Automatic position of label text. When called first, the positioning algorithm\n             * starts at the position defined by offset.\n             * The algorithm tries to find a position with the least number of\n             * overlappings with other elements, while retaining the distance\n             * to the anchor element.\n             *\n             * @name Label#autoPosition\n             * @see Label#offset\n             * @type Boolean\n             * @default false\n             *\n             * @example\n             * \tvar p1 = board.create('point', [-2, 1], {id: 'A'});\n             * \tvar p2 = board.create('point', [-0.85, 1], {\n             *      name: 'B', id: 'B', label:{autoPosition: true, offset:[10, 10]}\n             *  });\n             * \tvar p3 = board.create('point', [-1, 1.2], {\n             *      name: 'C', id: 'C', label:{autoPosition: true, offset:[10, 10]}\n             *  });\n             *  var c = board.create('circle', [p1, p2]);\n             * \tvar l = board.create('line', [p1, p2]);\n             *\n             * </pre><div id=\"JXG7d4dafe7-1a07-4d3f-95cb-bfed9d96dea2\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG7d4dafe7-1a07-4d3f-95cb-bfed9d96dea2',\n             *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n             *     \tvar p1 = board.create('point', [-2, 1], {id: 'A'});\n             *     \tvar p2 = board.create('point', [-0.85, 1], {name: 'B', id: 'B', label:{autoPosition: true, offset:[10, 10]}});\n             *     \tvar p3 = board.create('point', [-1, 1.2], {name: 'C', id: 'C', label:{autoPosition: true, offset:[10, 10]}});\n             *      var c = board.create('circle', [p1, p2]);\n             *     \tvar l = board.create('line', [p1, p2]);\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             *\n             */\n            autoPosition: false\n\n            /**#@-*/\n        },\n\n        /* special legend options */\n        legend: {\n            /**\n             * @visprop\n             */\n\n             /**\n              * Default style of a legend element. The only possible value is 'vertical'.\n              * @name: Legend#style\n              * @type String\n              * @default 'vertical'\n              */\n            style: 'vertical',\n\n            /**\n             * Label names of a legend element.\n             * @name: Legend#labels\n             * @type Array\n             * @default \"['1', '2', '3', '4', '5', '6', '7', '8']\"\n             */\n            labels: ['1', '2', '3', '4', '5', '6', '7', '8'],\n\n            /**\n             * (Circular) array of label colors.\n             * @name: Legend#colors\n             * @type Array\n             * @default \"['#B02B2C', '#3F4C6B', '#C79810', '#D15600', '#FFFF88', '#c3d9ff', '#4096EE', '#008C00']\"\n             */\n            colors: ['#B02B2C', '#3F4C6B', '#C79810', '#D15600', '#FFFF88', '#c3d9ff', '#4096EE', '#008C00'],\n\n            /**\n             * Height (in px) of one legend entry\n             * @name: Legend#rowHeight\n             * @type Number\n             * @default 20\n             *\n             */\n            rowHeight: 20,\n\n            strokeWidth: 5\n\n            /**#@-*/\n        },\n\n        /* special line options */\n        line: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Configure the arrow head at the position of its first point or the corresponding\n             * intersection with the canvas border\n             *\n             * In case firstArrow is an object it has the sub-attributes:\n             * <pre>\n             * {\n             *      type: 1, // possible values are 1, 2, ..., 7. Default value is 1.\n             *      size: 6, // size of the arrow head. Default value is 6.\n             *               // This value is multiplied with the strokeWidth of the line\n             *               // Exception: for type=7 size is ignored\n             *      highlightSize: 6, // size of the arrow head in case the element is highlighted. Default value\n             * }\n             * </pre>\n             * type=7 is the default for curves if firstArrow: true\n             *\n             * @example\n             *     board.options.line.lastArrow = false;\n             *     board.options.line.firstArrow = {size: 10, highlightSize: 10};\n             *     board.options.line.point1 = {visible: false, withLabel: true, label: {visible: true, anchorX: 'right'}};\n             *     board.options.line.strokeWidth = 4;\n             *     board.options.line.highlightStrokeWidth = 4;\n             *\n             *     board.create('segment', [[-5,4], [3,4]], {firstArrow: {type: 1}, point1: {name: 'type:1'}});\n             *     board.create('segment', [[-5,3], [3,3]], {firstArrow: {type: 2}, point1: {name: 'type:2'}});\n             *     board.create('segment', [[-5,2], [3,2]], {firstArrow: {type: 3}, point1: {name: 'type:3'}});\n             *     board.create('segment', [[-5,1], [3,1]], {firstArrow: {type: 4}, point1: {name: 'type:4'}});\n             *     board.create('segment', [[-5,0], [3,0]], {firstArrow: {type: 5}, point1: {name: 'type:5'}});\n             *     board.create('segment', [[-5,-1], [3,-1]], {firstArrow: {type: 6}, point1: {name: 'type:6'}});\n             *     board.create('segment', [[-5,-2], [3,-2]], {firstArrow: {type: 7}, point1: {name: 'type:7'}});\n             *\n             * </pre><div id=\"JXGc94a93da-c942-4204-8bb6-b39726cbb09b\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGc94a93da-c942-4204-8bb6-b39726cbb09b',\n             *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});\n             *         board.options.line.lastArrow = false;\n             *         board.options.line.firstArrow = {size: 10, highlightSize: 10};\n             *         board.options.line.point1 = {visible: false, withLabel: true, label: {visible: true, anchorX: 'right'}};\n             *         board.options.line.strokeWidth = 4;\n             *         board.options.line.highlightStrokeWidth = 4;\n             *\n             *         board.create('segment', [[-5,4], [3,4]], {firstArrow: {type: 1}, point1: {name: 'type:1'}});\n             *         board.create('segment', [[-5,3], [3,3]], {firstArrow: {type: 2}, point1: {name: 'type:2'}});\n             *         board.create('segment', [[-5,2], [3,2]], {firstArrow: {type: 3}, point1: {name: 'type:3'}});\n             *         board.create('segment', [[-5,1], [3,1]], {firstArrow: {type: 4}, point1: {name: 'type:4'}});\n             *         board.create('segment', [[-5,0], [3,0]], {firstArrow: {type: 5}, point1: {name: 'type:5'}});\n             *         board.create('segment', [[-5,-1], [3,-1]], {firstArrow: {type: 6}, point1: {name: 'type:6'}});\n             *         board.create('segment', [[-5,-2], [3,-2]], {firstArrow: {type: 7}, point1: {name: 'type:7'}});\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             * @name Line#firstArrow\n             * @see Line#lastArrow\n             * @see Line#touchFirstPoint\n             * @type Boolean / Object\n             * @default false\n             */\n            firstArrow: false,\n\n            /**\n             * Configute the arrow head at the position of its second point or the corresponding\n             * intersection with the canvas border.\n             *\n             * In case lastArrow is an object it has the sub-attributes:\n             * <pre>\n             * {\n             *      type: 1, // possible values are 1, 2, ..., 7. Default value is 1.\n             *      size: 6, // size of the arrow head. Default value is 6.\n             *               // This value is multiplied with the strokeWidth of the line.\n             *               // Exception: for type=7 size is ignored\n             *      highlightSize: 6, // size of the arrow head in case the element is highlighted. Default value is 6.\n             * }\n             * </pre>\n             * type=7 is the default for curves if lastArrow: true\n             *\n             * @example\n             *     var p1 = board.create('point', [-5, 2], {size:1});\n             *     var p2 = board.create('point', [5, 2], {size:10});\n             *     var li = board.create('segment', ['A','B'],\n             *         {name:'seg',\n             *          strokeColor:'#000000',\n             *          strokeWidth:1,\n             *          highlightStrokeWidth: 5,\n             *          lastArrow: {type: 2, size: 8, highlightSize: 6},\n             *          touchLastPoint: true,\n             *          firstArrow: {type: 3, size: 8}\n             *         });\n             *\n             * </pre><div id=\"JXG184e915c-c2ef-11e8-bece-04d3b0c2aad3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG184e915c-c2ef-11e8-bece-04d3b0c2aad3',\n             *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n             *         var p1 = board.create('point', [-5, 2], {size:1});\n             *         var p2 = board.create('point', [5, 2], {size:10});\n             *         var li = board.create('segment', ['A','B'],\n             *             {name:'seg',\n             *              strokeColor:'#000000',\n             *              strokeWidth:1,\n             *              highlightStrokeWidth: 5,\n             *              lastArrow: {type: 2, size: 8, highlightSize: 6},\n             *              touchLastPoint: true,\n             *              firstArrow: {type: 3, size: 8}\n             *             });\n             *     })();\n             *\n             * </script>\n             *\n             * @example\n             *     board.options.line.strokeWidth = 4;\n             *     board.options.line.highlightStrokeWidth = 4;\n             *     board.options.line.firstArrow = false;\n             *     board.options.line.lastArrow = {size: 10, highlightSize: 10};\n             *     board.options.line.point2 = {visible: false, withLabel: true, label: {visible: true}};\n             *\n             *     board.create('segment', [[-5,4], [3,4]], {lastArrow: {type: 1}, point2: {name: 'type:1'}});\n             *     board.create('segment', [[-5,3], [3,3]], {lastArrow: {type: 2}, point2: {name: 'type:2'}});\n             *     board.create('segment', [[-5,2], [3,2]], {lastArrow: {type: 3}, point2: {name: 'type:3'}});\n             *     board.create('segment', [[-5,1], [3,1]], {lastArrow: {type: 4}, point2: {name: 'type:4'}});\n             *     board.create('segment', [[-5,0], [3,0]], {lastArrow: {type: 5}, point2: {name: 'type:5'}});\n             *     board.create('segment', [[-5,-1], [3,-1]], {lastArrow: {type: 6}, point2: {name: 'type:6'}});\n             *     board.create('segment', [[-5,-2], [3,-2]], {lastArrow: {type: 7}, point2: {name: 'type:7'}});\n             *\n             * </pre><div id=\"JXGca206b1c-e319-4899-8b90-778f53fd926d\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGca206b1c-e319-4899-8b90-778f53fd926d',\n             *             {boundingbox: [-8, 8, 8,-8], axis: false, showcopyright: false, shownavigation: false});\n             *         board.options.line.strokeWidth = 4;\n             *         board.options.line.highlightStrokeWidth = 4;\n             *         board.options.line.firstArrow = false;\n             *         board.options.line.lastArrow = {size: 10, highlightSize: 10};\n             *         board.options.line.point2 = {visible: false, withLabel: true, label: {visible: true}};\n             *\n             *         board.create('segment', [[-5,4], [3,4]], {lastArrow: {type: 1}, point2: {name: 'type:1'}});\n             *         board.create('segment', [[-5,3], [3,3]], {lastArrow: {type: 2}, point2: {name: 'type:2'}});\n             *         board.create('segment', [[-5,2], [3,2]], {lastArrow: {type: 3}, point2: {name: 'type:3'}});\n             *         board.create('segment', [[-5,1], [3,1]], {lastArrow: {type: 4}, point2: {name: 'type:4'}});\n             *         board.create('segment', [[-5,0], [3,0]], {lastArrow: {type: 5}, point2: {name: 'type:5'}});\n             *         board.create('segment', [[-5,-1], [3,-1]], {lastArrow: {type: 6}, point2: {name: 'type:6'}});\n             *         board.create('segment', [[-5,-2], [3,-2]], {lastArrow: {type: 7}, point2: {name: 'type:7'}});\n             *     })();\n             *\n             * </script><pre>\n             *\n             * @name Line#lastArrow\n             * @see Line#firstArrow\n             * @see Line#touchLastPoint\n             * @type Boolean / Object\n             * @default false\n             */\n            lastArrow: false,\n\n            /**\n             * This number (pixel value) controls where infinite lines end at the canvas border. If zero, the line\n             * ends exactly at the border, if negative there is a margin to the inside, if positive the line\n             * ends outside of the canvas (which is invisible).\n             *\n             * @name: Line#margin\n             * @type Number\n             * @default 0\n             */\n            margin: 0,\n\n            /**\n             * If true, line stretches infinitely in direction of its first point.\n             * Otherwise it ends at point1.\n             *\n             * @name Line#straightFirst\n             * @see Line#straightLast\n             * @type Boolean\n             * @default true\n             */\n            straightFirst: true,\n\n            /**\n             * If true, line stretches infinitely in direction of its second point.\n             * Otherwise it ends at point2.\n             *\n             * @name Line#straightLast\n             * @see Line#straightFirst\n             * @type Boolean\n             * @default true\n             */\n            straightLast: true,\n\n            fillColor: 'none',               // Important for VML on IE\n            highlightFillColor: 'none',  // Important for VML on IE\n            strokeColor: Color.palette.blue,\n            highlightStrokeColor: '#c3d9ff',\n            withTicks: false,\n\n            /**\n             * Attributes for first defining point of the line.\n             *\n             * @type Point\n             * @name Line#point1\n             */\n            point1: {                  // Default values for point1 if created by line\n                visible: false,\n                withLabel: false,\n                fixed: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for second defining point of the line.\n             *\n             * @type Point\n             * @name Line#point2\n             */\n            point2: {                  // Default values for point2 if created by line\n                visible: false,\n                withLabel: false,\n                fixed: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for ticks of the line.\n             *\n             * @type Ticks\n             * @name Line#ticks\n             */\n            ticks: {\n                drawLabels: true,\n                label: {\n                    offset: [4, -12 + 3] // This seems to be a good offset for 12 point fonts\n                },\n                drawZero: false,\n                insertTicks: false,\n                minTicksDistance: 50,\n                minorHeight: 4,          // if <0: full width and height\n                majorHeight: -1,         // if <0: full width and height\n                minorTicks: 4,\n                defaultDistance: 1,\n                strokeOpacity: 0.3,\n                visible: 'inherit'\n            },\n\n            /**\n             * Attributes for the line label.\n             *\n             * @type Label\n             * @name Line#label\n             */\n            label: {\n                position: 'llft'\n            },\n\n            /**\n             * If set to true, the point will snap to a grid defined by\n             * {@link Point#snapSizeX} and {@link Point#snapSizeY}.\n             *\n             * @see Point#snapSizeX\n             * @see Point#snapSizeY\n             * @type Boolean\n             * @name Line#snapToGrid\n             * @default false\n             */\n            snapToGrid: false,\n\n            /**\n             * Defines together with {@link Point#snapSizeY} the grid the point snaps on to.\n             * The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.\n             * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks\n             * of the default ticks of the default x axes of the board.\n             *\n             * @see Point#snapToGrid\n             * @see Point#snapSizeY\n             * @see JXG.Board#defaultAxes\n             * @type Number\n             * @name Line#snapSizeX\n             * @default 1\n             */\n            snapSizeX: 1,\n\n            /**\n             * Defines together with {@link Point#snapSizeX} the grid the point snaps on to.\n             * The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.\n             * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks\n             * of the default ticks of the default y axes of the board.\n             *\n             * @see Point#snapToGrid\n             * @see Point#snapSizeX\n             * @see JXG.Board#defaultAxes\n             * @type Number\n             * @name Line#snapSizeY\n             * @default 1\n             */\n            snapSizeY: 1,\n\n            /**\n             * If set to true and {@link Line#firstArrow} is set to true, the arrow head will just touch\n             * the circle line of the start point of the line.\n             *\n             * @see Line#firstArrow\n             * @type Boolean\n             * @name Line#touchFirstPoint\n             * @default false\n             */\n            touchFirstPoint: false,\n\n            /**\n             * If set to true and {@link Line#lastArrow} is set to true, the arrow head will just touch\n             * the circle line of the start point of the line.\n             * @see Line#firstArrow\n             * @type Boolean\n             * @name Line#touchLastPoint\n             * @default false\n             */\n            touchLastPoint: false,\n\n            /**\n             * Line endings (linecap) of a straight line.\n             * Possible values are:\n             * <ul>\n             * <li> 'butt',\n             * <li> 'round',\n             * <li> 'square'.\n             * </ul>\n             * Not available for VML renderer.\n             * [lineCap description]\n             * @name Line#lineCap\n             * @type String\n             * @default 'butt'\n             */\n            lineCap: 'butt'\n\n            /**#@-*/\n        },\n\n        /* special options for locus curves */\n        locus: {\n            /**#@+\n             * @visprop\n             */\n\n            translateToOrigin: false,\n            translateTo10: false,\n            stretch: false,\n            toOrigin: null,\n            to10: null\n            /**#@-*/\n        },\n\n        /* special cardinal spline options */\n        metapostspline: {\n            /**#@+\n             * @visprop\n             */\n\n             /**\n              * Controls if the data points of the cardinal spline when given as\n              * arrays should be converted into {@link JXG.Points}.\n              *\n              * @name createPoints\n              * @memberOf Metapostspline.prototype\n              *\n              * @see Metapostspline#points\n              *\n              * @type Boolean\n              * @default true\n              */\n            createPoints: true,\n\n            /**\n             * If set to true, the supplied coordinates are interpreted as\n             * [[x_0, y_0], [x_1, y_1], p, ...].\n             * Otherwise, if the data consists of two arrays of equal length,\n             * it is interpreted as\n             * [[x_o x_1, ..., x_n], [y_0, y_1, ..., y_n]]\n             *\n             * @name isArrayOfCoordinates\n             * @memberOf Metapostspline.prototype\n             * @type Boolean\n             * @default false\n             */\n            isArrayOfCoordinates: false,\n\n            /**\n             * Attributes for the points generated by Metapostspline in cases\n             * {@link createPoints} is set to true\n             *\n             * @name points\n             * @memberOf Metapostspline.prototype\n             *\n             * @see Metapostspline#createPoints\n             * @type Object\n             */\n            points: {\n                strokeOpacity: 0.05,\n                fillOpacity: 0.05,\n                highlightStrokeOpacity: 1.0,\n                highlightFillOpacity: 1.0,\n                withLabel: false,\n                name: '',\n                fixed: false\n            }\n\n            /**#@-*/\n        },\n\n        /* special mirrorelement options */\n        mirrorelement: {\n            /**#@+\n             * @visprop\n             */\n\n            fixed: true,\n\n            /**\n             * Attributes of mirror point, i.e. the point along which the element is mirrored.\n             *\n             * @type Point\n             * @name mirrorelement#point\n             */\n            point: {},\n\n            /**\n             * Attributes of circle center, i.e. the center of the circle,\n             * if a circle is the mirror element and the transformation type is 'Euclidean'\n             *\n             * @type Point\n             * @name mirrorelement#center\n             */\n            center: {},\n\n            /**\n             * Type of transformation. Possible values are 'Euclidean', 'projective'.\n             *\n             * If the value is 'Euclidean', the mirror element of a circle is again a circle,\n             * otherwise it is a conic section.\n             *\n             * @type String\n             * @name mirrorelement#type\n             * @default 'Euclidean'\n             */\n            type: 'Euclidean'\n\n            /**#@-*/\n        },\n\n        // /* special options for Msector of 3 points */\n        // msector: {\n        //     strokeColor: '#000000', // Msector line\n        //     point: {               // Msector point\n        //         visible: false,\n        //         fixed: false,\n        //         withLabel: false,\n        //         name: ''\n        //     }\n        // },\n\n        /* special options for normal lines */\n        normal: {\n            /**#@+\n             * @visprop\n             */\n\n            strokeColor: '#000000', //  normal line\n\n            /**\n             * Attributes of helper point of normal.\n             *\n             * @type Point\n             * @name Normal#point\n             */\n            point: {\n                visible: false,\n                fixed: false,\n                withLabel: false,\n                name: ''\n            }\n            /**#@-*/\n        },\n\n        /* special options for orthogonal projection points */\n        orthogonalprojection: {\n            /**#@+\n             * @visprop\n             */\n\n\n            /**#@-*/\n        },\n\n        /* special options for parallel lines */\n        parallel: {\n            /**#@+\n             * @visprop\n             */\n\n            strokeColor: '#000000', // Parallel line\n\n            /**\n             * Attributes of helper point of normal.\n             *\n             * @type Point\n             * @name Parallel#point\n             */\n            point: {\n                visible: false,\n                fixed: false,\n                withLabel: false,\n                name: ''\n            },\n\n            label: {\n                position: 'llft'\n            }\n            /**#@-*/\n        },\n\n        /* special perpendicular options */\n        perpendicular: {\n            /**#@+\n             * @visprop\n             */\n\n            strokeColor: '#000000', // Perpendicular line\n            straightFirst: true,\n            straightLast: true\n            /**#@-*/\n        },\n\n        /* special perpendicular options */\n        perpendicularsegment: {\n            /**#@+\n             * @visprop\n             */\n\n            strokeColor: '#000000', // Perpendicular segment\n            straightFirst: false,\n            straightLast: false,\n            point: {               // Perpendicular point\n                visible: false,\n                fixed: true,\n                withLabel: false,\n                name: ''\n            }\n            /**#@-*/\n        },\n\n        /* special point options */\n        point: {\n            /**#@+\n             * @visprop\n             */\n\n            withLabel: true,\n            label: {},\n\n            /**\n             * This attribute was used to determined the point layout. It was derived from GEONExT and was\n             * replaced by {@link Point#face} and {@link Point#size}.\n             *\n             * @name Point#style\n             *\n             * @see Point#face\n             * @see Point#size\n             * @type Number\n             * @default 5\n             * @deprecated\n             */\n            style: 5,\n\n            /**\n             * There are different point styles which differ in appearance.\n             * Posssible values are\n             * <table><tr><th>Value</th></tr>\n             * <tr><td>cross</td></tr>\n             * <tr><td>circle</td></tr>\n             * <tr><td>square</td></tr>\n             * <tr><td>plus</td></tr>\n             * <tr><td>diamond</td></tr>\n             * <tr><td>triangleUp</td></tr>\n             * <tr><td>triangleDown</td></tr>\n             * <tr><td>triangleLeft</td></tr>\n             * <tr><td>triangleRight</td></tr>\n             * </table>\n             *\n             * @name Point#face\n             *\n             * @type String\n             * @see JXG.Point#setStyle\n             * @default circle\n             */\n            face: 'o',\n\n            /**\n             * Size of a point, either in pixel or user coordinates.\n             * Means radius resp. half the width of a point (depending on the face).\n             *\n             * @name Point#size\n             *\n             * @see Point#face\n             * @see JXG.Point#setStyle\n             * @see Point#sizeUnit\n             * @type Number\n             * @default 3\n             */\n            size: 3,\n\n            /**\n             * Unit for size.\n             * Possible values are 'screen' and 'user.\n             *\n             * @name Point#sizeUnit\n             *\n             * @see Point#size\n             * @type String\n             * @default 'screen'\n             */\n            sizeUnit: 'screen',\n\n            strokeWidth: 2,\n\n            fillColor: Color.palette.red,\n            strokeColor: Color.palette.red,\n            highlightFillColor:'#c3d9ff',\n            highlightStrokeColor: '#c3d9ff',\n            // strokeOpacity: 1.0,\n            // fillOpacity: 1.0,\n            // highlightFillOpacity: 0.5,\n            // highlightStrokeOpacity: 0.5,\n\n            // fillColor: '#ff0000',\n            // highlightFillColor: '#eeeeee',\n            // strokeWidth: 2,\n            // strokeColor: '#ff0000',\n            // highlightStrokeColor: '#c3d9ff',\n\n            /**\n             * If true, the point size changes on zoom events.\n             *\n             * @type Boolean\n             * @name Point#zoom\n             * @default false\n             *\n             */\n            zoom: false,             // Change the point size on zoom\n\n            /**\n             * If true, the infobox is shown on mouse/pen over, if false not.\n             * If the value is 'inherit', the value of\n             * {@link JXG.Board#showInfobox} is taken.\n             *\n             * @name Point#showInfobox\n             * @see JXG.Board#showInfobox\n             * @type {Boolean|String} true | false | 'inherit'\n             * @default true\n             */\n            showInfobox: 'inherit',\n\n            /**\n             * Truncating rule for the digits in the infobox.\n             * <ul>\n             * <li>'auto': done automatically by JXG.autoDigits()\n             * <li>'none': no truncation\n             * <li>number: truncate after \"number digits\" with JXG.toFixed()\n             * </ul>\n             *\n             * @name Point#infoboxDigits\n             *\n             * @type String, Number\n             * @default 'auto'\n             * @see JXG#autoDigits\n             * @see JXG#toFixed\n             */\n            infoboxDigits: 'auto',\n\n            draft: false,\n\n            /**\n             * List of attractor elements. If the distance of the point is less than\n             * attractorDistance the point is made to glider of this element.\n             *\n             * @name Point#attractors\n             *\n             * @type Array\n             * @default empty\n             */\n            attractors: [],\n\n            /**\n             * Unit for attractorDistance and snatchDistance, used for magnetized points and for snapToPoints.\n             * Possible values are 'screen' and 'user'.\n             *\n             * @name Point#attractorUnit\n             *\n             * @see Point#attractorDistance\n             * @see Point#snatchDistance\n             * @see Point#snapToPoints\n             * @see Point#attractors\n             * @type String\n             * @default 'user'\n             */\n            attractorUnit: 'user',    // 'screen', 'user'\n\n            /**\n             * If the distance of the point to one of its attractors is less\n             * than this number the point will be a glider on this\n             * attracting element.\n             * If set to zero nothing happens.\n             *\n             * @name Point#attractorDistance\n             *\n             * @type Number\n             * @default 0.0\n             */\n            attractorDistance: 0.0,\n\n            /**\n             * If the distance of the point to one of its attractors is at least\n             * this number the point will be released from being a glider on the\n             * attracting element.\n             * If set to zero nothing happens.\n             *\n             * @name Point#snatchDistance\n             *\n             * @type Number\n             * @default 0.0\n             */\n            snatchDistance: 0.0,\n\n            /**\n             * If set to true, the point will snap to a grid of integer multiples of\n             * {@link Point#snapSizeX} and {@link Point#snapSizeY} (in user coordinates).\n             * <p>\n             * The coordinates of the grid points are either integer multiples of snapSizeX and snapSizeY\n             * (given in user coordinates, not pixels) or are the intersection points\n             * of the major ticks of the boards default axes in case that snapSizeX, snapSizeY are negative.\n             *\n             * @name Point#snapToGrid\n             *\n             * @see Point#snapSizeX\n             * @see Point#snapSizeY\n             * @type Boolean\n             * @default false\n             */\n            snapToGrid: false,\n\n            /**\n             * If set to true, the point will only snap to (possibly invisibly) grid points\n             * when within {@link Point#attractorDistance} of such a grid point.\n             * <p>\n             * The coordinates of the grid points are either integer multiples of snapSizeX and snapSizeY\n             * (given in user coordinates, not pixels) or are the intersection points\n             * of the major ticks of the boards default axes in case that snapSizeX, snapSizeY are negative.\n             *\n             * @name Point#attractToGrid\n             *\n             * @see Point#attractorDistance\n             * @see Point#attractorUnit\n             * @see Point#snapToGrid\n             * @see Point#snapSizeX\n             * @see Point#snapSizeY\n             * @type Boolean\n             * @default false\n             *\n             * @example\n             * board.create('point', [3, 3], { attractToGrid: true, attractorDistance: 10, attractorunit: 'screen' });\n             *\n             * </pre><div id=\"JXG397ab787-cd40-449c-a7e7-a3f7bab1d4f6\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG397ab787-cd40-449c-a7e7-a3f7bab1d4f6',\n             *             {boundingbox: [-1, 4, 7,-4], axis: true, showcopyright: false, shownavigation: false});\n             *     board.create('point', [3, 3], { attractToGrid: true, attractorDistance: 10, attractorunit: 'screen' });\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             */\n            attractToGrid: false,\n\n            /**\n             * Defines together with {@link Point#snapSizeY} the grid the point snaps on to.\n             * It is given in user coordinates, not in pixels.\n             * The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.\n             * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks\n             * of the default ticks of the default x axes of the board.\n             *\n             * @name Point#snapSizeX\n             *\n             * @see Point#snapToGrid\n             * @see Point#snapSizeY\n             * @see JXG.Board#defaultAxes\n             * @type Number\n             * @default 1\n             */\n            snapSizeX: 1,\n\n            /**\n             * Defines together with {@link Point#snapSizeX} the grid the point snaps on to.\n             * It is given in user coordinates, not in pixels.\n             * The point will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.\n             * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks\n             * of the default ticks of the default y axes of the board.\n             *\n             * @name Point#snapSizeY\n             *\n             * @see Point#snapToGrid\n             * @see Point#snapSizeX\n             * @see JXG.Board#defaultAxes\n             * @type Number\n             * @default 1\n             */\n            snapSizeY: 1,\n\n            /**\n             * If set to true, the point will snap to the nearest point in distance of\n             * {@link Point#attractorDistance}.\n             *\n             * @name Point#snapToPoints\n             *\n             * @see Point#attractorDistance\n             * @type Boolean\n             * @default false\n             */\n            snapToPoints: false,\n\n            /**\n             * List of elements which are ignored by snapToPoints.\n             * @name Point#ignoredSnapToPoints\n             *\n             * @type Array\n             * @default empty\n             */\n            ignoredSnapToPoints: []\n\n            /**#@-*/\n        },\n\n        /* special polygon options */\n        polygon: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * If <tt>true</tt>, moving the mouse over inner points triggers hasPoint.\n             *\n             * @see JXG.GeometryElement#hasPoint\n             * @name Polygon#hasInnerPoints\n             * @type Boolean\n             * @default false\n             */\n            hasInnerPoints: false,\n\n            fillColor: Color.palette.yellow,\n            highlightFillColor: Color.palette.yellow,\n            // fillColor: '#00ff00',\n            // highlightFillColor: '#00ff00',\n            fillOpacity: 0.3,\n            highlightFillOpacity: 0.2,\n\n            /**\n             * Is the polygon bordered by lines?\n             *\n             * @type Boolean\n             * @name Polygon#withLines\n             * @default true\n             */\n            withLines: true,\n\n            /**\n             * Attributes for the polygon border lines.\n             *\n             * @type Line\n             * @name Polygon#borders\n             */\n            borders: {\n                withLabel: false,\n                strokeWidth: 1,\n                highlightStrokeWidth: 1,\n                // Polygon layer + 1\n                layer: 5,\n                label: {\n                    position: 'top'\n                },\n                visible: 'inherit'\n            },\n\n            /**\n             * Attributes for the polygon vertices.\n             *\n             * @type Point\n             * @name Polygon#vertices\n             */\n            vertices: {\n                layer: 9,\n                withLabel: false,\n                name: '',\n                strokeColor: Color.palette.red,\n                fillColor: Color.palette.red,\n                fixed: false,\n                visible: 'inherit'\n            },\n\n            /**\n             * Attributes for the polygon label.\n             *\n             * @type Label\n             * @name Polygon#label\n             */\n            label: {\n                offset: [0, 0]\n            }\n\n            /**#@-*/\n        },\n\n        /* special polygonal chain options\n        */\n        polygonalchain: {\n            /**#@+\n             * @visprop\n             */\n\n            fillColor: 'none',\n            highlightFillColor: 'none'\n\n            /**#@-*/\n        },\n\n        /* special prescribed angle options\n        * Not yet implemented. But angle.setAngle(val) is implemented.\n        */\n        prescribedangle: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Attributes for the helper point of the prescribed angle.\n             *\n             * @type Point\n             * @name PrescribedAngle#anglePoint\n             */\n            anglePoint: {\n                size: 2,\n                visible: false,\n                withLabel: false\n            }\n\n            /**#@-*/\n        },\n\n        /* special reflection options */\n        reflection: {\n            /**#@+\n             * @visprop\n             */\n\n            fixed: true,\n\n            /**\n             * Attributes of circle center, i.e. the center of the circle,\n             * if a circle is the mirror element and the transformation type is 'Euclidean'\n             *\n             * @type Point\n             * @name mirrorelement#center\n             */\n            center: {},\n\n            /**\n             * Type of transformation. Possible values are 'Euclidean', 'projective'.\n             *\n             * If the value is 'Euclidean', the reflected element of a circle is again a circle,\n             * otherwise it is a conic section.\n             *\n             * @type String\n             * @name reflection#type\n             * @default 'Euclidean'\n             */\n            type: 'Euclidean'\n\n            /**#@-*/\n        },\n\n        /* special regular polygon options */\n        regularpolygon: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * If <tt>true</tt>, moving the mouse over inner points triggers hasPoint.\n             * @see JXG.GeometryElement#hasPoint\n             *\n             * @name RegularPolygon#hasInnerPoints\n             * @type Boolean\n             * @default false\n             */\n            hasInnerPoints: false,\n            fillColor: Color.palette.yellow,\n            highlightFillColor: Color.palette.yellow,\n            fillOpacity: 0.3,\n            highlightFillOpacity: 0.2,\n\n            /**\n             * Is the polygon bordered by lines?\n             *\n             * @type Boolean\n             * @name RegularPolygon#withLines\n             * @default true\n             */\n            withLines: true,\n\n            /**\n             * Attributes for the polygon border lines.\n             *\n             * @type Line\n             * @name RegularPolygon#borders\n             */\n            borders: {\n                withLabel: false,\n                strokeWidth: 1,\n                highlightStrokeWidth: 1,\n                // Polygon layer + 1\n                layer: 5,\n                label: {\n                    position: 'top'\n                }\n            },\n\n            /**\n             * Attributes for the polygon vertices.\n             *\n             * @type Point\n             * @name RegularPolygon#vertices\n             */\n            vertices: {\n                layer: 9,\n                withLabel: true,\n                strokeColor: Color.palette.red,\n                fillColor: Color.palette.red,\n                fixed: false\n            },\n\n            /**\n             * Attributes for the polygon label.\n             *\n             * @type Label\n             * @name Polygon#label\n             */\n            label: {\n                offset: [0, 0]\n            }\n\n            /**#@-*/\n        },\n\n        /* special options for riemann sums */\n        riemannsum: {\n            /**#@+\n             * @visprop\n             */\n\n            withLabel: false,\n            fillOpacity: 0.3,\n            fillColor: Color.palette.yellow\n\n            /**#@-*/\n        },\n\n        /* special sector options */\n        sector: {\n            /**#@+\n             * @visprop\n             */\n\n            fillColor: Color.palette.yellow,\n            highlightFillColor: Color.palette.yellow,\n            // fillColor: '#00ff00',\n            // highlightFillColor: '#00ff00',\n\n            fillOpacity: 0.3,\n            highlightFillOpacity: 0.3,\n            highlightOnSector: false,\n            highlightStrokeWidth: 0,\n\n            /**\n             * Type of sector. Possible values are 'minor', 'major', and 'auto'.\n             *\n             * @type String\n             * @name Sector#selection\n             * @default 'auto'\n             */\n            selection: 'auto',\n\n            /**\n             * Attributes for sub-element arc. It is only available, if the sector is defined by three points.\n             *\n             * @type Arc\n             * @name Sector#arc\n             * @default '{visible:false}'\n             */\n            arc: {\n                visible: false,\n                fillColor: 'none'\n            },\n\n            /**\n             * Attributes for helper point radiuspoint in case it is provided by coordinates.\n             *\n             * @type Point\n             * @name Sector#radiusPoint\n             */\n            radiusPoint: {\n                visible: false,\n                withLabel: false\n            },\n\n            /**\n             * Attributes for helper point center in case it is provided by coordinates.\n             *\n             * @type Point\n             * @name Sector#center\n             */\n            center: {\n                visible: false,\n                withLabel: false\n            },\n\n            /**\n             * Attributes for helper point anglepoint in case it is provided by coordinates.\n             *\n             * @type Point\n             * @name Sector#anglePoint\n             */\n            anglePoint: {\n                visible: false,\n                withLabel: false\n            },\n\n            /**\n             * Attributes for the sector label.\n             *\n             * @type Label\n             * @name Sector#label\n             */\n            label: {\n                offset: [0, 0],\n                anchorX: 'auto',\n                anchorY: 'auto'\n            }\n\n            /**#@-*/\n        },\n\n        /* special segment options */\n        segment: {\n            /**#@+\n             * @visprop\n             */\n\n            label: {\n                position: 'top'\n            }\n            /**#@-*/\n        },\n\n        semicircle: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Attributes for center point of the semicircle.\n             *\n             * @type Point\n             * @name Semicircle#center\n             */\n            center: {\n                visible: false,\n                withLabel: false,\n                fixed: false,\n                fillColor: Color.palette.red,\n                strokeColor: Color.palette.red,\n                highlightFillColor:'#eeeeee',\n                highlightStrokeColor: Color.palette.red,\n                name: ''\n            }\n\n            /**#@-*/\n        },\n\n        /* special slider options */\n        slider: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * The slider only returns integer multiples of this value, e.g. for discrete values set this property to <tt>1</tt>. For\n             * continuous results set this to <tt>-1</tt>.\n             *\n             * @memberOf Slider.prototype\n             * @name snapWidth\n             * @type Number\n             */\n            snapWidth: -1,      // -1 = deactivated\n\n            /**\n             * The precision of the slider value displayed in the optional text.\n             * Replaced by the attribute \"digits\".\n             *\n             * @memberOf Slider.prototype\n             * @name precision\n             * @type Number\n             * @deprecated\n             * @see Slider#digits\n             * @default 2\n             */\n            precision: 2,\n\n            /**\n             * The number of digits of the slider value displayed in the optional text.\n             *\n             * @memberOf Slider.prototype\n             * @name digits\n             * @type Number\n             * @default 2\n             */\n            digits: 2,\n\n            firstArrow: false,\n            lastArrow: false,\n\n            /**\n             * Show slider ticks.\n             *\n             * @type Boolean\n             * @name Slider#withTicks\n             * @default true\n             */\n            withTicks: true,\n\n            /**\n             * Show slider label.\n             *\n             * @type Boolean\n             * @name Slider#withLabel\n             * @default true\n             */\n            withLabel: true,\n\n            /**\n             * If not null, this replaces the part \"name = \" in the slider label.\n             * Possible types: string, number or function.\n             * @type String\n             * @name suffixLabel\n             * @memberOf Slider.prototype\n             * @default null\n             * @see JXG.Slider#unitLabel\n             * @see JXG.Slider#postLabel\n             */\n            suffixLabel: null,\n\n            /**\n             * If not null, this is appended to the value in the slider label.\n             * Possible types: string, number or function.\n             * @type String\n             * @name unitLabel\n             * @memberOf Slider.prototype\n             * @default null\n             * @see JXG.Slider#suffixLabel\n             * @see JXG.Slider#postLabel\n             */\n            unitLabel: null,\n\n            /**\n             * If not null, this is appended to the value and to unitLabel in the slider label.\n             * Possible types: string, number or function.\n             * @type String\n             * @name postLabel\n             * @memberOf Slider.prototype\n             * @default null\n             * @see JXG.Slider#suffixLabel\n             * @see JXG.Slider#unitLabel\n             */\n            postLabel: null,\n\n            layer: 9,\n            showInfobox: false,\n            name: '',\n            visible: true,\n            strokeColor: '#000000',\n            highlightStrokeColor: '#888888',\n            fillColor: '#ffffff',\n            highlightFillColor: 'none',\n\n            /**\n             * Size of slider point.\n             *\n             * @type Number\n             * @name Slider#size\n             * @default 6\n             * @see Point#size\n             */\n            size: 6,\n\n            /**\n             * Attributes for first (left) helper point defining the slider position.\n             *\n             * @type Point\n             * @name Slider#point1\n             */\n            point1: {\n                needsRegularUpdate: false,\n                showInfobox: false,\n                withLabel: false,\n                visible: false,\n                fixed: true,\n                name: ''\n            },\n\n            /**\n             * Attributes for second (right) helper point defining the slider position.\n             *\n             * @type Point\n             * @name Slider#point2\n             */\n            point2: {\n                needsRegularUpdate: false,\n                showInfobox: false,\n                withLabel: false,\n                visible: false,\n                fixed: true,\n                name: ''\n            },\n\n            /**\n             * Attributes for the base line of the slider.\n             *\n             * @type Line\n             * @name Slider#baseline\n             */\n            baseline: {\n                needsRegularUpdate: false,\n                visible: 'inherit',\n                fixed: true,\n                scalable: false,\n                tabindex: null,\n                name: '',\n                strokeWidth: 1,\n                strokeColor: '#000000',\n                highlightStrokeColor: '#888888'\n            },\n\n            /**\n             * Attributes for the ticks of the base line of the slider.\n             *\n             * @type Ticks\n             * @name Slider#ticks\n             */\n            ticks: {\n                needsRegularUpdate: false,\n                fixed: true,\n\n                // Label drawing\n                drawLabels: false,\n                digits: 2,\n                includeBoundaries: 1,\n                drawZero: true,\n                label: {\n                    offset: [-4, -14],\n                    display: 'internal'\n                },\n\n                minTicksDistance: 30,\n                insertTicks: true,\n                minorHeight: 4,         // if <0: full width and height\n                majorHeight: 5,        // if <0: full width and height\n                minorTicks: 0,\n                defaultDistance: 1,\n                strokeOpacity: 1,\n                strokeWidth: 1,\n                tickEndings: [0, 1],\n                majortickEndings: [0, 1],\n                strokeColor: '#000000',\n                visible: 'inherit'\n            },\n\n            /**\n             * Attributes for the highlighting line of the slider.\n             *\n             * @type Line\n             * @name Slider#highline\n             */\n            highline: {\n                strokeWidth: 3,\n                visible: 'inherit',\n                fixed: true,\n                tabindex: null,\n                name: '',\n                strokeColor: '#000000',\n                highlightStrokeColor: '#888888'\n            },\n\n            /**\n             * Attributes for the slider label.\n             *\n             * @type Label\n             * @name Slider#label\n             */\n            label: {\n                visible: 'inherit',\n                strokeColor: '#000000'\n            },\n\n            /**\n             * If true, 'up' events on the baseline will trigger slider moves.\n             *\n             * @type: Boolean\n             * @name Slider#moveOnUp\n             * @default: true\n             */\n            moveOnUp: true\n\n            /**#@-*/\n        },\n\n        /* special options for comb */\n        comb: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * Frequency of comb elements.\n             *\n             * @type Number\n             * @name Comb#frequency\n             * @default 0.2\n             */\n            frequency: 0.2,\n\n            /**\n             * Width of the comb.\n             *\n             * @type Number\n             * @name Comb#width\n             * @default 0.4\n             */\n            width: 0.4,\n\n            /**\n             * Angle under which comb elements are positioned.\n             *\n             * @type Number\n             * @name Comb#angle\n             * @default 60 degrees\n             */\n            angle: Math.PI / 3,\n\n            /**\n             * Should the comb go right to left instead of left to right.\n             *\n             * @type Boolean\n             * @name Comb#reverse\n             * @default false\n             */\n            reverse: false,\n\n            /**\n             * Attributes for first defining point of the comb.\n             *\n             * @type Point\n             * @name Comb#point1\n             */\n            point1: {\n                visible: false,\n                withLabel: false,\n                fixed: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for second defining point of the comb.\n             *\n             * @type Point\n             * @name Comb#point2\n             */\n            point2: {\n                visible: false,\n                withLabel: false,\n                fixed: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for the curve displaying the comb.\n             *\n             * @type Curve\n             * @name Comb#curve\n             */\n            curve: {\n                strokeWidth: 1,\n                strokeColor: '#000000',\n                fillColor: 'none'\n            }\n        },\n\n        /* special options for slope triangle */\n        slopetriangle: {\n            /**#@+\n             * @visprop\n             */\n\n            fillColor: Color.palette.red,\n            fillOpacity: 0.4,\n            highlightFillColor: Color.palette.red,\n            highlightFillOpacity: 0.3,\n\n            borders: {\n                lastArrow: {\n                    type: 1,\n                    size: 6\n                }\n            },\n\n            /**\n             * Attributes for the gliding helper point.\n             *\n             * @type Point\n             * @name Slopetriangle#glider\n             */\n            glider: {\n                fixed: true,\n                visible: false,\n                withLabel: false\n            },\n\n            /**\n             * Attributes for the base line.\n             *\n             * @type Line\n             * @name Slopetriangle#baseline\n             */\n            baseline: {\n                visible: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for the base point.\n             *\n             * @type Point\n             * @name Slopetriangle#basepoint\n             */\n            basepoint: {\n                visible: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for the tangent.\n             * The tangent is constructed by slop triangle if the construction\n             * is based on a glider, solely.\n             *\n             * @type Line\n             * @name Slopetriangle#tangent\n             */\n            tangent: {\n                visible: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for the top point.\n             *\n             * @type Point\n             * @name Slopetriangle#toppoint\n             */\n            toppoint: {\n                visible: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for the slope triangle label.\n             *\n             * @type Label\n             * @name Slopetriangle#label\n             */\n            label: {\n                visible: true\n            }\n            /**#@-*/\n        },\n\n        /* special options for step functions */\n        stepfunction: {\n            /**#@+\n             * @visprop\n             */\n\n            /**#@-*/\n        },\n\n        /* special tape measure options */\n        tapemeasure: {\n            /**#@+\n             * @visprop\n             */\n\n            strokeColor: '#000000',\n            strokeWidth: 2,\n            highlightStrokeColor: '#000000',\n\n            /**\n             * Show tape measure ticks.\n             *\n             * @type Boolean\n             * @name Tapemeasure#withTicks\n             * @default true\n             */\n            withTicks: true,\n\n            /**\n             * Show tape measure label.\n             *\n             * @type Boolean\n             * @name Tapemeasure#withLabel\n             * @default true\n             */\n            withLabel: true,\n\n            /**\n             * The precision of the tape measure value displayed in the optional text.\n             * Replaced by the attribute digits\n             *\n             * @memberOf Tapemeasure.prototype\n             * @name precision\n             * @type Number\n             * @deprecated\n             * @see Tapemeasure#digits\n             * @default 2\n             */\n            precision: 2,\n\n            /**\n             * The precision of the tape measure value displayed in the optional text.\n             * @memberOf Tapemeasure.prototype\n             * @name precision\n             * @type Number\n             * @default 2\n             */\n            digits: 2,\n\n            /**\n             * Attributes for first helper point defining the tape measure position.\n             *\n             * @type Point\n             * @name Tapemeasure#point1\n             */\n            point1: {\n                visible: 'inherit',\n                strokeColor: '#000000',\n                fillColor: '#ffffff',\n                fillOpacity: 0.0,\n                highlightFillOpacity: 0.1,\n                size: 6,\n                snapToPoints: true,\n                attractorUnit: 'screen',\n                attractorDistance: 20,\n                showInfobox: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for second helper point defining the tape measure position.\n             *\n             * @type Point\n             * @name Tapemeasure#point2\n             */\n            point2: {\n                visible: 'inherit',\n                strokeColor: '#000000',\n                fillColor: '#ffffff',\n                fillOpacity: 0.0,\n                highlightFillOpacity: 0.1,\n                size: 6,\n                snapToPoints: true,\n                attractorUnit: 'screen',\n                attractorDistance: 20,\n                showInfobox: false,\n                withLabel: false,\n                name: ''\n            },\n\n            /**\n             * Attributes for the ticks of the tape measure.\n             *\n             * @type Ticks\n             * @name Tapemeasure#ticks\n             */\n            ticks: {\n                drawLabels: false,\n                drawZero: true,\n                insertTicks: true,\n                minorHeight: 8,\n                majorHeight: 16,\n                minorTicks: 4,\n                tickEndings: [0, 1],\n                majorTickEndings: [0, 1],\n                defaultDistance: 0.1,\n                strokeOpacity: 1,\n                strokeWidth: 1,\n                strokeColor: '#000000',\n                visible: 'inherit'\n            },\n\n            /**\n             * Attributes for the tape measure label.\n             *\n             * @type Label\n             * @name Tapemeasure#label\n             */\n            label: {\n                position: 'top'\n            }\n            /**#@-*/\n        },\n\n        /* special text options */\n        text: {\n            /**#@+\n             * @visprop\n             */\n\n            /**\n             * The font size in pixels.\n             *\n             * @name fontSize\n             * @memberOf Text.prototype\n             * @default 12\n             * @type Number\n             * @see Text#fontUnit\n             */\n            fontSize: 12,\n\n            /**\n             * CSS unit for the font size of a text element. Usually, this will be the default value 'px' but\n             * for responsive application, also 'vw', 'vh', vmax', 'vmin' or 'rem' might be useful.\n             *\n             * @name fontUnit\n             * @memberOf Text.prototype\n             * @default 'px'\n             * @type String\n             * @see Text#fontSize\n             *\n             * @example\n             * var txt = board.create('text', [2, 2, \"hello\"], {fontSize: 8, fontUnit: 'vmin'});\n             *\n             * </pre><div id=\"JXG2da7e972-ac62-416b-a94b-32559c9ec9f9\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG2da7e972-ac62-416b-a94b-32559c9ec9f9',\n             *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n             *     var txt = board.create('text', [2, 2, \"hello\"], {fontSize: 8, fontUnit: 'vmin'});\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             */\n            fontUnit: 'px',\n\n            /**\n             * Used to round texts given by a number.\n             *\n             * @name digits\n             * @memberOf Text.prototype\n             * @default 2\n             * @type Number\n             */\n            digits: 2,\n\n            /**\n             * If set to true, the text is parsed and evaluated.\n             * For labels parse==true results in converting names of the form k_a to subscripts.\n             * If the text is given by string and parse==true, the string is parsed as\n             * JessieCode expression.\n             *\n             * @name parse\n             * @memberOf Text.prototype\n             * @default true\n             * @type Boolean\n             */\n            parse: true,\n\n            /**\n             * If set to true and caja's sanitizeHTML function can be found it\n             * will be used to sanitize text output.\n             *\n             * @name useCaja\n             * @memberOf Text.prototype\n             * @default false\n             * @type Boolean\n             */\n            useCaja: false,\n\n            /**\n             * If enabled, the text will be handled as label. Intended for internal use.\n             *\n             * @name isLabel\n             * @memberOf Text.prototype\n             * @default false\n             * @type Boolean\n             */\n            isLabel: false,\n\n            strokeColor: '#000000',\n            highlightStrokeColor: '#000000',\n            highlightStrokeOpacity: 0.666666,\n\n            /**\n             * Default CSS properties of the HTML text element.\n             * <p>\n             * The CSS properties which are set here, are handed over to the style property\n             * of the HTML text element. That means, they have higher property than any\n             * CSS class.\n             * <p>\n             * If a property which is set here should be overruled by a CSS class\n             * then this property should be removed here.\n             * <p>\n             * The reason, why this attribute should be kept to its default value at all,\n             * is that screen dumps of SVG boards with <tt>board.renderer.dumpToCanvas()</tt>\n             * will ignore the font-family if it is set in a CSS class.\n             * It has to be set explicitly as style attribute.\n             * <p>\n             * In summary, the order of priorities from high to low is\n             * <ol>\n             *  <li> JXG.Options.text.cssStyle\n             *  <li> JXG.Options.text.cssDefaultStyle\n             *  <li> JXG.Options.text.cssClass\n             * </ol>\n             * @example\n             * If all texts should get its font-family from the default CSS class\n             * before initializing the board\n             * <pre>\n             *   JXG.Options.text.cssDefaultStyle = '';\n             *   JXG.Options.text.highlightCssDefaultStyle = '';\n             * </pre>\n             * should be called.\n             *\n             * @name cssDefaultStyle\n             * @memberOf Text.prototype\n             * @default  'font-family: Arial, Helvetica, Geneva, sans-serif;'\n             * @type String\n             * @see Text#highlightCssDefaultStyle\n             * @see Text#cssStyle\n             * @see Text#highlightCssStyle\n             */\n            cssDefaultStyle: 'font-family: Arial, Helvetica, Geneva, sans-serif;',\n\n            /**\n             * Default CSS properties of the HTML text element in case of highlighting.\n             * <p>\n             * The CSS properties which are set here, are handed over to the style property\n             * of the HTML text element. That means, they have higher property than any\n             * CSS class.\n             * @example\n             * If all texts should get its font-family from the default CSS class\n             * before initializing the board\n             * <pre>\n             *   JXG.Options.text.cssDefaultStyle = '';\n             *   JXG.Options.text.highlightCssDefaultStyle = '';\n             * </pre>\n             * should be called.\n             *\n             * @name highlightCssDefaultStyle\n             * @memberOf Text.prototype\n             * @default  'font-family: Arial, Helvetica, Geneva, sans-serif;'\n             * @type String\n             * @see Text#cssDefaultStyle\n             * @see Text#cssStyle\n             * @see Text#highlightCssStyle\n            */\n            highlightCssDefaultStyle: 'font-family: Arial, Helvetica, Geneva, sans-serif;',\n\n            /**\n             * CSS properties of the HTML text element.\n             * <p>\n             * The CSS properties which are set here, are handed over to the style property\n             * of the HTML text element. That means, they have higher property than any\n             * CSS class.\n             *\n             * @name cssStyle\n             * @memberOf Text.prototype\n             * @default  ''\n             * @type String\n             * @see Text#cssDefaultStyle\n             * @see Text#highlightCssDefaultStyle\n             * @see Text#highlightCssStyle\n            */\n            cssStyle: '',\n\n            /**\n             * CSS properties of the HTML text element in case of highlighting.\n             * <p>\n             * The CSS properties which are set here, are handed over to the style property\n             * of the HTML text element. That means, they have higher property than any\n             * CSS class.\n             *\n             * @name highlightCssStyle\n             * @memberOf Text.prototype\n             * @default  ''\n             * @type String\n             * @see Text#cssDefaultStyle\n             * @see Text#highlightCssDefaultStyle\n             * @see Text#cssStyle\n            */\n            highlightCssStyle: '',\n\n            transitionDuration: 0,\n\n            /**\n             * If true, the input will be given to ASCIIMathML before rendering.\n             *\n             * @name useASCIIMathML\n             * @memberOf Text.prototype\n             * @default false\n             * @type Boolean\n             */\n            useASCIIMathML: false,\n\n            /**\n             * If true, MathJax will be used to render the input string.\n             * Supports MathJax 2 as well as Mathjax 3.\n             * It is recommended to use this option together with the option\n             * \"parse: false\". Otherwise, 4 backslashes (e.g. \\\\\\\\alpha) are needed\n             * instead of two (e.g. \\\\alpha).\n             *\n             * @name useMathJax\n             * @memberOf Text.prototype\n             * @default false\n             * @type Boolean\n             * @see Text#parse\n             *\n             * @example\n             *  // Before loading MathJax, it has to be configured something like this:\n             * window.MathJax = {\n             *   tex: {\n             *     inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n             *     displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ],\n             *     packages: ['base', 'ams']\n             *   },\n             *   options: {\n             *     ignoreHtmlClass: 'tex2jax_ignore',\n             *     processHtmlClass: 'tex2jax_process'\n             *   }\n             * };\n             *\n             * // Display style\n             * board.create('text',[ 2,2,  function(){return '$$X=\\\\frac{2}{x}$$'}], {\n             *     fontSize: 15, color:'green', useMathJax: true});\n             *\n             * // Inline style\n             * board.create('text',[-2,2,  function(){return '$X_A=\\\\frac{2}{x}$'}], {\n             *     fontSize: 15, color:'green', useMathJax: true});\n             *\n             * var A = board.create('point', [-2, 0]);\n             * var B = board.create('point', [1, 0]);\n             * var C = board.create('point', [0, 1]);\n             *\n             * var graph = board.create('ellipse', [A, B, C], {\n             *         fixed: true,\n             *         withLabel: true,\n             *         strokeColor: 'black',\n             *         strokeWidth: 2,\n             *         fillColor: '#cccccc',\n             *         fillOpacity: 0.3,\n             *         highlightStrokeColor: 'red',\n             *         highlightStrokeWidth: 3,\n             *         name: '$1=\\\\frac{(x-h)^2}{a^2}+\\\\frac{(y-k)^2}{b^2}$',\n             *         label: {useMathJax: true}\n             *     });\n             *\n             * var nvect1 = board.create('text', [-4, -3, '\\\\[\\\\overrightarrow{V}\\\\]'],\n             * {\n             *   fontSize: 24, parse: false\n             * });\n             * var nvect1 = board.create('text', [-2, -4, function() {return '$\\\\overrightarrow{G}$';}],\n             * {\n             *   fontSize: 24, useMathJax: true\n             * });\n             *\n             * </pre>\n             * <script>\n             * window.MathJax = {\n             *   tex: {\n             *     inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n             *     displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ],\n             *     packages: ['base', 'ams']\n             *   },\n             *   options: {\n             *     ignoreHtmlClass: 'tex2jax_ignore',\n             *     processHtmlClass: 'tex2jax_process'\n             *   }\n             * };\n             * </script>\n             * <script src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\" id=\"MathJax-script\"></script>\n             * <div id=\"JXGe2a04876-5813-4db0-b7e8-e48bf4e220b9\" class=\"jxgbox\" style=\"width: 400px; height: 400px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGe2a04876-5813-4db0-b7e8-e48bf4e220b9',\n             *             {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright: false, shownavigation: false});\n             *     // Display style\n             *     board.create('text',[ 2,2,  function(){return '$$X=\\\\frac{2}{x}$$'}], {\n             *         fontSize: 15, color:'green', useMathJax: true});\n             *\n             *     // Inline style\n             *     board.create('text',[-2,2,  function(){return '$X_A=\\\\frac{2}{x}$'}], {\n             *         fontSize: 15, color:'green', useMathJax: true});\n             *\n             *     var A = board.create('point', [-2, 0]);\n             *     var B = board.create('point', [1, 0]);\n             *     var C = board.create('point', [0, 1]);\n             *\n             *     var graph = board.create('ellipse', [A, B, C], {\n             *             fixed: true,\n             *             withLabel: true,\n             *             strokeColor: 'black',\n             *             strokeWidth: 2,\n             *             fillColor: '#cccccc',\n             *             fillOpacity: 0.3,\n             *             highlightStrokeColor: 'red',\n             *             highlightStrokeWidth: 3,\n             *             name: '$1=\\\\frac{(x-h)^2}{a^2}+\\\\frac{(y-k)^2}{b^2}$',\n             *             label: {useMathJax: true}\n             *         });\n             *\n             *     var nvect1 = board.create('text', [-4, -3, '\\\\[\\\\overrightarrow{V}\\\\]'],\n             *     {\n             *       fontSize: 24, parse: false\n             *     });\n             *     var nvect1 = board.create('text', [-2, -4, function() {return '$\\\\overrightarrow{G}$';}],\n             *     {\n             *       fontSize: 24, useMathJax: true\n             *     });\n             *     })();\n             *\n             * </script><pre>\n             *\n             *\n             * @example\n             * // Load MathJax:\n             * // &lt;script src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\"&lt;&lt;/script&gt;\n             *\n             * // function and its derivative\n             * var f1 = function(x) { return x * x * x; },\n             * graph1 = board.create('functiongraph', [f1, -0.1, 1.1]),\n             *\n             * A = board.create('glider', [0.5, f1(0.5), graph1], {\n             *             name: 'f(x)',\n             *             color: 'black',\n             *             face:'x',\n             *             fixed: true,\n             *             size: 3,\n             *             label: {offset: [-30, 10], fontSize: 15}\n             *         }),\n             * B = board.create('glider', [0.7, f1(0.7), graph1], {\n             *             name: 'f(x+&Delta;x)',\n             *             size: 3,\n             *             label: {offset: [-60, 10], fontSize: 15}\n             *         }),\n             *\n             * secant_line = board.create('line', [A,B],{dash: 1, color: 'green'}),\n             * a_h_segment = board.create('segment', [A, [\n             *                     function(){ return B.X() > A.X() ? B.X() : A.X()},\n             *                     function(){ return B.X() > A.X() ? A.Y() : B.Y()}\n             *                 ]],{ name: '&Delta;x', dash: 1, color: 'black'});\n             *\n             * b_v_segment = board.create('segment', [B, [\n             *                     function(){ return B.X() > A.X() ? B.X() : A.X()},\n             *                     function(){ return B.X() > A.X() ? A.Y() : B.Y()}\n             *                 ]],{ name: '&Delta;y', dash: 1, color: 'black'}),\n             *\n             * ma = board.create('midpoint', [a_h_segment.point1, a_h_segment.point2\n             *     ], {visible: false});\n             *\n             * board.create('text', [0, 0, function() {return '\\\\[\\\\Delta_x='+(B.X()-A.X()).toFixed(4)+'\\\\]'}], {\n             *     anchor: ma, useMathJax: true, fixed: true, color: 'green', anchorY: 'top'\n             * });\n             *\n             * mb = board.create('midpoint', [b_v_segment.point1, b_v_segment.point2], {visible: false});\n             * board.create('text', [0, 0, function() {return '\\\\[\\\\Delta_y='+(B.Y()-A.Y()).toFixed(4)+'\\\\]'}], {\n             *     anchor: mb, useMathJax: true, fixed: true, color: 'green'\n             * });\n             *\n             * dval = board.create('text',[0.1, 0.8,\n             *     function(){\n             *         return '\\\\[\\\\frac{\\\\Delta_y}{\\\\Delta_x}=\\\\frac{' + ((B.Y()-A.Y()).toFixed(4)) + '}{' + ((B.X()-A.X()).toFixed(4)) +\n             *             '}=' + (((B.Y()-A.Y()).toFixed(4))/((B.X()-A.X()).toFixed(4))).toFixed(4) + '\\\\]';\n             *     }],{fontSize: 15, useMathJax: true});\n             *\n             * </pre>\n             * <script src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\" id=\"MathJax-script\"></script>\n             * <div id=\"JXG8c2b65e7-4fc4-43f7-b23c-5076a7fa9621\" class=\"jxgbox\" style=\"width: 400px; height: 400px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG8c2b65e7-4fc4-43f7-b23c-5076a7fa9621',\n             *             {boundingbox: [-0.1, 1.1, 1.1, -0.1], axis: true, showcopyright: false, shownavigation: false});\n             *     // function and its derivative\n             *     var f1 = function(x) { return x * x * x; },\n             *     graph1 = board.create('functiongraph', [f1, -0.1, 1.1]),\n             *\n             *     A = board.create('glider', [0.5, f1(0.5), graph1], {\n             *                 name: 'f(x)',\n             *                 color: 'black',\n             *                 face:'x',\n             *                 fixed: true,\n             *                 size: 3,\n             *                 label: {offset: [-30, 10], fontSize: 15}\n             *             }),\n             *     B = board.create('glider', [0.7, f1(0.7), graph1], {\n             *                 name: 'f(x+&Delta;x)',\n             *                 size: 3,\n             *                 label: {offset: [-60, 10], fontSize: 15}\n             *             }),\n             *\n             *     secant_line = board.create('line', [A,B],{dash: 1, color: 'green'}),\n             *     a_h_segment = board.create('segment', [A, [\n             *                         function(){ return B.X() > A.X() ? B.X() : A.X()},\n             *                         function(){ return B.X() > A.X() ? A.Y() : B.Y()}\n             *                     ]],{ name: '&Delta;x', dash: 1, color: 'black'});\n             *\n             *     b_v_segment = board.create('segment', [B, [\n             *                         function(){ return B.X() > A.X() ? B.X() : A.X()},\n             *                         function(){ return B.X() > A.X() ? A.Y() : B.Y()}\n             *                     ]],{ name: '&Delta;y', dash: 1, color: 'black'}),\n             *\n             *     ma = board.create('midpoint', [a_h_segment.point1, a_h_segment.point2\n             *         ], {visible: false});\n             *\n             *     board.create('text', [0, 0, function() {return '\\\\[\\\\Delta_x='+(B.X()-A.X()).toFixed(4)+'\\\\]'}], {\n             *         anchor: ma, useMathJax: true, fixed: true, color: 'green', anchorY: 'top'\n             *     });\n             *\n             *     mb = board.create('midpoint', [b_v_segment.point1, b_v_segment.point2], {visible: false});\n             *     board.create('text', [0, 0, function() {return '\\\\[\\\\Delta_y='+(B.Y()-A.Y()).toFixed(4)+'\\\\]'}], {\n             *         anchor: mb, useMathJax: true, fixed: true, color: 'green'\n             *     });\n             *\n             *     dval = board.create('text',[0.1, 0.8,\n             *         function(){\n             *             return '\\\\[\\\\frac{\\\\Delta_y}{\\\\Delta_x}=\\\\frac{' + ((B.Y()-A.Y()).toFixed(4)) + '}{' + ((B.X()-A.X()).toFixed(4)) +\n             *                 '}=' + (((B.Y()-A.Y()).toFixed(4))/((B.X()-A.X()).toFixed(4))).toFixed(4) + '\\\\]';\n             *         }],{fontSize: 15, useMathJax: true});\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             * @example\n             * var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-1, 10, 11, -2], axis: true});\n             * board.options.text.useMathjax = true;\n             *\n             * a = board.create('slider',[[-0.7,1.5],[5,1.5],[0,0.5,1]], {\n             *     suffixlabel:'\\\\(t_1=\\\\)',\n             *     unitLabel: ' \\\\(\\\\text{ ms}\\\\)',\n             *     snapWidth:0.01}),\n             *\n             * func = board.create('functiongraph',[function(x){return (a.Value()*x*x)}], {strokeColor: \"red\"});\n             * text1 = board.create('text', [5, 1, function(){\n             *             return '\\\\(a(t)= { 1 \\\\over ' + a.Value().toFixed(3) + '}\\\\)';\n             *         }], {fontSize: 15, fixed:true, strokeColor:'red', anchorY: 'top', parse: false});\n             *\n             * </pre><div id=\"JXGf8bd01db-fb6a-4a5c-9e7f-8823f7aa5ac6\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXGf8bd01db-fb6a-4a5c-9e7f-8823f7aa5ac6',\n             *             {boundingbox: [-1, 10, 11, -2], axis: true, showcopyright: false, shownavigation: false});\n             *     board.options.text.useMathjax = true;\n             *\n             *     a = board.create('slider',[[-0.7,1.5],[5,1.5],[0,0.5,1]], {\n             *         suffixlabel:'\\\\(t_1=\\\\)',\n             *         unitLabel: ' \\\\(\\\\text{ ms}\\\\)',\n             *         snapWidth:0.01}),\n             *\n             *     func = board.create('functiongraph',[function(x){return (a.Value()*x*x)}], {strokeColor: \"red\"});\n             *     text1 = board.create('text', [5, 1, function(){\n             *                 return '\\\\(a(t)= { 1 \\\\over ' + a.Value().toFixed(3) + '}\\\\)';\n             *             }], {fontSize: 15, fixed:true, strokeColor:'red', anchorY: 'top', parse: false});\n             *\n             *     })();\n             *\n             * </script><pre>\n             *\n             */\n            useMathJax: false,\n\n            /**\n             *\n             * If true, KaTeX will be used to render the input string.\n             * For this feature, katex.min.js and katex.min.css have to be included.\n             * <p>\n             * The example below does not work, because there is a conflict with\n             * the MathJax library which is used below.\n             * </p>\n             *\n             * @name useKatex\n             * @memberOf Text.prototype\n             * @default false\n             * @type Boolean\n             *\n             *\n             * @example\n             * JXG.Options.text.useKatex = true;\n             *\n             * const board = JXG.JSXGraph.initBoard('jxgbox', {\n             *     boundingbox: [-2, 5, 8, -5], axis:true\n             * });\n             *\n             * var a = board.create('slider',[[-0.7,1.5],[5,1.5],[0,0.5,1]], {\n             *     suffixlabel:'t_1=',\n             *     unitLabel: ' \\\\text{ ms}',\n             *     snapWidth:0.01});\n             *\n             * func = board.create('functiongraph',[function(x){return (a.Value()*x*x)}], {strokeColor: \"red\"});\n             * text1 = board.create('text', [5, 1, function(){\n             *             return 'a(t)= { 1 \\\\over ' + a.Value().toFixed(3) + '}';\n             *         }], {fontSize: 15, fixed:true, strokeColor:'red', anchorY: 'top'});\n             *\n             * </pre>\n             * <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css\" integrity=\"sha384-0cCFrwW/0bAk1Z/6IMgIyNU3kfTcNirlObr4WjrUU7+hZeD6ravdYJ3kPWSeC31M\" crossorigin=\"anonymous\">\n             * <script src=\"https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.js\" integrity=\"sha384-dtFDxK2tSkECx/6302Z4VN2ZRqt6Gis+b1IwCjJPrn0kMYFQT9rbtyQWg5NFWAF7\" crossorigin=\"anonymous\"></script>\n             * <div id=\"JXG497f065c-cfc1-44c3-ba21-5fa581668869\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n             * <script type=\"text/javascript\">\n             *     (function() {\n             *         var board = JXG.JSXGraph.initBoard('JXG497f065c-cfc1-44c3-ba21-5fa581668869',\n             *             {boundingbox: [-2, 5, 8, -5], axis: true, showcopyright: false, shownavigation: false});\n             *     board.options.useKatex = true;\n             *     var a = board.create('slider',[[-0.7,1.5],[5,1.5],[0,0.5,1]], {\n             *         suffixlabel:'t_1=',\n             *         unitLabel: ' \\\\text{ ms}',\n             *         snapWidth:0.01});\n             *\n             *     func = board.create('functiongraph',[function(x){return (a.Value()*x*x)}], {strokeColor: \"red\"});\n             *     text1 = board.create('text', [5, 1, function(){\n             *                 return 'a(t)= { 1 \\\\over ' + a.Value().toFixed(3) + '}';\n             *             }], {fontSize: 15, fixed:true, strokeColor:'red', anchorY: 'top'});\n             *\n             *     })();\n             *\n             * </script><pre>\n             */\n            useKatex: false,\n\n            /**\n             * Determines the rendering method of the text. Possible values\n             * include <tt>'html'</tt> and <tt>'internal</tt>.\n             *\n             * @name display\n             * @memberOf Text.prototype\n             * @default 'html'\n             * @type String\n             */\n            display: 'html',\n\n            /**\n             * Anchor element {@link Point}, {@link Text} or {@link Image} of the text.\n             * If it exists, the coordinates of the text are relative\n             * to this anchor element. In this case, only numbers are possible coordinates,\n             * functions are not supported.\n             *\n             * @name anchor\n             * @memberOf Text.prototype\n             * @default null\n             * @type Object\n             */\n            anchor: null,\n\n            /**\n             * The horizontal alignment of the text. Possible values include <tt>'auto</tt>, <tt>'left'</tt>,\n             * <tt>'middle'</tt>, and <tt>'right'</tt>.\n             *\n             * @name anchorX\n             * @memberOf Text.prototype\n             * @default 'left'\n             * @type String\n             */\n            anchorX: 'left',\n\n            /**\n             * The vertical alignment of the text. Possible values include <tt>'auto</tt>, <tt>'top'</tt>, <tt>'middle'</tt>, and\n             * <tt>'bottom'</tt>.\n             * For MathJax or KaTeX, 'top' is recommended.\n             *\n             * @name anchorY\n             * @memberOf Text.prototype\n             * @default 'middle'\n             * @type String\n             */\n            anchorY: 'middle',\n\n            /**\n             * CSS class of the text in non-highlighted view.\n             *\n             * @name cssClass\n             * @memberOf Text.prototype\n             * @type String\n             * @default 'JXGtext'\n             */\n            cssClass: 'JXGtext',\n\n            /**\n             * CSS class of the text in highlighted view.\n             *\n             * @name highlightCssClass\n             * @memberOf Text.prototype\n             * @type String\n             * @default 'JXGtext'\n             */\n            highlightCssClass: 'JXGtext',\n\n            /**\n             * Sensitive area for dragging the text.\n             * Possible values are 'all', or something else.\n             * If set to 'small', a sensitivity margin at the right and left border is taken.\n             * This may be extended to left, right, ... in the future.\n             *\n             * @name Text#dragArea\n             * @type String\n             * @default 'all'\n             */\n            dragArea: 'all',\n\n            withLabel: false,\n\n            /**\n             * Text rotation in degrees.\n             * Works for non-zero values only in combination with display=='internal'.\n             *\n             * @name Text#rotate\n             * @type Number\n             * @default 0\n             */\n            rotate: 0,\n\n            visible: true,\n\n            /**\n             * Defines together with {@link Text#snapSizeY} the grid the text snaps on to.\n             * The text will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.\n             * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks\n             * of the default ticks of the default x axes of the board.\n             *\n             * @name snapSizeX\n             * @memberOf Text.prototype\n             *\n             * @see Point#snapToGrid\n             * @see Text#snapSizeY\n             * @see JXG.Board#defaultAxes\n             * @type Number\n             * @default 1\n             */\n            snapSizeX: 1,\n\n            /**\n             * Defines together with {@link Text#snapSizeX} the grid the text snaps on to.\n             * The text will only snap on integer multiples to snapSizeX in x and snapSizeY in y direction.\n             * If this value is equal to or less than <tt>0</tt>, it will use the grid displayed by the major ticks\n             * of the default ticks of the default y axes of the board.\n             *\n             * @name snapSizeY\n             * @memberOf Text.prototype\n             *\n             * @see Point#snapToGrid\n             * @see Text#snapSizeX\n             * @see JXG.Board#defaultAxes\n             * @type Number\n             * @default 1\n             */\n            snapSizeY: 1,\n\n            /**\n             * List of attractor elements. If the distance of the text is less than\n             * attractorDistance the text is made to glider of this element.\n             *\n             * @name attractors\n             * @memberOf Text.prototype\n             * @type Array\n             * @default empty\n             */\n            attractors: []\n\n            /**#@-*/\n        },\n\n        /* special options for trace curves */\n        tracecurve: {\n            /**#@+\n             * @visprop\n             */\n            strokeColor: '#000000',\n            fillColor: 'none',\n\n            /**\n             * The number of evaluated data points.\n             * @memberOf Tracecurve.prototype\n             * @default 100\n             * @name numberPoints\n             * @type Number\n             */\n            numberPoints: 100\n\n            /**#@-*/\n        },\n\n        /*special turtle options */\n        turtle: {\n            /**#@+\n             * @visprop\n             */\n\n            strokeWidth: 1,\n            fillColor: 'none',\n            strokeColor: '#000000',\n\n            /**\n             * Attributes for the turtle arrow.\n             *\n             * @type Curve\n             * @name Turtle#arrow\n             */\n            arrow: {\n                strokeWidth: 2,\n                withLabel: false,\n                strokeColor: Color.palette.red,\n                lastArrow: true\n            }\n            /**#@-*/\n        },\n\n        /**\n         * Abbreviations of attributes. Setting the shortcut means setting abbreviated properties\n         * to the same value.\n         * It is used in {@link JXG.GeometryElement#setAttribute} and in\n         * the constructor {@link JXG.GeometryElement}.\n         * Attention: In Options.js abbreviations are not allowed.\n         * @type Object\n         * @name JXG.Options#shortcuts\n         *\n         */\n        shortcuts: {\n            color: ['strokeColor', 'fillColor'],\n            opacity: ['strokeOpacity', 'fillOpacity'],\n            highlightColor: ['highlightStrokeColor', 'highlightFillColor'],\n            highlightOpacity: ['highlightStrokeOpacity', 'highlightFillOpacity'],\n            strokeWidth: ['strokeWidth', 'highlightStrokeWidth']\n        }\n    };\n\n    /**\n     * Holds all possible properties and the according validators for geometry elements.\n     * A validator is either a function\n     * which takes one parameter and returns true, if the value is valid for the property,\n     * or it is false if no validator is required.\n     */\n    JXG.Validator = (function () {\n        var i,\n            validatePixel = function (v) {\n                return (/^[0-9]+px$/).test(v);\n            },\n            validateDisplay = function (v) {\n                return (v  === 'html' || v === 'internal');\n            },\n            validateColor = function (v) {\n                // for now this should do it...\n                return Type.isString(v);\n            },\n            validatePointFace = function (v) {\n                return Type.exists(JXG.normalizePointFace(v));\n            },\n            validateInteger = function (v) {\n                return (Math.abs(v - Math.round(v)) < Mat.eps);\n            },\n            validateNotNegativeInteger = function (v) {\n                return validateInteger(v) && v >= 0;\n            },\n            validatePositiveInteger = function (v) {\n                return validateInteger(v) && v > 0;\n            },\n            validateScreenCoords = function (v) {\n                return v.length >= 2 && validateInteger(v[0]) && validateInteger(v[1]);\n            },\n            validateRenderer = function (v) {\n                return (v === 'vml' || v === 'svg' || v === 'canvas' || v === 'no');\n            },\n            validatePositive = function (v) {\n                return v > 0;\n            },\n            validateNotNegative = function (v) {\n                return v >= 0;\n            },\n            v = {},\n            validators = {\n                attractorDistance: validateNotNegative,\n                color: validateColor,\n                defaultDistance: Type.isNumber,\n                display: validateDisplay,\n                doAdvancedPlot: false,\n                draft: false,\n                drawLabels: false,\n                drawZero: false,\n                face: validatePointFace,\n                factor: Type.isNumber,\n                fillColor: validateColor,\n                fillOpacity: Type.isNumber,\n                firstArrow: false,\n                fontSize: validateInteger,\n                dash: validateInteger,\n                gridX: Type.isNumber,\n                gridY: Type.isNumber,\n                hasGrid: false,\n                highlightFillColor: validateColor,\n                highlightFillOpacity: Type.isNumber,\n                highlightStrokeColor: validateColor,\n                highlightStrokeOpacity: Type.isNumber,\n                insertTicks: false,\n                //: validateScreenCoords,\n                lastArrow: false,\n                layer: validateNotNegativeInteger,\n                majorHeight: validateInteger,\n                minorHeight: validateInteger,\n                minorTicks: validateNotNegative,\n                minTicksDistance: validatePositiveInteger,\n                numberPointsHigh: validatePositiveInteger,\n                numberPointsLow: validatePositiveInteger,\n                opacity: Type.isNumber,\n                radius: Type.isNumber,\n                RDPsmoothing: false,\n                renderer: validateRenderer,\n                right: validatePixel,\n                showCopyright: false,\n                showInfobox: false,\n                showNavigation: false,\n                size: validateNotNegative, //validateInteger,\n                snapSizeX: validatePositive,\n                snapSizeY: validatePositive,\n                snapWidth: Type.isNumber,\n                snapToGrid: false,\n                snatchDistance: validateNotNegative,\n                straightFirst: false,\n                straightLast: false,\n                stretch: false,\n                strokeColor: validateColor,\n                strokeOpacity: Type.isNumber,\n                strokeWidth: validateNotNegative, //validateInteger,\n                takeFirst: false,\n                takeSizeFromFile: false,\n                to10: false,\n                toOrigin: false,\n                translateTo10: false,\n                translateToOrigin: false,\n                useASCIIMathML: false,\n                useDirection: false,\n                useMathJax: false,\n                withLabel: false,\n                withTicks: false,\n                zoom: false\n            };\n\n        // this seems like a redundant step but it makes sure that\n        // all properties in the validator object have lower case names\n        // and the validator object is easier to read.\n        for (i in validators) {\n            if (validators.hasOwnProperty(i)) {\n                v[i.toLowerCase()] = validators[i];\n            }\n        }\n\n        return v;\n    }());\n\n    /**\n     * All point faces can be defined with more than one name, e.g. a cross faced point can be given\n     * by face equal to 'cross' or equal to 'x'. This method maps all possible values to fixed ones to\n     * simplify if- and switch-clauses regarding point faces. The translation table is as follows:\n     * <table>\n     * <tr><th>Input</th><th>Output</th></tr>\n     * <tr><td>cross, x</td><td>x</td></tr>\n     * <tr><td>circle, o</td><td>o</td></tr>\n     * <tr><td>square, []</td><td>[]</td></tr>\n     * <tr><td>plus, +</td><td>+</td></tr>\n     * <tr><td>diamond, &lt;&gt;</td><td>&lt;&gt;</td></tr>\n     * <tr><td>triangleup, a, ^</td><td>A</td></tr>\n     * <tr><td>triangledown, v</td><td>v</td></tr>\n     * <tr><td>triangleleft, &lt;</td><td>&lt;</td></tr>\n     * <tr><td>triangleright, &gt;</td><td>&gt;</td></tr>\n     * </table>\n     * @param {String} s A string which should determine a valid point face.\n     * @returns {String} Returns a normalized string or undefined if the given string is not a valid\n     * point face.\n     */\n    JXG.normalizePointFace = function (s) {\n        var map = {\n            cross: 'x',\n            x: 'x',\n            circle: 'o',\n            o: 'o',\n            square: '[]',\n            '[]': '[]',\n            plus: '+',\n            '+': '+',\n            diamond: '<>',\n            '<>': '<>',\n            triangleup: '^',\n            a: '^',\n            '^': '^',\n            triangledown: 'v',\n            v: 'v',\n            triangleleft: '<',\n            '<': '<',\n            triangleright: '>',\n            '>': '>'\n        };\n\n        return map[s];\n    };\n\n\n    /**\n     * Apply the options stored in this object to all objects on the given board.\n     * @param {JXG.Board} board The board to which objects the options will be applied.\n     */\n    JXG.useStandardOptions = function (board) {\n        var el, t, p, copyProps,\n            o = JXG.Options,\n            boardHadGrid = board.hasGrid;\n\n        board.options.grid.hasGrid = o.grid.hasGrid;\n        board.options.grid.gridX = o.grid.gridX;\n        board.options.grid.gridY = o.grid.gridY;\n        board.options.grid.gridColor = o.grid.gridColor;\n        board.options.grid.gridOpacity = o.grid.gridOpacity;\n        board.options.grid.gridDash = o.grid.gridDash;\n        board.options.grid.snapToGrid = o.grid.snapToGrid;\n        board.options.grid.snapSizeX = o.grid.SnapSizeX;\n        board.options.grid.snapSizeY = o.grid.SnapSizeY;\n        board.takeSizeFromFile = o.takeSizeFromFile;\n\n        copyProps = function (p, o) {\n            p.visProp.fillcolor = o.fillColor;\n            p.visProp.highlightfillcolor = o.highlightFillColor;\n            p.visProp.strokecolor = o.strokeColor;\n            p.visProp.highlightstrokecolor = o.highlightStrokeColor;\n        };\n\n        for (el in board.objects) {\n            if (board.objects.hasOwnProperty(el)) {\n                p = board.objects[el];\n                if (p.elementClass === Const.OBJECT_CLASS_POINT) {\n                    copyProps(p, o.point);\n                } else if (p.elementClass === Const.OBJECT_CLASS_LINE) {\n                    copyProps(p, o.line);\n\n                    for (t = 0; t < p.ticks.length; t++) {\n                        p.ticks[t].majorTicks = o.line.ticks.majorTicks;\n                        p.ticks[t].minTicksDistance = o.line.ticks.minTicksDistance;\n                        p.ticks[t].visProp.minorheight = o.line.ticks.minorHeight;\n                        p.ticks[t].visProp.majorheight = o.line.ticks.majorHeight;\n                    }\n                } else if (p.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n                    copyProps(p, o.circle);\n                } else if (p.type === Const.OBJECT_TYPE_ANGLE) {\n                    copyProps(p, o.angle);\n                } else if (p.type === Const.OBJECT_TYPE_ARC) {\n                    copyProps(p, o.arc);\n                } else if (p.type === Const.OBJECT_TYPE_POLYGON) {\n                    copyProps(p, o.polygon);\n                } else if (p.type === Const.OBJECT_TYPE_CONIC) {\n                    copyProps(p, o.conic);\n                } else if (p.type === Const.OBJECT_TYPE_CURVE) {\n                    copyProps(p, o.curve);\n                } else if (p.type === Const.OBJECT_TYPE_SECTOR) {\n                    p.arc.visProp.fillcolor = o.sector.fillColor;\n                    p.arc.visProp.highlightfillcolor = o.sector.highlightFillColor;\n                    p.arc.visProp.fillopacity = o.sector.fillOpacity;\n                    p.arc.visProp.highlightfillopacity = o.sector.highlightFillOpacity;\n                }\n            }\n        }\n\n        board.fullUpdate();\n        if (boardHadGrid && !board.hasGrid) {\n            board.removeGrids(board);\n        } else if (!boardHadGrid && board.hasGrid) {\n            board.create('grid', []);\n        }\n    };\n\n    /**\n     * Converts all color values to greyscale and calls useStandardOption to put them onto the board.\n     * @param {JXG.Board} board The board to which objects the options will be applied.\n     * @see #useStandardOptions\n     */\n    JXG.useBlackWhiteOptions = function (board) {\n        var o = JXG.Options;\n        o.point.fillColor = Color.rgb2bw(o.point.fillColor);\n        o.point.highlightFillColor = Color.rgb2bw(o.point.highlightFillColor);\n        o.point.strokeColor = Color.rgb2bw(o.point.strokeColor);\n        o.point.highlightStrokeColor = Color.rgb2bw(o.point.highlightStrokeColor);\n\n        o.line.fillColor = Color.rgb2bw(o.line.fillColor);\n        o.line.highlightFillColor = Color.rgb2bw(o.line.highlightFillColor);\n        o.line.strokeColor = Color.rgb2bw(o.line.strokeColor);\n        o.line.highlightStrokeColor = Color.rgb2bw(o.line.highlightStrokeColor);\n\n        o.circle.fillColor = Color.rgb2bw(o.circle.fillColor);\n        o.circle.highlightFillColor = Color.rgb2bw(o.circle.highlightFillColor);\n        o.circle.strokeColor = Color.rgb2bw(o.circle.strokeColor);\n        o.circle.highlightStrokeColor = Color.rgb2bw(o.circle.highlightStrokeColor);\n\n        o.arc.fillColor = Color.rgb2bw(o.arc.fillColor);\n        o.arc.highlightFillColor = Color.rgb2bw(o.arc.highlightFillColor);\n        o.arc.strokeColor = Color.rgb2bw(o.arc.strokeColor);\n        o.arc.highlightStrokeColor = Color.rgb2bw(o.arc.highlightStrokeColor);\n\n        o.polygon.fillColor = Color.rgb2bw(o.polygon.fillColor);\n        o.polygon.highlightFillColor  = Color.rgb2bw(o.polygon.highlightFillColor);\n\n        o.sector.fillColor = Color.rgb2bw(o.sector.fillColor);\n        o.sector.highlightFillColor  = Color.rgb2bw(o.sector.highlightFillColor);\n\n        o.curve.strokeColor = Color.rgb2bw(o.curve.strokeColor);\n        o.grid.gridColor = Color.rgb2bw(o.grid.gridColor);\n\n        JXG.useStandardOptions(board);\n    };\n\n// needs to be exported\nJXG.Options.normalizePointFace = JXG.normalizePointFace;\n\nexport default JXG.Options;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Type from \"../utils/type\";\n\n/**\n * Parser helper routines. The methods in here are for parsing expressions in Geonext Syntax.\n * @namespace\n */\nJXG.GeonextParser = {\n    /**\n     * Converts expression of the form <i>leftop^rightop</i> into <i>Math.pow(leftop,rightop)</i>.\n     * @param {String} te Expression of the form <i>leftop^rightop</i>\n     * @returns {String} Converted expression.\n     */\n    replacePow: function (te) {\n        var count, pos, c, previousIndex, leftop, rightop, pre, p, left, i, right, expr;\n\n        // delete all whitespace immediately before and after all ^ operators\n        te = te.replace(/(\\s*)\\^(\\s*)/g, \"^\");\n\n        //  Loop over all ^ operators\n        i = te.indexOf(\"^\");\n        previousIndex = -1;\n\n        while (i >= 0 && i < te.length - 1) {\n            if (previousIndex === i) {\n                throw new Error(\"JSXGraph: Error while parsing expression '\" + te + \"'\");\n            }\n            previousIndex = i;\n\n            // left and right are the substrings before, resp. after the ^ character\n            left = te.slice(0, i);\n            right = te.slice(i + 1);\n\n            // If there is a \")\" immediately before the ^ operator, it can be the end of a\n            // (i) term in parenthesis\n            // (ii) function call\n            // (iii) method  call\n            // In either case, first the corresponding opening parenthesis is searched.\n            // This is the case, when count==0\n            if (left.charAt(left.length - 1) === \")\") {\n                count = 1;\n                pos = left.length - 2;\n\n                while (pos >= 0 && count > 0) {\n                    c = left.charAt(pos);\n                    if (c === \")\") {\n                        count++;\n                    } else if (c === \"(\") {\n                        count -= 1;\n                    }\n                    pos -= 1;\n                }\n\n                if (count === 0) {\n                    // Now, we have found the opning parenthesis and we have to look\n                    // if it is (i), or (ii), (iii).\n                    leftop = \"\";\n                    // Search for F or p.M before (...)^\n                    pre = left.substring(0, pos + 1);\n                    p = pos;\n                    while (p >= 0 && pre.substr(p, 1).match(/([\\w.]+)/)) {\n                        leftop = RegExp.$1 + leftop;\n                        p -= 1;\n                    }\n                    leftop += left.substring(pos + 1, left.length);\n                    leftop = leftop.replace(/([()+*%^\\-/\\][])/g, \"\\\\$1\");\n                } else {\n                    throw new Error(\"JSXGraph: Missing '(' in expression\");\n                }\n            } else {\n                // Otherwise, the operand has to be a constant (or variable).\n                leftop = \"[\\\\w\\\\.]+\"; // former: \\\\w\\\\.\n            }\n\n            // To the right of the ^ operator there also may be a function or method call\n            // or a term in parenthesis. Alos, ere we search for the closing\n            // parenthesis.\n            if (right.match(/^([\\w.]*\\()/)) {\n                count = 1;\n                pos = RegExp.$1.length;\n\n                while (pos < right.length && count > 0) {\n                    c = right.charAt(pos);\n\n                    if (c === \")\") {\n                        count -= 1;\n                    } else if (c === \"(\") {\n                        count += 1;\n                    }\n                    pos += 1;\n                }\n\n                if (count === 0) {\n                    rightop = right.substring(0, pos);\n                    rightop = rightop.replace(/([()+*%^\\-/[\\]])/g, \"\\\\$1\");\n                } else {\n                    throw new Error(\"JSXGraph: Missing ')' in expression\");\n                }\n            } else {\n                // Otherwise, the operand has to be a constant (or variable).\n                rightop = \"[\\\\w\\\\.]+\";\n            }\n            // Now, we have the two operands and replace ^ by JXG.Math.pow\n            expr = new RegExp(\"(\" + leftop + \")\\\\^(\" + rightop + \")\");\n            //te = te.replace(expr, 'JXG.Math.pow($1,$2)');\n            te = te.replace(expr, \"pow($1,$2)\");\n            i = te.indexOf(\"^\");\n        }\n\n        return te;\n    },\n\n    /**\n     * Converts expression of the form <i>If(a,b,c)</i> into <i>(a)?(b):(c)/i>.\n     * @param {String} te Expression of the form <i>If(a,b,c)</i>\n     * @returns {String} Converted expression.\n     */\n    replaceIf: function (te) {\n        var left,\n            right,\n            i,\n            pos,\n            count,\n            k1,\n            k2,\n            c,\n            meat,\n            s = \"\",\n            first = null,\n            second = null,\n            third = null;\n\n        i = te.indexOf(\"If(\");\n        if (i < 0) {\n            return te;\n        }\n\n        // \"\" means not defined. Here, we replace it by 0\n        te = te.replace(/\"\"/g, \"0\");\n        while (i >= 0) {\n            left = te.slice(0, i);\n            right = te.slice(i + 3);\n\n            // Search the end of the If() command and take out the meat\n            count = 1;\n            pos = 0;\n            k1 = -1;\n            k2 = -1;\n\n            while (pos < right.length && count > 0) {\n                c = right.charAt(pos);\n\n                if (c === \")\") {\n                    count -= 1;\n                } else if (c === \"(\") {\n                    count += 1;\n                } else if (c === \",\" && count === 1) {\n                    if (k1 < 0) {\n                        // first komma\n                        k1 = pos;\n                    } else {\n                        // second komma\n                        k2 = pos;\n                    }\n                }\n                pos += 1;\n            }\n            meat = right.slice(0, pos - 1);\n            right = right.slice(pos);\n\n            // Test the two kommas\n            if (k1 < 0) {\n                // , missing\n                return \"\";\n            }\n\n            if (k2 < 0) {\n                // , missing\n                return \"\";\n            }\n\n            first = meat.slice(0, k1);\n            second = meat.slice(k1 + 1, k2);\n            third = meat.slice(k2 + 1);\n\n            // Recurse\n            first = this.replaceIf(first);\n            second = this.replaceIf(second);\n            third = this.replaceIf(third);\n\n            s += left + \"((\" + first + \")?\" + \"(\" + second + \"):(\" + third + \"))\";\n            te = right;\n            first = null;\n            second = null;\n            i = te.indexOf(\"If(\");\n        }\n        s += right;\n        return s;\n    },\n\n    /**\n     * Replace an element's name in terms by an element's id.\n     * @param {String} term Term containing names of elements.\n     * @param {JXG.Board} board Reference to the board the elements are on.\n     * @param {Boolean} [jc=false] If true, all id's will be surrounded by <tt>$('</tt> and <tt>')</tt>.\n     * @returns {String} The same string with names replaced by ids.\n     **/\n    replaceNameById: function (term, board, jc) {\n        var end,\n            elName,\n            el,\n            i,\n            pos = 0,\n            funcs = [\"X\", \"Y\", \"L\", \"V\"],\n            printId = function (id) {\n                if (jc) {\n                    return \"$('\" + id + \"')\";\n                }\n\n                return id;\n            };\n\n        // Find X(el), Y(el), ...\n        // All functions declared in funcs\n        for (i = 0; i < funcs.length; i++) {\n            pos = term.indexOf(funcs[i] + \"(\");\n\n            while (pos >= 0) {\n                if (pos >= 0) {\n                    end = term.indexOf(\")\", pos + 2);\n                    if (end >= 0) {\n                        elName = term.slice(pos + 2, end);\n                        elName = elName.replace(/\\\\(['\"])?/g, \"$1\");\n                        el = board.elementsByName[elName];\n\n                        if (el) {\n                            term =\n                                term.slice(0, pos + 2) +\n                                (jc ? \"$('\" : \"\") +\n                                printId(el.id) +\n                                term.slice(end);\n                        }\n                    }\n                }\n                end = term.indexOf(\")\", pos + 2);\n                pos = term.indexOf(funcs[i] + \"(\", end);\n            }\n        }\n\n        pos = term.indexOf(\"Dist(\");\n        while (pos >= 0) {\n            if (pos >= 0) {\n                end = term.indexOf(\",\", pos + 5);\n                if (end >= 0) {\n                    elName = term.slice(pos + 5, end);\n                    elName = elName.replace(/\\\\(['\"])?/g, \"$1\");\n                    el = board.elementsByName[elName];\n\n                    if (el) {\n                        term = term.slice(0, pos + 5) + printId(el.id) + term.slice(end);\n                    }\n                }\n            }\n            end = term.indexOf(\",\", pos + 5);\n            pos = term.indexOf(\",\", end);\n            end = term.indexOf(\")\", pos + 1);\n\n            if (end >= 0) {\n                elName = term.slice(pos + 1, end);\n                elName = elName.replace(/\\\\(['\"])?/g, \"$1\");\n                el = board.elementsByName[elName];\n\n                if (el) {\n                    term = term.slice(0, pos + 1) + printId(el.id) + term.slice(end);\n                }\n            }\n            end = term.indexOf(\")\", pos + 1);\n            pos = term.indexOf(\"Dist(\", end);\n        }\n\n        funcs = [\"Deg\", \"Rad\"];\n        for (i = 0; i < funcs.length; i++) {\n            pos = term.indexOf(funcs[i] + \"(\");\n            while (pos >= 0) {\n                if (pos >= 0) {\n                    end = term.indexOf(\",\", pos + 4);\n                    if (end >= 0) {\n                        elName = term.slice(pos + 4, end);\n                        elName = elName.replace(/\\\\(['\"])?/g, \"$1\");\n                        el = board.elementsByName[elName];\n\n                        if (el) {\n                            term = term.slice(0, pos + 4) + printId(el.id) + term.slice(end);\n                        }\n                    }\n                }\n\n                end = term.indexOf(\",\", pos + 4);\n                pos = term.indexOf(\",\", end);\n                end = term.indexOf(\",\", pos + 1);\n\n                if (end >= 0) {\n                    elName = term.slice(pos + 1, end);\n                    elName = elName.replace(/\\\\(['\"])?/g, \"$1\");\n                    el = board.elementsByName[elName];\n\n                    if (el) {\n                        term = term.slice(0, pos + 1) + printId(el.id) + term.slice(end);\n                    }\n                }\n\n                end = term.indexOf(\",\", pos + 1);\n                pos = term.indexOf(\",\", end);\n                end = term.indexOf(\")\", pos + 1);\n\n                if (end >= 0) {\n                    elName = term.slice(pos + 1, end);\n                    elName = elName.replace(/\\\\(['\"])?/g, \"$1\");\n                    el = board.elementsByName[elName];\n                    if (el) {\n                        term = term.slice(0, pos + 1) + printId(el.id) + term.slice(end);\n                    }\n                }\n\n                end = term.indexOf(\")\", pos + 1);\n                pos = term.indexOf(funcs[i] + \"(\", end);\n            }\n        }\n\n        return term;\n    },\n\n    /**\n     * Replaces element ids in terms by element this.board.objects['id'].\n     * @param {String} term A GEONE<sub>x</sub>T function string with JSXGraph ids in it.\n     * @returns {String} The input string with element ids replaced by this.board.objects[\"id\"].\n     **/\n    replaceIdByObj: function (term) {\n        // Search for expressions like \"X(gi23)\" or \"Y(gi23A)\" and convert them to objects['gi23'].X().\n        var expr = /(X|Y|L)\\(([\\w_]+)\\)/g;\n        term = term.replace(expr, \"$('$2').$1()\");\n\n        expr = /(V)\\(([\\w_]+)\\)/g;\n        term = term.replace(expr, \"$('$2').Value()\");\n\n        expr = /(Dist)\\(([\\w_]+),([\\w_]+)\\)/g;\n        term = term.replace(expr, \"dist($('$2'), $('$3'))\");\n\n        expr = /(Deg)\\(([\\w_]+),([ \\w[\\w_]+),([\\w_]+)\\)/g;\n        term = term.replace(expr, \"deg($('$2'),$('$3'),$('$4'))\");\n\n        // Search for Rad('gi23','gi24','gi25')\n        expr = /Rad\\(([\\w_]+),([\\w_]+),([\\w_]+)\\)/g;\n        term = term.replace(expr, \"rad($('$1'),$('$2'),$('$3'))\");\n\n        // it's ok, it will run through the jessiecode parser afterwards...\n        /*jslint regexp: true*/\n        expr = /N\\((.+)\\)/g;\n        term = term.replace(expr, \"($1)\");\n\n        return term;\n    },\n\n    /**\n     * Converts the given algebraic expression in GEONE<sub>x</sub>T syntax into an equivalent expression in JavaScript syntax.\n     * @param {String} term Expression in GEONExT syntax\n     * @param {JXG.Board} board\n     * @returns {String} Given expression translated to JavaScript.\n     */\n    geonext2JS: function (term, board) {\n        var expr,\n            newterm,\n            i,\n            from = [\n                \"Abs\",\n                \"ACos\",\n                \"ASin\",\n                \"ATan\",\n                \"Ceil\",\n                \"Cos\",\n                \"Exp\",\n                \"Factorial\",\n                \"Floor\",\n                \"Log\",\n                \"Max\",\n                \"Min\",\n                \"Random\",\n                \"Round\",\n                \"Sin\",\n                \"Sqrt\",\n                \"Tan\",\n                \"Trunc\"\n            ],\n            to = [\n                \"abs\",\n                \"acos\",\n                \"asin\",\n                \"atan\",\n                \"ceil\",\n                \"cos\",\n                \"exp\",\n                \"factorial\",\n                \"floor\",\n                \"log\",\n                \"max\",\n                \"min\",\n                \"random\",\n                \"round\",\n                \"sin\",\n                \"sqrt\",\n                \"tan\",\n                \"ceil\"\n            ];\n\n        // Hacks, to enable not well formed XML, @see JXG.GeonextReader#replaceLessThan\n        term = term.replace(/&lt;/g, \"<\");\n        term = term.replace(/&gt;/g, \">\");\n        term = term.replace(/&amp;/g, \"&\");\n\n        // Umwandeln der GEONExT-Syntax in JavaScript-Syntax\n        newterm = term;\n        newterm = this.replaceNameById(newterm, board);\n        newterm = this.replaceIf(newterm);\n        // Exponentiations-Problem x^y -> Math(exp(x,y).\n        newterm = this.replacePow(newterm);\n        newterm = this.replaceIdByObj(newterm);\n\n        for (i = 0; i < from.length; i++) {\n            // sin -> Math.sin and asin -> Math.asin\n            expr = new RegExp([\"(\\\\W|^)(\", from[i], \")\"].join(\"\"), \"ig\");\n            newterm = newterm.replace(expr, [\"$1\", to[i]].join(\"\"));\n        }\n        newterm = newterm.replace(/True/g, \"true\");\n        newterm = newterm.replace(/False/g, \"false\");\n        newterm = newterm.replace(/fasle/g, \"false\");\n        newterm = newterm.replace(/Pi/g, \"PI\");\n        newterm = newterm.replace(/\"/g, \"'\");\n\n        return newterm;\n    },\n\n    /**\n     * Finds dependencies in a given term and resolves them by adding the\n     * dependent object to the found objects child elements.\n     * @param {JXG.GeometryElement} me Object depending on objects in given term.\n     * @param {String} term String containing dependencies for the given object.\n     * @param {JXG.Board} [board=me.board] Reference to a board\n     */\n    findDependencies: function (me, term, board) {\n        var elements, el, expr, elmask;\n\n        if (!Type.exists(board)) {\n            board = me.board;\n        }\n\n        elements = board.elementsByName;\n\n        for (el in elements) {\n            if (elements.hasOwnProperty(el)) {\n                if (el !== me.name) {\n                    if (elements[el].elementClass === Const.OBJECT_CLASS_TEXT) {\n                        if (!Type.evaluate(elements[el].visProp.islabel)) {\n                            elmask = el.replace(/\\[/g, \"\\\\[\");\n                            elmask = elmask.replace(/\\]/g, \"\\\\]\");\n\n                            // Searches (A), (A,B),(A,B,C)\n                            expr = new RegExp(\n                                \"\\\\(([\\\\w\\\\[\\\\]'_ ]+,)*(\" + elmask + \")(,[\\\\w\\\\[\\\\]'_ ]+)*\\\\)\",\n                                \"g\"\n                            );\n\n                            if (term.search(expr) >= 0) {\n                                elements[el].addChild(me);\n                            }\n                        }\n                    } else {\n                        elmask = el.replace(/\\[/g, \"\\\\[\");\n                        elmask = elmask.replace(/\\]/g, \"\\\\]\");\n\n                        // Searches (A), (A,B),(A,B,C)\n                        expr = new RegExp(\n                            \"\\\\(([\\\\w\\\\[\\\\]'_ ]+,)*(\" + elmask + \")(,[\\\\w\\\\[\\\\]'_ ]+)*\\\\)\",\n                            \"g\"\n                        );\n\n                        if (term.search(expr) >= 0) {\n                            elements[el].addChild(me);\n                        }\n                    }\n                }\n            }\n        }\n    },\n\n    /**\n     * Converts the given algebraic expression in GEONE<sub>x</sub>T syntax into an equivalent expression in JessieCode syntax.\n     * @param {String} term Expression in GEONExT syntax\n     * @param {JXG.Board} board\n     * @returns {String} Given expression translated to JavaScript.\n     */\n    gxt2jc: function (term, board) {\n        var newterm,\n            from = [\"Sqrt\"],\n            to = [\"sqrt\"];\n\n        // Hacks, to enable not well formed XML, @see JXG.GeonextReader#replaceLessThan\n        term = term.replace(/&lt;/g, \"<\");\n        term = term.replace(/&gt;/g, \">\");\n        term = term.replace(/&amp;/g, \"&\");\n        newterm = term;\n        newterm = this.replaceNameById(newterm, board, true);\n        newterm = newterm.replace(/True/g, \"true\");\n        newterm = newterm.replace(/False/g, \"false\");\n        newterm = newterm.replace(/fasle/g, \"false\");\n\n        return newterm;\n    }\n};\n\nexport default JXG.GeonextParser;\n","/*\n JessieCode Interpreter and Compiler\n\n    Copyright 2011-2019\n        Michael Gerhaeuser,\n        Alfred Wassermann\n\n    JessieCode is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JessieCode is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JessieCode. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true, console: true, self: true, document: true, parser: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview JessieCode is a scripting language designed to provide a\n * simple scripting language to build constructions\n * with JSXGraph. It is similar to JavaScript, but prevents access to the DOM.\n * Hence, it can be used in community driven math portals which want to use\n * JSXGraph to display interactive math graphics.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Text from \"../base/text\";\nimport Mat from \"../math/math\";\nimport Interval from \"../math/ia\";\nimport Geometry from \"../math/geometry\";\nimport Statistics from \"../math/statistics\";\nimport Type from \"../utils/type\";\nimport UUID from \"../utils/uuid\";\nimport Env from \"../utils/env\";\n// import $__fs from \"fs\";\n// import $__path from \"path\";\n\n// IE 6-8 compatibility\nif (!Object.create) {\n    Object.create = function (o, properties) {\n        if (typeof o !== \"object\" && typeof o !== \"function\")\n            throw new TypeError(\"Object prototype may only be an Object: \" + o);\n        else if (o === null)\n            throw new Error(\n                \"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\"\n            );\n\n        if (typeof properties != \"undefined\")\n            throw new Error(\n                \"This browser's implementation of Object.create is a shim and doesn't support a second argument.\"\n            );\n\n        function F() {}\n\n        F.prototype = o;\n\n        return new F();\n    };\n}\n\nvar priv = {\n    modules: {\n        math: Mat,\n        \"math/geometry\": Geometry,\n        \"math/statistics\": Statistics,\n        \"math/numerics\": Mat.Numerics\n    }\n};\n\n/**\n * A JessieCode object provides an interface to the parser and stores all variables and objects used within a JessieCode script.\n * The optional argument <tt>code</tt> is interpreted after initializing. To evaluate more code after initializing a JessieCode instance\n * please use {@link JXG.JessieCode#parse}. For code snippets like single expressions use {@link JXG.JessieCode#snippet}.\n * @constructor\n * @param {String} [code] Code to parse.\n * @param {Boolean} [geonext=false] Geonext compatibility mode.\n */\nJXG.JessieCode = function (code, geonext) {\n    // Control structures\n\n    /**\n     * The global scope.\n     * @type Object\n     */\n    this.scope = {\n        id: 0,\n        hasChild: true,\n        args: [],\n        locals: {},\n        context: null,\n        previous: null\n    };\n\n    /**\n     * Keeps track of all possible scopes every required.\n     * @type Array\n     */\n    this.scopes = [];\n    this.scopes.push(this.scope);\n\n    /**\n     * A stack to store debug information (like line and column where it was defined) of a parameter\n     * @type Array\n     * @private\n     */\n    this.dpstack = [[]];\n\n    /**\n     * Determines the parameter stack scope.\n     * @type Number\n     * @private\n     */\n    this.pscope = 0;\n\n    /**\n     * Used to store the property-value definition while parsing an object literal.\n     * @type Array\n     * @private\n     */\n    this.propstack = [{}];\n\n    /**\n     * The current scope of the object literal stack {@link JXG.JessieCode#propstack}.\n     * @type Number\n     * @private\n     */\n    this.propscope = 0;\n\n    /**\n     * Store the left hand side of an assignment. If an element is constructed and no attributes are given, this is\n     * used as the element's name.\n     * @type Array\n     * @private\n     */\n    this.lhs = [];\n\n    /**\n     * lhs flag, used by JXG.JessieCode#replaceNames\n     * @type Boolean\n     * @default false\n     */\n    this.isLHS = false;\n\n    /**\n     * The id of an HTML node in which innerHTML all warnings are stored (if no <tt>console</tt> object is available).\n     * @type String\n     * @default 'jcwarn'\n     */\n    this.warnLog = \"jcwarn\";\n\n    /**\n     * Store $log messages in case there's no console.\n     * @type Array\n     */\n    this.$log = [];\n\n    /**\n     * Built-in functions and constants\n     * @type Object\n     */\n    this.builtIn = this.defineBuiltIn();\n\n    /**\n     * List of all possible operands in JessieCode (except of JSXGraph objects).\n     * @type Object\n     */\n    this.operands = this.getPossibleOperands();\n\n    /**\n     * The board which currently is used to create and look up elements.\n     * @type JXG.Board\n     */\n    this.board = null;\n\n    /**\n     * Keep track of which element is created in which line.\n     * @type Object\n     */\n    this.lineToElement = {};\n\n    this.parCurLine = 1;\n    this.parCurColumn = 0;\n    this.line = 1;\n    this.col = 1;\n\n    if (JXG.CA) {\n        this.CA = new JXG.CA(this.node, this.createNode, this);\n    }\n\n    this.code = \"\";\n\n    if (typeof code === \"string\") {\n        this.parse(code, geonext);\n    }\n};\n\nJXG.extend(\n    JXG.JessieCode.prototype,\n    /** @lends JXG.JessieCode.prototype */ {\n        /**\n         * Create a new parse tree node.\n         * @param {String} type Type of node, e.g. node_op, node_var, or node_const\n         * @param value The nodes value, e.g. a variables value or a functions body.\n         * @param {Array} children Arbitrary number of child nodes.\n         */\n        node: function (type, value, children) {\n            return {\n                type: type,\n                value: value,\n                children: children\n            };\n        },\n\n        /**\n         * Create a new parse tree node. Basically the same as node(), but this builds\n         * the children part out of an arbitrary number of parameters, instead of one\n         * array parameter.\n         * @param {String} type Type of node, e.g. node_op, node_var, or node_const\n         * @param value The nodes value, e.g. a variables value or a functions body.\n         * @param children Arbitrary number of parameters; define the child nodes.\n         */\n        createNode: function (type, value, children) {\n            var n = this.node(type, value, []),\n                i;\n\n            for (i = 2; i < arguments.length; i++) {\n                n.children.push(arguments[i]);\n            }\n\n            if (n.type == \"node_const\" && Type.isNumber(n.value)) {\n                n.isMath = true;\n            }\n\n            n.line = this.parCurLine;\n            n.col = this.parCurColumn;\n\n            return n;\n        },\n\n        /**\n         * Create a new scope.\n         * @param {Array} args\n         * @returns {Object}\n         */\n        pushScope: function (args) {\n            var scope = {\n                args: args,\n                locals: {},\n                context: null,\n                previous: this.scope\n            };\n\n            this.scope.hasChild = true;\n            this.scope = scope;\n            scope.id = this.scopes.push(scope) - 1;\n\n            return scope;\n        },\n\n        /**\n         * Remove the current scope and reinstate the previous scope\n         * @returns {Object}\n         */\n        popScope: function () {\n            var s = this.scope.previous;\n\n            // make sure the global scope is not lost\n            this.scope = s !== null ? s : this.scope;\n\n            return this.scope;\n        },\n\n        /**\n         * Looks up an {@link JXG.GeometryElement} by its id.\n         * @param {String} id\n         * @returns {JXG.GeometryElement}\n         */\n        getElementById: function (id) {\n            return this.board.objects[id];\n        },\n\n        log: function () {\n            this.$log.push(arguments);\n\n            if (typeof console === \"object\" && console.log) {\n                console.log.apply(console, arguments);\n            }\n        },\n\n        /**\n         * Returns a element creator function which takes two parameters: the parents array and the attributes object.\n         * @param {String} vname The element type, e.g. 'point', 'line', 'midpoint'\n         * @returns {function}\n         */\n        creator: (function () {\n            // stores the already defined creators\n            var _ccache = {},\n                r;\n\n            r = function (vname) {\n                var f;\n\n                // _ccache is global, i.e. it is the same for ALL JessieCode instances.\n                // That's why we need the board id here\n                if (typeof _ccache[this.board.id + vname] === \"function\") {\n                    f = _ccache[this.board.id + vname];\n                } else {\n                    f = (function (that) {\n                        return function (parameters, attributes) {\n                            var attr;\n\n                            if (Type.exists(attributes)) {\n                                attr = attributes;\n                            } else {\n                                attr = {};\n                            }\n                            if (attr.name === undefined && attr.id === undefined) {\n                                attr.name =\n                                    that.lhs[that.scope.id] !== 0\n                                        ? that.lhs[that.scope.id]\n                                        : \"\";\n                            }\n                            return that.board.create(vname, parameters, attr);\n                        };\n                    })(this);\n\n                    f.creator = true;\n                    _ccache[this.board.id + vname] = f;\n                }\n\n                return f;\n            };\n\n            r.clearCache = function () {\n                _ccache = {};\n            };\n\n            return r;\n        })(),\n\n        /**\n         * Assigns a value to a variable in the current scope.\n         * @param {String} vname Variable name\n         * @param value Anything\n         * @see JXG.JessieCode#sstack\n         * @see JXG.JessieCode#scope\n         */\n        letvar: function (vname, value) {\n            if (this.builtIn[vname]) {\n                this._warn('\"' + vname + '\" is a predefined value.');\n            }\n\n            this.scope.locals[vname] = value;\n        },\n\n        /**\n         * Checks if the given variable name can be found in the current scope chain.\n         * @param {String} vname\n         * @returns {Object} A reference to the scope object the variable can be found in or null if it can't be found.\n         */\n        isLocalVariable: function (vname) {\n            var s = this.scope;\n\n            while (s !== null) {\n                if (Type.exists(s.locals[vname])) {\n                    return s;\n                }\n\n                s = s.previous;\n            }\n\n            return null;\n        },\n\n        /**\n         * Checks if the given variable name is a parameter in any scope from the current to the global scope.\n         * @param {String} vname\n         * @returns {Object} A reference to the scope object that contains the variable in its arg list.\n         */\n        isParameter: function (vname) {\n            var s = this.scope;\n\n            while (s !== null) {\n                if (Type.indexOf(s.args, vname) > -1) {\n                    return s;\n                }\n\n                s = s.previous;\n            }\n\n            return null;\n        },\n\n        /**\n         * Checks if the given variable name is a valid creator method.\n         * @param {String} vname\n         * @returns {Boolean}\n         */\n        isCreator: function (vname) {\n            // check for an element with this name\n            return !!JXG.elements[vname];\n        },\n\n        /**\n         * Checks if the given variable identifier is a valid member of the JavaScript Math Object.\n         * @param {String} vname\n         * @returns {Boolean}\n         */\n        isMathMethod: function (vname) {\n            return vname !== \"E\" && !!Math[vname];\n        },\n\n        /**\n         * Returns true if the given identifier is a builtIn variable/function.\n         * @param {String} vname\n         * @returns {Boolean}\n         */\n        isBuiltIn: function (vname) {\n            return !!this.builtIn[vname];\n        },\n\n        /**\n         * Looks up the value of the given variable. We use a simple type inspection.\n         *\n         * @param {String} vname Name of the variable\n         * @param {Boolean} [local=false] Only look up the internal symbol table and don't look for\n         * the <tt>vname</tt> in Math or the element list.\n         * @param {Boolean} [isFunctionName=false] Lookup function of tpye builtIn, Math.*, creator.\n         *\n         * @see JXG.JessieCode#resolveType\n         */\n        getvar: function (vname, local, isFunctionName) {\n            var s;\n\n            local = Type.def(local, false);\n\n            // Local scope has always precedence\n            s = this.isLocalVariable(vname);\n            if (s !== null) {\n                return s.locals[vname];\n            }\n\n            // Handle the - so far only - few constants by hard coding them.\n            if (vname === \"$board\" || vname === \"EULER\" || vname === \"PI\") {\n                return this.builtIn[vname];\n            }\n\n            if (!!isFunctionName) {\n                if (this.isBuiltIn(vname)) {\n                    return this.builtIn[vname];\n                }\n\n                if (this.isMathMethod(vname)) {\n                    return Math[vname];\n                }\n\n                // check for an element with this name\n                if (this.isCreator(vname)) {\n                    return this.creator(vname);\n                }\n            }\n\n            if (!local) {\n                s = this.board.select(vname);\n                if (s !== vname) {\n                    return s;\n                }\n            }\n        },\n\n        /**\n         * Look up the value of a local variable.\n         * @param {string} vname\n         * @returns {*}\n         */\n        resolve: function (vname) {\n            var s = this.scope;\n\n            while (s !== null) {\n                if (Type.exists(s.locals[vname])) {\n                    return s.locals[vname];\n                }\n\n                s = s.previous;\n            }\n        },\n\n        /**\n         * TODO this needs to be called from JS and should not generate JS code\n         * Looks up a variable identifier in various tables and generates JavaScript code that could be eval'd to get the value.\n         * @param {String} vname Identifier\n         * @param {Boolean} [local=false] Don't resolve ids and names of elements\n         * @param {Boolean} [withProps=false]\n         */\n        getvarJS: function (vname, local, withProps) {\n            var s,\n                r = \"\",\n                re;\n\n            local = Type.def(local, false);\n            withProps = Type.def(withProps, false);\n\n            s = this.isParameter(vname);\n            if (s !== null) {\n                return vname;\n            }\n\n            s = this.isLocalVariable(vname);\n            if (s !== null && !withProps) {\n                return \"$jc$.resolve('\" + vname + \"')\";\n            }\n\n            // check for an element with this name\n            if (this.isCreator(vname)) {\n                return (\n                    \"(function () { var a = Array.prototype.slice.call(arguments, 0), props = \" +\n                    (withProps ? \"a.pop()\" : \"{}\") +\n                    \"; return $jc$.board.create.apply($jc$.board, ['\" +\n                    vname +\n                    \"'].concat([a, props])); })\"\n                );\n            }\n\n            if (withProps) {\n                this._error(\n                    \"Syntax error (attribute values are allowed with element creators only)\"\n                );\n            }\n\n            if (this.isBuiltIn(vname)) {\n                // If src does not exist, it is a number. In that case, just return the value.\n                r = this.builtIn[vname].src || this.builtIn[vname];\n\n                // Get the \"real\" name of the function\n                if (Type.isNumber(r)) {\n                    return r;\n                }\n                // Search a JSXGraph object in board\n                if (r.match(/board\\.select/)) {\n                    return r;\n                }\n\n                vname = r.split(\".\").pop();\n                if (Type.exists(this.board.mathLib)) {\n                    // Handle builtin case: ln(x) -> Math.log\n                    re = new RegExp(\"^Math.\" + vname);\n                    if (re.exec(r) !== null) {\n                        return r.replace(re, \"$jc$.board.mathLib.\" + vname);\n                    }\n                }\n                if (Type.exists(this.board.mathLibJXG)) {\n                    // Handle builtin case: factorial(x) -> JXG.Math.factorial\n                    re = new RegExp(\"^JXG.Math.\");\n                    if (re.exec(r) !== null) {\n                        return r.replace(re, \"$jc$.board.mathLibJXG.\");\n                    }\n                    return r;\n                }\n                return r;\n\n                // return this.builtIn[vname].src || this.builtIn[vname];\n            }\n\n            if (this.isMathMethod(vname)) {\n                return \"$jc$.board.mathLib.\" + vname;\n                //                return 'Math.' + vname;\n            }\n\n            // if (!local) {\n            //     if (Type.isId(this.board, vname)) {\n            //         r = '$jc$.board.objects[\\'' + vname + '\\']';\n            //     } else if (Type.isName(this.board, vname)) {\n            //         r = '$jc$.board.elementsByName[\\'' + vname + '\\']';\n            //     } else if (Type.isGroup(this.board, vname)) {\n            //         r = '$jc$.board.groups[\\'' + vname + '\\']';\n            //     }\n\n            //     return r;\n            // }\n            if (!local) {\n                if (Type.isId(this.board, vname)) {\n                    r = \"$jc$.board.objects['\" + vname + \"']\";\n                    if (this.board.objects[vname].elType === \"slider\") {\n                        r += \".Value()\";\n                    }\n                } else if (Type.isName(this.board, vname)) {\n                    r = \"$jc$.board.elementsByName['\" + vname + \"']\";\n                    if (this.board.elementsByName[vname].elType === \"slider\") {\n                        r += \".Value()\";\n                    }\n                } else if (Type.isGroup(this.board, vname)) {\n                    r = \"$jc$.board.groups['\" + vname + \"']\";\n                }\n\n                return r;\n            }\n\n            return \"\";\n        },\n\n        /**\n         * Adds the property <tt>isMap</tt> to a function and sets it to true.\n         * @param {function} f\n         * @returns {function}\n         */\n        makeMap: function (f) {\n            f.isMap = true;\n\n            return f;\n        },\n\n        functionCodeJS: function (node) {\n            var p = node.children[0].join(\", \"),\n                bo = \"\",\n                bc = \"\";\n\n            if (node.value === \"op_map\") {\n                bo = \"{ return  \";\n                bc = \" }\";\n            }\n\n            return (\n                \"function (\" +\n                p +\n                \") {\\n\" +\n                \"var $oldscope$ = $jc$.scope;\\n\" +\n                \"$jc$.scope = $jc$.scopes[\" +\n                this.scope.id +\n                \"];\\n\" +\n                \"var r = (function () \" +\n                bo +\n                this.compile(node.children[1], true) +\n                bc +\n                \")();\\n\" +\n                \"$jc$.scope = $oldscope$;\\n\" +\n                \"return r;\\n\" +\n                \"}\"\n            );\n        },\n\n        /**\n         * Converts a node type <tt>node_op</tt> and value <tt>op_map</tt> or <tt>op_function</tt> into a executable\n         * function. Does a simple type inspection.\n         * @param {Object} node\n         * @returns {function}\n         * @see JXG.JessieCode#resolveType\n         */\n        defineFunction: function (node) {\n            var fun,\n                i,\n                that = this,\n                list = node.children[0],\n                scope = this.pushScope(list);\n\n            if (this.board.options.jc.compile) {\n                this.isLHS = false;\n\n                // we currently need to put the parameters into the local scope\n                // until the compiled JS variable lookup code is fixed\n                for (i = 0; i < list.length; i++) {\n                    scope.locals[list[i]] = list[i];\n                }\n\n                this.replaceNames(node.children[1]);\n\n                /** @ignore */\n                fun = (function (jc) {\n                    var fun,\n                        // str = 'var f = ' + $jc$.functionCodeJS(node) + '; f;';\n                        str = 'var f = function($jc$) { return ' +\n                            jc.functionCodeJS(node) +\n                            '}; f;';\n\n                    try {\n                        // yeah, eval is evil, but we don't have much choice here.\n                        // the str is well defined and there is no user input in it that we didn't check before\n\n                        /*jslint evil:true*/\n                        // fun = eval(str);\n                        fun = eval(str)(jc);\n                        /*jslint evil:false*/\n\n                        scope.argtypes = [];\n                        for (i = 0; i < list.length; i++) {\n                            scope.argtypes.push(that.resolveType(list[i], node));\n                        }\n\n                        return fun;\n                    } catch (e) {\n                        // $jc$._warn('error compiling function\\n\\n' + str + '\\n\\n' + e.toString());\n                        jc._warn(\"error compiling function\\n\\n\" + str + \"\\n\\n\" + e.toString());\n                        return function () {};\n                    }\n                })(this);\n\n                // clean up scope\n                this.popScope();\n            } else {\n                /** @ignore */\n                fun = (function (_pstack, that, id) {\n                    return function () {\n                        var r, oldscope;\n\n                        oldscope = that.scope;\n                        that.scope = that.scopes[id];\n\n                        for (r = 0; r < _pstack.length; r++) {\n                            that.scope.locals[_pstack[r]] = arguments[r];\n                        }\n\n                        r = that.execute(node.children[1]);\n                        that.scope = oldscope;\n\n                        return r;\n                    };\n                })(list, this, scope.id);\n            }\n\n            fun.node = node;\n            fun.scope = scope;\n            fun.toJS = fun.toString;\n            fun.toString = (function (_that) {\n                return function () {\n                    return _that.compile(_that.replaceIDs(Type.deepCopy(node)));\n                };\n            })(this);\n\n            fun.deps = {};\n            this.collectDependencies(node.children[1], fun.deps);\n\n            return fun;\n        },\n\n        /**\n         * Merge all attribute values given with an element creator into one object.\n         * @param {Object} o An arbitrary number of objects\n         * @returns {Object} All given objects merged into one. If properties appear in more (case sensitive) than one\n         * object the last value is taken.\n         */\n        mergeAttributes: function (o) {\n            var i,\n                attr = {};\n\n            for (i = 0; i < arguments.length; i++) {\n                attr = Type.deepCopy(attr, arguments[i], true);\n            }\n\n            return attr;\n        },\n\n        /**\n         * Sets the property <tt>what</tt> of <tt>o</tt> to <tt>value</tt>\n         * @param {JXG.Point|JXG.Text} o\n         * @param {String} what\n         * @param value\n         */\n        setProp: function (o, what, value) {\n            var par = {},\n                x,\n                y;\n\n            if (o.elementClass === Const.OBJECT_CLASS_POINT && (what === \"X\" || what === \"Y\")) {\n                // set coords\n\n                what = what.toLowerCase();\n\n                // we have to deal with three cases here:\n                // o.isDraggable && typeof value === number:\n                //   stay draggable, just set the new coords (e.g. via moveTo)\n                // o.isDraggable && typeof value === function:\n                //   convert to !o.isDraggable, set the new coords via o.addConstraint()\n                // !o.isDraggable:\n                //   stay !o.isDraggable, update the given coord by overwriting X/YEval\n\n                if (o.isDraggable && typeof value === \"number\") {\n                    x = what === \"x\" ? value : o.X();\n                    y = what === \"y\" ? value : o.Y();\n\n                    o.setPosition(Const.COORDS_BY_USER, [x, y]);\n                } else if (\n                    o.isDraggable &&\n                    (typeof value === \"function\" || typeof value === \"string\")\n                ) {\n                    x = what === \"x\" ? value : o.coords.usrCoords[1];\n                    y = what === \"y\" ? value : o.coords.usrCoords[2];\n\n                    o.addConstraint([x, y]);\n                } else if (!o.isDraggable) {\n                    x = what === \"x\" ? value : o.XEval.origin;\n                    y = what === \"y\" ? value : o.YEval.origin;\n\n                    o.addConstraint([x, y]);\n                }\n\n                this.board.update();\n            } else if (\n                o.elementClass === Const.OBJECT_CLASS_TEXT &&\n                (what === \"X\" || what === \"Y\")\n            ) {\n                if (typeof value === \"number\") {\n                    o[what] = function () {\n                        return value;\n                    };\n                } else if (typeof value === \"function\") {\n                    o.isDraggable = false;\n                    o[what] = value;\n                } else if (typeof value === \"string\") {\n                    o.isDraggable = false;\n                    o[what] = Type.createFunction(value, this.board, null, true);\n                    o[what + \"jc\"] = value;\n                }\n\n                o[what].origin = value;\n\n                this.board.update();\n            } else if (o.type && o.elementClass && o.visProp) {\n                if (\n                    Type.exists(o[o.methodMap[what]]) &&\n                    typeof o[o.methodMap[what]] !== \"function\"\n                ) {\n                    o[o.methodMap[what]] = value;\n                } else {\n                    par[what] = value;\n                    o.setAttribute(par);\n                }\n            } else {\n                o[what] = value;\n            }\n        },\n\n        /**\n         * Generic method to parse JessieCode.\n         * This consists of generating an AST with parser.parse,\n         * apply simplifying rules from CA and\n         * manipulate the AST according to the second parameter \"cmd\".\n         * @param  {String} code      JessieCode code to be parsed\n         * @param  {String} cmd       Type of manipulation to be done with AST\n         * @param {Boolean} [geonext=false] Geonext compatibility mode.\n         * @param {Boolean} dontstore If false, the code string is stored in this.code.\n         * @return {Object}           Returns result of computation as directed in cmd.\n         */\n        _genericParse: function (code, cmd, geonext, dontstore) {\n            var i,\n                setTextBackup,\n                ast,\n                result,\n                ccode = code.replace(/\\r\\n/g, \"\\n\").split(\"\\n\"),\n                cleaned = [];\n\n            if (!dontstore) {\n                this.code += code + \"\\n\";\n            }\n\n            if (Text) {\n                setTextBackup = Text.Text.prototype.setText;\n                Text.Text.prototype.setText = Text.Text.prototype.setTextJessieCode;\n            }\n\n            try {\n                if (!Type.exists(geonext)) {\n                    geonext = false;\n                }\n\n                for (i = 0; i < ccode.length; i++) {\n                    if (geonext) {\n                        ccode[i] = JXG.GeonextParser.geonext2JS(ccode[i], this.board);\n                    }\n                    cleaned.push(ccode[i]);\n                }\n\n                code = cleaned.join(\"\\n\");\n                ast = parser.parse(code);\n                if (this.CA) {\n                    ast = this.CA.expandDerivatives(ast, null, ast);\n                    ast = this.CA.removeTrivialNodes(ast);\n                }\n                switch (cmd) {\n                    case \"parse\":\n                        result = this.execute(ast);\n                        break;\n                    case \"manipulate\":\n                        result = this.compile(ast);\n                        break;\n                    case \"getAst\":\n                        result = ast;\n                        break;\n                    default:\n                        result = false;\n                }\n            } catch (e) {\n                // catch is mandatory in old IEs\n                // console.log(e);\n                // We throw the error again,\n                // so the user can catch it.\n                throw e;\n            } finally {\n                // make sure the original text method is back in place\n                if (Text) {\n                    Text.Text.prototype.setText = setTextBackup;\n                }\n            }\n\n            return result;\n        },\n\n        /**\n         * Parses JessieCode.\n         * This consists of generating an AST with parser.parse, apply simplifying rules\n         * from CA and executing the ast by calling this.execute(ast).\n         *\n         * @param {String} code             JessieCode code to be parsed\n         * @param {Boolean} [geonext=false] Geonext compatibility mode.\n         * @param {Boolean} dontstore       If false, the code string is stored in this.code.\n         * @return {Object}                 Parse JessieCode code and execute it.\n         */\n        parse: function (code, geonext, dontstore) {\n            return this._genericParse(code, \"parse\", geonext, dontstore);\n        },\n\n        /**\n         * Manipulate JessieCode.\n         * This consists of generating an AST with parser.parse,\n         * apply simlifying rules from CA\n         * and compile the AST back to JessieCode.\n         *\n         * @param {String} code             JessieCode code to be parsed\n         * @param {Boolean} [geonext=false] Geonext compatibility mode.\n         * @param {Boolean} dontstore       If false, the code string is stored in this.code.\n         * @return {String}                 Simplified JessieCode code\n         */\n        manipulate: function (code, geonext, dontstore) {\n            return this._genericParse(code, \"manipulate\", geonext, dontstore);\n        },\n\n        /**\n         * Get abstract syntax tree (AST) from JessieCode code.\n         * This consists of generating an AST with parser.parse.\n         *\n         * @param {String} code\n         * @param {Boolean} [geonext=false] Geonext compatibility mode.\n         * @param {Boolean} dontstore\n         * @return {Node}  AST\n         */\n        getAST: function (code, geonext, dontstore) {\n            return this._genericParse(code, \"getAst\", geonext, dontstore);\n        },\n\n        /**\n         * Parses a JessieCode snippet, e.g. \"3+4\", and wraps it into a function, if desired.\n         * @param {String} code A small snippet of JessieCode. Must not be an assignment.\n         * @param {Boolean} funwrap If true, the code is wrapped in a function.\n         * @param {String} varname Name of the parameter(s)\n         * @param {Boolean} [geonext=false] Geonext compatibility mode.\n         */\n        snippet: function (code, funwrap, varname, geonext) {\n            var c;\n\n            funwrap = Type.def(funwrap, true);\n            varname = Type.def(varname, \"\");\n            geonext = Type.def(geonext, false);\n\n            c =\n                (funwrap ? \" function (\" + varname + \") { return \" : \"\") +\n                code +\n                (funwrap ? \"; }\" : \"\") +\n                \";\";\n\n            return this.parse(c, geonext, true);\n        },\n\n        /**\n         * Traverses through the given subtree and changes all values of nodes with the replaced flag set by\n         * {@link JXG.JessieCode#replaceNames} to the name of the element (if not empty).\n         * @param {Object} node\n         */\n        replaceIDs: function (node) {\n            var i, v;\n\n            if (node.replaced) {\n                // These children exist, if node.replaced is set.\n                v = this.board.objects[node.children[1][0].value];\n\n                if (Type.exists(v) && v.name !== \"\") {\n                    node.type = \"node_var\";\n                    node.value = v.name;\n\n                    // Maybe it's not necessary, but just to be sure that everything is cleaned up we better delete all\n                    // children and the replaced flag\n                    node.children.length = 0;\n                    delete node.replaced;\n                }\n            }\n\n            if (Type.isArray(node)) {\n                for (i = 0; i < node.length; i++) {\n                    node[i] = this.replaceIDs(node[i]);\n                }\n            }\n\n            if (node.children) {\n                // assignments are first evaluated on the right hand side\n                for (i = node.children.length; i > 0; i--) {\n                    if (Type.exists(node.children[i - 1])) {\n                        node.children[i - 1] = this.replaceIDs(node.children[i - 1]);\n                    }\n                }\n            }\n\n            return node;\n        },\n\n        /**\n         * Traverses through the given subtree and changes all elements referenced by names through referencing them by ID.\n         * An identifier is only replaced if it is not found in all scopes above the current scope and if it\n         * has not been blacklisted within the codeblock determined by the given subtree.\n         * @param {Object} node\n         */\n        replaceNames: function (node) {\n            var i, v;\n\n            v = node.value;\n\n            // We are interested only in nodes of type node_var and node_op > op_lhs.\n            // Currently, we are not checking if the id is a local variable. in this case, we're stuck anyway.\n\n            if (node.type === \"node_op\" && v === \"op_lhs\" && node.children.length === 1) {\n                this.isLHS = true;\n            } else if (node.type === \"node_var\") {\n                if (this.isLHS) {\n                    this.letvar(v, true);\n                } else if (\n                    !Type.exists(this.getvar(v, true)) &&\n                    Type.exists(this.board.elementsByName[v])\n                ) {\n                    node = this.createReplacementNode(node);\n                }\n            }\n\n            if (Type.isArray(node)) {\n                for (i = 0; i < node.length; i++) {\n                    node[i] = this.replaceNames(node[i]);\n                }\n            }\n\n            if (node.children) {\n                // Assignments are first evaluated on the right hand side\n                for (i = node.children.length; i > 0; i--) {\n                    if (Type.exists(node.children[i - 1])) {\n                        node.children[i - 1] = this.replaceNames(node.children[i - 1]);\n                    }\n                }\n            }\n\n            if (\n                node.type === \"node_op\" &&\n                node.value === \"op_lhs\" &&\n                node.children.length === 1\n            ) {\n                this.isLHS = false;\n            }\n\n            return node;\n        },\n\n        /**\n         * Replaces node_var nodes with node_op&gt;op_execfun nodes, calling the internal $() function with the id of the\n         * element accessed by the node_var node.\n         * @param {Object} node\n         * @returns {Object} op_execfun node\n         */\n        createReplacementNode: function (node) {\n            var v = node.value,\n                el = this.board.elementsByName[v];\n\n            node = this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"$\"), [\n                this.createNode(\"node_str\", el.id)\n            ]);\n\n            node.replaced = true;\n\n            return node;\n        },\n\n        /**\n         * Search the parse tree below <tt>node</tt> for <em>stationary</em> dependencies, i.e. dependencies hard coded into\n         * the function.\n         * @param {Object} node\n         * @param {Object} result An object where the referenced elements will be stored. Access key is their id.\n         */\n        collectDependencies: function (node, result) {\n            var i, v, e, le;\n\n            if (Type.isArray(node)) {\n                le = node.length;\n                for (i = 0; i < le; i++) {\n                    this.collectDependencies(node[i], result);\n                }\n                return;\n            }\n\n            v = node.value;\n\n            if (node.type === \"node_var\") {\n                e = this.getvar(v);\n                if (e && e.visProp && e.type && e.elementClass && e.id) {\n                    result[e.id] = e;\n                }\n            }\n\n            // The $()-function-calls are special because their parameter is given as a string, not as a node_var.\n            if (\n                node.type === \"node_op\" &&\n                node.value === \"op_execfun\" &&\n                node.children.length > 1 &&\n                node.children[0].value === \"$\" &&\n                node.children[1].length > 0\n            ) {\n                e = node.children[1][0].value;\n                result[e] = this.board.objects[e];\n            }\n\n            if (node.children) {\n                for (i = node.children.length; i > 0; i--) {\n                    if (Type.exists(node.children[i - 1])) {\n                        this.collectDependencies(node.children[i - 1], result);\n                    }\n                }\n            }\n        },\n\n        resolveProperty: function (e, v, compile) {\n            compile = Type.def(compile, false);\n\n            // is it a geometry element or a board?\n            if (e /*&& e.type && e.elementClass*/ && e.methodMap) {\n                // yeah, it is. but what does the user want?\n                if (Type.exists(e.subs) && Type.exists(e.subs[v])) {\n                    // a subelement it is, good sir.\n                    e = e.subs;\n                } else if (Type.exists(e.methodMap[v])) {\n                    // the user wants to call a method\n                    v = e.methodMap[v];\n                } else {\n                    // the user wants to change an attribute\n                    e = e.visProp;\n                    v = v.toLowerCase();\n                }\n            }\n\n            if (Type.isFunction(e)) {\n                this._error(\"Accessing function properties is not allowed.\");\n            }\n\n            if (!Type.exists(e)) {\n                this._error(e + \" is not an object\");\n            }\n\n            if (!Type.exists(e[v])) {\n                this._error(\"unknown property \" + v);\n            }\n\n            if (compile && typeof e[v] === \"function\") {\n                return function () {\n                    return e[v].apply(e, arguments);\n                };\n            }\n\n            return e[v];\n        },\n\n        /**\n         * Type inspection: check if the string vname appears as function name in the\n         * AST node. Used in \"op_execfun\". This allows the JessieCode exmples below.\n         *\n         * @private\n         * @param {String} vname\n         * @param {Object} node\n         * @returns 'any' or 'function'\n         * @see JXG.JessieCode#execute\n         * @see JXG.JessieCode#getvar\n         *\n         * @example\n         *  var p = board.create('point', [2, 0], {name: 'X'});\n         *  var txt = 'X(X)';\n         *  console.log(board.jc.parse(txt));\n         *\n         * @example\n         *  var p = board.create('point', [2, 0], {name: 'X'});\n         *  var txt = 'f = function(el, X) { return X(el); }; f(X, X);';\n         *  console.log(board.jc.parse(txt));\n         *\n         * @example\n         *  var p = board.create('point', [2, 0], {name: 'point'});\n         *  var txt = 'B = point(1,3); X(point);';\n         *  console.log(board.jc.parse(txt));\n         *\n         * @example\n         *  var p = board.create('point', [2, 0], {name: 'A'});\n         *  var q = board.create('point', [-2, 0], {name: 'X'});\n         *  var txt = 'getCoord=function(p, f){ return f(p); }; getCoord(A, X);';\n         *  console.log(board.jc.parse(txt));\n         */\n        resolveType: function (vname, node) {\n            var i,\n                t,\n                type = \"any\"; // Possible values: 'function', 'any'\n\n            if (Type.isArray(node)) {\n                // node contains the parameters of a function call or function declaration\n                for (i = 0; i < node.length; i++) {\n                    t = this.resolveType(vname, node[i]);\n                    if (t !== \"any\") {\n                        type = t;\n                        return type;\n                    }\n                }\n            }\n\n            if (\n                node.type === \"node_op\" &&\n                node.value === \"op_execfun\" &&\n                node.children[0].type === \"node_var\" &&\n                node.children[0].value === vname\n            ) {\n                return \"function\";\n            }\n\n            if (node.type === \"node_op\") {\n                for (i = 0; i < node.children.length; i++) {\n                    if (\n                        node.children[0].type === \"node_var\" &&\n                        node.children[0].value === vname &&\n                        (node.value === \"op_add\" ||\n                            node.value === \"op_sub\" ||\n                            node.value === \"op_mul\" ||\n                            node.value === \"op_div\" ||\n                            node.value === \"op_mod\" ||\n                            node.value === \"op_exp\" ||\n                            node.value === \"op_neg\")\n                    ) {\n                        return \"any\";\n                    }\n                }\n\n                for (i = 0; i < node.children.length; i++) {\n                    t = this.resolveType(vname, node.children[i]);\n                    if (t !== \"any\") {\n                        type = t;\n                        return type;\n                    }\n                }\n            }\n\n            return \"any\";\n        },\n\n        /**\n         * Resolves the lefthand side of an assignment operation\n         * @param node\n         * @returns {Object} An object with two properties. <strong>o</strong> which contains the object, and\n         * a string <strong>what</strong> which contains the property name.\n         */\n        getLHS: function (node) {\n            var res;\n\n            if (node.type === \"node_var\") {\n                res = {\n                    o: this.scope.locals,\n                    what: node.value\n                };\n            } else if (node.type === \"node_op\" && node.value === \"op_property\") {\n                res = {\n                    o: this.execute(node.children[0]),\n                    what: node.children[1]\n                };\n            } else if (node.type === \"node_op\" && node.value === \"op_extvalue\") {\n                res = {\n                    o: this.execute(node.children[0]),\n                    what: this.execute(node.children[1])\n                };\n            } else {\n                throw new Error(\"Syntax error: Invalid left-hand side of assignment.\");\n            }\n\n            return res;\n        },\n\n        getLHSCompiler: function (node, js) {\n            var res;\n\n            if (node.type === \"node_var\") {\n                res = node.value;\n            } else if (node.type === \"node_op\" && node.value === \"op_property\") {\n                res = [this.compile(node.children[0], js), \"'\" + node.children[1] + \"'\"];\n            } else if (node.type === \"node_op\" && node.value === \"op_extvalue\") {\n                res = [\n                    this.compile(node.children[0], js),\n                    node.children[1].type === \"node_const\"\n                        ? node.children[1].value\n                        : this.compile(node.children[1], js)\n                ];\n            } else {\n                throw new Error(\"Syntax error: Invalid left-hand side of assignment.\");\n            }\n\n            return res;\n        },\n\n        /**\n         * Executes a parse subtree.\n         * @param {Object} node\n         * @returns {Number|String|Object|Boolean} Something\n         * @private\n         */\n        execute: function (node) {\n            var ret,\n                v,\n                i,\n                e,\n                l,\n                undef,\n                list,\n                ilist,\n                parents = [],\n                // exec fun\n                fun,\n                attr,\n                sc;\n\n            ret = 0;\n\n            if (!node) {\n                return ret;\n            }\n\n            this.line = node.line;\n            this.col = node.col;\n\n            switch (node.type) {\n                case \"node_op\":\n                    switch (node.value) {\n                        case \"op_none\":\n                            if (node.children[0]) {\n                                this.execute(node.children[0]);\n                            }\n                            if (node.children[1]) {\n                                ret = this.execute(node.children[1]);\n                            }\n                            break;\n                        case \"op_assign\":\n                            v = this.getLHS(node.children[0]);\n                            this.lhs[this.scope.id] = v.what;\n\n                            if (\n                                v.o.type &&\n                                v.o.elementClass &&\n                                v.o.methodMap &&\n                                v.what === \"label\"\n                            ) {\n                                this._error(\"Left-hand side of assignment is read-only.\");\n                            }\n\n                            ret = this.execute(node.children[1]);\n                            if (\n                                v.o !== this.scope.locals ||\n                                (Type.isArray(v.o) && typeof v.what === \"number\")\n                            ) {\n                                // it is either an array component being set or a property of an object.\n                                this.setProp(v.o, v.what, ret);\n                            } else {\n                                // this is just a local variable inside JessieCode\n                                this.letvar(v.what, ret);\n                            }\n                            this.lhs[this.scope.id] = 0;\n                            break;\n                        case \"op_if\":\n                            if (this.execute(node.children[0])) {\n                                ret = this.execute(node.children[1]);\n                            }\n                            break;\n                        case \"op_conditional\":\n                        // fall through\n                        case \"op_if_else\":\n                            if (this.execute(node.children[0])) {\n                                ret = this.execute(node.children[1]);\n                            } else {\n                                ret = this.execute(node.children[2]);\n                            }\n                            break;\n                        case \"op_while\":\n                            while (this.execute(node.children[0])) {\n                                this.execute(node.children[1]);\n                            }\n                            break;\n                        case \"op_do\":\n                            do {\n                                this.execute(node.children[0]);\n                            } while (this.execute(node.children[1]));\n                            break;\n                        case \"op_for\":\n                            for (\n                                this.execute(node.children[0]);\n                                this.execute(node.children[1]);\n                                this.execute(node.children[2])\n                            ) {\n                                this.execute(node.children[3]);\n                            }\n                            break;\n                        case \"op_proplst\":\n                            if (node.children[0]) {\n                                this.execute(node.children[0]);\n                            }\n                            if (node.children[1]) {\n                                this.execute(node.children[1]);\n                            }\n                            break;\n                        case \"op_emptyobject\":\n                            ret = {};\n                            break;\n                        case \"op_proplst_val\":\n                            this.propstack.push({});\n                            this.propscope++;\n\n                            this.execute(node.children[0]);\n                            ret = this.propstack[this.propscope];\n\n                            this.propstack.pop();\n                            this.propscope--;\n                            break;\n                        case \"op_prop\":\n                            // child 0: Identifier\n                            // child 1: Value\n                            this.propstack[this.propscope][node.children[0]] = this.execute(\n                                node.children[1]\n                            );\n                            break;\n                        case \"op_array\":\n                            ret = [];\n                            l = node.children[0].length;\n\n                            for (i = 0; i < l; i++) {\n                                ret.push(this.execute(node.children[0][i]));\n                            }\n\n                            break;\n                        case \"op_extvalue\":\n                            ret = this.execute(node.children[0]);\n                            i = this.execute(node.children[1]);\n\n                            if (\n                                typeof i === \"number\" &&\n                                Math.abs(Math.round(i) - i) < Mat.eps\n                            ) {\n                                ret = ret[i];\n                            } else {\n                                ret = undef;\n                            }\n                            break;\n                        case \"op_return\":\n                            if (this.scope === 0) {\n                                this._error(\"Unexpected return.\");\n                            } else {\n                                return this.execute(node.children[0]);\n                            }\n                            break;\n                        case \"op_map\":\n                            if (\n                                !node.children[1].isMath &&\n                                node.children[1].type !== \"node_var\"\n                            ) {\n                                this._error(\n                                    \"execute: In a map only function calls and mathematical expressions are allowed.\"\n                                );\n                            }\n\n                            /** @ignore */\n                            fun = this.defineFunction(node);\n                            fun.isMap = true;\n\n                            ret = fun;\n                            break;\n                        case \"op_function\":\n                            // parse the parameter list\n                            // after this, the parameters are in pstack\n\n                            /** @ignore */\n                            fun = this.defineFunction(node);\n                            fun.isMap = false;\n\n                            ret = fun;\n                            break;\n                        case \"op_execfun\":\n                            // node.children:\n                            //   [0]: Name of the function\n                            //   [1]: Parameter list as a parse subtree\n                            //   [2]: Properties, only used in case of a create function\n                            this.dpstack.push([]);\n                            this.pscope++;\n\n                            // parameter parsing is done below\n                            list = node.children[1];\n\n                            // parse the properties only if given\n                            if (Type.exists(node.children[2])) {\n                                if (node.children[3]) {\n                                    ilist = node.children[2];\n                                    attr = {};\n\n                                    for (i = 0; i < ilist.length; i++) {\n                                        attr = Type.deepCopy(\n                                            attr,\n                                            this.execute(ilist[i]),\n                                            true\n                                        );\n                                    }\n                                } else {\n                                    attr = this.execute(node.children[2]);\n                                }\n                            }\n\n                            // look up the variables name in the variable table\n                            node.children[0]._isFunctionName = true;\n                            fun = this.execute(node.children[0]);\n                            delete node.children[0]._isFunctionName;\n\n                            // determine the scope the function wants to run in\n                            if (fun && fun.sc) {\n                                sc = fun.sc;\n                            } else {\n                                sc = this;\n                            }\n\n                            if (!fun.creator && Type.exists(node.children[2])) {\n                                this._error(\n                                    \"Unexpected value. Only element creators are allowed to have a value after the function call.\"\n                                );\n                            }\n\n                            // interpret ALL the parameters\n                            for (i = 0; i < list.length; i++) {\n                                if (\n                                    Type.exists(fun.scope) &&\n                                    Type.exists(fun.scope.argtypes) &&\n                                    fun.scope.argtypes[i] === \"function\"\n                                ) {\n                                    // Type inspection\n                                    list[i]._isFunctionName = true;\n                                    parents[i] = this.execute(list[i]);\n                                    delete list[i]._isFunctionName;\n                                } else {\n                                    parents[i] = this.execute(list[i]);\n                                }\n                                //parents[i] = Type.evalSlider(this.execute(list[i]));\n                                this.dpstack[this.pscope].push({\n                                    line: node.children[1][i].line,\n                                    // SketchBin currently works only if the last column of the\n                                    // parent position is taken. This is due to how I patched JS/CC\n                                    // to count the lines and columns. So, ecol will do for now\n                                    col: node.children[1][i].ecol\n                                });\n                            }\n\n                            // check for the function in the variable table\n                            if (typeof fun === \"function\" && !fun.creator) {\n                                ret = fun.apply(sc, parents);\n                            } else if (typeof fun === \"function\" && !!fun.creator) {\n                                e = this.line;\n\n                                // creator methods are the only ones that take properties, hence this special case\n                                try {\n                                    ret = fun(parents, attr);\n                                    ret.jcLineStart = e;\n                                    ret.jcLineEnd = node.eline;\n\n                                    for (i = e; i <= node.line; i++) {\n                                        this.lineToElement[i] = ret;\n                                    }\n\n                                    ret.debugParents = this.dpstack[this.pscope];\n                                } catch (ex) {\n                                    this._error(ex.toString());\n                                }\n                            } else {\n                                this._error(\"Function '\" + fun + \"' is undefined.\");\n                            }\n\n                            // clear parameter stack\n                            this.dpstack.pop();\n                            this.pscope--;\n                            break;\n                        case \"op_property\":\n                            e = this.execute(node.children[0]);\n                            v = node.children[1];\n\n                            ret = this.resolveProperty(e, v, false);\n\n                            // set the scope, in case this is a method the user wants to call\n                            if (Type.exists(ret)) {\n                                ret.sc = e;\n                            }\n\n                            break;\n                        case \"op_use\":\n                            this._warn(\"Use of the 'use' operator is deprecated.\");\n                            this.use(node.children[0].toString());\n                            break;\n                        case \"op_delete\":\n                            this._warn(\n                                \"Use of the 'delete' operator is deprecated. Please use the remove() function.\"\n                            );\n                            v = this.getvar(node.children[0]);\n                            ret = this.del(v);\n                            break;\n                        case \"op_eq\":\n                            // == is intentional\n                            /*jslint eqeq:true*/\n                            ret =\n                                this.execute(node.children[0]) ==\n                                this.execute(node.children[1]);\n                            /*jslint eqeq:false*/\n                            break;\n                        case \"op_neq\":\n                            // != is intentional\n                            /*jslint eqeq:true*/\n                            ret =\n                                this.execute(node.children[0]) !=\n                                this.execute(node.children[1]);\n                            /*jslint eqeq:true*/\n                            break;\n                        case \"op_approx\":\n                            ret =\n                                Math.abs(\n                                    this.execute(node.children[0]) -\n                                        this.execute(node.children[1])\n                                ) < Mat.eps;\n                            break;\n                        case \"op_gt\":\n                            ret =\n                                this.execute(node.children[0]) > this.execute(node.children[1]);\n                            break;\n                        case \"op_lt\":\n                            ret =\n                                this.execute(node.children[0]) < this.execute(node.children[1]);\n                            break;\n                        case \"op_geq\":\n                            ret =\n                                this.execute(node.children[0]) >=\n                                this.execute(node.children[1]);\n                            break;\n                        case \"op_leq\":\n                            ret =\n                                this.execute(node.children[0]) <=\n                                this.execute(node.children[1]);\n                            break;\n                        case \"op_or\":\n                            ret =\n                                this.execute(node.children[0]) ||\n                                this.execute(node.children[1]);\n                            break;\n                        case \"op_and\":\n                            ret =\n                                this.execute(node.children[0]) &&\n                                this.execute(node.children[1]);\n                            break;\n                        case \"op_not\":\n                            ret = !this.execute(node.children[0]);\n                            break;\n                        case \"op_add\":\n                            ret = this.add(\n                                this.execute(node.children[0]),\n                                this.execute(node.children[1])\n                            );\n                            break;\n                        case \"op_sub\":\n                            ret = this.sub(\n                                this.execute(node.children[0]),\n                                this.execute(node.children[1])\n                            );\n                            break;\n                        case \"op_div\":\n                            ret = this.div(\n                                this.execute(node.children[0]),\n                                this.execute(node.children[1])\n                            );\n                            break;\n                        case \"op_mod\":\n                            // use mathematical modulo, JavaScript implements the symmetric modulo.\n                            ret = this.mod(\n                                this.execute(node.children[0]),\n                                this.execute(node.children[1]),\n                                true\n                            );\n                            break;\n                        case \"op_mul\":\n                            ret = this.mul(\n                                this.execute(node.children[0]),\n                                this.execute(node.children[1])\n                            );\n                            break;\n                        case \"op_exp\":\n                            ret = this.pow(\n                                this.execute(node.children[0]),\n                                this.execute(node.children[1])\n                            );\n                            break;\n                        case \"op_neg\":\n                            ret = this.neg(this.execute(node.children[0]));\n                            break;\n                    }\n                    break;\n\n                case \"node_var\":\n                    // node._isFunctionName is set in execute: at op_execfun.\n                    ret = this.getvar(node.value, false, node._isFunctionName);\n                    break;\n\n                case \"node_const\":\n                    if (node.value === null) {\n                        ret = null;\n                    } else {\n                        ret = Number(node.value);\n                    }\n                    break;\n\n                case \"node_const_bool\":\n                    ret = node.value;\n                    break;\n\n                case \"node_str\":\n                    //ret = node.value.replace(/\\\\'/, \"'\").replace(/\\\\\"/, '\"').replace(/\\\\\\\\/, '\\\\');\n                    /*jslint regexp:true*/\n                    ret = node.value.replace(/\\\\(.)/g, \"$1\"); // Remove backslash, important in JessieCode tags\n                    /*jslint regexp:false*/\n                    break;\n            }\n\n            return ret;\n        },\n\n        /**\n         * Compiles a parse tree back to JessieCode.\n         * @param {Object} node\n         * @param {Boolean} [js=false] Compile either to JavaScript or back to JessieCode (required for the UI).\n         * @returns Something\n         * @private\n         */\n        compile: function (node, js) {\n            var e,\n                i,\n                list,\n                scope,\n                ret = \"\";\n\n            if (!Type.exists(js)) {\n                js = false;\n            }\n\n            if (!node) {\n                return ret;\n            }\n\n            switch (node.type) {\n                case \"node_op\":\n                    switch (node.value) {\n                        case \"op_none\":\n                            if (node.children[0]) {\n                                ret = this.compile(node.children[0], js);\n                            }\n                            if (node.children[1]) {\n                                ret += this.compile(node.children[1], js);\n                            }\n                            break;\n                        case \"op_assign\":\n                            //e = this.compile(node.children[0], js);\n                            if (js) {\n                                e = this.getLHSCompiler(node.children[0], js);\n                                if (Type.isArray(e)) {\n                                    ret =\n                                        \"$jc$.setProp(\" +\n                                        e[0] +\n                                        \", \" +\n                                        e[1] +\n                                        \", \" +\n                                        this.compile(node.children[1], js) +\n                                        \");\\n\";\n                                } else {\n                                    if (this.isLocalVariable(e) !== this.scope) {\n                                        this.scope.locals[e] = true;\n                                    }\n                                    ret =\n                                        \"$jc$.scopes[\" +\n                                        this.scope.id +\n                                        \"].locals['\" +\n                                        e +\n                                        \"'] = \" +\n                                        this.compile(node.children[1], js) +\n                                        \";\\n\";\n                                }\n                            } else {\n                                e = this.compile(node.children[0]);\n                                ret = e + \" = \" + this.compile(node.children[1], js) + \";\\n\";\n                            }\n                            break;\n                        case \"op_if\":\n                            ret =\n                                \" if (\" +\n                                this.compile(node.children[0], js) +\n                                \") \" +\n                                this.compile(node.children[1], js);\n                            break;\n                        case \"op_if_else\":\n                            ret =\n                                \" if (\" +\n                                this.compile(node.children[0], js) +\n                                \")\" +\n                                this.compile(node.children[1], js);\n                            ret += \" else \" + this.compile(node.children[2], js);\n                            break;\n                        case \"op_conditional\":\n                            ret =\n                                \"((\" +\n                                this.compile(node.children[0], js) +\n                                \")?(\" +\n                                this.compile(node.children[1], js);\n                            ret += \"):(\" + this.compile(node.children[2], js) + \"))\";\n                            break;\n                        case \"op_while\":\n                            ret =\n                                \" while (\" +\n                                this.compile(node.children[0], js) +\n                                \") {\\n\" +\n                                this.compile(node.children[1], js) +\n                                \"}\\n\";\n                            break;\n                        case \"op_do\":\n                            ret =\n                                \" do {\\n\" +\n                                this.compile(node.children[0], js) +\n                                \"} while (\" +\n                                this.compile(node.children[1], js) +\n                                \");\\n\";\n                            break;\n                        case \"op_for\":\n                            //ret = ' for (' + this.compile(node.children[0], js) + '; ' + this.compile(node.children[1], js) + '; ' + this.compile(node.children[2], js) + ') {\\n' + this.compile(node.children[3], js) + '\\n}\\n';\n                            ret =\n                                \" for (\" +\n                                this.compile(node.children[0], js) + // Assignment ends with \";\"\n                                this.compile(node.children[1], js) +\n                                \"; \" + // Logical test comes without \";\"\n                                this.compile(node.children[2], js).slice(0, -2) + // Counting comes with \";\" which has to be removed\n                                \") {\\n\" +\n                                this.compile(node.children[3], js) +\n                                \"\\n}\\n\";\n                            break;\n                        case \"op_proplst\":\n                            if (node.children[0]) {\n                                ret = this.compile(node.children[0], js) + \", \";\n                            }\n\n                            ret += this.compile(node.children[1], js);\n                            break;\n                        case \"op_prop\":\n                            // child 0: Identifier\n                            // child 1: Value\n                            ret = node.children[0] + \": \" + this.compile(node.children[1], js);\n                            break;\n                        case \"op_emptyobject\":\n                            ret = js ? \"{}\" : \"<< >>\";\n                            break;\n                        case \"op_proplst_val\":\n                            ret = this.compile(node.children[0], js);\n                            break;\n                        case \"op_array\":\n                            list = [];\n                            for (i = 0; i < node.children[0].length; i++) {\n                                list.push(this.compile(node.children[0][i], js));\n                            }\n                            ret = \"[\" + list.join(\", \") + \"]\";\n                            break;\n                        case \"op_extvalue\":\n                            ret =\n                                this.compile(node.children[0], js) +\n                                \"[\" +\n                                this.compile(node.children[1], js) +\n                                \"]\";\n                            break;\n                        case \"op_return\":\n                            ret = \" return \" + this.compile(node.children[0], js) + \";\\n\";\n                            break;\n                        case \"op_map\":\n                            if (\n                                !node.children[1].isMath &&\n                                node.children[1].type !== \"node_var\"\n                            ) {\n                                this._error(\n                                    \"compile: In a map only function calls and mathematical expressions are allowed.\"\n                                );\n                            }\n\n                            list = node.children[0];\n                            if (js) {\n                                ret =\n                                    \" $jc$.makeMap(function (\" +\n                                    list.join(\", \") +\n                                    \") { return \" +\n                                    this.compile(node.children[1], js) +\n                                    \"; })\";\n                            } else {\n                                ret =\n                                    \"map (\" +\n                                    list.join(\", \") +\n                                    \") -> \" +\n                                    this.compile(node.children[1], js);\n                            }\n\n                            break;\n                        case \"op_function\":\n                            list = node.children[0];\n                            scope = this.pushScope(list);\n                            if (js) {\n                                ret = this.functionCodeJS(node);\n                            } else {\n                                ret =\n                                    \" function (\" +\n                                    list.join(\", \") +\n                                    \") \" +\n                                    this.compile(node.children[1], js);\n                            }\n                            this.popScope();\n                            break;\n                        case \"op_execfunmath\":\n                            console.log(\"op_execfunmath: TODO\");\n                            ret = \"-1\";\n                            break;\n                        case \"op_execfun\":\n                            // parse the properties only if given\n                            if (node.children[2]) {\n                                list = [];\n                                for (i = 0; i < node.children[2].length; i++) {\n                                    list.push(this.compile(node.children[2][i], js));\n                                }\n\n                                if (js) {\n                                    e = \"$jc$.mergeAttributes(\" + list.join(\", \") + \")\";\n                                } else {\n                                    e = list.join(\", \");\n                                }\n                            }\n                            node.children[0].withProps = !!node.children[2];\n                            list = [];\n                            for (i = 0; i < node.children[1].length; i++) {\n                                list.push(this.compile(node.children[1][i], js));\n                            }\n                            ret =\n                                this.compile(node.children[0], js) +\n                                \"(\" +\n                                list.join(\", \") +\n                                (node.children[2] && js ? \", \" + e : \"\") +\n                                \")\" +\n                                (node.children[2] && !js ? \" \" + e : \"\");\n                            if (js) {\n                                // Inserting a newline here allows simulataneously\n                                // - procedural calls like Q.moveTo(...); and\n                                // - function calls in expressions like log(x) + 1;\n                                // Problem: procedural calls will not be ended by a semicolon.\n                                ret += \"\\n\";\n                            }\n\n                            // save us a function call when compiled to javascript\n                            if (js && node.children[0].value === \"$\") {\n                                ret =\n                                    \"$jc$.board.objects[\" +\n                                    this.compile(node.children[1][0], js) +\n                                    \"]\";\n                            }\n                            break;\n                        case \"op_property\":\n                            if (js && node.children[1] !== \"X\" && node.children[1] !== \"Y\") {\n                                ret =\n                                    \"$jc$.resolveProperty(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", '\" +\n                                    node.children[1] +\n                                    \"', true)\";\n                            } else {\n                                ret =\n                                    this.compile(node.children[0], js) + \".\" + node.children[1];\n                            }\n                            break;\n                        case \"op_use\":\n                            this._warn(\"Use of the 'use' operator is deprecated.\");\n                            if (js) {\n                                ret = \"$jc$.use('\";\n                            } else {\n                                ret = \"use('\";\n                            }\n\n                            ret += node.children[0].toString() + \"');\";\n                            break;\n                        case \"op_delete\":\n                            this._warn(\n                                \"Use of the 'delete' operator is deprecated. Please use the remove() function.\"\n                            );\n                            if (js) {\n                                ret = \"$jc$.del(\";\n                            } else {\n                                ret = \"remove(\";\n                            }\n\n                            ret += this.compile(node.children[0], js) + \")\";\n                            break;\n                        case \"op_eq\":\n                            ret =\n                                \"(\" +\n                                this.compile(node.children[0], js) +\n                                \" === \" +\n                                this.compile(node.children[1], js) +\n                                \")\";\n                            break;\n                        case \"op_neq\":\n                            ret =\n                                \"(\" +\n                                this.compile(node.children[0], js) +\n                                \" !== \" +\n                                this.compile(node.children[1], js) +\n                                \")\";\n                            break;\n                        case \"op_approx\":\n                            ret =\n                                \"(\" +\n                                this.compile(node.children[0], js) +\n                                \" ~= \" +\n                                this.compile(node.children[1], js) +\n                                \")\";\n                            break;\n                        case \"op_gt\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.gt(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" > \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_lt\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.lt(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" < \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_geq\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.geq(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" >= \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_leq\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.leq(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" <= \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_or\":\n                            ret =\n                                \"(\" +\n                                this.compile(node.children[0], js) +\n                                \" || \" +\n                                this.compile(node.children[1], js) +\n                                \")\";\n                            break;\n                        case \"op_and\":\n                            ret =\n                                \"(\" +\n                                this.compile(node.children[0], js) +\n                                \" && \" +\n                                this.compile(node.children[1], js) +\n                                \")\";\n                            break;\n                        case \"op_not\":\n                            ret = \"!(\" + this.compile(node.children[0], js) + \")\";\n                            break;\n                        case \"op_add\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.add(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" + \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_sub\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.sub(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" - \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_div\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.div(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" / \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_mod\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.mod(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \", true)\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" % \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_mul\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.mul(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \" * \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_exp\":\n                            if (js) {\n                                ret =\n                                    \"$jc$.pow(\" +\n                                    this.compile(node.children[0], js) +\n                                    \", \" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            } else {\n                                ret =\n                                    \"(\" +\n                                    this.compile(node.children[0], js) +\n                                    \"^\" +\n                                    this.compile(node.children[1], js) +\n                                    \")\";\n                            }\n                            break;\n                        case \"op_neg\":\n                            if (js) {\n                                ret = \"$jc$.neg(\" + this.compile(node.children[0], js) + \")\";\n                            } else {\n                                ret = \"(-\" + this.compile(node.children[0], js) + \")\";\n                            }\n                            break;\n                    }\n                    break;\n\n                case \"node_var\":\n                    if (js) {\n                        ret = this.getvarJS(node.value, false, node.withProps);\n                    } else {\n                        ret = node.value;\n                    }\n                    break;\n\n                case \"node_const\":\n                    ret = node.value;\n                    break;\n\n                case \"node_const_bool\":\n                    ret = node.value;\n                    break;\n\n                case \"node_str\":\n                    ret = \"'\" + node.value + \"'\";\n                    break;\n            }\n\n            if (node.needsBrackets) {\n                if (js) {\n                    ret = \"{\\n\" + ret + \"\\n}\\n\";\n                } else {\n                    ret = \"<< \" + ret + \" >>\";\n                }\n            }\n\n            return ret;\n        },\n\n        /**\n         * This is used as the global getName() function.\n         * @param {JXG.GeometryElement} obj\n         * @param {Boolean} useId\n         * @returns {String}\n         */\n        getName: function (obj, useId) {\n            var name = \"\";\n\n            if (Type.exists(obj) && Type.exists(obj.getName)) {\n                name = obj.getName();\n                if ((!Type.exists(name) || name === \"\") && !!useId) {\n                    name = obj.id;\n                }\n            } else if (!!useId) {\n                name = obj.id;\n            }\n\n            return name;\n        },\n\n        /**\n         * This is used as the global X() function.\n         * @param {JXG.Point|JXG.Text} e\n         * @returns {Number}\n         */\n        X: function (e) {\n            return e.X();\n        },\n\n        /**\n         * This is used as the global Y() function.\n         * @param {JXG.Point|JXG.Text} e\n         * @returns {Number}\n         */\n        Y: function (e) {\n            return e.Y();\n        },\n\n        /**\n         * This is used as the global V() function.\n         * @param {Glider|Slider} e\n         * @returns {Number}\n         */\n        V: function (e) {\n            return e.Value();\n        },\n\n        /**\n         * This is used as the global L() function.\n         * @param {JXG.Line} e\n         * @returns {Number}\n         */\n        L: function (e) {\n            return e.L();\n        },\n\n        /**\n         * This is used as the global area() function.\n         * @param {JXG.Circle|JXG.Polygon} obj\n         * @returns {Number}\n         */\n        area: function (obj) {\n            if (!Type.exists(obj) || !Type.exists(obj.Area)) {\n                this._error(\"Error: Can't calculate area.\");\n            }\n\n            return obj.Area();\n        },\n\n        /**\n         * This is used as the global dist() function.\n         * @param {JXG.Point} p1\n         * @param {JXG.Point} p2\n         * @returns {Number}\n         */\n        dist: function (p1, p2) {\n            if (!Type.exists(p1) || !Type.exists(p1.Dist)) {\n                this._error(\"Error: Can't calculate distance.\");\n            }\n\n            return p1.Dist(p2);\n        },\n\n        /**\n         * This is used as the global radius() function.\n         * @param {JXG.Circle|Sector} obj\n         * @returns {Number}\n         */\n        radius: function (obj) {\n            if (!Type.exists(obj) || !Type.exists(obj.Radius)) {\n                this._error(\"Error: Can't calculate radius.\");\n            }\n\n            return obj.Radius();\n        },\n\n        /**\n         * + operator implementation\n         * @param {Number|Array|JXG.Point} a\n         * @param {Number|Array|JXG.Point} b\n         * @returns {Number|Array}\n         */\n        add: function (a, b) {\n            var i, len, res;\n\n            a = Type.evalSlider(a);\n            b = Type.evalSlider(b);\n\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                res = Interval.add(a, b);\n            } else if (Type.isArray(a) && Type.isArray(b)) {\n                len = Math.min(a.length, b.length);\n                res = [];\n\n                for (i = 0; i < len; i++) {\n                    res[i] = a[i] + b[i];\n                }\n            } else if (Type.isNumber(a) && Type.isNumber(b)) {\n                res = a + b;\n            } else if (Type.isString(a) || Type.isString(b)) {\n                res = a.toString() + b.toString();\n            } else {\n                this._error(\n                    \"Operation + not defined on operands \" + typeof a + \" and \" + typeof b\n                );\n            }\n\n            return res;\n        },\n\n        /**\n         * - operator implementation\n         * @param {Number|Array|JXG.Point} a\n         * @param {Number|Array|JXG.Point} b\n         * @returns {Number|Array}\n         */\n        sub: function (a, b) {\n            var i, len, res;\n\n            a = Type.evalSlider(a);\n            b = Type.evalSlider(b);\n\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                res = Interval.sub(a, b);\n            } else if (Type.isArray(a) && Type.isArray(b)) {\n                len = Math.min(a.length, b.length);\n                res = [];\n\n                for (i = 0; i < len; i++) {\n                    res[i] = a[i] - b[i];\n                }\n            } else if (Type.isNumber(a) && Type.isNumber(b)) {\n                res = a - b;\n            } else {\n                this._error(\n                    \"Operation - not defined on operands \" + typeof a + \" and \" + typeof b\n                );\n            }\n\n            return res;\n        },\n\n        /**\n         * unary - operator implementation\n         * @param {Number|Array|JXG.Point} a\n         * @returns {Number|Array}\n         */\n        neg: function (a) {\n            var i, len, res;\n\n            a = Type.evalSlider(a);\n\n            if (Interval.isInterval(a)) {\n                res = Interval.negative(a);\n            } else if (Type.isArray(a)) {\n                len = a.length;\n                res = [];\n\n                for (i = 0; i < len; i++) {\n                    res[i] = -a[i];\n                }\n            } else if (Type.isNumber(a)) {\n                res = -a;\n            } else {\n                this._error(\"Unary operation - not defined on operand \" + typeof a);\n            }\n\n            return res;\n        },\n\n        /**\n         * Multiplication of vectors and numbers\n         * @param {Number|Array} a\n         * @param {Number|Array} b\n         * @returns {Number|Array} (Inner) product of the given input values.\n         */\n        mul: function (a, b) {\n            var i, len, res;\n\n            a = Type.evalSlider(a);\n            b = Type.evalSlider(b);\n\n            if (Type.isArray(a) && Type.isNumber(b)) {\n                // swap b and a\n                i = a;\n                a = b;\n                b = a;\n            }\n\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                res = Interval.mul(a, b);\n            } else if (Type.isArray(a) && Type.isArray(b)) {\n                len = Math.min(a.length, b.length);\n                res = Mat.innerProduct(a, b, len);\n            } else if (Type.isNumber(a) && Type.isArray(b)) {\n                len = b.length;\n                res = [];\n\n                for (i = 0; i < len; i++) {\n                    res[i] = a * b[i];\n                }\n            } else if (Type.isNumber(a) && Type.isNumber(b)) {\n                res = a * b;\n            } else {\n                this._error(\n                    \"Operation * not defined on operands \" + typeof a + \" and \" + typeof b\n                );\n            }\n\n            return res;\n        },\n\n        /**\n         * Implementation of the / operator.\n         * @param {Number|Array} a\n         * @param {Number} b\n         * @returns {Number|Array}\n         */\n        div: function (a, b) {\n            var i, len, res;\n\n            a = Type.evalSlider(a);\n            b = Type.evalSlider(b);\n\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                res = Interval.div(a, b);\n            } else if (Type.isArray(a) && Type.isNumber(b)) {\n                len = a.length;\n                res = [];\n\n                for (i = 0; i < len; i++) {\n                    res[i] = a[i] / b;\n                }\n            } else if (Type.isNumber(a) && Type.isNumber(b)) {\n                res = a / b;\n            } else {\n                this._error(\n                    \"Operation * not defined on operands \" + typeof a + \" and \" + typeof b\n                );\n            }\n\n            return res;\n        },\n\n        /**\n         * Implementation of the % operator.\n         * @param {Number|Array} a\n         * @param {Number} b\n         * @returns {Number|Array}\n         */\n        mod: function (a, b) {\n            var i, len, res;\n\n            a = Type.evalSlider(a);\n            b = Type.evalSlider(b);\n\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                return Interval.fmod(a, b);\n            } else if (Type.isArray(a) && Type.isNumber(b)) {\n                len = a.length;\n                res = [];\n\n                for (i = 0; i < len; i++) {\n                    res[i] = Mat.mod(a[i], b, true);\n                }\n            } else if (Type.isNumber(a) && Type.isNumber(b)) {\n                res = Mat.mod(a, b, true);\n            } else {\n                this._error(\n                    \"Operation * not defined on operands \" + typeof a + \" and \" + typeof b\n                );\n            }\n\n            return res;\n        },\n\n        /**\n         * Pow function wrapper to allow direct usage of sliders.\n         * @param {Number|Slider} a\n         * @param {Number|Slider} b\n         * @returns {Number}\n         */\n        pow: function (a, b) {\n            a = Type.evalSlider(a);\n            b = Type.evalSlider(b);\n\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                return Interval.pow(a, b);\n            }\n            return Mat.pow(a, b);\n        },\n\n        lt: function (a, b) {\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                return Interval.lt(a, b);\n            }\n            return a < b;\n        },\n        leq: function (a, b) {\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                return Interval.leq(a, b);\n            }\n            return a <= b;\n        },\n        gt: function (a, b) {\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                return Interval.gt(a, b);\n            }\n            return a > b;\n        },\n        geq: function (a, b) {\n            if (Interval.isInterval(a) || Interval.isInterval(b)) {\n                return Intervalt.geq(a, b);\n            }\n            return a >= b;\n        },\n\n        randint: function (min, max, step) {\n            if (!Type.exists(step)) {\n                step = 1;\n            }\n            return Math.round((Math.random() * (max - min)) / step) * step + min;\n        },\n\n        DDD: function (f) {\n            console.log(\"Dummy derivative function. This should never appear!\");\n        },\n\n        /**\n         * Implementation of the ?: operator\n         * @param {Boolean} cond Condition\n         * @param {*} v1\n         * @param {*} v2\n         * @returns {*} Either v1 or v2.\n         */\n        ifthen: function (cond, v1, v2) {\n            if (cond) {\n                return v1;\n            }\n\n            return v2;\n        },\n\n        /**\n         * Implementation of the delete() builtin function\n         * @param {JXG.GeometryElement} element\n         */\n        del: function (element) {\n            if (\n                typeof element === \"object\" &&\n                JXG.exists(element.type) &&\n                JXG.exists(element.elementClass)\n            ) {\n                this.board.removeObject(element);\n            }\n        },\n\n        /**\n         * Implementation of the use() builtin function\n         * @param {String} board\n         */\n        use: function (board) {\n            var b,\n                ref,\n                found = false;\n\n            if (typeof board === \"string\") {\n                // search all the boards for the one with the appropriate container div\n                for (b in JXG.boards) {\n                    if (JXG.boards.hasOwnProperty(b) && JXG.boards[b].container === board) {\n                        ref = JXG.boards[b];\n                        found = true;\n                        break;\n                    }\n                }\n            } else {\n                ref = board;\n                found = true;\n            }\n\n            if (found) {\n                this.board = ref;\n                this.builtIn.$board = ref;\n                this.builtIn.$board.src = \"$jc$.board\";\n            } else {\n                this._error(\"Board '\" + board + \"' not found!\");\n            }\n        },\n\n        /**\n         * Find the first symbol to the given value from the given scope upwards.\n         * @param v Value\n         * @param {Number} [scope=-1] The scope, default is to start with current scope (-1).\n         * @returns {Array} An array containing the symbol and the scope if a symbol could be found,\n         * an empty array otherwise;\n         */\n        findSymbol: function (v, scope) {\n            var i, s;\n\n            scope = Type.def(scope, -1);\n\n            if (scope === -1) {\n                s = this.scope;\n            } else {\n                s = this.scopes[scope];\n            }\n\n            while (s !== null) {\n                for (i in s.locals) {\n                    if (s.locals.hasOwnProperty(i) && s.locals[i] === v) {\n                        return [i, s];\n                    }\n                }\n\n                s = s.previous;\n            }\n\n            return [];\n        },\n\n        /**\n         * Import modules into a JessieCode script.\n         * @param {String} module\n         */\n        importModule: function (module) {\n            return priv.modules[module.toLowerCase()];\n        },\n\n        /**\n         * Defines built in methods and constants.\n         * @returns {Object} BuiltIn control object\n         */\n        defineBuiltIn: function () {\n            var that = this,\n                builtIn = {\n                    PI: Math.PI,\n                    EULER: Math.E,\n                    D: that.DDD,\n                    X: that.X,\n                    Y: that.Y,\n                    V: that.V,\n                    L: that.L,\n\n                    acosh: Mat.acosh,\n                    acot: Mat.acot,\n                    asinh: Mat.asinh,\n                    binomial: Mat.binomial,\n                    cbrt: Mat.cbrt,\n                    cosh: Mat.cosh,\n                    cot: Mat.cot,\n                    deg: Geometry.trueAngle,\n                    A: that.area,\n                    area: that.area,\n                    dist: that.dist,\n                    R: that.radius,\n                    radius: that.radius,\n                    erf: Mat.erf,\n                    erfc: Mat.erfc,\n                    erfi: Mat.erfi,\n                    factorial: Mat.factorial,\n                    gcd: Mat.gcd,\n                    lb: Mat.log2,\n                    lcm: Mat.lcm,\n                    ld: Mat.log2,\n                    lg: Mat.log10,\n                    ln: Math.log,\n                    log: Mat.log,\n                    log10: Mat.log10,\n                    log2: Mat.log2,\n                    ndtr: Mat.ndtr,\n                    ndtri: Mat.ndtri,\n                    nthroot: Mat.nthroot,\n                    pow: Mat.pow,\n                    rad: Geometry.rad,\n                    ratpow: Mat.ratpow,\n                    trunc: Type.trunc,\n                    sinh: Mat.sinh,\n\n                    randint: that.randint,\n\n                    IfThen: that.ifthen,\n                    import: that.importModule,\n                    use: that.use,\n                    remove: that.del,\n                    $: that.getElementById,\n                    getName: that.getName,\n                    name: that.getName,\n                    $board: that.board,\n                    $log: that.log\n                };\n\n            // special scopes for factorial, deg, and rad\n            builtIn.rad.sc = Geometry;\n            builtIn.deg.sc = Geometry;\n            builtIn.factorial.sc = Mat;\n\n            // set the javascript equivalent for the builtIns\n            // some of the anonymous functions should be replaced by global methods later on\n            // EULER and PI don't get a source attribute - they will be lost anyways and apparently\n            // some browser will throw an exception when a property is assigned to a primitive value.\n            builtIn.X.src = \"$jc$.X\";\n            builtIn.Y.src = \"$jc$.Y\";\n            builtIn.V.src = \"$jc$.V\";\n            builtIn.L.src = \"$jc$.L\";\n\n            builtIn.acosh.src = \"JXG.Math.acosh\";\n            builtIn.acot.src = \"JXG.Math.acot\";\n            builtIn.asinh.src = \"JXG.Math.asinh\";\n            builtIn.binomial.src = \"JXG.Math.binomial\";\n            builtIn.cbrt.src = \"JXG.Math.cbrt\";\n            builtIn.cot.src = \"JXG.Math.cot\";\n            builtIn.cosh.src = \"JXG.Math.cosh\";\n            builtIn.deg.src = \"JXG.Math.Geometry.trueAngle\";\n            builtIn.erf.src = \"JXG.Math.erf\";\n            builtIn.erfc.src = \"JXG.Math.erfc\";\n            builtIn.erfi.src = \"JXG.Math.erfi\";\n            builtIn.A.src = \"$jc$.area\";\n            builtIn.area.src = \"$jc$.area\";\n            builtIn.dist.src = \"$jc$.dist\";\n            builtIn.R.src = \"$jc$.radius\";\n            builtIn.radius.src = \"$jc$.radius\";\n            builtIn.factorial.src = \"JXG.Math.factorial\";\n            builtIn.gcd.src = \"JXG.Math.gcd\";\n            builtIn.lb.src = \"JXG.Math.log2\";\n            builtIn.lcm.src = \"JXG.Math.lcm\";\n            builtIn.ld.src = \"JXG.Math.log2\";\n            builtIn.lg.src = \"JXG.Math.log10\";\n            builtIn.ln.src = \"Math.log\";\n            builtIn.log.src = \"JXG.Math.log\";\n            builtIn.log10.src = \"JXG.Math.log10\";\n            builtIn.log2.src = \"JXG.Math.log2\";\n            builtIn.ndtr.src = \"JXG.Math.ndtr\";\n            builtIn.ndtri.src = \"JXG.Math.ndtri\";\n            builtIn.nthroot.src = \"JXG.Math.nthroot\";\n            builtIn.pow.src = \"JXG.Math.pow\";\n            builtIn.rad.src = \"JXG.Math.Geometry.rad\";\n            builtIn.ratpow.src = \"JXG.Math.ratpow\";\n            builtIn.trunc.src = \"JXG.trunc\";\n            builtIn.sinh.src = \"JXG.Math.sinh\";\n\n            builtIn.randint.src = \"$jc$.randint\";\n\n            builtIn[\"import\"].src = \"$jc$.importModule\";\n            builtIn.use.src = \"$jc$.use\";\n            builtIn.remove.src = \"$jc$.del\";\n            builtIn.IfThen.src = \"$jc$.ifthen\";\n            // usually unused, see node_op > op_execfun\n            builtIn.$.src = \"(function (n) { return $jc$.board.select(n); })\";\n            builtIn.getName.src = \"$jc$.getName\";\n            builtIn.name.src = \"$jc$.getName\";\n            if (builtIn.$board) {\n                builtIn.$board.src = \"$jc$.board\";\n            }\n            builtIn.$log.src = \"$jc$.log\";\n\n            return builtIn;\n        },\n\n        /**\n         * Returns information about the possible functions and constants.\n         * @returns {Object}\n         */\n        getPossibleOperands: function () {\n            var FORBIDDEN = [\"E\"],\n                jessiecode = this.defineBuiltIn(),\n                math = Math,\n                jc,\n                ma,\n                merge,\n                i,\n                j,\n                p,\n                len,\n                e,\n                funcs,\n                funcsJC,\n                consts,\n                operands,\n                sort,\n                pack;\n\n            sort = function (a, b) {\n                return a.toLowerCase().localeCompare(b.toLowerCase());\n            };\n\n            pack = function (name, origin) {\n                var that = null;\n\n                if (origin === \"jc\") that = jessiecode[name];\n                else if (origin === \"Math\") that = math[name];\n                else return;\n\n                if (FORBIDDEN.indexOf(name) >= 0) {\n                    return;\n                } else if (JXG.isFunction(that)) {\n                    return {\n                        name: name,\n                        type: \"function\",\n                        numParams: that.length,\n                        origin: origin\n                    };\n                } else if (JXG.isNumber(that)) {\n                    return {\n                        name: name,\n                        type: \"constant\",\n                        value: that,\n                        origin: origin\n                    };\n                } else if (that !== undefined) {\n                    console.error(\"undefined type\", that);\n                }\n            };\n\n            jc = Object.getOwnPropertyNames(jessiecode).sort(sort);\n            ma = Object.getOwnPropertyNames(math).sort(sort);\n            merge = [];\n            i = 0;\n            j = 0;\n\n            while (i < jc.length || j < ma.length) {\n                if (jc[i] === ma[j]) {\n                    p = pack(ma[j], \"Math\");\n                    if (JXG.exists(p)) merge.push(p);\n                    i++;\n                    j++;\n                } else if (\n                    !JXG.exists(ma[j]) ||\n                    jc[i].toLowerCase().localeCompare(ma[j].toLowerCase()) < 0\n                ) {\n                    p = pack(jc[i], \"jc\");\n                    if (JXG.exists(p)) merge.push(p);\n                    i++;\n                } else {\n                    p = pack(ma[j], \"Math\");\n                    if (JXG.exists(p)) merge.push(p);\n                    j++;\n                }\n            }\n\n            funcs = [];\n            funcsJC = [];\n            consts = [];\n            operands = {};\n            len = merge.length;\n            for (i = 0; i < len; i++) {\n                e = merge[i];\n                switch (e.type) {\n                    case \"function\":\n                        funcs.push(e.name);\n                        if (e.origin === \"jc\") funcsJC.push(e.name);\n                        break;\n                    case \"constant\":\n                        consts.push(e.name);\n                        break;\n                }\n                operands[e.name] = e;\n            }\n\n            return {\n                all: operands,\n                list: merge,\n                functions: funcs,\n                functions_jessiecode: funcsJC,\n                constants: consts\n            };\n        },\n\n        /**\n         * Output a debugging message. Uses debug console, if available. Otherwise an HTML element with the\n         * id \"debug\" and an innerHTML property is used.\n         * @param {String} log\n         * @private\n         */\n        _debug: function (log) {\n            if (typeof console === \"object\") {\n                console.log(log);\n            } else if (Env.isBrowser && document && document.getElementById(\"debug\") !== null) {\n                document.getElementById(\"debug\").innerHTML += log + \"<br />\";\n            }\n        },\n\n        /**\n         * Throws an exception with the given error message.\n         * @param {String} msg Error message\n         */\n        _error: function (msg) {\n            var e = new Error(\"Error(\" + this.line + \"): \" + msg);\n            e.line = this.line;\n            throw e;\n        },\n\n        /**\n         * Output a warning message using {@link JXG#debug} and precedes the message with \"Warning: \".\n         * @param {String} msg\n         */\n        _warn: function (msg) {\n            if (typeof console === \"object\") {\n                console.log(\"Warning(\" + this.line + \"): \" + msg);\n            } else if (\n                Env.isBrowser &&\n                document &&\n                document.getElementById(this.warnLog) !== null\n            ) {\n                document.getElementById(this.warnLog).innerHTML +=\n                    \"Warning(\" + this.line + \"): \" + msg + \"<br />\";\n            }\n        },\n\n        _log: function (msg) {\n            if (typeof window !== \"object\" && typeof self === \"object\" && self.postMessage) {\n                self.postMessage({ type: \"log\", msg: \"Log: \" + msg.toString() });\n            } else {\n                console.log(\"Log: \", arguments);\n            }\n        }\n    }\n);\n\n/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function () {\n    var o = function (k, v, o, l) {\n            for (o = o || {}, l = k.length; l--; o[k[l]] = v);\n            return o;\n        },\n        $V0 = [2, 14],\n        $V1 = [1, 13],\n        $V2 = [1, 37],\n        $V3 = [1, 14],\n        $V4 = [1, 15],\n        $V5 = [1, 21],\n        $V6 = [1, 16],\n        $V7 = [1, 17],\n        $V8 = [1, 33],\n        $V9 = [1, 18],\n        $Va = [1, 19],\n        $Vb = [1, 12],\n        $Vc = [1, 59],\n        $Vd = [1, 60],\n        $Ve = [1, 58],\n        $Vf = [1, 46],\n        $Vg = [1, 48],\n        $Vh = [1, 49],\n        $Vi = [1, 50],\n        $Vj = [1, 51],\n        $Vk = [1, 52],\n        $Vl = [1, 53],\n        $Vm = [1, 54],\n        $Vn = [1, 45],\n        $Vo = [1, 38],\n        $Vp = [1, 39],\n        $Vq = [\n            5, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77, 78,\n            79, 80, 82, 91, 93\n        ],\n        $Vr = [\n            5, 7, 8, 12, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76, 77,\n            78, 79, 80, 82, 91, 93\n        ],\n        $Vs = [\n            8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57,\n            64, 65, 66, 83, 86\n        ],\n        $Vt = [2, 48],\n        $Vu = [1, 72],\n        $Vv = [\n            10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 66,\n            83, 86\n        ],\n        $Vw = [1, 78],\n        $Vx = [\n            8, 10, 16, 32, 34, 35, 37, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64,\n            65, 66, 83, 86\n        ],\n        $Vy = [1, 82],\n        $Vz = [\n            8, 10, 16, 32, 34, 35, 37, 39, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 64, 65, 66,\n            83, 86\n        ],\n        $VA = [1, 83],\n        $VB = [1, 84],\n        $VC = [1, 85],\n        $VD = [\n            8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 50, 51, 53, 54, 55, 57, 64, 65, 66, 83,\n            86\n        ],\n        $VE = [1, 89],\n        $VF = [1, 90],\n        $VG = [1, 91],\n        $VH = [1, 92],\n        $VI = [1, 97],\n        $VJ = [\n            8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 53, 54, 55, 57, 64, 65,\n            66, 83, 86\n        ],\n        $VK = [1, 103],\n        $VL = [1, 104],\n        $VM = [\n            8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 57, 64, 65, 66,\n            83, 86\n        ],\n        $VN = [1, 105],\n        $VO = [1, 106],\n        $VP = [1, 107],\n        $VQ = [1, 126],\n        $VR = [1, 139],\n        $VS = [83, 86],\n        $VT = [1, 150],\n        $VU = [10, 66, 86],\n        $VV = [\n            8, 10, 16, 20, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55,\n            57, 64, 65, 66, 82, 83, 86\n        ],\n        $VW = [1, 167],\n        $VX = [10, 86];\n    var parser = {\n        trace: function trace() {},\n        yy: {},\n        symbols_: {\n            error: 2,\n            Program: 3,\n            StatementList: 4,\n            EOF: 5,\n            IfStatement: 6,\n            IF: 7,\n            \"(\": 8,\n            Expression: 9,\n            \")\": 10,\n            Statement: 11,\n            ELSE: 12,\n            LoopStatement: 13,\n            WHILE: 14,\n            FOR: 15,\n            \";\": 16,\n            DO: 17,\n            UnaryStatement: 18,\n            USE: 19,\n            IDENTIFIER: 20,\n            DELETE: 21,\n            ReturnStatement: 22,\n            RETURN: 23,\n            EmptyStatement: 24,\n            StatementBlock: 25,\n            \"{\": 26,\n            \"}\": 27,\n            ExpressionStatement: 28,\n            AssignmentExpression: 29,\n            ConditionalExpression: 30,\n            LeftHandSideExpression: 31,\n            \"=\": 32,\n            LogicalORExpression: 33,\n            \"?\": 34,\n            \":\": 35,\n            LogicalANDExpression: 36,\n            \"||\": 37,\n            EqualityExpression: 38,\n            \"&&\": 39,\n            RelationalExpression: 40,\n            \"==\": 41,\n            \"!=\": 42,\n            \"~=\": 43,\n            AdditiveExpression: 44,\n            \"<\": 45,\n            \">\": 46,\n            \"<=\": 47,\n            \">=\": 48,\n            MultiplicativeExpression: 49,\n            \"+\": 50,\n            \"-\": 51,\n            UnaryExpression: 52,\n            \"*\": 53,\n            \"/\": 54,\n            \"%\": 55,\n            ExponentExpression: 56,\n            \"^\": 57,\n            \"!\": 58,\n            MemberExpression: 59,\n            CallExpression: 60,\n            PrimaryExpression: 61,\n            FunctionExpression: 62,\n            MapExpression: 63,\n            \".\": 64,\n            \"[\": 65,\n            \"]\": 66,\n            BasicLiteral: 67,\n            ObjectLiteral: 68,\n            ArrayLiteral: 69,\n            NullLiteral: 70,\n            BooleanLiteral: 71,\n            StringLiteral: 72,\n            NumberLiteral: 73,\n            NULL: 74,\n            TRUE: 75,\n            FALSE: 76,\n            STRING: 77,\n            NUMBER: 78,\n            NAN: 79,\n            INFINITY: 80,\n            ElementList: 81,\n            \"<<\": 82,\n            \">>\": 83,\n            PropertyList: 84,\n            Property: 85,\n            \",\": 86,\n            PropertyName: 87,\n            Arguments: 88,\n            AttributeList: 89,\n            Attribute: 90,\n            FUNCTION: 91,\n            ParameterDefinitionList: 92,\n            MAP: 93,\n            \"->\": 94,\n            $accept: 0,\n            $end: 1\n        },\n        terminals_: {\n            2: \"error\",\n            5: \"EOF\",\n            7: \"IF\",\n            8: \"(\",\n            10: \")\",\n            12: \"ELSE\",\n            14: \"WHILE\",\n            15: \"FOR\",\n            16: \";\",\n            17: \"DO\",\n            19: \"USE\",\n            20: \"IDENTIFIER\",\n            21: \"DELETE\",\n            23: \"RETURN\",\n            26: \"{\",\n            27: \"}\",\n            32: \"=\",\n            34: \"?\",\n            35: \":\",\n            37: \"||\",\n            39: \"&&\",\n            41: \"==\",\n            42: \"!=\",\n            43: \"~=\",\n            45: \"<\",\n            46: \">\",\n            47: \"<=\",\n            48: \">=\",\n            50: \"+\",\n            51: \"-\",\n            53: \"*\",\n            54: \"/\",\n            55: \"%\",\n            57: \"^\",\n            58: \"!\",\n            64: \".\",\n            65: \"[\",\n            66: \"]\",\n            74: \"NULL\",\n            75: \"TRUE\",\n            76: \"FALSE\",\n            77: \"STRING\",\n            78: \"NUMBER\",\n            79: \"NAN\",\n            80: \"INFINITY\",\n            82: \"<<\",\n            83: \">>\",\n            86: \",\",\n            91: \"FUNCTION\",\n            93: \"MAP\",\n            94: \"->\"\n        },\n        productions_: [\n            0,\n            [3, 2],\n            [6, 5],\n            [6, 7],\n            [13, 5],\n            [13, 9],\n            [13, 7],\n            [18, 2],\n            [18, 2],\n            [22, 2],\n            [22, 3],\n            [24, 1],\n            [25, 3],\n            [4, 2],\n            [4, 0],\n            [11, 1],\n            [11, 1],\n            [11, 1],\n            [11, 1],\n            [11, 1],\n            [11, 1],\n            [11, 1],\n            [28, 2],\n            [9, 1],\n            [29, 1],\n            [29, 3],\n            [30, 1],\n            [30, 5],\n            [33, 1],\n            [33, 3],\n            [36, 1],\n            [36, 3],\n            [38, 1],\n            [38, 3],\n            [38, 3],\n            [38, 3],\n            [40, 1],\n            [40, 3],\n            [40, 3],\n            [40, 3],\n            [40, 3],\n            [44, 1],\n            [44, 3],\n            [44, 3],\n            [49, 1],\n            [49, 3],\n            [49, 3],\n            [49, 3],\n            [56, 1],\n            [56, 3],\n            [52, 1],\n            [52, 2],\n            [52, 2],\n            [52, 2],\n            [31, 1],\n            [31, 1],\n            [59, 1],\n            [59, 1],\n            [59, 1],\n            [59, 3],\n            [59, 4],\n            [61, 1],\n            [61, 1],\n            [61, 1],\n            [61, 1],\n            [61, 3],\n            [67, 1],\n            [67, 1],\n            [67, 1],\n            [67, 1],\n            [70, 1],\n            [71, 1],\n            [71, 1],\n            [72, 1],\n            [73, 1],\n            [73, 1],\n            [73, 1],\n            [69, 2],\n            [69, 3],\n            [68, 2],\n            [68, 3],\n            [84, 1],\n            [84, 3],\n            [85, 3],\n            [87, 1],\n            [87, 1],\n            [87, 1],\n            [60, 2],\n            [60, 3],\n            [60, 2],\n            [60, 4],\n            [60, 3],\n            [88, 2],\n            [88, 3],\n            [89, 1],\n            [89, 3],\n            [90, 1],\n            [90, 1],\n            [81, 1],\n            [81, 3],\n            [62, 4],\n            [62, 5],\n            [63, 5],\n            [63, 6],\n            [92, 1],\n            [92, 3]\n        ],\n        performAction: function anonymous(\n            yytext,\n            yyleng,\n            yylineno,\n            yy,\n            yystate /* action[1] */,\n            $$ /* vstack */,\n            _$ /* lstack */\n        ) {\n            /* this == yyval */\n\n            var $0 = $$.length - 1;\n            switch (yystate) {\n                case 1:\n                    return $$[$0 - 1];\n                    break;\n                case 2:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 4]),\n                        \"node_op\",\n                        \"op_if\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    break;\n                case 3:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 6]),\n                        \"node_op\",\n                        \"op_if_else\",\n                        $$[$0 - 4],\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    break;\n                case 4:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 4]),\n                        \"node_op\",\n                        \"op_while\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    break;\n                case 5:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 8]),\n                        \"node_op\",\n                        \"op_for\",\n                        $$[$0 - 6],\n                        $$[$0 - 4],\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    break;\n                case 6:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 6]),\n                        \"node_op\",\n                        \"op_do\",\n                        $$[$0 - 5],\n                        $$[$0 - 2]\n                    );\n                    break;\n                case 7:\n                    this.$ = AST.createNode(lc(_$[$0 - 1]), \"node_op\", \"op_use\", $$[$0]);\n                    break;\n                case 8:\n                    this.$ = AST.createNode(lc(_$[$0 - 1]), \"node_op\", \"op_delete\", $$[$0]);\n                    break;\n                case 9:\n                    this.$ = AST.createNode(lc(_$[$0 - 1]), \"node_op\", \"op_return\", undefined);\n                    break;\n                case 10:\n                    this.$ = AST.createNode(lc(_$[$0 - 2]), \"node_op\", \"op_return\", $$[$0 - 1]);\n                    break;\n                case 11:\n                case 14:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_op\", \"op_none\");\n                    break;\n                case 12:\n                    this.$ = $$[$0 - 1];\n                    this.$.needsBrackets = true;\n                    break;\n                case 13:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 1]),\n                        \"node_op\",\n                        \"op_none\",\n                        $$[$0 - 1],\n                        $$[$0]\n                    );\n                    break;\n                case 15:\n                case 16:\n                case 17:\n                case 18:\n                case 19:\n                case 20:\n                case 21:\n                case 23:\n                case 24:\n                case 26:\n                case 28:\n                case 30:\n                case 32:\n                case 36:\n                case 41:\n                case 44:\n                case 48:\n                case 50:\n                case 52:\n                case 54:\n                case 55:\n                case 56:\n                case 58:\n                case 62:\n                case 81:\n                case 84:\n                case 85:\n                case 86:\n                    this.$ = $$[$0];\n                    break;\n                case 22:\n                case 65:\n                case 93:\n                    this.$ = $$[$0 - 1];\n                    break;\n                case 25:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_assign\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 27:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 4]),\n                        \"node_op\",\n                        \"op_conditional\",\n                        $$[$0 - 4],\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 29:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_or\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 31:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_and\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 33:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_eq\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 34:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_neq\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 35:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_approx\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 37:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_lt\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 38:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_gt\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 39:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_leq\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 40:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_geq\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 42:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_add\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 43:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_sub\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 45:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_mul\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 46:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_div\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 47:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_mod\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 49:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_exp\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 51:\n                    this.$ = AST.createNode(lc(_$[$0 - 1]), \"node_op\", \"op_not\", $$[$0]);\n                    this.$.isMath = false;\n                    break;\n                case 53:\n                    this.$ = AST.createNode(lc(_$[$0 - 1]), \"node_op\", \"op_neg\", $$[$0]);\n                    this.$.isMath = true;\n                    break;\n                case 57:\n                case 63:\n                case 64:\n                case 66:\n                case 67:\n                case 68:\n                case 97:\n                    this.$ = $$[$0];\n                    this.$.isMath = false;\n                    break;\n                case 59:\n                case 91:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_property\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 60:\n                case 90:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 3]),\n                        \"node_op\",\n                        \"op_extvalue\",\n                        $$[$0 - 3],\n                        $$[$0 - 1]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 61:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_var\", $$[$0]);\n                    break;\n                case 69:\n                    this.$ = $$[$0];\n                    this.$.isMath = true;\n                    break;\n                case 70:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_const\", null);\n                    break;\n                case 71:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_const_bool\", true);\n                    break;\n                case 72:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_const_bool\", false);\n                    break;\n                case 73:\n                    this.$ = AST.createNode(\n                        lc(_$[$0]),\n                        \"node_str\",\n                        $$[$0].substring(1, $$[$0].length - 1)\n                    );\n                    break;\n                case 74:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_const\", parseFloat($$[$0]));\n                    break;\n                case 75:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_const\", NaN);\n                    break;\n                case 76:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_const\", Infinity);\n                    break;\n                case 77:\n                    this.$ = AST.createNode(lc(_$[$0 - 1]), \"node_op\", \"op_array\", []);\n                    break;\n                case 78:\n                    this.$ = AST.createNode(lc(_$[$0 - 2]), \"node_op\", \"op_array\", $$[$0 - 1]);\n                    break;\n                case 79:\n                    this.$ = AST.createNode(lc(_$[$0 - 1]), \"node_op\", \"op_emptyobject\", {});\n                    this.$.needsBrackets = true;\n                    break;\n                case 80:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_proplst_val\",\n                        $$[$0 - 1]\n                    );\n                    this.$.needsBrackets = true;\n                    break;\n                case 82:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_proplst\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    break;\n                case 83:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_prop\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    break;\n                case 87:\n                case 89:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 1]),\n                        \"node_op\",\n                        \"op_execfun\",\n                        $$[$0 - 1],\n                        $$[$0]\n                    );\n                    this.$.isMath = true;\n                    break;\n                case 88:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 2]),\n                        \"node_op\",\n                        \"op_execfun\",\n                        $$[$0 - 2],\n                        $$[$0 - 1],\n                        $$[$0],\n                        true\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 92:\n                    this.$ = [];\n                    break;\n                case 94:\n                case 98:\n                case 104:\n                    this.$ = [$$[$0]];\n                    break;\n                case 95:\n                case 99:\n                case 105:\n                    this.$ = $$[$0 - 2].concat($$[$0]);\n                    break;\n                case 96:\n                    this.$ = AST.createNode(lc(_$[$0]), \"node_var\", $$[$0]);\n                    this.$.isMath = true;\n                    break;\n                case 100:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 3]),\n                        \"node_op\",\n                        \"op_function\",\n                        [],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 101:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 4]),\n                        \"node_op\",\n                        \"op_function\",\n                        $$[$0 - 2],\n                        $$[$0]\n                    );\n                    this.$.isMath = false;\n                    break;\n                case 102:\n                    this.$ = AST.createNode(lc(_$[$0 - 4]), \"node_op\", \"op_map\", [], $$[$0]);\n                    break;\n                case 103:\n                    this.$ = AST.createNode(\n                        lc(_$[$0 - 5]),\n                        \"node_op\",\n                        \"op_map\",\n                        $$[$0 - 3],\n                        $$[$0]\n                    );\n                    break;\n            }\n        },\n        table: [\n            o(\n                [\n                    5, 7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 50, 51, 58, 65, 74, 75, 76, 77,\n                    78, 79, 80, 82, 91, 93\n                ],\n                $V0,\n                { 3: 1, 4: 2 }\n            ),\n            { 1: [3] },\n            {\n                5: [1, 3],\n                6: 6,\n                7: $V1,\n                8: $V2,\n                9: 20,\n                11: 4,\n                13: 7,\n                14: $V3,\n                15: $V4,\n                16: $V5,\n                17: $V6,\n                18: 8,\n                19: $V7,\n                20: $V8,\n                21: $V9,\n                22: 9,\n                23: $Va,\n                24: 11,\n                25: 5,\n                26: $Vb,\n                28: 10,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 1: [2, 1] },\n            o($Vq, [2, 13]),\n            o($Vr, [2, 15]),\n            o($Vr, [2, 16]),\n            o($Vr, [2, 17]),\n            o($Vr, [2, 18]),\n            o($Vr, [2, 19]),\n            o($Vr, [2, 20]),\n            o($Vr, [2, 21]),\n            o(\n                [\n                    7, 8, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 50, 51, 58, 65, 74, 75, 76,\n                    77, 78, 79, 80, 82, 91, 93\n                ],\n                $V0,\n                { 4: 61 }\n            ),\n            { 8: [1, 62] },\n            { 8: [1, 63] },\n            { 8: [1, 64] },\n            {\n                6: 6,\n                7: $V1,\n                8: $V2,\n                9: 20,\n                11: 65,\n                13: 7,\n                14: $V3,\n                15: $V4,\n                16: $V5,\n                17: $V6,\n                18: 8,\n                19: $V7,\n                20: $V8,\n                21: $V9,\n                22: 9,\n                23: $Va,\n                24: 11,\n                25: 5,\n                26: $Vb,\n                28: 10,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 20: [1, 66] },\n            { 20: [1, 67] },\n            {\n                8: $V2,\n                9: 69,\n                16: [1, 68],\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 16: [1, 70] },\n            o($Vr, [2, 11]),\n            o($Vs, [2, 23]),\n            o($Vs, [2, 24]),\n            o(\n                [\n                    8, 10, 16, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55,\n                    64, 65, 66, 83, 86\n                ],\n                $Vt,\n                { 32: [1, 71], 57: $Vu }\n            ),\n            o(\n                [\n                    8, 10, 16, 32, 35, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57,\n                    64, 65, 66, 83, 86\n                ],\n                [2, 26],\n                { 34: [1, 73], 37: [1, 74] }\n            ),\n            o($Vv, [2, 54], { 88: 77, 8: $Vw, 64: [1, 75], 65: [1, 76] }),\n            o($Vv, [2, 55], { 88: 79, 8: $Vw, 64: [1, 81], 65: [1, 80] }),\n            o($Vx, [2, 28], { 39: $Vy }),\n            o($Vs, [2, 56]),\n            o($Vs, [2, 57]),\n            o($Vs, [2, 58]),\n            o($Vz, [2, 30], { 41: $VA, 42: $VB, 43: $VC }),\n            o($Vs, [2, 61]),\n            o($Vs, [2, 62]),\n            o($Vs, [2, 63]),\n            o($Vs, [2, 64]),\n            {\n                8: $V2,\n                9: 86,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 8: [1, 87] },\n            { 8: [1, 88] },\n            o($VD, [2, 32], { 45: $VE, 46: $VF, 47: $VG, 48: $VH }),\n            o($Vs, [2, 66]),\n            o($Vs, [2, 67]),\n            o($Vs, [2, 68]),\n            o($Vs, [2, 69]),\n            {\n                20: $VI,\n                72: 98,\n                73: 99,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                83: [1, 93],\n                84: 94,\n                85: 95,\n                87: 96\n            },\n            {\n                8: $V2,\n                20: $V8,\n                29: 102,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                66: [1, 100],\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                81: 101,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($VJ, [2, 36], { 50: $VK, 51: $VL }),\n            o($Vs, [2, 70]),\n            o($Vs, [2, 71]),\n            o($Vs, [2, 72]),\n            o($Vs, [2, 73]),\n            o($Vs, [2, 74]),\n            o($Vs, [2, 75]),\n            o($Vs, [2, 76]),\n            o($VM, [2, 41], { 53: $VN, 54: $VO, 55: $VP }),\n            o($Vs, [2, 44]),\n            o($Vs, [2, 50]),\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                50: $Vc,\n                51: $Vd,\n                52: 108,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                50: $Vc,\n                51: $Vd,\n                52: 110,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                50: $Vc,\n                51: $Vd,\n                52: 111,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                6: 6,\n                7: $V1,\n                8: $V2,\n                9: 20,\n                11: 4,\n                13: 7,\n                14: $V3,\n                15: $V4,\n                16: $V5,\n                17: $V6,\n                18: 8,\n                19: $V7,\n                20: $V8,\n                21: $V9,\n                22: 9,\n                23: $Va,\n                24: 11,\n                25: 5,\n                26: $Vb,\n                27: [1, 112],\n                28: 10,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                9: 113,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                9: 114,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                9: 115,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 14: [1, 116] },\n            o($Vr, [2, 7]),\n            o($Vr, [2, 8]),\n            o($Vr, [2, 9]),\n            { 16: [1, 117] },\n            o($Vr, [2, 22]),\n            {\n                8: $V2,\n                20: $V8,\n                29: 118,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                50: $Vc,\n                51: $Vd,\n                52: 119,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                29: 120,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                36: 121,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 20: [1, 122] },\n            {\n                8: $V2,\n                9: 123,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($Vs, [2, 87], { 89: 124, 90: 125, 68: 127, 20: $VQ, 82: $Vn }),\n            {\n                8: $V2,\n                10: [1, 128],\n                20: $V8,\n                29: 102,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                81: 129,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($Vs, [2, 89]),\n            {\n                8: $V2,\n                9: 130,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 20: [1, 131] },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                38: 132,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                40: 133,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                40: 134,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                40: 135,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 10: [1, 136] },\n            { 10: [1, 137], 20: $VR, 92: 138 },\n            { 10: [1, 140], 20: $VR, 92: 141 },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                44: 142,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                44: 143,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                44: 144,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                44: 145,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($Vs, [2, 79]),\n            { 83: [1, 146], 86: [1, 147] },\n            o($VS, [2, 81]),\n            { 35: [1, 148] },\n            { 35: [2, 84] },\n            { 35: [2, 85] },\n            { 35: [2, 86] },\n            o($Vs, [2, 77]),\n            { 66: [1, 149], 86: $VT },\n            o($VU, [2, 98]),\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                49: 151,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                49: 152,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                50: $Vc,\n                51: $Vd,\n                52: 153,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                50: $Vc,\n                51: $Vd,\n                52: 154,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                31: 109,\n                50: $Vc,\n                51: $Vd,\n                52: 155,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($Vs, [2, 51]),\n            o(\n                [\n                    8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54,\n                    55, 64, 65, 66, 83, 86\n                ],\n                $Vt,\n                { 57: $Vu }\n            ),\n            o($Vs, [2, 52]),\n            o($Vs, [2, 53]),\n            o(\n                [\n                    5, 7, 8, 10, 12, 14, 15, 16, 17, 19, 20, 21, 23, 26, 27, 32, 34, 35, 37, 39,\n                    41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54, 55, 57, 58, 64, 65, 66, 74, 75,\n                    76, 77, 78, 79, 80, 82, 83, 86, 91, 93\n                ],\n                [2, 12]\n            ),\n            { 10: [1, 156] },\n            { 10: [1, 157] },\n            { 16: [1, 158] },\n            { 8: [1, 159] },\n            o($Vr, [2, 10]),\n            o($Vs, [2, 25]),\n            o($Vs, [2, 49]),\n            { 35: [1, 160] },\n            o($Vx, [2, 29], { 39: $Vy }),\n            o($Vs, [2, 59]),\n            { 66: [1, 161] },\n            o(\n                [\n                    8, 10, 16, 32, 34, 35, 37, 39, 41, 42, 43, 45, 46, 47, 48, 50, 51, 53, 54,\n                    55, 57, 64, 65, 66, 83\n                ],\n                [2, 88],\n                { 86: [1, 162] }\n            ),\n            o($Vs, [2, 94]),\n            o($Vs, [2, 96]),\n            o($Vs, [2, 97]),\n            o($VV, [2, 92]),\n            { 10: [1, 163], 86: $VT },\n            { 66: [1, 164] },\n            o($Vs, [2, 91]),\n            o($Vz, [2, 31], { 41: $VA, 42: $VB, 43: $VC }),\n            o($VD, [2, 33], { 45: $VE, 46: $VF, 47: $VG, 48: $VH }),\n            o($VD, [2, 34], { 45: $VE, 46: $VF, 47: $VG, 48: $VH }),\n            o($VD, [2, 35], { 45: $VE, 46: $VF, 47: $VG, 48: $VH }),\n            o($Vs, [2, 65]),\n            { 25: 165, 26: $Vb },\n            { 10: [1, 166], 86: $VW },\n            o($VX, [2, 104]),\n            { 94: [1, 168] },\n            { 10: [1, 169], 86: $VW },\n            o($VJ, [2, 37], { 50: $VK, 51: $VL }),\n            o($VJ, [2, 38], { 50: $VK, 51: $VL }),\n            o($VJ, [2, 39], { 50: $VK, 51: $VL }),\n            o($VJ, [2, 40], { 50: $VK, 51: $VL }),\n            o($Vs, [2, 80]),\n            {\n                20: $VI,\n                72: 98,\n                73: 99,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                85: 170,\n                87: 96\n            },\n            {\n                8: $V2,\n                20: $V8,\n                29: 171,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($Vs, [2, 78]),\n            {\n                8: $V2,\n                20: $V8,\n                29: 172,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($VM, [2, 42], { 53: $VN, 54: $VO, 55: $VP }),\n            o($VM, [2, 43], { 53: $VN, 54: $VO, 55: $VP }),\n            o($Vs, [2, 45]),\n            o($Vs, [2, 46]),\n            o($Vs, [2, 47]),\n            {\n                6: 6,\n                7: $V1,\n                8: $V2,\n                9: 20,\n                11: 173,\n                13: 7,\n                14: $V3,\n                15: $V4,\n                16: $V5,\n                17: $V6,\n                18: 8,\n                19: $V7,\n                20: $V8,\n                21: $V9,\n                22: 9,\n                23: $Va,\n                24: 11,\n                25: 5,\n                26: $Vb,\n                28: 10,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                6: 6,\n                7: $V1,\n                8: $V2,\n                9: 20,\n                11: 174,\n                13: 7,\n                14: $V3,\n                15: $V4,\n                16: $V5,\n                17: $V6,\n                18: 8,\n                19: $V7,\n                20: $V8,\n                21: $V9,\n                22: 9,\n                23: $Va,\n                24: 11,\n                25: 5,\n                26: $Vb,\n                28: 10,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                9: 175,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                9: 176,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                20: $V8,\n                29: 177,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($Vs, [2, 60]),\n            { 20: $VQ, 68: 127, 82: $Vn, 90: 178 },\n            o($VV, [2, 93]),\n            o($Vs, [2, 90]),\n            o($Vs, [2, 100]),\n            { 25: 179, 26: $Vb },\n            { 20: [1, 180] },\n            {\n                8: $V2,\n                9: 181,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 94: [1, 182] },\n            o($VS, [2, 82]),\n            o($VS, [2, 83]),\n            o($VU, [2, 99]),\n            o($Vq, [2, 2], { 12: [1, 183] }),\n            o($Vr, [2, 4]),\n            { 16: [1, 184] },\n            { 10: [1, 185] },\n            o($Vs, [2, 27]),\n            o($Vs, [2, 95]),\n            o($Vs, [2, 101]),\n            o($VX, [2, 105]),\n            o($Vs, [2, 102]),\n            {\n                8: $V2,\n                9: 186,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                6: 6,\n                7: $V1,\n                8: $V2,\n                9: 20,\n                11: 187,\n                13: 7,\n                14: $V3,\n                15: $V4,\n                16: $V5,\n                17: $V6,\n                18: 8,\n                19: $V7,\n                20: $V8,\n                21: $V9,\n                22: 9,\n                23: $Va,\n                24: 11,\n                25: 5,\n                26: $Vb,\n                28: 10,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            {\n                8: $V2,\n                9: 188,\n                20: $V8,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            { 16: [1, 189] },\n            o($Vs, [2, 103]),\n            o($Vr, [2, 3]),\n            { 10: [1, 190] },\n            o($Vr, [2, 6]),\n            {\n                6: 6,\n                7: $V1,\n                8: $V2,\n                9: 20,\n                11: 191,\n                13: 7,\n                14: $V3,\n                15: $V4,\n                16: $V5,\n                17: $V6,\n                18: 8,\n                19: $V7,\n                20: $V8,\n                21: $V9,\n                22: 9,\n                23: $Va,\n                24: 11,\n                25: 5,\n                26: $Vb,\n                28: 10,\n                29: 22,\n                30: 23,\n                31: 24,\n                33: 25,\n                36: 28,\n                38: 32,\n                40: 40,\n                44: 47,\n                49: 55,\n                50: $Vc,\n                51: $Vd,\n                52: 56,\n                56: 57,\n                58: $Ve,\n                59: 26,\n                60: 27,\n                61: 29,\n                62: 30,\n                63: 31,\n                65: $Vf,\n                67: 34,\n                68: 35,\n                69: 36,\n                70: 41,\n                71: 42,\n                72: 43,\n                73: 44,\n                74: $Vg,\n                75: $Vh,\n                76: $Vi,\n                77: $Vj,\n                78: $Vk,\n                79: $Vl,\n                80: $Vm,\n                82: $Vn,\n                91: $Vo,\n                93: $Vp\n            },\n            o($Vr, [2, 5])\n        ],\n        defaultActions: { 3: [2, 1], 97: [2, 84], 98: [2, 85], 99: [2, 86] },\n        parseError: function parseError(str, hash) {\n            if (hash.recoverable) {\n                this.trace(str);\n            } else {\n                var error = new Error(str);\n                error.hash = hash;\n                throw error;\n            }\n        },\n        parse: function parse(input) {\n            var self = this,\n                stack = [0],\n                tstack = [],\n                vstack = [null],\n                lstack = [],\n                table = this.table,\n                yytext = \"\",\n                yylineno = 0,\n                yyleng = 0,\n                recovering = 0,\n                TERROR = 2,\n                EOF = 1;\n            var args = lstack.slice.call(arguments, 1);\n            var lexer = Object.create(this.lexer);\n            var sharedState = { yy: {} };\n            for (var k in this.yy) {\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n                    sharedState.yy[k] = this.yy[k];\n                }\n            }\n            lexer.setInput(input, sharedState.yy);\n            sharedState.yy.lexer = lexer;\n            sharedState.yy.parser = this;\n            if (typeof lexer.yylloc == \"undefined\") {\n                lexer.yylloc = {};\n            }\n            var yyloc = lexer.yylloc;\n            lstack.push(yyloc);\n            var ranges = lexer.options && lexer.options.ranges;\n            if (typeof sharedState.yy.parseError === \"function\") {\n                this.parseError = sharedState.yy.parseError;\n            } else {\n                this.parseError = Object.getPrototypeOf(this).parseError;\n            }\n            function popStack(n) {\n                stack.length = stack.length - 2 * n;\n                vstack.length = vstack.length - n;\n                lstack.length = lstack.length - n;\n            }\n            _token_stack: var lex = function () {\n                var token;\n                token = lexer.lex() || EOF;\n                if (typeof token !== \"number\") {\n                    token = self.symbols_[token] || token;\n                }\n                return token;\n            };\n            var symbol,\n                preErrorSymbol,\n                state,\n                action,\n                a,\n                r,\n                yyval = {},\n                p,\n                len,\n                newState,\n                expected;\n            while (true) {\n                state = stack[stack.length - 1];\n                if (this.defaultActions[state]) {\n                    action = this.defaultActions[state];\n                } else {\n                    if (symbol === null || typeof symbol == \"undefined\") {\n                        symbol = lex();\n                    }\n                    action = table[state] && table[state][symbol];\n                }\n                if (typeof action === \"undefined\" || !action.length || !action[0]) {\n                    var errStr = \"\";\n                    expected = [];\n                    for (p in table[state]) {\n                        if (this.terminals_[p] && p > TERROR) {\n                            expected.push(\"'\" + this.terminals_[p] + \"'\");\n                        }\n                    }\n                    if (lexer.showPosition) {\n                        errStr =\n                            \"Parse error on line \" +\n                            (yylineno + 1) +\n                            \":\\n\" +\n                            lexer.showPosition() +\n                            \"\\nExpecting \" +\n                            expected.join(\", \") +\n                            \", got '\" +\n                            (this.terminals_[symbol] || symbol) +\n                            \"'\";\n                    } else {\n                        errStr =\n                            \"Parse error on line \" +\n                            (yylineno + 1) +\n                            \": Unexpected \" +\n                            (symbol == EOF\n                                ? \"end of input\"\n                                : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n                    }\n                    this.parseError(errStr, {\n                        text: lexer.match,\n                        token: this.terminals_[symbol] || symbol,\n                        line: lexer.yylineno,\n                        loc: yyloc,\n                        expected: expected\n                    });\n                }\n                if (action[0] instanceof Array && action.length > 1) {\n                    throw new Error(\n                        \"Parse Error: multiple actions possible at state: \" +\n                            state +\n                            \", token: \" +\n                            symbol\n                    );\n                }\n                switch (action[0]) {\n                    case 1:\n                        stack.push(symbol);\n                        vstack.push(lexer.yytext);\n                        lstack.push(lexer.yylloc);\n                        stack.push(action[1]);\n                        symbol = null;\n                        if (!preErrorSymbol) {\n                            yyleng = lexer.yyleng;\n                            yytext = lexer.yytext;\n                            yylineno = lexer.yylineno;\n                            yyloc = lexer.yylloc;\n                            if (recovering > 0) {\n                                recovering--;\n                            }\n                        } else {\n                            symbol = preErrorSymbol;\n                            preErrorSymbol = null;\n                        }\n                        break;\n                    case 2:\n                        len = this.productions_[action[1]][1];\n                        yyval.$ = vstack[vstack.length - len];\n                        yyval._$ = {\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\n                            last_line: lstack[lstack.length - 1].last_line,\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\n                            last_column: lstack[lstack.length - 1].last_column\n                        };\n                        if (ranges) {\n                            yyval._$.range = [\n                                lstack[lstack.length - (len || 1)].range[0],\n                                lstack[lstack.length - 1].range[1]\n                            ];\n                        }\n                        r = this.performAction.apply(\n                            yyval,\n                            [\n                                yytext,\n                                yyleng,\n                                yylineno,\n                                sharedState.yy,\n                                action[1],\n                                vstack,\n                                lstack\n                            ].concat(args)\n                        );\n                        if (typeof r !== \"undefined\") {\n                            return r;\n                        }\n                        if (len) {\n                            stack = stack.slice(0, -1 * len * 2);\n                            vstack = vstack.slice(0, -1 * len);\n                            lstack = lstack.slice(0, -1 * len);\n                        }\n                        stack.push(this.productions_[action[1]][0]);\n                        vstack.push(yyval.$);\n                        lstack.push(yyval._$);\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n                        stack.push(newState);\n                        break;\n                    case 3:\n                        return true;\n                }\n            }\n            return true;\n        }\n    };\n\n    var AST = {\n        node: function (type, value, children) {\n            return {\n                type: type,\n                value: value,\n                children: children\n            };\n        },\n\n        createNode: function (pos, type, value, children) {\n            var i,\n                n = this.node(type, value, []);\n\n            for (i = 3; i < arguments.length; i++) {\n                n.children.push(arguments[i]);\n            }\n\n            n.line = pos[0];\n            n.col = pos[1];\n            n.eline = pos[2];\n            n.ecol = pos[3];\n\n            return n;\n        }\n    };\n\n    var lc = function (lc1) {\n        return [lc1.first_line, lc1.first_column, lc1.last_line, lc1.last_column];\n    };\n\n    /* generated by jison-lex 0.3.4 */\n    var lexer = (function () {\n        var lexer = {\n            EOF: 1,\n\n            parseError: function parseError(str, hash) {\n                if (this.yy.parser) {\n                    this.yy.parser.parseError(str, hash);\n                } else {\n                    throw new Error(str);\n                }\n            },\n\n            // resets the lexer, sets new input\n            setInput: function (input, yy) {\n                this.yy = yy || this.yy || {};\n                this._input = input;\n                this._more = this._backtrack = this.done = false;\n                this.yylineno = this.yyleng = 0;\n                this.yytext = this.matched = this.match = \"\";\n                this.conditionStack = [\"INITIAL\"];\n                this.yylloc = {\n                    first_line: 1,\n                    first_column: 0,\n                    last_line: 1,\n                    last_column: 0\n                };\n                if (this.options.ranges) {\n                    this.yylloc.range = [0, 0];\n                }\n                this.offset = 0;\n                return this;\n            },\n\n            // consumes and returns one char from the input\n            input: function () {\n                var ch = this._input[0];\n                this.yytext += ch;\n                this.yyleng++;\n                this.offset++;\n                this.match += ch;\n                this.matched += ch;\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n                if (lines) {\n                    this.yylineno++;\n                    this.yylloc.last_line++;\n                } else {\n                    this.yylloc.last_column++;\n                }\n                if (this.options.ranges) {\n                    this.yylloc.range[1]++;\n                }\n\n                this._input = this._input.slice(1);\n                return ch;\n            },\n\n            // unshifts one char (or a string) into the input\n            unput: function (ch) {\n                var len = ch.length;\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n                this._input = ch + this._input;\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\n                //this.yyleng -= len;\n                this.offset -= len;\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n                this.match = this.match.substr(0, this.match.length - 1);\n                this.matched = this.matched.substr(0, this.matched.length - 1);\n\n                if (lines.length - 1) {\n                    this.yylineno -= lines.length - 1;\n                }\n                var r = this.yylloc.range;\n\n                this.yylloc = {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.yylineno + 1,\n                    first_column: this.yylloc.first_column,\n                    last_column: lines\n                        ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) +\n                          oldLines[oldLines.length - lines.length].length -\n                          lines[0].length\n                        : this.yylloc.first_column - len\n                };\n\n                if (this.options.ranges) {\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n                }\n                this.yyleng = this.yytext.length;\n                return this;\n            },\n\n            // When called from action, caches matched text and appends it on next action\n            more: function () {\n                this._more = true;\n                return this;\n            },\n\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n            reject: function () {\n                if (this.options.backtrack_lexer) {\n                    this._backtrack = true;\n                } else {\n                    return this.parseError(\n                        \"Lexical error on line \" +\n                            (this.yylineno + 1) +\n                            \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" +\n                            this.showPosition(),\n                        {\n                            text: \"\",\n                            token: null,\n                            line: this.yylineno\n                        }\n                    );\n                }\n                return this;\n            },\n\n            // retain first n characters of the match\n            less: function (n) {\n                this.unput(this.match.slice(n));\n            },\n\n            // displays already matched input, i.e. for error messages\n            pastInput: function () {\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\n                return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n            },\n\n            // displays upcoming input, i.e. for error messages\n            upcomingInput: function () {\n                var next = this.match;\n                if (next.length < 20) {\n                    next += this._input.substr(0, 20 - next.length);\n                }\n                return (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(\n                    /\\n/g,\n                    \"\"\n                );\n            },\n\n            // displays the character position where the lexing error occurred, i.e. for error messages\n            showPosition: function () {\n                var pre = this.pastInput();\n                var c = new Array(pre.length + 1).join(\"-\");\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n            },\n\n            // test the lexed token: return FALSE when not a match, otherwise return token\n            test_match: function (match, indexed_rule) {\n                var token, lines, backup;\n\n                if (this.options.backtrack_lexer) {\n                    // save context\n                    backup = {\n                        yylineno: this.yylineno,\n                        yylloc: {\n                            first_line: this.yylloc.first_line,\n                            last_line: this.last_line,\n                            first_column: this.yylloc.first_column,\n                            last_column: this.yylloc.last_column\n                        },\n                        yytext: this.yytext,\n                        match: this.match,\n                        matches: this.matches,\n                        matched: this.matched,\n                        yyleng: this.yyleng,\n                        offset: this.offset,\n                        _more: this._more,\n                        _input: this._input,\n                        yy: this.yy,\n                        conditionStack: this.conditionStack.slice(0),\n                        done: this.done\n                    };\n                    if (this.options.ranges) {\n                        backup.yylloc.range = this.yylloc.range.slice(0);\n                    }\n                }\n\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n                if (lines) {\n                    this.yylineno += lines.length;\n                }\n                this.yylloc = {\n                    first_line: this.yylloc.last_line,\n                    last_line: this.yylineno + 1,\n                    first_column: this.yylloc.last_column,\n                    last_column: lines\n                        ? lines[lines.length - 1].length -\n                          lines[lines.length - 1].match(/\\r?\\n?/)[0].length\n                        : this.yylloc.last_column + match[0].length\n                };\n                this.yytext += match[0];\n                this.match += match[0];\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                if (this.options.ranges) {\n                    this.yylloc.range = [this.offset, (this.offset += this.yyleng)];\n                }\n                this._more = false;\n                this._backtrack = false;\n                this._input = this._input.slice(match[0].length);\n                this.matched += match[0];\n                token = this.performAction.call(\n                    this,\n                    this.yy,\n                    this,\n                    indexed_rule,\n                    this.conditionStack[this.conditionStack.length - 1]\n                );\n                if (this.done && this._input) {\n                    this.done = false;\n                }\n                if (token) {\n                    return token;\n                } else if (this._backtrack) {\n                    // recover context\n                    for (var k in backup) {\n                        this[k] = backup[k];\n                    }\n                    return false; // rule action called reject() implying the next rule should be tested instead.\n                }\n                return false;\n            },\n\n            // return next match in input\n            next: function () {\n                if (this.done) {\n                    return this.EOF;\n                }\n                if (!this._input) {\n                    this.done = true;\n                }\n\n                var token, match, tempMatch, index;\n                if (!this._more) {\n                    this.yytext = \"\";\n                    this.match = \"\";\n                }\n                var rules = this._currentRules();\n                for (var i = 0; i < rules.length; i++) {\n                    tempMatch = this._input.match(this.rules[rules[i]]);\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                        match = tempMatch;\n                        index = i;\n                        if (this.options.backtrack_lexer) {\n                            token = this.test_match(tempMatch, rules[i]);\n                            if (token !== false) {\n                                return token;\n                            } else if (this._backtrack) {\n                                match = false;\n                                continue; // rule action called reject() implying a rule MISmatch.\n                            } else {\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                                return false;\n                            }\n                        } else if (!this.options.flex) {\n                            break;\n                        }\n                    }\n                }\n                if (match) {\n                    token = this.test_match(match, rules[index]);\n                    if (token !== false) {\n                        return token;\n                    }\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                    return false;\n                }\n                if (this._input === \"\") {\n                    return this.EOF;\n                } else {\n                    return this.parseError(\n                        \"Lexical error on line \" +\n                            (this.yylineno + 1) +\n                            \". Unrecognized text.\\n\" +\n                            this.showPosition(),\n                        {\n                            text: \"\",\n                            token: null,\n                            line: this.yylineno\n                        }\n                    );\n                }\n            },\n\n            // return next match that has a token\n            lex: function lex() {\n                var r = this.next();\n                if (r) {\n                    return r;\n                } else {\n                    return this.lex();\n                }\n            },\n\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n            begin: function begin(condition) {\n                this.conditionStack.push(condition);\n            },\n\n            // pop the previously active lexer condition state off the condition stack\n            popState: function popState() {\n                var n = this.conditionStack.length - 1;\n                if (n > 0) {\n                    return this.conditionStack.pop();\n                } else {\n                    return this.conditionStack[0];\n                }\n            },\n\n            // produce the lexer rule set which is active for the currently active lexer condition state\n            _currentRules: function _currentRules() {\n                if (\n                    this.conditionStack.length &&\n                    this.conditionStack[this.conditionStack.length - 1]\n                ) {\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]]\n                        .rules;\n                } else {\n                    return this.conditions[\"INITIAL\"].rules;\n                }\n            },\n\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n            topState: function topState(n) {\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\n                if (n >= 0) {\n                    return this.conditionStack[n];\n                } else {\n                    return \"INITIAL\";\n                }\n            },\n\n            // alias for begin(condition)\n            pushState: function pushState(condition) {\n                this.begin(condition);\n            },\n\n            // return the number of states currently on the stack\n            stateStackSize: function stateStackSize() {\n                return this.conditionStack.length;\n            },\n            options: {},\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n                var YYSTATE = YY_START;\n                switch ($avoiding_name_collisions) {\n                    case 0 /* ignore */:\n                        break;\n                    case 1:\n                        return 78;\n                        break;\n                    case 2:\n                        return 78;\n                        break;\n                    case 3:\n                        return 77;\n                        break;\n                    case 4:\n                        return 77;\n                        break;\n                    case 5 /* ignore comment */:\n                        break;\n                    case 6 /* ignore multiline comment */:\n                        break;\n                    case 7:\n                        return 7;\n                        break;\n                    case 8:\n                        return 12;\n                        break;\n                    case 9:\n                        return 14;\n                        break;\n                    case 10:\n                        return 17;\n                        break;\n                    case 11:\n                        return 15;\n                        break;\n                    case 12:\n                        return 91;\n                        break;\n                    case 13:\n                        return 93;\n                        break;\n                    case 14:\n                        return 19;\n                        break;\n                    case 15:\n                        return 23;\n                        break;\n                    case 16:\n                        return 21;\n                        break;\n                    case 17:\n                        return 75;\n                        break;\n                    case 18:\n                        return 76;\n                        break;\n                    case 19:\n                        return 74;\n                        break;\n                    case 20:\n                        return 80;\n                        break;\n                    case 21:\n                        return 94;\n                        break;\n                    case 22:\n                        return 94;\n                        break;\n                    case 23:\n                        return 82;\n                        break;\n                    case 24:\n                        return 83;\n                        break;\n                    case 25:\n                        return 26;\n                        break;\n                    case 26:\n                        return 27;\n                        break;\n                    case 27:\n                        return 16;\n                        break;\n                    case 28:\n                        return \"#\";\n                        break;\n                    case 29:\n                        return 34;\n                        break;\n                    case 30:\n                        return 35;\n                        break;\n                    case 31:\n                        return 79;\n                        break;\n                    case 32:\n                        return 64;\n                        break;\n                    case 33:\n                        return 65;\n                        break;\n                    case 34:\n                        return 66;\n                        break;\n                    case 35:\n                        return 8;\n                        break;\n                    case 36:\n                        return 10;\n                        break;\n                    case 37:\n                        return 58;\n                        break;\n                    case 38:\n                        return 57;\n                        break;\n                    case 39:\n                        return 53;\n                        break;\n                    case 40:\n                        return 54;\n                        break;\n                    case 41:\n                        return 55;\n                        break;\n                    case 42:\n                        return 50;\n                        break;\n                    case 43:\n                        return 51;\n                        break;\n                    case 44:\n                        return 47;\n                        break;\n                    case 45:\n                        return 45;\n                        break;\n                    case 46:\n                        return 48;\n                        break;\n                    case 47:\n                        return 46;\n                        break;\n                    case 48:\n                        return 41;\n                        break;\n                    case 49:\n                        return 43;\n                        break;\n                    case 50:\n                        return 42;\n                        break;\n                    case 51:\n                        return 39;\n                        break;\n                    case 52:\n                        return 37;\n                        break;\n                    case 53:\n                        return 32;\n                        break;\n                    case 54:\n                        return 86;\n                        break;\n                    case 55:\n                        return 5;\n                        break;\n                    case 56:\n                        return 20;\n                        break;\n                    case 57:\n                        return \"INVALID\";\n                        break;\n                }\n            },\n            rules: [\n                /^(?:\\s+)/,\n                /^(?:[0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+\\b)/,\n                /^(?:[0-9]+)/,\n                /^(?:\"(\\\\[\"]|[^\"])*\")/,\n                /^(?:'(\\\\[']|[^'])*')/,\n                /^(?:\\/\\/.*)/,\n                /^(?:\\/\\*(.|\\n|\\r)*?\\*\\/)/,\n                /^(?:if\\b)/,\n                /^(?:else\\b)/,\n                /^(?:while\\b)/,\n                /^(?:do\\b)/,\n                /^(?:for\\b)/,\n                /^(?:function\\b)/,\n                /^(?:map\\b)/,\n                /^(?:use\\b)/,\n                /^(?:return\\b)/,\n                /^(?:delete\\b)/,\n                /^(?:true\\b)/,\n                /^(?:false\\b)/,\n                /^(?:null\\b)/,\n                /^(?:Infinity\\b)/,\n                /^(?:->)/,\n                /^(?:=>)/,\n                /^(?:<<)/,\n                /^(?:>>)/,\n                /^(?:\\{)/,\n                /^(?:\\})/,\n                /^(?:;)/,\n                /^(?:#)/,\n                /^(?:\\?)/,\n                /^(?::)/,\n                /^(?:NaN\\b)/,\n                /^(?:\\.)/,\n                /^(?:\\[)/,\n                /^(?:\\])/,\n                /^(?:\\()/,\n                /^(?:\\))/,\n                /^(?:!)/,\n                /^(?:\\^)/,\n                /^(?:\\*)/,\n                /^(?:\\/)/,\n                /^(?:%)/,\n                /^(?:\\+)/,\n                /^(?:-)/,\n                /^(?:<=)/,\n                /^(?:<)/,\n                /^(?:>=)/,\n                /^(?:>)/,\n                /^(?:==)/,\n                /^(?:~=)/,\n                /^(?:!=)/,\n                /^(?:&&)/,\n                /^(?:\\|\\|)/,\n                /^(?:=)/,\n                /^(?:,)/,\n                /^(?:$)/,\n                /^(?:[A-Za-z_\\$][A-Za-z0-9_]*)/,\n                /^(?:.)/\n            ],\n            conditions: {\n                INITIAL: {\n                    rules: [\n                        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n                        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,\n                        38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n                        56, 57\n                    ],\n                    inclusive: true\n                }\n            }\n        };\n        return lexer;\n    })();\n    parser.lexer = lexer;\n    function Parser() {\n        this.yy = {};\n    }\n    Parser.prototype = parser;\n    parser.Parser = Parser;\n    return new Parser();\n})();\n\nif (\n    typeof windows !== \"undefined\" &&\n    typeof require !== \"undefined\" &&\n    typeof exports !== \"undefined\"\n) {\n    exports.parser = parser;\n    exports.Parser = parser.Parser;\n    exports.parse = function () {\n        return parser.parse.apply(parser, arguments);\n    };\n    exports.main = function commonjsMain(args) {\n        if (!args[1]) {\n            console.log(\"Usage: \" + args[0] + \" FILE\");\n            process.exit(1);\n        }\n        var source = \"\"; // $__fs.readFileSync($__path.normalize(args[1]), \"utf8\");\n        return exports.parser.parse(source);\n    };\n    if (typeof module !== \"undefined\" && require.main === module) {\n        exports.main(process.argv.slice(1));\n    }\n}\n// Work around an issue with browsers that don't support Object.getPrototypeOf()\nparser.yy.parseError = parser.parseError;\n\nexport default JXG.JessieCode;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Andreas Walter,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * Functions for color conversions. This was originally based on a class to parse color values by\n * Stoyan Stefanov <sstoo@gmail.com> (see http://www.phpied.com/rgb-color-parser-in-javascript/)\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"./type\";\nimport Mat from \"../math/math\";\n\n// private constants and helper functions\n\n// simple colors contains string color constants that can be used in various browser\n// in javascript\nvar simpleColors = {\n        aliceblue: \"f0f8ff\",\n        antiquewhite: \"faebd7\",\n        aqua: \"00ffff\",\n        aquamarine: \"7fffd4\",\n        azure: \"f0ffff\",\n        beige: \"f5f5dc\",\n        bisque: \"ffe4c4\",\n        black: \"000000\",\n        blanchedalmond: \"ffebcd\",\n        blue: \"0000ff\",\n        blueviolet: \"8a2be2\",\n        brown: \"a52a2a\",\n        burlywood: \"deb887\",\n        cadetblue: \"5f9ea0\",\n        chartreuse: \"7fff00\",\n        chocolate: \"d2691e\",\n        coral: \"ff7f50\",\n        cornflowerblue: \"6495ed\",\n        cornsilk: \"fff8dc\",\n        crimson: \"dc143c\",\n        cyan: \"00ffff\",\n        darkblue: \"00008b\",\n        darkcyan: \"008b8b\",\n        darkgoldenrod: \"b8860b\",\n        darkgray: \"a9a9a9\",\n        darkgreen: \"006400\",\n        darkkhaki: \"bdb76b\",\n        darkmagenta: \"8b008b\",\n        darkolivegreen: \"556b2f\",\n        darkorange: \"ff8c00\",\n        darkorchid: \"9932cc\",\n        darkred: \"8b0000\",\n        darksalmon: \"e9967a\",\n        darkseagreen: \"8fbc8f\",\n        darkslateblue: \"483d8b\",\n        darkslategray: \"2f4f4f\",\n        darkturquoise: \"00ced1\",\n        darkviolet: \"9400d3\",\n        deeppink: \"ff1493\",\n        deepskyblue: \"00bfff\",\n        dimgray: \"696969\",\n        dodgerblue: \"1e90ff\",\n        feldspar: \"d19275\",\n        firebrick: \"b22222\",\n        floralwhite: \"fffaf0\",\n        forestgreen: \"228b22\",\n        fuchsia: \"ff00ff\",\n        gainsboro: \"dcdcdc\",\n        ghostwhite: \"f8f8ff\",\n        gold: \"ffd700\",\n        goldenrod: \"daa520\",\n        gray: \"808080\",\n        green: \"008000\",\n        greenyellow: \"adff2f\",\n        honeydew: \"f0fff0\",\n        hotpink: \"ff69b4\",\n        indianred: \"cd5c5c\",\n        indigo: \"4b0082\",\n        ivory: \"fffff0\",\n        khaki: \"f0e68c\",\n        lavender: \"e6e6fa\",\n        lavenderblush: \"fff0f5\",\n        lawngreen: \"7cfc00\",\n        lemonchiffon: \"fffacd\",\n        lightblue: \"add8e6\",\n        lightcoral: \"f08080\",\n        lightcyan: \"e0ffff\",\n        lightgoldenrodyellow: \"fafad2\",\n        lightgrey: \"d3d3d3\",\n        lightgreen: \"90ee90\",\n        lightpink: \"ffb6c1\",\n        lightsalmon: \"ffa07a\",\n        lightseagreen: \"20b2aa\",\n        lightskyblue: \"87cefa\",\n        lightslateblue: \"8470ff\",\n        lightslategray: \"778899\",\n        lightsteelblue: \"b0c4de\",\n        lightyellow: \"ffffe0\",\n        lime: \"00ff00\",\n        limegreen: \"32cd32\",\n        linen: \"faf0e6\",\n        magenta: \"ff00ff\",\n        maroon: \"800000\",\n        mediumaquamarine: \"66cdaa\",\n        mediumblue: \"0000cd\",\n        mediumorchid: \"ba55d3\",\n        mediumpurple: \"9370d8\",\n        mediumseagreen: \"3cb371\",\n        mediumslateblue: \"7b68ee\",\n        mediumspringgreen: \"00fa9a\",\n        mediumturquoise: \"48d1cc\",\n        mediumvioletred: \"c71585\",\n        midnightblue: \"191970\",\n        mintcream: \"f5fffa\",\n        mistyrose: \"ffe4e1\",\n        moccasin: \"ffe4b5\",\n        navajowhite: \"ffdead\",\n        navy: \"000080\",\n        oldlace: \"fdf5e6\",\n        olive: \"808000\",\n        olivedrab: \"6b8e23\",\n        orange: \"ffa500\",\n        orangered: \"ff4500\",\n        orchid: \"da70d6\",\n        palegoldenrod: \"eee8aa\",\n        palegreen: \"98fb98\",\n        paleturquoise: \"afeeee\",\n        palevioletred: \"d87093\",\n        papayawhip: \"ffefd5\",\n        peachpuff: \"ffdab9\",\n        peru: \"cd853f\",\n        pink: \"ffc0cb\",\n        plum: \"dda0dd\",\n        powderblue: \"b0e0e6\",\n        purple: \"800080\",\n        red: \"ff0000\",\n        rosybrown: \"bc8f8f\",\n        royalblue: \"4169e1\",\n        saddlebrown: \"8b4513\",\n        salmon: \"fa8072\",\n        sandybrown: \"f4a460\",\n        seagreen: \"2e8b57\",\n        seashell: \"fff5ee\",\n        sienna: \"a0522d\",\n        silver: \"c0c0c0\",\n        skyblue: \"87ceeb\",\n        slateblue: \"6a5acd\",\n        slategray: \"708090\",\n        snow: \"fffafa\",\n        springgreen: \"00ff7f\",\n        steelblue: \"4682b4\",\n        tan: \"d2b48c\",\n        teal: \"008080\",\n        thistle: \"d8bfd8\",\n        tomato: \"ff6347\",\n        turquoise: \"40e0d0\",\n        violet: \"ee82ee\",\n        violetred: \"d02090\",\n        wheat: \"f5deb3\",\n        white: \"ffffff\",\n        whitesmoke: \"f5f5f5\",\n        yellow: \"ffff00\",\n        yellowgreen: \"9acd32\"\n    },\n    // array of color definition objects\n    colorDefs = [\n        {\n            re: /^\\s*rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*([\\d.]{1,3})\\s*\\)\\s*$/,\n            example: [\"rgba(123, 234, 45, 0.5)\", \"rgba(255,234,245,1.0)\"],\n            process: function (bits) {\n                return [parseInt(bits[1], 10), parseInt(bits[2], 10), parseInt(bits[3], 10)];\n            }\n        },\n        {\n            re: /^\\s*rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)\\s*$/,\n            example: [\"rgb(123, 234, 45)\", \"rgb(255,234,245)\"],\n            process: function (bits) {\n                return [parseInt(bits[1], 10), parseInt(bits[2], 10), parseInt(bits[3], 10)];\n            }\n        },\n        {\n            re: /^(\\w{2})(\\w{2})(\\w{2})$/,\n            example: [\"#00ff00\", \"336699\"],\n            process: function (bits) {\n                return [parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16)];\n            }\n        },\n        {\n            re: /^(\\w{1})(\\w{1})(\\w{1})$/,\n            example: [\"#fb0\", \"f0f\"],\n            process: function (bits) {\n                return [\n                    parseInt(bits[1] + bits[1], 16),\n                    parseInt(bits[2] + bits[2], 16),\n                    parseInt(bits[3] + bits[3], 16)\n                ];\n            }\n        }\n    ];\n\n/**\n * Converts a valid HTML/CSS color string into a rgb value array. This is the base\n * function for the following wrapper functions which only adjust the output to\n * different flavors like an object, string or hex values.\n * @param {String,Array,Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black',\n * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or\n * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method\n * expects the parameters ag and ab.\n * @param {Number} ag\n * @param {Number} ab\n * @returns {Array} RGB color values as an array [r, g, b] with values ranging from 0 to 255.\n */\nJXG.rgbParser = function (color, ag, ab) {\n    var color_string,\n        channels,\n        re,\n        processor,\n        bits,\n        i,\n        r,\n        g,\n        b,\n        values = color,\n        testFloat;\n\n    if (!Type.exists(color)) {\n        return [];\n    }\n\n    if (Type.exists(ag) && Type.exists(ab)) {\n        values = [color, ag, ab];\n    }\n\n    color_string = values;\n\n    testFloat = false;\n    if (Type.isArray(color_string)) {\n        for (i = 0; i < 3; i++) {\n            testFloat = testFloat || /\\./.test(values[i].toString());\n        }\n\n        for (i = 0; i < 3; i++) {\n            testFloat = testFloat && values[i] >= 0.0 && values[i] <= 1.0;\n        }\n\n        if (testFloat) {\n            return [\n                Math.ceil(values[0] * 255),\n                Math.ceil(values[1] * 255),\n                Math.ceil(values[2] * 255)\n            ];\n        }\n\n        return values;\n    }\n\n    if (typeof values === \"string\") {\n        color_string = values;\n    }\n\n    // strip any leading #\n    if (color_string.charAt(0) === \"#\") {\n        // remove # if any\n        color_string = color_string.substr(1, 6);\n    }\n\n    color_string = color_string.replace(/ /g, \"\").toLowerCase();\n\n    // before getting into regexps, try simple matches\n    // and overwrite the input\n    color_string = simpleColors[color_string] || color_string;\n\n    // search through the colorDefs definitions to find a match\n    for (i = 0; i < colorDefs.length; i++) {\n        re = colorDefs[i].re;\n        processor = colorDefs[i].process;\n        bits = re.exec(color_string);\n\n        if (bits) {\n            channels = processor(bits);\n            r = channels[0];\n            g = channels[1];\n            b = channels[2];\n        }\n    }\n\n    if (isNaN(r) || isNaN(g) || isNaN(b)) {\n        return [];\n    }\n\n    // validate/cleanup values\n    r = r < 0 || isNaN(r) ? 0 : r > 255 ? 255 : r;\n    g = g < 0 || isNaN(g) ? 0 : g > 255 ? 255 : g;\n    b = b < 0 || isNaN(b) ? 0 : b > 255 ? 255 : b;\n\n    return [r, g, b];\n};\n\n/**\n * Converts a valid HTML/CSS color string into a string of the 'rgb(r, g, b)' format.\n * @param {String,Array,Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black',\n * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or\n * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method\n * expects the parameters ag and ab.\n * @param {Number} ag\n * @param {Number} ab\n * @returns {String} A 'rgb(r, g, b)' formatted string\n */\nJXG.rgb2css = function (color, ag, ab) {\n    var r;\n\n    r = JXG.rgbParser(color, ag, ab);\n\n    return \"rgb(\" + r[0] + \", \" + r[1] + \", \" + r[2] + \")\";\n};\n\n/**\n * Converts a valid HTML/CSS color string into a HTML rgb string.\n * @param {String,Array,Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black',\n * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or\n * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method\n * expects the parameters ag and ab.\n * @param {Number} ag\n * @param {Number} ab\n * @returns {String} A '#rrggbb' formatted string\n */\nJXG.rgb2hex = function (color, ag, ab) {\n    var r, g, b;\n\n    r = JXG.rgbParser(color, ag, ab);\n    g = r[1];\n    b = r[2];\n    r = r[0];\n    r = r.toString(16);\n    g = g.toString(16);\n    b = b.toString(16);\n\n    if (r.length === 1) {\n        r = \"0\" + r;\n    }\n\n    if (g.length === 1) {\n        g = \"0\" + g;\n    }\n\n    if (b.length === 1) {\n        b = \"0\" + b;\n    }\n\n    return \"#\" + r + g + b;\n};\n\n/**\n * Converts a valid HTML/CSS color string from the '#rrggbb' format into the 'rgb(r, g, b)' format.\n * @param {String} hex A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', or 'black'\n * @deprecated Use {@link JXG#rgb2css} instead.\n * @returns {String} A 'rgb(r, g, b)' formatted string\n */\nJXG.hex2rgb = function (hex) {\n    JXG.deprecated(\"JXG.hex2rgb()\", \"JXG.rgb2css()\");\n    return JXG.rgb2css(hex);\n};\n\n/**\n * Converts HSV color to RGB color.\n * Based on C Code in \"Computer Graphics -- Principles and Practice,\"\n * Foley et al, 1996, p. 593.\n * See also http://www.efg2.com/Lab/Graphics/Colors/HSV.htm\n * @param {Number} H value between 0 and 360\n * @param {Number} S value between 0.0 (shade of gray) to 1.0 (pure color)\n * @param {Number} V value between 0.0 (black) to 1.0 (white)\n * @returns {String} RGB color string\n */\nJXG.hsv2rgb = function (H, S, V) {\n    var R, G, B, f, i, hTemp, p, q, t;\n\n    H = ((H % 360.0) + 360.0) % 360;\n\n    if (S === 0) {\n        if (isNaN(H) || H < Mat.eps) {\n            R = V;\n            G = V;\n            B = V;\n        } else {\n            return \"#ffffff\";\n        }\n    } else {\n        if (H >= 360) {\n            hTemp = 0.0;\n        } else {\n            hTemp = H;\n        }\n\n        // h is now IN [0,6)\n        hTemp = hTemp / 60;\n        // largest integer <= h\n        i = Math.floor(hTemp);\n        // fractional part of h\n        f = hTemp - i;\n        p = V * (1.0 - S);\n        q = V * (1.0 - S * f);\n        t = V * (1.0 - S * (1.0 - f));\n\n        switch (i) {\n            case 0:\n                R = V;\n                G = t;\n                B = p;\n                break;\n            case 1:\n                R = q;\n                G = V;\n                B = p;\n                break;\n            case 2:\n                R = p;\n                G = V;\n                B = t;\n                break;\n            case 3:\n                R = p;\n                G = q;\n                B = V;\n                break;\n            case 4:\n                R = t;\n                G = p;\n                B = V;\n                break;\n            case 5:\n                R = V;\n                G = p;\n                B = q;\n                break;\n        }\n    }\n\n    R = Math.round(R * 255).toString(16);\n    R = R.length === 2 ? R : R.length === 1 ? \"0\" + R : \"00\";\n    G = Math.round(G * 255).toString(16);\n    G = G.length === 2 ? G : G.length === 1 ? \"0\" + G : \"00\";\n    B = Math.round(B * 255).toString(16);\n    B = B.length === 2 ? B : B.length === 1 ? \"0\" + B : \"00\";\n\n    return [\"#\", R, G, B].join(\"\");\n};\n\n/**\n * Converts a color from the RGB color space into the HSV space. Input can be any valid HTML/CSS color definition.\n * @param {String,Array,Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black',\n * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or\n * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method\n * expects the parameters ag and ab.\n * @param {Number} ag\n * @param {Number} ab\n * @returns {Array} Contains the h, s, and v value in this order.\n * @see http://zach.in.tu-clausthal.de/teaching/cg1_0708/folien/13_color_3_4up.pdf\n */\nJXG.rgb2hsv = function (color, ag, ab) {\n    var r, g, b, fr, fg, fb, fmax, fmin, h, s, v, max, min;\n\n    r = JXG.rgbParser(color, ag, ab);\n\n    g = r[1];\n    b = r[2];\n    r = r[0];\n    fr = r / 255.0;\n    fg = g / 255.0;\n    fb = b / 255.0;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    fmax = max / 255.0;\n    fmin = min / 255.0;\n\n    v = fmax;\n    s = 0.0;\n\n    if (v > 0) {\n        s = (v - fmin) / v;\n    }\n\n    h = 1.0 / (fmax - fmin);\n\n    if (s > 0) {\n        if (max === r) {\n            h = (fg - fb) * h;\n        } else if (max === g) {\n            h = 2 + (fb - fr) * h;\n        } else {\n            h = 4 + (fr - fg) * h;\n        }\n    }\n\n    h *= 60;\n\n    if (h < 0) {\n        h += 360;\n    }\n\n    if (max === min) {\n        h = 0.0;\n    }\n\n    return [h, s, v];\n};\n\n/**\n * Converts a color from the RGB color space into the LMS space. Input can be any valid HTML/CSS color definition.\n * @param {String,Array,Number} color A valid HTML or CSS styled color value, e.g. '#12ab21', '#abc', 'black',\n * or 'rgb(12, 132, 233)'. This can also be an array containing three color values either from 0.0 to 1.0 or\n * from 0 to 255. They will be interpreted as red, green, and blue values. In case this is a number this method\n * expects the parameters ag and ab.\n * @param {Number} ag\n * @param {Number} ab\n * @returns {Array} Contains the l, m, and s value in this order.\n */\nJXG.rgb2LMS = function (color, ag, ab) {\n    var r,\n        g,\n        b,\n        l,\n        m,\n        s,\n        ret,\n        // constants\n        matrix = [\n            [0.05059983, 0.08585369, 0.0095242],\n            [0.01893033, 0.08925308, 0.01370054],\n            [0.00292202, 0.00975732, 0.07145979]\n        ];\n\n    r = JXG.rgbParser(color, ag, ab);\n    g = r[1];\n    b = r[2];\n    r = r[0];\n\n    // de-gamma\n    // Maybe this can be made faster by using a cache\n    r = Math.pow(r, 0.476190476);\n    g = Math.pow(g, 0.476190476);\n    b = Math.pow(b, 0.476190476);\n\n    l = r * matrix[0][0] + g * matrix[0][1] + b * matrix[0][2];\n    m = r * matrix[1][0] + g * matrix[1][1] + b * matrix[1][2];\n    s = r * matrix[2][0] + g * matrix[2][1] + b * matrix[2][2];\n\n    ret = [l, m, s];\n    ret.l = l;\n    ret.m = m;\n    ret.s = s;\n\n    return ret;\n};\n\n/**\n * Convert color information from LMS to RGB color space.\n * @param {Number} l\n * @param {Number} m\n * @param {Number} s\n * @returns {Array} Contains the r, g, and b value in this order.\n */\nJXG.LMS2rgb = function (l, m, s) {\n    var r,\n        g,\n        b,\n        ret,\n        // constants\n        matrix = [\n            [30.830854, -29.832659, 1.610474],\n            [-6.481468, 17.715578, -2.532642],\n            [-0.37569, -1.199062, 14.273846]\n        ],\n        // re-gamma, inspired by GIMP modules/display-filter-color-blind.c:\n        // Copyright (C) 2002-2003 Michael Natterer <mitch@gimp.org>,\n        //                         Sven Neumann <sven@gimp.org>,\n        //                         Robert Dougherty <bob@vischeck.com> and\n        //                         Alex Wade <alex@vischeck.com>\n        // This code is an implementation of an algorithm described by Hans Brettel,\n        // Francoise Vienot and John Mollon in the Journal of the Optical Society of\n        // America V14(10), pg 2647. (See http://vischeck.com/ for more info.)\n        lut_lookup = function (value) {\n            var offset = 127,\n                step = 64;\n\n            while (step > 0) {\n                if (Math.pow(offset, 0.476190476) > value) {\n                    offset -= step;\n                } else {\n                    if (Math.pow(offset + 1, 0.476190476) > value) {\n                        return offset;\n                    }\n\n                    offset += step;\n                }\n\n                step /= 2;\n            }\n\n            /*  the algorithm above can't reach 255  */\n            if (offset === 254 && 13.994955247 < value) {\n                return 255;\n            }\n\n            return offset;\n        };\n\n    // transform back to rgb\n    r = l * matrix[0][0] + m * matrix[0][1] + s * matrix[0][2];\n    g = l * matrix[1][0] + m * matrix[1][1] + s * matrix[1][2];\n    b = l * matrix[2][0] + m * matrix[2][1] + s * matrix[2][2];\n\n    r = lut_lookup(r);\n    g = lut_lookup(g);\n    b = lut_lookup(b);\n\n    ret = [r, g, b];\n    ret.r = r;\n    ret.g = g;\n    ret.b = b;\n\n    return ret;\n};\n\n/**\n * Splits a RGBA color value like #112233AA into it's RGB and opacity parts.\n * @param {String} rgba A RGBA color value\n * @returns {Array} An array containing the rgb color value in the first and the opacity in the second field.\n */\nJXG.rgba2rgbo = function (rgba) {\n    var opacity;\n\n    if (rgba.length === 9 && rgba.charAt(0) === \"#\") {\n        opacity = parseInt(rgba.substr(7, 2).toUpperCase(), 16) / 255;\n        rgba = rgba.substr(0, 7);\n    } else {\n        opacity = 1;\n    }\n\n    return [rgba, opacity];\n};\n\n/**\n * Generates a RGBA color value like #112233AA from it's RGB and opacity parts.\n * @param {String} rgb A RGB color value.\n * @param {Number} o The desired opacity >=0, <=1.\n * @returns {String} The RGBA color value.\n */\nJXG.rgbo2rgba = function (rgb, o) {\n    var rgba;\n\n    if (rgb === \"none\") {\n        return rgb;\n    }\n\n    rgba = Math.round(o * 255).toString(16);\n    if (rgba.length === 1) {\n        rgba = \"0\" + rgba;\n    }\n\n    return rgb + rgba;\n};\n\n/**\n * Decolorizes the given color.\n * @param {String} color HTML string containing the HTML color code.\n * @returns {String} Returns a HTML color string\n */\nJXG.rgb2bw = function (color) {\n    var x,\n        tmp,\n        arr,\n        HexChars = \"0123456789ABCDEF\";\n\n    if (color === \"none\") {\n        return color;\n    }\n\n    arr = JXG.rgbParser(color);\n    x = Math.floor(0.3 * arr[0] + 0.59 * arr[1] + 0.11 * arr[2]);\n\n    // rgbParser and Math.floor ensure that x is 0 <= x <= 255.\n    // Bitwise operators can be used.\n    /*jslint bitwise: true*/\n    tmp = HexChars.charAt((x >> 4) & 0xf) + HexChars.charAt(x & 0xf);\n\n    color = \"#\" + tmp + tmp + tmp;\n\n    return color;\n};\n\n/**\n * Converts a color into how a colorblind human approximately would see it.\n * @param {String} color HTML string containing the HTML color code.\n * @param {String} deficiency The type of color blindness. Possible\n * options are <i>protanopia</i>, <i>deuteranopia</i>, and <i>tritanopia</i>.\n * @returns {String} Returns a HTML color string\n */\nJXG.rgb2cb = function (color, deficiency) {\n    var rgb,\n        l,\n        m,\n        s,\n        lms,\n        tmp,\n        a1,\n        b1,\n        c1,\n        a2,\n        b2,\n        c2,\n        inflection,\n        HexChars = \"0123456789ABCDEF\";\n\n    if (color === \"none\") {\n        return color;\n    }\n\n    lms = JXG.rgb2LMS(color);\n    l = lms[0];\n    m = lms[1];\n    s = lms[2];\n\n    deficiency = deficiency.toLowerCase();\n\n    switch (deficiency) {\n        case \"protanopia\":\n            a1 = -0.06150039994295001;\n            b1 = 0.08277001656812001;\n            c1 = -0.013200141220000003;\n            a2 = 0.05858939668799999;\n            b2 = -0.07934519995360001;\n            c2 = 0.013289415272000003;\n            inflection = 0.6903216543277437;\n\n            tmp = s / m;\n\n            if (tmp < inflection) {\n                l = -(b1 * m + c1 * s) / a1;\n            } else {\n                l = -(b2 * m + c2 * s) / a2;\n            }\n            break;\n        case \"tritanopia\":\n            a1 = -0.00058973116217;\n            b1 = 0.007690316482;\n            c1 = -0.01011703519052;\n            a2 = 0.025495080838999994;\n            b2 = -0.0422740347;\n            c2 = 0.017005316784;\n            inflection = 0.8349489908460004;\n\n            tmp = m / l;\n\n            if (tmp < inflection) {\n                s = -(a1 * l + b1 * m) / c1;\n            } else {\n                s = -(a2 * l + b2 * m) / c2;\n            }\n            break;\n        default:\n            a1 = -0.06150039994295001;\n            b1 = 0.08277001656812001;\n            c1 = -0.013200141220000003;\n            a2 = 0.05858939668799999;\n            b2 = -0.07934519995360001;\n            c2 = 0.013289415272000003;\n            inflection = 0.5763833686400911;\n\n            tmp = s / l;\n\n            if (tmp < inflection) {\n                m = -(a1 * l + c1 * s) / b1;\n            } else {\n                m = -(a2 * l + c2 * s) / b2;\n            }\n            break;\n    }\n\n    rgb = JXG.LMS2rgb(l, m, s);\n\n    // LMS2rgb returns an array of values ranging from 0 to 255 (both included)\n    // bitwise operators are safe to use.\n    /*jslint bitwise: true*/\n    tmp = HexChars.charAt((rgb[0] >> 4) & 0xf) + HexChars.charAt(rgb[0] & 0xf);\n    color = \"#\" + tmp;\n    tmp = HexChars.charAt((rgb[1] >> 4) & 0xf) + HexChars.charAt(rgb[1] & 0xf);\n    color += tmp;\n    tmp = HexChars.charAt((rgb[2] >> 4) & 0xf) + HexChars.charAt(rgb[2] & 0xf);\n    color += tmp;\n\n    return color;\n};\n\n/**\n * Determines highlight color to a given color. Done by reducing (or increasing) the opacity.\n * @param {String} color HTML RGBA string containing the HTML color code.\n * @returns {String} Returns a HTML RGBA color string\n */\nJXG.autoHighlight = function (colstr) {\n    var col = JXG.rgba2rgbo(colstr),\n        c = col[0],\n        opa = col[1];\n\n    if (colstr.charAt(0) === \"#\") {\n        if (opa < 0.3) {\n            opa *= 1.8;\n        } else {\n            opa *= 0.4;\n        }\n\n        return JXG.rgbo2rgba(c, opa);\n    }\n\n    return colstr;\n};\n\n/**\n * Calculate whether a light or a dark color is needed as a contrast.\n * Especially useful to determine whether white or black font goes\n * better with a given background color.\n * @param {String} hexColor HEX value of color.\n * @param {String} [darkColor=\"#000000\"] HEX string for a dark color.\n * @param {String} [lightColor=\"#ffffff\"] HEX string for a light color.\n * @param {Number} [threshold=8]\n * @returns {String} Returns darkColor or lightColor.\n */\nJXG.contrast = function (hexColor, darkColor, lightColor, threshold) {\n    var rgb,\n        black = \"#000000\",\n        rgbBlack,\n        l1,\n        l2,\n        contrastRatio;\n\n    darkColor = darkColor || \"#000000\";\n    lightColor = lightColor || \"#ffffff\";\n    threshold = threshold || 7;\n\n    // hexColor RGB\n    rgb = JXG.rgbParser(hexColor);\n\n    // Black RGB\n    rgbBlack = JXG.rgbParser(black);\n\n    // Calc contrast ratio\n    l1 =\n        0.2126 * Math.pow(rgb[0] / 255, 2.2) +\n        0.7152 * Math.pow(rgb[1] / 255, 2.2) +\n        0.0722 * Math.pow(rgb[2] / 255, 2.2);\n\n    l2 =\n        0.2126 * Math.pow(rgbBlack[0] / 255, 2.2) +\n        0.7152 * Math.pow(rgbBlack[1] / 255, 2.2) +\n        0.0722 * Math.pow(rgbBlack[2] / 255, 2.2);\n\n    if (l1 > l2) {\n        contrastRatio = Math.floor((l1 + 0.05) / (l2 + 0.05));\n    } else {\n        contrastRatio = Math.floor((l2 + 0.05) / (l1 + 0.05));\n    }\n    contrastRatio = contrastRatio - 1;\n\n    // If contrast is more than threshold, return darkColor\n    if (contrastRatio > threshold) {\n        return darkColor;\n    }\n    // if not, return lightColor.\n    return lightColor;\n};\n\n/**\n * Use the color scheme of JSXGraph up to version 1.3.2.\n * This method has to be called before JXG.JSXGraph.initBoard();\n *\n * @see JXG.palette\n * @see JXG.paletteWong\n *\n * @example\n *\n * JXG.setClassicColors();\n * var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox: [-5, 5, 5,-5]});\n *\n */\nJXG.setClassicColors = function () {\n    JXG.Options.elements.strokeColor = \"blue\";\n    JXG.Options.elements.fillColor = \"red\";\n    JXG.Options.hatch.strokeColor = \"blue\";\n    JXG.Options.angle.fillColor = \"#ff7f00\";\n    JXG.Options.angle.highlightFillColor = \"#ff7f00\";\n    JXG.Options.angle.strokeColor = \"#ff7f00\";\n    JXG.Options.angle.label.strokeColor = \"blue\";\n    JXG.Options.arc.strokeColor = \"blue\";\n    JXG.Options.circle.center.fillColor = \"red\";\n    JXG.Options.circle.center.strokeColor = \"blue\";\n    JXG.Options.circumcircle.strokeColor = \"blue\";\n    JXG.Options.circumcircle.center.fillColor = \"red\";\n    JXG.Options.circumcircle.center.strokeColor = \"blue\";\n    JXG.Options.circumcirclearc.strokeColor = \"blue\";\n    JXG.Options.circumcirclesector.strokeColor = \"blue\";\n    JXG.Options.circumcirclesector.fillColor = \"green\";\n    JXG.Options.circumcirclesector.highlightFillColor = \"green\";\n    JXG.Options.conic.strokeColor = \"blue\";\n    JXG.Options.curve.strokeColor = \"blue\";\n    JXG.Options.incircle.strokeColor = \"blue\";\n    JXG.Options.incircle.center.fillColor = \"red\";\n    JXG.Options.incircle.center.strokeColor = \"blue\";\n    JXG.Options.inequality.fillColor = \"red\";\n    JXG.Options.integral.fillColor = \"red\";\n    JXG.Options.integral.curveLeft.color = \"red\";\n    JXG.Options.integral.curveRight.color = \"red\";\n    JXG.Options.line.strokeColor = \"blue\";\n    JXG.Options.point.fillColor = \"red\";\n    JXG.Options.point.strokeColor = \"red\";\n    JXG.Options.polygon.fillColor = \"green\";\n    JXG.Options.polygon.highlightFillColor = \"green\";\n    JXG.Options.polygon.vertices.strokeColor = \"red\";\n    JXG.Options.polygon.vertices.fillColor = \"red\";\n    JXG.Options.regularpolygon.fillColor = \"green\";\n    JXG.Options.regularpolygon.highlightFillColor = \"green\";\n    JXG.Options.regularpolygon.vertices.strokeColor = \"red\";\n    JXG.Options.regularpolygon.vertices.fillColor = \"red\";\n    JXG.Options.riemannsum.fillColor = \"yellow\";\n    JXG.Options.sector.fillColor = \"green\";\n    JXG.Options.sector.highlightFillColor = \"green\";\n    JXG.Options.semicircle.center.fillColor = \"red\";\n    JXG.Options.semicircle.center.strokeColor = \"blue\";\n    JXG.Options.slopetriangle.fillColor = \"red\";\n    JXG.Options.slopetriangle.highlightFillColor = \"red\";\n    JXG.Options.turtle.arrow.strokeColor = \"blue\";\n};\n\nJXG.extend(\n    JXG,\n    /** @lends JXG */ {\n        /**\n         * Bang Wong color palette,\n         * optimized for various type\n         * of color blindness.\n         * It contains values for\n         * <ul>\n         * <li> 'black'\n         * <li> 'orange'\n         * <li> 'skyblue'\n         * <li> 'bluishgreen'\n         * <li> 'yellow'\n         * <li> 'darkblue'\n         * <li> 'vermillion'\n         * <li> 'reddishpurple'\n         * </ul>\n         *\n         * As substitutes for standard colors, it contains the following aliases:\n         *\n         * <ul>\n         * <li> black (= #000000)\n         * <li> blue (= darkblue)\n         * <li> green (= bluishgreen)\n         * <li> purple (= reddishpurple)\n         * <li> red (= vermillion)\n         * <li> white (= #ffffff)\n         * </ul>\n         *\n         * See <a href=\"https://www.nature.com/articles/nmeth.1618\">Bang Wong: \"Points of view: Color blindness\"</a>\n         * and\n         * <a href=\"https://davidmathlogic.com/colorblind/\">https://davidmathlogic.com/colorblind/</a>.\n         *\n         * @name JXG.paletteWong\n         * @type Object\n         * @see JXG.palette\n         * @example\n         * var p = board.create('line', [[-1, 1], [2, -3]], {strokeColor: JXG.paletteWong.yellow});\n         */\n        paletteWong: {\n            black: \"#000000\",\n            orange: \"#E69F00\",\n            skyblue: \"#56B4E9\",\n            bluishgreen: \"#009E73\",\n            yellow: \"#F0E442\",\n            darkblue: \"#0072B2\",\n            vermillion: \"#D55E00\",\n            reddishpurple: \"#CC79A7\",\n\n            blue: \"#0072B2\",\n            red: \"#D55E00\", // vermillion\n            green: \"#009E73\", // bluishgreen\n            purple: \"#CC79A7\", // reddishpurple\n            white: \"#ffffff\"\n        }\n    }\n);\n\n/**\n * Default color palette.\n * Contains at least color values for\n * <ul>\n * <li> black\n * <li> blue\n * <li> green\n * <li> purple\n * <li> red\n * <li> white\n * <li> yellow\n * </ul>\n *\n * @name JXG.palette\n * @type Object\n * @default JXG.paletteWong\n * @see JXG.paletteWong\n *\n * @example\n *\n * var p = board.create('line', [[-1, 1], [2, -3]], {strokeColor: JXG.palette.yellow});\n *\n */\nJXG.palette = JXG.paletteWong;\n\nexport default JXG;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Andreas Walter,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true, document: true, navigator: true, module: true, global: true, self: true, require: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview The functions in this file help with the detection of the environment JSXGraph runs in. We can distinguish\n * between node.js, windows 8 app and browser, what rendering techniques are supported and (most of the time) if the device\n * the browser runs on is a tablet/cell or a desktop computer.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"./type\";\n\nJXG.extendConstants(\n    JXG,\n    /** @lends JXG */ {\n        /**\n         * Determines the property that stores the relevant information in the event object.\n         * @type String\n         * @default 'touches'\n         * @private\n         */\n        touchProperty: \"touches\"\n    }\n);\n\nJXG.extend(\n    JXG,\n    /** @lends JXG */ {\n        /**\n         * Determines whether evt is a touch event.\n         * @param evt {Event}\n         * @returns {Boolean}\n         */\n        isTouchEvent: function (evt) {\n            return JXG.exists(evt[JXG.touchProperty]);\n        },\n\n        /**\n         * Determines whether evt is a pointer event.\n         * @param evt {Event}\n         * @returns {Boolean}\n         */\n        isPointerEvent: function (evt) {\n            return JXG.exists(evt.pointerId);\n        },\n\n        /**\n         * Determines whether evt is neither a touch event nor a pointer event.\n         * @param evt {Event}\n         * @returns {Boolean}\n         */\n        isMouseEvent: function (evt) {\n            return !JXG.isTouchEvent(evt) && !JXG.isPointerEvent(evt);\n        },\n\n        /**\n         * Determines the number of touch points in a touch event.\n         * For other events, -1 is returned.\n         * @param evt {Event}\n         * @returns {Number}\n         */\n        getNumberOfTouchPoints: function (evt) {\n            var n = -1;\n\n            if (JXG.isTouchEvent(evt)) {\n                n = evt[JXG.touchProperty].length;\n            }\n\n            return n;\n        },\n\n        /**\n         * Checks whether an mouse, pointer or touch event evt is the first event of a multitouch event.\n         * Attention: When two or more pointer device types are being used concurrently,\n         *            it is only checked whether the passed event is the first one of its type!\n         * @param evt {Event}\n         * @returns {boolean}\n         */\n        isFirstTouch: function (evt) {\n            var touchPoints = JXG.getNumberOfTouchPoints(evt);\n\n            if (JXG.isPointerEvent(evt)) {\n                return evt.isPrimary;\n            }\n\n            return touchPoints === 1;\n        },\n\n        /**\n         * A document/window environment is available.\n         * @type Boolean\n         * @default false\n         */\n        isBrowser: typeof window === \"object\" && typeof document === \"object\",\n\n        /**\n         * Features of ECMAScript 6+ are available.\n         * @type Boolean\n         * @default false\n         */\n        supportsES6: function () {\n            var testMap;\n            /* jshint ignore:start */\n            try {\n                // This would kill the old uglifyjs: testMap = (a = 0) => a;\n                new Function(\"(a = 0) => a\");\n                return true;\n            } catch (err) {\n                return false;\n            }\n            /* jshint ignore:end */\n        },\n\n        /**\n         * Detect browser support for VML.\n         * @returns {Boolean} True, if the browser supports VML.\n         */\n        supportsVML: function () {\n            // From stackoverflow.com\n            return this.isBrowser && !!document.namespaces;\n        },\n\n        /**\n         * Detect browser support for SVG.\n         * @returns {Boolean} True, if the browser supports SVG.\n         */\n        supportsSVG: function () {\n            return (\n                this.isBrowser &&\n                document.implementation.hasFeature(\n                    \"http://www.w3.org/TR/SVG11/feature#BasicStructure\",\n                    \"1.1\"\n                )\n            );\n        },\n\n        /**\n         * Detect browser support for Canvas.\n         * @returns {Boolean} True, if the browser supports HTML canvas.\n         */\n        supportsCanvas: function () {\n            var c,\n                hasCanvas = false;\n\n            if (this.isNode()) {\n                try {\n                    // c = typeof module === \"object\" ? module.require(\"canvas\") : $__canvas;\n                    c = typeof module === \"object\" ? module.require(\"canvas\") : import('canvas');\n                    hasCanvas = !!c;\n                } catch (err) {}\n            }\n\n            return (\n                hasCanvas || (this.isBrowser && !!document.createElement(\"canvas\").getContext)\n            );\n        },\n\n        /**\n         * True, if run inside a node.js environment.\n         * @returns {Boolean}\n         */\n        isNode: function () {\n            // This is not a 100% sure but should be valid in most cases\n            // We are not inside a browser\n            /* eslint-disable no-undef */\n            return (\n                !this.isBrowser &&\n                (typeof process !== 'undefined') &&\n                (process.release.name.search(/node|io.js/) !== -1)\n            /* eslint-enable no-undef */\n\n                // there is a module object (plain node, no requirejs)\n                // ((typeof module === \"object\" && !!module.exports) ||\n                //     // there is a global object and requirejs is loaded\n                //     (typeof global === \"object\" &&\n                //         global.requirejsVars &&\n                //         !global.requirejsVars.isBrowser)\n                // )\n            );\n        },\n\n        /**\n         * True if run inside a webworker environment.\n         * @returns {Boolean}\n         */\n        isWebWorker: function () {\n            return (\n                !this.isBrowser &&\n                typeof self === \"object\" &&\n                typeof self.postMessage === \"function\"\n            );\n        },\n\n        /**\n         * Checks if the environments supports the W3C Pointer Events API {@link http://www.w3.org/Submission/pointer-events/}\n         * @returns {Boolean}\n         */\n        supportsPointerEvents: function () {\n            return !!(\n                (\n                    this.isBrowser &&\n                    window.navigator &&\n                    (window.PointerEvent || // Chrome/Edge/IE11+\n                        window.navigator.pointerEnabled || // IE11+\n                        window.navigator.msPointerEnabled)\n                ) // IE10-\n            );\n        },\n\n        /**\n         * Determine if the current browser supports touch events\n         * @returns {Boolean} True, if the browser supports touch events.\n         */\n        isTouchDevice: function () {\n            return this.isBrowser && window.ontouchstart !== undefined;\n        },\n\n        /**\n         * Detects if the user is using an Android powered device.\n         * @returns {Boolean}\n         */\n        isAndroid: function () {\n            return (\n                Type.exists(navigator) &&\n                navigator.userAgent.toLowerCase().indexOf(\"android\") > -1\n            );\n        },\n\n        /**\n         * Detects if the user is using the default Webkit browser on an Android powered device.\n         * @returns {Boolean}\n         */\n        isWebkitAndroid: function () {\n            return this.isAndroid() && navigator.userAgent.indexOf(\" AppleWebKit/\") > -1;\n        },\n\n        /**\n         * Detects if the user is using a Apple iPad / iPhone.\n         * @returns {Boolean}\n         */\n        isApple: function () {\n            return (\n                Type.exists(navigator) &&\n                (navigator.userAgent.indexOf(\"iPad\") > -1 ||\n                    navigator.userAgent.indexOf(\"iPhone\") > -1)\n            );\n        },\n\n        /**\n         * Detects if the user is using Safari on an Apple device.\n         * @returns {Boolean}\n         */\n        isWebkitApple: function () {\n            return (\n                this.isApple() && navigator.userAgent.search(/Mobile\\/[0-9A-Za-z.]*Safari/) > -1\n            );\n        },\n\n        /**\n         * Returns true if the run inside a Windows 8 \"Metro\" App.\n         * @returns {Boolean}\n         */\n        isMetroApp: function () {\n            return (\n                typeof window === \"object\" &&\n                window.clientInformation &&\n                window.clientInformation.appVersion &&\n                window.clientInformation.appVersion.indexOf(\"MSAppHost\") > -1\n            );\n        },\n\n        /**\n         * Detects if the user is using a Mozilla browser\n         * @returns {Boolean}\n         */\n        isMozilla: function () {\n            return (\n                Type.exists(navigator) &&\n                navigator.userAgent.toLowerCase().indexOf(\"mozilla\") > -1 &&\n                navigator.userAgent.toLowerCase().indexOf(\"apple\") === -1\n            );\n        },\n\n        /**\n         * Detects if the user is using a firefoxOS powered device.\n         * @returns {Boolean}\n         */\n        isFirefoxOS: function () {\n            return (\n                Type.exists(navigator) &&\n                navigator.userAgent.toLowerCase().indexOf(\"android\") === -1 &&\n                navigator.userAgent.toLowerCase().indexOf(\"apple\") === -1 &&\n                navigator.userAgent.toLowerCase().indexOf(\"mobile\") > -1 &&\n                navigator.userAgent.toLowerCase().indexOf(\"mozilla\") > -1\n            );\n        },\n\n        /**\n         * Internet Explorer version. Works only for IE > 4.\n         * @type Number\n         */\n        ieVersion: (function () {\n            var div,\n                all,\n                v = 3;\n\n            if (typeof document !== \"object\") {\n                return 0;\n            }\n\n            div = document.createElement(\"div\");\n            all = div.getElementsByTagName(\"i\");\n\n            do {\n                div.innerHTML = \"<!--[if gt IE \" + ++v + \"]><\" + \"i><\" + \"/i><![endif]-->\";\n            } while (all[0]);\n\n            return v > 4 ? v : undefined;\n        })(),\n\n        /**\n         * Reads the width and height of an HTML element.\n         * @param {String} elementId The HTML id of an HTML DOM node.\n         * @returns {Object} An object with the two properties width and height.\n         */\n        getDimensions: function (elementId, doc) {\n            var element,\n                display,\n                els,\n                originalVisibility,\n                originalPosition,\n                originalDisplay,\n                originalWidth,\n                originalHeight,\n                style,\n                pixelDimRegExp = /\\d+(\\.\\d*)?px/;\n\n            if (!this.isBrowser || elementId === null) {\n                return {\n                    width: 500,\n                    height: 500\n                };\n            }\n\n            doc = doc || document;\n            // Borrowed from prototype.js\n            element = doc.getElementById(elementId);\n            if (!Type.exists(element)) {\n                throw new Error(\n                    \"\\nJSXGraph: HTML container element '\" + elementId + \"' not found.\"\n                );\n            }\n\n            display = element.style.display;\n\n            // Work around a bug in Safari\n            if (display !== \"none\" && display !== null) {\n                if (element.clientWidth > 0 && element.clientHeight > 0) {\n                    return { width: element.clientWidth, height: element.clientHeight };\n                }\n\n                // a parent might be set to display:none; try reading them from styles\n                style = window.getComputedStyle\n                    ? window.getComputedStyle(element)\n                    : element.style;\n                return {\n                    width: pixelDimRegExp.test(style.width) ? parseFloat(style.width) : 0,\n                    height: pixelDimRegExp.test(style.height) ? parseFloat(style.height) : 0\n                };\n            }\n\n            // All *Width and *Height properties give 0 on elements with display set to none,\n            // hence we show the element temporarily\n            els = element.style;\n\n            // save style\n            originalVisibility = els.visibility;\n            originalPosition = els.position;\n            originalDisplay = els.display;\n\n            // show element\n            els.visibility = \"hidden\";\n            els.position = \"absolute\";\n            els.display = \"block\";\n\n            // read the dimension\n            originalWidth = element.clientWidth;\n            originalHeight = element.clientHeight;\n\n            // restore original css values\n            els.display = originalDisplay;\n            els.position = originalPosition;\n            els.visibility = originalVisibility;\n\n            return {\n                width: originalWidth,\n                height: originalHeight\n            };\n        },\n\n        /**\n         * Adds an event listener to a DOM element.\n         * @param {Object} obj Reference to a DOM node.\n         * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.\n         * @param {Function} fn The function to call when the event is triggered.\n         * @param {Object} owner The scope in which the event trigger is called.\n         * @param {Object|Boolean} [options=false] This parameter is passed as the third parameter to the method addEventListener. Depending on the data type it is either\n         * an options object or the useCapture Boolean.\n         * \n         */\n        addEvent: function (obj, type, fn, owner, options) {\n            var el = function () {\n                return fn.apply(owner, arguments);\n            };\n\n            el.origin = fn;\n            // Check if owner is a board\n            if (typeof owner === 'object' && Type.exists(owner.BOARD_MODE_NONE)) {\n                owner['x_internal' + type] = owner['x_internal' + type] || [];\n                owner['x_internal' + type].push(el);\n            }\n\n            // Non-IE browser\n            if (Type.exists(obj) && Type.exists(obj.addEventListener)) {\n                options = options || false;  // options or useCapture\n                obj.addEventListener(type, el, options);\n            }\n\n            // IE\n            if (Type.exists(obj) && Type.exists(obj.attachEvent)) {\n                obj.attachEvent(\"on\" + type, el);\n            }\n        },\n\n        /**\n         * Removes an event listener from a DOM element.\n         * @param {Object} obj Reference to a DOM node.\n         * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.\n         * @param {Function} fn The function to call when the event is triggered.\n         * @param {Object} owner The scope in which the event trigger is called.\n         */\n        removeEvent: function (obj, type, fn, owner) {\n            var i;\n\n            if (!Type.exists(owner)) {\n                JXG.debug(\"no such owner\");\n                return;\n            }\n\n            if (!Type.exists(owner[\"x_internal\" + type])) {\n                JXG.debug(\"no such type: \" + type);\n                return;\n            }\n\n            if (!Type.isArray(owner[\"x_internal\" + type])) {\n                JXG.debug(\"owner[x_internal + \" + type + \"] is not an array\");\n                return;\n            }\n\n            i = Type.indexOf(owner[\"x_internal\" + type], fn, \"origin\");\n\n            if (i === -1) {\n                JXG.debug(\"removeEvent: no such event function in internal list: \" + fn);\n                return;\n            }\n\n            try {\n                // Non-IE browser\n                if (Type.exists(obj) && Type.exists(obj.removeEventListener)) {\n                    obj.removeEventListener(type, owner[\"x_internal\" + type][i], false);\n                }\n\n                // IE\n                if (Type.exists(obj) && Type.exists(obj.detachEvent)) {\n                    obj.detachEvent(\"on\" + type, owner[\"x_internal\" + type][i]);\n                }\n            } catch (e) {\n                JXG.debug(\"event not registered in browser: (\" + type + \" -- \" + fn + \")\");\n            }\n\n            owner[\"x_internal\" + type].splice(i, 1);\n        },\n\n        /**\n         * Removes all events of the given type from a given DOM node; Use with caution and do not use it on a container div\n         * of a {@link JXG.Board} because this might corrupt the event handling system.\n         * @param {Object} obj Reference to a DOM node.\n         * @param {String} type The event to catch, without leading 'on', e.g. 'mousemove' instead of 'onmousemove'.\n         * @param {Object} owner The scope in which the event trigger is called.\n         */\n        removeAllEvents: function (obj, type, owner) {\n            var i, len;\n            if (owner[\"x_internal\" + type]) {\n                len = owner[\"x_internal\" + type].length;\n\n                for (i = len - 1; i >= 0; i--) {\n                    JXG.removeEvent(obj, type, owner[\"x_internal\" + type][i].origin, owner);\n                }\n\n                if (owner[\"x_internal\" + type].length > 0) {\n                    JXG.debug(\"removeAllEvents: Not all events could be removed.\");\n                }\n            }\n        },\n\n        /**\n         * Cross browser mouse / touch coordinates retrieval relative to the board's top left corner.\n         * @param {Object} [e] The browsers event object. If omitted, <tt>window.event</tt> will be used.\n         * @param {Number} [index] If <tt>e</tt> is a touch event, this provides the index of the touch coordinates, i.e. it determines which finger.\n         * @param {Object} [doc] The document object.\n         * @returns {Array} Contains the position as x,y-coordinates in the first resp. second component.\n         */\n        getPosition: function (e, index, doc) {\n            var i,\n                len,\n                evtTouches,\n                posx = 0,\n                posy = 0;\n\n            if (!e) {\n                e = window.event;\n            }\n\n            doc = doc || document;\n            evtTouches = e[JXG.touchProperty];\n\n            // touchend events have their position in \"changedTouches\"\n            if (Type.exists(evtTouches) && evtTouches.length === 0) {\n                evtTouches = e.changedTouches;\n            }\n\n            if (Type.exists(index) && Type.exists(evtTouches)) {\n                if (index === -1) {\n                    len = evtTouches.length;\n\n                    for (i = 0; i < len; i++) {\n                        if (evtTouches[i]) {\n                            e = evtTouches[i];\n                            break;\n                        }\n                    }\n                } else {\n                    e = evtTouches[index];\n                }\n            }\n\n            // Scrolling is ignored.\n            // e.clientX is supported since IE6\n            if (e.clientX) {\n                posx = e.clientX;\n                posy = e.clientY;\n            }\n\n            return [posx, posy];\n        },\n\n        /**\n         * Calculates recursively the offset of the DOM element in which the board is stored.\n         * @param {Object} obj A DOM element\n         * @returns {Array} An array with the elements left and top offset.\n         */\n        getOffset: function (obj) {\n            var cPos,\n                o = obj,\n                o2 = obj,\n                l = o.offsetLeft - o.scrollLeft,\n                t = o.offsetTop - o.scrollTop;\n\n            cPos = this.getCSSTransform([l, t], o);\n            l = cPos[0];\n            t = cPos[1];\n\n            /*\n             * In Mozilla and Webkit: offsetParent seems to jump at least to the next iframe,\n             * if not to the body. In IE and if we are in an position:absolute environment\n             * offsetParent walks up the DOM hierarchy.\n             * In order to walk up the DOM hierarchy also in Mozilla and Webkit\n             * we need the parentNode steps.\n             */\n            o = o.offsetParent;\n            while (o) {\n                l += o.offsetLeft;\n                t += o.offsetTop;\n\n                if (o.offsetParent) {\n                    l += o.clientLeft - o.scrollLeft;\n                    t += o.clientTop - o.scrollTop;\n                }\n\n                cPos = this.getCSSTransform([l, t], o);\n                l = cPos[0];\n                t = cPos[1];\n\n                o2 = o2.parentNode;\n\n                while (o2 !== o) {\n                    l += o2.clientLeft - o2.scrollLeft;\n                    t += o2.clientTop - o2.scrollTop;\n\n                    cPos = this.getCSSTransform([l, t], o2);\n                    l = cPos[0];\n                    t = cPos[1];\n\n                    o2 = o2.parentNode;\n                }\n                o = o.offsetParent;\n            }\n\n            return [l, t];\n        },\n\n        /**\n         * Access CSS style sheets.\n         * @param {Object} obj A DOM element\n         * @param {String} stylename The CSS property to read.\n         * @returns The value of the CSS property and <tt>undefined</tt> if it is not set.\n         */\n        getStyle: function (obj, stylename) {\n            var r,\n                doc = obj.ownerDocument;\n\n            // Non-IE\n            if (doc.defaultView && doc.defaultView.getComputedStyle) {\n                r = doc.defaultView.getComputedStyle(obj, null).getPropertyValue(stylename);\n                // IE\n            } else if (obj.currentStyle && JXG.ieVersion >= 9) {\n                r = obj.currentStyle[stylename];\n            } else {\n                if (obj.style) {\n                    // make stylename lower camelcase\n                    stylename = stylename.replace(/-([a-z]|[0-9])/gi, function (all, letter) {\n                        return letter.toUpperCase();\n                    });\n                    r = obj.style[stylename];\n                }\n            }\n\n            return r;\n        },\n\n        /**\n         * Reads css style sheets of a given element. This method is a getStyle wrapper and\n         * defaults the read value to <tt>0</tt> if it can't be parsed as an integer value.\n         * @param {DOMElement} el\n         * @param {string} css\n         * @returns {number}\n         */\n        getProp: function (el, css) {\n            var n = parseInt(this.getStyle(el, css), 10);\n            return isNaN(n) ? 0 : n;\n        },\n\n        /**\n         * Correct position of upper left corner in case of\n         * a CSS transformation. Here, only translations are\n         * extracted. All scaling transformations are corrected\n         * in {@link JXG.Board#getMousePosition}.\n         * @param {Array} cPos Previously determined position\n         * @param {Object} obj A DOM element\n         * @returns {Array} The corrected position.\n         */\n        getCSSTransform: function (cPos, obj) {\n            var i,\n                j,\n                str,\n                arrStr,\n                start,\n                len,\n                len2,\n                arr,\n                t = [\n                    \"transform\",\n                    \"webkitTransform\",\n                    \"MozTransform\",\n                    \"msTransform\",\n                    \"oTransform\"\n                ];\n\n            // Take the first transformation matrix\n            len = t.length;\n\n            for (i = 0, str = \"\"; i < len; i++) {\n                if (Type.exists(obj.style[t[i]])) {\n                    str = obj.style[t[i]];\n                    break;\n                }\n            }\n\n            /**\n             * Extract the coordinates and apply the transformation\n             * to cPos\n             */\n            if (str !== \"\") {\n                start = str.indexOf(\"(\");\n\n                if (start > 0) {\n                    len = str.length;\n                    arrStr = str.substring(start + 1, len - 1);\n                    arr = arrStr.split(\",\");\n\n                    for (j = 0, len2 = arr.length; j < len2; j++) {\n                        arr[j] = parseFloat(arr[j]);\n                    }\n\n                    if (str.indexOf(\"matrix\") === 0) {\n                        cPos[0] += arr[4];\n                        cPos[1] += arr[5];\n                    } else if (str.indexOf(\"translateX\") === 0) {\n                        cPos[0] += arr[0];\n                    } else if (str.indexOf(\"translateY\") === 0) {\n                        cPos[1] += arr[0];\n                    } else if (str.indexOf(\"translate\") === 0) {\n                        cPos[0] += arr[0];\n                        cPos[1] += arr[1];\n                    }\n                }\n            }\n\n            // Zoom is used by reveal.js\n            if (Type.exists(obj.style.zoom)) {\n                str = obj.style.zoom;\n                if (str !== \"\") {\n                    cPos[0] *= parseFloat(str);\n                    cPos[1] *= parseFloat(str);\n                }\n            }\n\n            return cPos;\n        },\n\n        /**\n         * Scaling CSS transformations applied to the div element containing the JSXGraph constructions\n         * are determined. In IE prior to 9, 'rotate', 'skew', 'skewX', 'skewY' are not supported.\n         * @returns {Array} 3x3 transformation matrix without translation part. See {@link JXG.Board#updateCSSTransforms}.\n         */\n        getCSSTransformMatrix: function (obj) {\n            var i,\n                j,\n                str,\n                arrstr,\n                start,\n                len,\n                len2,\n                arr,\n                st,\n                doc = obj.ownerDocument,\n                t = [\n                    \"transform\",\n                    \"webkitTransform\",\n                    \"MozTransform\",\n                    \"msTransform\",\n                    \"oTransform\"\n                ],\n                mat = [\n                    [1, 0, 0],\n                    [0, 1, 0],\n                    [0, 0, 1]\n                ];\n\n            // This should work on all browsers except IE 6-8\n            if (doc.defaultView && doc.defaultView.getComputedStyle) {\n                st = doc.defaultView.getComputedStyle(obj, null);\n                str =\n                    st.getPropertyValue(\"-webkit-transform\") ||\n                    st.getPropertyValue(\"-moz-transform\") ||\n                    st.getPropertyValue(\"-ms-transform\") ||\n                    st.getPropertyValue(\"-o-transform\") ||\n                    st.getPropertyValue(\"transform\");\n            } else {\n                // Take the first transformation matrix\n                len = t.length;\n                for (i = 0, str = \"\"; i < len; i++) {\n                    if (Type.exists(obj.style[t[i]])) {\n                        str = obj.style[t[i]];\n                        break;\n                    }\n                }\n            }\n\n            if (str !== \"\") {\n                start = str.indexOf(\"(\");\n\n                if (start > 0) {\n                    len = str.length;\n                    arrstr = str.substring(start + 1, len - 1);\n                    arr = arrstr.split(\",\");\n\n                    for (j = 0, len2 = arr.length; j < len2; j++) {\n                        arr[j] = parseFloat(arr[j]);\n                    }\n\n                    if (str.indexOf(\"matrix\") === 0) {\n                        mat = [\n                            [1, 0, 0],\n                            [0, arr[0], arr[1]],\n                            [0, arr[2], arr[3]]\n                        ];\n                    } else if (str.indexOf(\"scaleX\") === 0) {\n                        mat[1][1] = arr[0];\n                    } else if (str.indexOf(\"scaleY\") === 0) {\n                        mat[2][2] = arr[0];\n                    } else if (str.indexOf(\"scale\") === 0) {\n                        mat[1][1] = arr[0];\n                        mat[2][2] = arr[1];\n                    }\n                }\n            }\n\n            // CSS style zoom is used by reveal.js\n            // Recursively search for zoom style entries.\n            // This is necessary for reveal.js on webkit.\n            // It fails if the user does zooming\n            if (Type.exists(obj.style.zoom)) {\n                str = obj.style.zoom;\n                if (str !== \"\") {\n                    mat[1][1] *= parseFloat(str);\n                    mat[2][2] *= parseFloat(str);\n                }\n            }\n\n            return mat;\n        },\n\n        /**\n         * Process data in timed chunks. Data which takes long to process, either because it is such\n         * a huge amount of data or the processing takes some time, causes warnings in browsers about\n         * irresponsive scripts. To prevent these warnings, the processing is split into smaller pieces\n         * called chunks which will be processed in serial order.\n         * Copyright 2009 Nicholas C. Zakas. All rights reserved. MIT Licensed\n         * @param {Array} items to do\n         * @param {Function} process Function that is applied for every array item\n         * @param {Object} context The scope of function process\n         * @param {Function} callback This function is called after the last array element has been processed.\n         */\n        timedChunk: function (items, process, context, callback) {\n            //create a clone of the original\n            var todo = items.concat(),\n                timerFun = function () {\n                    var start = +new Date();\n\n                    do {\n                        process.call(context, todo.shift());\n                    } while (todo.length > 0 && +new Date() - start < 300);\n\n                    if (todo.length > 0) {\n                        window.setTimeout(timerFun, 1);\n                    } else {\n                        callback(items);\n                    }\n                };\n\n            window.setTimeout(timerFun, 1);\n        },\n\n        /**\n         * Scale and vertically shift a DOM element (usually a JSXGraph div)\n         * inside of a parent DOM\n         * element which is set to fullscreen.\n         * This is realized with a CSS transformation.\n         *\n         * @param  {String} wrap_id  id of the parent DOM element which is in fullscreen mode\n         * @param  {String} inner_id id of the DOM element which is scaled and shifted\n         * @param  {Object} doc      document object or shadow root\n         * @param  {Number} scale    Relative size of the JSXGraph board in the fullscreen window.\n         *\n         * @private\n         * @see JXG.Board#toFullscreen\n         * @see JXG.Board#fullscreenListener\n         *\n         */\n        scaleJSXGraphDiv: function (wrap_id, inner_id, doc, scale) {\n            var len = doc.styleSheets.length, style, rule, w, h, b, wi, hi, bi,\n                scale_l, vshift_l, // scale_p, vshift_p,\n                f = scale,\n                rule_inner_l, // rule_inner_p,\n                pseudo_keys = [\n                    \":fullscreen\",\n                    \":-webkit-full-screen\",\n                    \":-moz-full-screen\",\n                    \":-ms-fullscreen\"\n                ],\n                len_pseudo = pseudo_keys.length,\n                i,\n                // A previously installed CSS rule to center the JSXGraph div has to\n                // be searched and removed again.\n                regex = new RegExp(\n                    \".*#\" +\n                        wrap_id +\n                        \":.*full.*screen.*#\" +\n                        inner_id +\n                        \".*auto;.*transform:.*matrix\"\n                );\n\n            b = doc.getElementById(wrap_id).getBoundingClientRect();\n            h = b.height;\n            w = b.width;\n\n            bi = doc.getElementById(inner_id).getBoundingClientRect();\n            hi = bi.height;\n            wi = bi.width;\n\n            if (wi / hi >= w / h) {\n                scale_l = (f * w) / wi;\n            } else {\n                scale_l = (f * h) / hi;\n            }\n            vshift_l = (h - hi) * 0.5;\n\n            // CSS rules to center the inner div horizontally and vertically.\n            rule_inner_l =\n                \"{margin:0 auto;transform:matrix(\" +\n                scale_l +\n                \",0,0,\" +\n                scale_l +\n                \",0,\" +\n                vshift_l +\n                \");}\";\n\n            if (len === 0) {\n                // In case there is not a single CSS rule defined at all.\n                style = document.createElement(\"style\");\n                // WebKit hack :(\n                style.appendChild(document.createTextNode(\"\"));\n                // Add the <style> element to the page\n                doc.appendChild(style);\n                len = doc.styleSheets.length;\n            }\n\n            // Remove a previously installed CSS rule.\n            if (\n                doc.styleSheets[len - 1].cssRules.length > 0 &&\n                regex.test(doc.styleSheets[len - 1].cssRules[0].cssText) &&\n                doc.styleSheets[len - 1].deleteRule\n            ) {\n                doc.styleSheets[len - 1].deleteRule(0);\n            }\n\n            // Install a CSS rule to center the JSXGraph div at the first position of the list.\n            for (i = 0; i < len_pseudo; i++) {\n                try {\n                    rule = \"#\" + wrap_id + pseudo_keys[i] + \" #\" + inner_id + rule_inner_l;\n                    // rule = '@media all and (orientation:landscape) {' + rule + '}';\n                    doc.styleSheets[len - 1].insertRule(rule, 0);\n\n                    break;\n                } catch (err) {\n                    // console.log('JXG.scaleJSXGraphDiv: Could not add CSS rule \"' + pseudo_keys[i] + '\".');\n                    // console.log('One possible reason could be that the id of the JSXGraph container does not start with a letter.');\n                }\n            }\n            if (i === len_pseudo) {\n                console.log(\"JXG.scaleJSXGraphDiv: Could not add any CSS rule.\");\n                console.log(\n                    \"One possible reason could be that the id of the JSXGraph container does not start with a letter.\"\n                );\n            }\n        }\n    }\n);\n\nexport default JXG;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the EventEmitter interface is defined.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"./type\";\n\n/**\n * Event namespace\n * @namespace\n */\nJXG.EventEmitter = {\n    /**\n     * Holds the registered event handlers.\n     * @type Object\n     */\n    eventHandlers: {},\n\n    /**\n     * Events can be suspended to prevent endless loops.\n     * @type Object\n     */\n    suspended: {},\n\n    /**\n     * Triggers all event handlers of this element for a given event.\n     * @param {Array} event\n     * @param {Array} args The arguments passed onto the event handler\n     * @returns Reference to the object.\n     */\n    trigger: function (event, args) {\n        var i, j, h, evt, len1, len2;\n\n        len1 = event.length;\n        for (j = 0; j < len1; j++) {\n            evt = this.eventHandlers[event[j]];\n            if (!this.suspended[event[j]]) {\n                this.suspended[event[j]] = true;\n                if (evt) {\n                    len2 = evt.length;\n                    for (i = 0; i < len2; i++) {\n                        h = evt[i];\n                        h.handler.apply(h.context, args);\n                    }\n                }\n\n                this.suspended[event[j]] = false;\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Register a new event handler. For a list of possible events see documentation\n     * of the elements and objects implementing\n     * the {@link EventEmitter} interface.\n     * @param {String} event\n     * @param {Function} handler\n     * @param {Object} [context] The context the handler will be called in, default is the element itself.\n     * @returns Reference to the object.\n     */\n    on: function (event, handler, context) {\n        if (!Type.isArray(this.eventHandlers[event])) {\n            this.eventHandlers[event] = [];\n        }\n\n        context = Type.def(context, this);\n\n        this.eventHandlers[event].push({\n            handler: handler,\n            context: context\n        });\n\n        return this;\n    },\n\n    /**\n     * Unregister an event handler.\n     * @param {String} event\n     * @param {Function} [handler]\n     * @returns Reference to the object.\n     */\n    off: function (event, handler) {\n        var i;\n\n        if (!event || !Type.isArray(this.eventHandlers[event])) {\n            return this;\n        }\n\n        if (handler) {\n            i = Type.indexOf(this.eventHandlers[event], handler, \"handler\");\n            if (i > -1) {\n                this.eventHandlers[event].splice(i, 1);\n            }\n\n            if (this.eventHandlers[event].length === 0) {\n                delete this.eventHandlers[event];\n            }\n        } else {\n            delete this.eventHandlers[event];\n        }\n\n        return this;\n    },\n\n    /**\n     * @description Implements the functionality from this interface in the given object.\n     * All objects getting their event handling\n     * capabilities from this method should document it by adding\n     * the <tt>on, off, triggerEventHandlers</tt> via the\n     * borrows tag as methods to their documentation:\n     * <pre>@borrows JXG.EventEmitter#on as this.on</pre>\n     * @param {Object} o\n     */\n    eventify: function (o) {\n        o.eventHandlers = {};\n        o.on = this.on;\n        o.off = this.off;\n        o.triggerEventHandlers = this.trigger;\n        o.trigger = this.trigger;\n        o.suspended = {};\n    }\n};\n\nexport default JXG.EventEmitter;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, html_sanitize: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview expect.js provides utilities for parameter magic by normalizing multi-type parameters.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"./type\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\n\nvar Expect = {\n    /**\n     * Apply an expect method on every element of an array.\n     *\n     * @param {Array} a\n     * @param {function} format\n     * @param {Boolean} [copy=false]\n     *\n     * @returns {Array}\n     */\n    each: function (a, format, copy) {\n        var i,\n            len,\n            r = [];\n\n        if (Type.exists(a.length)) {\n            len = a.length;\n            for (i = 0; i < len; i++) {\n                r.push(format.call(this, a[i], copy));\n            }\n        }\n\n        return r;\n    },\n\n    /**\n     * Normalize points and coord objects into a coord object.\n     *\n     * @param {JXG.Point|JXG.Coords} c\n     * @param {Boolean} [copy=false] Return a copy, not a reference\n     *\n     * @returns {JXG.Coords}\n     */\n    coords: function (c, copy) {\n        var coord = c;\n\n        if (c && c.elementClass === Const.OBJECT_CLASS_POINT) {\n            coord = c.coords;\n        } else if (c.usrCoords && c.scrCoords && c.usr2screen) {\n            coord = c;\n        }\n\n        if (copy) {\n            coord = new Coords(Const.COORDS_BY_USER, coord.usrCoords, coord.board);\n        }\n\n        return coord;\n    },\n\n    /**\n     * Normalize points, coordinate arrays and coord objects into a coordinate array.\n     *\n     * @param {JXG.Point|JXG.Coords|Array} c\n     * @param {Boolean} [copy=false] Return a copy, not a reference\n     *\n     * @returns {Array} Homogeneous coordinates\n     */\n    coordsArray: function (c, copy) {\n        var coord;\n\n        if (!Type.isArray(c)) {\n            coord = this.coords(c).usrCoords;\n        } else {\n            coord = c;\n        }\n\n        if (coord.length < 3) {\n            coord.unshift(1);\n        }\n\n        if (copy) {\n            coord = [coord[0], coord[1], coord[2]];\n        }\n\n        return coord;\n    }\n};\n\nJXG.Expect = Expect;\n\nexport default Expect;\n","/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Andreas Walter,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, html_sanitize: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview type.js contains several functions to help deal with javascript's weak types.\n * This file mainly consists of detector functions which verify if a variable is or is not of\n * a specific type and converter functions that convert variables to another type or normalize\n * the type of a variable.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\n\nJXG.extend(\n    JXG,\n    /** @lends JXG */ {\n        /**\n         * Checks if the given string is an id within the given board.\n         * @param {JXG.Board} board\n         * @param {String} s\n         * @returns {Boolean}\n         */\n        isId: function (board, s) {\n            return typeof s === \"string\" && !!board.objects[s];\n        },\n\n        /**\n         * Checks if the given string is a name within the given board.\n         * @param {JXG.Board} board\n         * @param {String} s\n         * @returns {Boolean}\n         */\n        isName: function (board, s) {\n            return typeof s === \"string\" && !!board.elementsByName[s];\n        },\n\n        /**\n         * Checks if the given string is a group id within the given board.\n         * @param {JXG.Board} board\n         * @param {String} s\n         * @returns {Boolean}\n         */\n        isGroup: function (board, s) {\n            return typeof s === \"string\" && !!board.groups[s];\n        },\n\n        /**\n         * Checks if the value of a given variable is of type string.\n         * @param v A variable of any type.\n         * @returns {Boolean} True, if v is of type string.\n         */\n        isString: function (v) {\n            return typeof v === \"string\";\n        },\n\n        /**\n         * Checks if the value of a given variable is of type number.\n         * @param v A variable of any type.\n         * @returns {Boolean} True, if v is of type number.\n         */\n        isNumber: function (v) {\n            return (\n                typeof v === \"number\" || Object.prototype.toString.call(v) === \"[Object Number]\"\n            );\n        },\n\n        /**\n         * Checks if a given variable references a function.\n         * @param v A variable of any type.\n         * @returns {Boolean} True, if v is a function.\n         */\n        isFunction: function (v) {\n            return typeof v === \"function\";\n        },\n\n        /**\n         * Checks if a given variable references an array.\n         * @param v A variable of any type.\n         * @returns {Boolean} True, if v is of type array.\n         */\n        isArray: function (v) {\n            var r;\n\n            // use the ES5 isArray() method and if that doesn't exist use a fallback.\n            if (Array.isArray) {\n                r = Array.isArray(v);\n            } else {\n                r =\n                    v !== null &&\n                    typeof v === \"object\" &&\n                    typeof v.splice === \"function\" &&\n                    typeof v.join === \"function\";\n            }\n\n            return r;\n        },\n\n        /**\n         * Tests if the input variable is an Object\n         * @param v\n         */\n        isObject: function (v) {\n            return typeof v === \"object\" && !this.isArray(v);\n        },\n\n        /**\n         * Tests if the input variable is a DOM Document or DocumentFragment node\n         * @param v A variable of any type\n         */\n        isDocumentOrFragment: function (v) {\n            return this.isObject(v) && (\n                v.nodeType === 9 || // Node.DOCUMENT_NODE\n                v.nodeType === 11   // Node.DOCUMENT_FRAGMENT_NODE\n            );\n        },\n\n        /**\n         * Checks if a given variable is a reference of a JSXGraph Point element.\n         * @param v A variable of any type.\n         * @returns {Boolean} True, if v is of type JXG.Point.\n         */\n        isPoint: function (v) {\n            if (v !== null && typeof v === \"object\" && this.exists(v.elementClass)) {\n                return v.elementClass === Const.OBJECT_CLASS_POINT;\n            }\n\n            return false;\n        },\n\n        isPoint3D: function (v) {\n            if (v !== null && typeof v === \"object\" && this.exists(v.elType)) {\n                return v.elType === \"point3d\";\n            }\n\n            return false;\n        },\n\n        /**\n         * Checks if a given variable is a reference of a JSXGraph Point element or an array of length at least two or\n         * a function returning an array of length two or three.\n         * @param {JXG.Board} board\n         * @param v A variable of any type.\n         * @returns {Boolean} True, if v is of type JXG.Point.\n         */\n        isPointType: function (board, v) {\n            var val, p;\n\n            if (this.isArray(v)) {\n                return true;\n            }\n            if (this.isFunction(v)) {\n                val = v();\n                if (this.isArray(val) && val.length > 1) {\n                    return true;\n                }\n            }\n            p = board.select(v);\n            return this.isPoint(p);\n        },\n\n        /**\n         * Checks if a given variable is a reference of a JSXGraph transformation element or an array\n         * of JSXGraph transformation elements.\n         * @param v A variable of any type.\n         * @returns {Boolean} True, if v is of type JXG.Transformation.\n         */\n        isTransformationOrArray: function (v) {\n            if (v !== null) {\n                if (this.isArray(v) && v.length > 0) {\n                    return this.isTransformationOrArray(v[0]);\n                }\n                if (typeof v === \"object\") {\n                    return v.type === Const.OBJECT_TYPE_TRANSFORMATION;\n                }\n            }\n            return false;\n        },\n\n        /**\n         * Checks if a given variable is neither undefined nor null. You should not use this together with global\n         * variables!\n         * @param v A variable of any type.\n         * @param {Boolean} [checkEmptyString=false] If set to true, it is also checked whether v is not equal to ''.\n         * @returns {Boolean} True, if v is neither undefined nor null.\n         */\n        exists: function (v, checkEmptyString) {\n            /* eslint-disable eqeqeq */\n            var result = !(v == undefined || v === null);\n            /* eslint-enable eqeqeq */\n            checkEmptyString = checkEmptyString || false;\n\n            if (checkEmptyString) {\n                return result && v !== \"\";\n            }\n            return result;\n        },\n        // exists: (function (undef) {\n        //     return function (v, checkEmptyString) {\n        //         var result = !(v === undef || v === null);\n\n        //         checkEmptyString = checkEmptyString || false;\n\n        //         if (checkEmptyString) {\n        //             return result && v !== '';\n        //         }\n        //         return result;\n        //     };\n        // }()),\n\n        /**\n         * Checks if v is an empty object or empty.\n         * @param v {Object|Array}\n         * @returns {boolean} True, if v is an empty object or array.\n         */\n        isEmpty: function (v) {\n            return Object.keys(v).length === 0;\n        },\n\n        /**\n         * Handle default parameters.\n         * @param v Given value\n         * @param d Default value\n         * @returns <tt>d</tt>, if <tt>v</tt> is undefined or null.\n         */\n        def: function (v, d) {\n            if (this.exists(v)) {\n                return v;\n            }\n\n            return d;\n        },\n\n        /**\n         * Converts a string containing either <strong>true</strong> or <strong>false</strong> into a boolean value.\n         * @param {String} s String containing either <strong>true</strong> or <strong>false</strong>.\n         * @returns {Boolean} String typed boolean value converted to boolean.\n         */\n        str2Bool: function (s) {\n            if (!this.exists(s)) {\n                return true;\n            }\n\n            if (typeof s === \"boolean\") {\n                return s;\n            }\n\n            if (this.isString(s)) {\n                return s.toLowerCase() === \"true\";\n            }\n\n            return false;\n        },\n\n        /**\n         * Convert a String, a number or a function into a function. This method is used in Transformation.js\n         * @param {JXG.Board} board Reference to a JSXGraph board. It is required to resolve dependencies given\n         * by a GEONE<sub>X</sub>T string, thus it must be a valid reference only in case one of the param\n         * values is of type string.\n         * @param {Array} param An array containing strings, numbers, or functions.\n         * @param {Number} n Length of <tt>param</tt>.\n         * @returns {Function} A function taking one parameter k which specifies the index of the param element\n         * to evaluate.\n         */\n        createEvalFunction: function (board, param, n) {\n            var f = [],\n                i;\n\n            for (i = 0; i < n; i++) {\n                f[i] = JXG.createFunction(param[i], board, \"\", true);\n            }\n\n            return function (k) {\n                return f[k]();\n            };\n        },\n\n        /**\n         * Convert a String, number or function into a function.\n         * @param {String|Number|Function} term A variable of type string, function or number.\n         * @param {JXG.Board} board Reference to a JSXGraph board. It is required to resolve dependencies given\n         * by a GEONE<sub>X</sub>T string, thus it must be a valid reference only in case one of the param\n         * values is of type string.\n         * @param {String} variableName Only required if evalGeonext is set to true. Describes the variable name\n         * of the variable in a GEONE<sub>X</sub>T string given as term.\n         * @param {Boolean} [evalGeonext=true] Set this true, if term should be treated as a GEONE<sub>X</sub>T string.\n         * @returns {Function} A function evaluation the value given by term or null if term is not of type string,\n         * function or number.\n         */\n        createFunction: function (term, board, variableName, evalGeonext) {\n            var f = null;\n\n            if ((!this.exists(evalGeonext) || evalGeonext) && this.isString(term)) {\n                // Convert GEONExT syntax into  JavaScript syntax\n                //newTerm = JXG.GeonextParser.geonext2JS(term, board);\n                //return new Function(variableName,'return ' + newTerm + ';');\n\n                //term = JXG.GeonextParser.replaceNameById(term, board);\n                //term = JXG.GeonextParser.geonext2JS(term, board);\n                f = board.jc.snippet(term, true, variableName, true);\n            } else if (this.isFunction(term)) {\n                f = term;\n            } else if (this.isNumber(term)) {\n                /** @ignore */\n                f = function () {\n                    return term;\n                };\n            } else if (this.isString(term)) {\n                // In case of string function like fontsize\n                /** @ignore */\n                f = function () {\n                    return term;\n                };\n            }\n\n            if (f !== null) {\n                f.origin = term;\n            }\n\n            return f;\n        },\n\n        /**\n         *  Test if the parents array contains existing points. If instead parents contains coordinate arrays or\n         *  function returning coordinate arrays\n         *  free points with these coordinates are created.\n         *\n         * @param {JXG.Board} board Board object\n         * @param {Array} parents Array containing parent elements for a new object. This array may contain\n         *    <ul>\n         *      <li> {@link JXG.Point} objects\n         *      <li> {@link JXG.GeometryElement#name} of {@link JXG.Point} objects\n         *      <li> {@link JXG.GeometryElement#id} of {@link JXG.Point} objects\n         *      <li> Coordinates of points given as array of numbers of length two or three, e.g. [2, 3].\n         *      <li> Coordinates of points given as array of functions of length two or three. Each function returns one coordinate, e.g.\n         *           [function(){ return 2; }, function(){ return 3; }]\n         *      <li> Function returning coordinates, e.g. function() { return [2, 3]; }\n         *    </ul>\n         *  In the last three cases a new point will be created.\n         * @param {String} attrClass Main attribute class of newly created points, see {@link JXG#copyAttributes}\n         * @param {Array} attrArray List of subtype attributes for the newly created points. The list of subtypes is mapped to the list of new points.\n         * @returns {Array} List of newly created {@link JXG.Point} elements or false if not all returned elements are points.\n         */\n        providePoints: function (board, parents, attributes, attrClass, attrArray) {\n            var i,\n                j,\n                len,\n                lenAttr = 0,\n                points = [],\n                attr,\n                val;\n\n            if (!this.isArray(parents)) {\n                parents = [parents];\n            }\n            len = parents.length;\n            if (this.exists(attrArray)) {\n                lenAttr = attrArray.length;\n            }\n            if (lenAttr === 0) {\n                attr = this.copyAttributes(attributes, board.options, attrClass);\n            }\n\n            for (i = 0; i < len; ++i) {\n                if (lenAttr > 0) {\n                    j = Math.min(i, lenAttr - 1);\n                    attr = this.copyAttributes(\n                        attributes,\n                        board.options,\n                        attrClass,\n                        attrArray[j]\n                    );\n                }\n                if (this.isArray(parents[i]) && parents[i].length > 1) {\n                    points.push(board.create(\"point\", parents[i], attr));\n                    points[points.length - 1]._is_new = true;\n                } else if (this.isFunction(parents[i])) {\n                    val = parents[i]();\n                    if (this.isArray(val) && val.length > 1) {\n                        points.push(board.create(\"point\", [parents[i]], attr));\n                        points[points.length - 1]._is_new = true;\n                    }\n                } else {\n                    points.push(board.select(parents[i]));\n                }\n\n                if (!this.isPoint(points[i])) {\n                    return false;\n                }\n            }\n\n            return points;\n        },\n\n        /**\n         *  Test if the parents array contains existing points. If instead parents contains coordinate arrays or\n         *  function returning coordinate arrays\n         *  free points with these coordinates are created.\n         *\n         * @param {JXG.View3D} view View3D object\n         * @param {Array} parents Array containing parent elements for a new object. This array may contain\n         *    <ul>\n         *      <li> {@link JXG.Point3D} objects\n         *      <li> {@link JXG.GeometryElement#name} of {@link JXG.Point3D} objects\n         *      <li> {@link JXG.GeometryElement#id} of {@link JXG.Point3D} objects\n         *      <li> Coordinates of 3D points given as array of numbers of length three, e.g. [2, 3, 1].\n         *      <li> Coordinates of 3D points given as array of functions of length three. Each function returns one coordinate, e.g.\n         *           [function(){ return 2; }, function(){ return 3; }, function(){ return 1; }]\n         *      <li> Function returning coordinates, e.g. function() { return [2, 3, 1]; }\n         *    </ul>\n         *  In the last three cases a new 3D point will be created.\n         * @param {String} attrClass Main attribute class of newly created 3D points, see {@link JXG#copyAttributes}\n         * @param {Array} attrArray List of subtype attributes for the newly created 3D points. The list of subtypes is mapped to the list of new 3D points.\n         * @returns {Array} List of newly created {@link JXG.Point3D} elements or false if not all returned elements are 3D points.\n         */\n        providePoints3D: function (view, parents, attributes, attrClass, attrArray) {\n            var i,\n                j,\n                len,\n                lenAttr = 0,\n                points = [],\n                attr,\n                val;\n\n            if (!this.isArray(parents)) {\n                parents = [parents];\n            }\n            len = parents.length;\n            if (this.exists(attrArray)) {\n                lenAttr = attrArray.length;\n            }\n            if (lenAttr === 0) {\n                attr = this.copyAttributes(attributes, view.board.options, attrClass);\n            }\n\n            for (i = 0; i < len; ++i) {\n                if (lenAttr > 0) {\n                    j = Math.min(i, lenAttr - 1);\n                    attr = this.copyAttributes(\n                        attributes,\n                        view.board.options,\n                        attrClass,\n                        attrArray[j]\n                    );\n                }\n\n                if (this.isArray(parents[i]) && parents[i].length > 1) {\n                    points.push(view.create(\"point3d\", parents[i], attr));\n                    points[points.length - 1]._is_new = true;\n                } else if (this.isFunction(parents[i])) {\n                    val = parents[i]();\n                    if (this.isArray(val) && val.length > 1) {\n                        points.push(view.create(\"point3d\", [parents[i]], attr));\n                        points[points.length - 1]._is_new = true;\n                    }\n                } else {\n                    points.push(view.select(parents[i]));\n                }\n\n                if (!this.isPoint3D(points[i])) {\n                    return false;\n                }\n            }\n\n            return points;\n        },\n\n        /**\n         * Generates a function which calls the function fn in the scope of owner.\n         * @param {Function} fn Function to call.\n         * @param {Object} owner Scope in which fn is executed.\n         * @returns {Function} A function with the same signature as fn.\n         */\n        bind: function (fn, owner) {\n            return function () {\n                return fn.apply(owner, arguments);\n            };\n        },\n\n        /**\n         * If <tt>val</tt> is a function, it will be evaluated without giving any parameters, else the input value\n         * is just returned.\n         * @param val Could be anything. Preferably a number or a function.\n         * @returns If <tt>val</tt> is a function, it is evaluated and the result is returned. Otherwise <tt>val</tt> is returned.\n         */\n        evaluate: function (val) {\n            if (this.isFunction(val)) {\n                return val();\n            }\n\n            return val;\n        },\n\n        /**\n         * Search an array for a given value.\n         * @param {Array} array\n         * @param value\n         * @param {String} [sub] Use this property if the elements of the array are objects.\n         * @returns {Number} The index of the first appearance of the given value, or\n         * <tt>-1</tt> if the value was not found.\n         */\n        indexOf: function (array, value, sub) {\n            var i,\n                s = this.exists(sub);\n\n            if (Array.indexOf && !s) {\n                return array.indexOf(value);\n            }\n\n            for (i = 0; i < array.length; i++) {\n                if ((s && array[i][sub] === value) || (!s && array[i] === value)) {\n                    return i;\n                }\n            }\n\n            return -1;\n        },\n\n        /**\n         * Eliminates duplicate entries in an array consisting of numbers and strings.\n         * @param {Array} a An array of numbers and/or strings.\n         * @returns {Array} The array with duplicate entries eliminated.\n         */\n        eliminateDuplicates: function (a) {\n            var i,\n                len = a.length,\n                result = [],\n                obj = {};\n\n            for (i = 0; i < len; i++) {\n                obj[a[i]] = 0;\n            }\n\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    result.push(i);\n                }\n            }\n\n            return result;\n        },\n\n        /**\n         * Swaps to array elements.\n         * @param {Array} arr\n         * @param {Number} i\n         * @param {Number} j\n         * @returns {Array} Reference to the given array.\n         */\n        swap: function (arr, i, j) {\n            var tmp;\n\n            tmp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = tmp;\n\n            return arr;\n        },\n\n        /**\n         * Generates a copy of an array and removes the duplicate entries. The original\n         * Array will be altered.\n         * @param {Array} arr\n         * @returns {Array}\n         */\n        uniqueArray: function (arr) {\n            var i,\n                j,\n                isArray,\n                ret = [];\n\n            if (arr.length === 0) {\n                return [];\n            }\n\n            for (i = 0; i < arr.length; i++) {\n                isArray = this.isArray(arr[i]);\n\n                if (!this.exists(arr[i])) {\n                    arr[i] = \"\";\n                    continue;\n                }\n                for (j = i + 1; j < arr.length; j++) {\n                    if (isArray && JXG.cmpArrays(arr[i], arr[j])) {\n                        arr[i] = [];\n                    } else if (!isArray && arr[i] === arr[j]) {\n                        arr[i] = \"\";\n                    }\n                }\n            }\n\n            j = 0;\n\n            for (i = 0; i < arr.length; i++) {\n                isArray = this.isArray(arr[i]);\n\n                if (!isArray && arr[i] !== \"\") {\n                    ret[j] = arr[i];\n                    j++;\n                } else if (isArray && arr[i].length !== 0) {\n                    ret[j] = arr[i].slice(0);\n                    j++;\n                }\n            }\n\n            arr = ret;\n            return ret;\n        },\n\n        /**\n         * Checks if an array contains an element equal to <tt>val</tt> but does not check the type!\n         * @param {Array} arr\n         * @param val\n         * @returns {Boolean}\n         */\n        isInArray: function (arr, val) {\n            return JXG.indexOf(arr, val) > -1;\n        },\n\n        /**\n         * Converts an array of {@link JXG.Coords} objects into a coordinate matrix.\n         * @param {Array} coords\n         * @param {Boolean} split\n         * @returns {Array}\n         */\n        coordsArrayToMatrix: function (coords, split) {\n            var i,\n                x = [],\n                m = [];\n\n            for (i = 0; i < coords.length; i++) {\n                if (split) {\n                    x.push(coords[i].usrCoords[1]);\n                    m.push(coords[i].usrCoords[2]);\n                } else {\n                    m.push([coords[i].usrCoords[1], coords[i].usrCoords[2]]);\n                }\n            }\n\n            if (split) {\n                m = [x, m];\n            }\n\n            return m;\n        },\n\n        /**\n         * Compare two arrays.\n         * @param {Array} a1\n         * @param {Array} a2\n         * @returns {Boolean} <tt>true</tt>, if the arrays coefficients are of same type and value.\n         */\n        cmpArrays: function (a1, a2) {\n            var i;\n\n            // trivial cases\n            if (a1 === a2) {\n                return true;\n            }\n\n            if (a1.length !== a2.length) {\n                return false;\n            }\n\n            for (i = 0; i < a1.length; i++) {\n                if (this.isArray(a1[i]) && this.isArray(a2[i])) {\n                    if (!this.cmpArrays(a1[i], a2[i])) {\n                        return false;\n                    }\n                } else if (a1[i] !== a2[i]) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        /**\n         * Removes an element from the given array\n         * @param {Array} ar\n         * @param el\n         * @returns {Array}\n         */\n        removeElementFromArray: function (ar, el) {\n            var i;\n\n            for (i = 0; i < ar.length; i++) {\n                if (ar[i] === el) {\n                    ar.splice(i, 1);\n                    return ar;\n                }\n            }\n\n            return ar;\n        },\n\n        /**\n         * Truncate a number <tt>n</tt> after <tt>p</tt> decimals.\n         * @param {Number} n\n         * @param {Number} p\n         * @returns {Number}\n         */\n        trunc: function (n, p) {\n            p = JXG.def(p, 0);\n\n            return this.toFixed(n, p);\n        },\n\n        /**\n         * Decimal adjustment of a number.\n         * From https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n         *\n         * @param    {String}    type    The type of adjustment.\n         * @param    {Number}    value    The number.\n         * @param    {Number}    exp        The exponent (the 10 logarithm of the adjustment base).\n         * @returns    {Number}            The adjusted value.\n         *\n         * @private\n         */\n        _decimalAdjust: function (type, value, exp) {\n            // If the exp is undefined or zero...\n            if (exp === undefined || +exp === 0) {\n                return Math[type](value);\n            }\n\n            value = +value;\n            exp = +exp;\n            // If the value is not a number or the exp is not an integer...\n            if (isNaN(value) || !(typeof exp === \"number\" && exp % 1 === 0)) {\n                return NaN;\n            }\n\n            // Shift\n            value = value.toString().split(\"e\");\n            value = Math[type](+(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp)));\n\n            // Shift back\n            value = value.toString().split(\"e\");\n            return +(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp));\n        },\n\n        /**\n         * Round a number to given number of decimal digits.\n         *\n         * Example: JXG._toFixed(3.14159, -2) gives 3.14\n         * @param  {Number} value Number to be rounded\n         * @param  {Number} exp   Number of decimal digits given as negative exponent\n         * @return {Number}       Rounded number.\n         *\n         * @private\n         */\n        _round10: function (value, exp) {\n            return this._decimalAdjust(\"round\", value, exp);\n        },\n\n        /**\n         * \"Floor\" a number to given number of decimal digits.\n         *\n         * Example: JXG._toFixed(3.14159, -2) gives 3.14\n         * @param  {Number} value Number to be floored\n         * @param  {Number} exp   Number of decimal digits given as negative exponent\n         * @return {Number}       \"Floored\" number.\n         *\n         * @private\n         */\n        _floor10: function (value, exp) {\n            return this._decimalAdjust(\"floor\", value, exp);\n        },\n\n        /**\n         * \"Ceil\" a number to given number of decimal digits.\n         *\n         * Example: JXG._toFixed(3.14159, -2) gives 3.15\n         * @param  {Number} value Number to be ceiled\n         * @param  {Number} exp   Number of decimal digits given as negative exponent\n         * @return {Number}       \"Ceiled\" number.\n         *\n         * @private\n         */\n        _ceil10: function (value, exp) {\n            return this._decimalAdjust(\"ceil\", value, exp);\n        },\n\n        /**\n         * Replacement of the default toFixed() method.\n         * It does a correct rounding (independent of the browser) and\n         * returns \"0.00\" for toFixed(-0.000001, 2) instead of \"-0.00\" which\n         * is returned by JavaScript's toFixed()\n         *\n         * @memberOf JXG\n         * @param  {Number} num    Number tp be rounded\n         * @param  {Number} digits Decimal digits\n         * @return {String}        Rounded number is returned as string\n         */\n        toFixed: function (num, digits) {\n            return this._round10(num, -digits).toFixed(digits);\n        },\n\n        /**\n         * Truncate a number <tt>val</tt> automatically.\n         * @memberOf JXG\n         * @param val\n         * @returns {Number}\n         */\n        autoDigits: function (val) {\n            var x = Math.abs(val),\n                str;\n\n            if (x >= 0.1) {\n                str = this.toFixed(val, 2);\n            } else if (x >= 0.01) {\n                str = this.toFixed(val, 4);\n            } else if (x >= 0.0001) {\n                str = this.toFixed(val, 6);\n            } else {\n                str = val;\n            }\n            return str;\n        },\n\n        /**\n         * Extracts the keys of a given object.\n         * @param object The object the keys are to be extracted\n         * @param onlyOwn If true, hasOwnProperty() is used to verify that only keys are collected\n         * the object owns itself and not some other object in the prototype chain.\n         * @returns {Array} All keys of the given object.\n         */\n        keys: function (object, onlyOwn) {\n            var keys = [],\n                property;\n\n            // the caller decides if we use hasOwnProperty\n            /*jslint forin:true*/\n            for (property in object) {\n                if (onlyOwn) {\n                    if (object.hasOwnProperty(property)) {\n                        keys.push(property);\n                    }\n                } else {\n                    keys.push(property);\n                }\n            }\n            /*jslint forin:false*/\n\n            return keys;\n        },\n\n        /**\n         * This outputs an object with a base class reference to the given object. This is useful if\n         * you need a copy of an e.g. attributes object and want to overwrite some of the attributes\n         * without changing the original object.\n         * @param {Object} obj Object to be embedded.\n         * @returns {Object} An object with a base class reference to <tt>obj</tt>.\n         */\n        clone: function (obj) {\n            var cObj = {};\n\n            cObj.prototype = obj;\n\n            return cObj;\n        },\n\n        /**\n         * Embeds an existing object into another one just like {@link #clone} and copies the contents of the second object\n         * to the new one. Warning: The copied properties of obj2 are just flat copies.\n         * @param {Object} obj Object to be copied.\n         * @param {Object} obj2 Object with data that is to be copied to the new one as well.\n         * @returns {Object} Copy of given object including some new/overwritten data from obj2.\n         */\n        cloneAndCopy: function (obj, obj2) {\n            var r,\n                cObj = function () {\n                    return undefined;\n                };\n\n            cObj.prototype = obj;\n\n            // no hasOwnProperty on purpose\n            /*jslint forin:true*/\n            /*jshint forin:true*/\n\n            for (r in obj2) {\n                cObj[r] = obj2[r];\n            }\n\n            /*jslint forin:false*/\n            /*jshint forin:false*/\n\n            return cObj;\n        },\n\n        /**\n         * Recursively merges obj2 into obj1. Contrary to {@link JXG#deepCopy} this won't create a new object\n         * but instead will overwrite obj1.\n         * @param {Object} obj1\n         * @param {Object} obj2\n         * @returns {Object}\n         */\n        merge: function (obj1, obj2) {\n            var i, j;\n\n            for (i in obj2) {\n                if (obj2.hasOwnProperty(i)) {\n                    if (this.isArray(obj2[i])) {\n                        if (!obj1[i]) {\n                            obj1[i] = [];\n                        }\n\n                        for (j = 0; j < obj2[i].length; j++) {\n                            if (typeof obj2[i][j] === \"object\") {\n                                obj1[i][j] = this.merge(obj1[i][j], obj2[i][j]);\n                            } else {\n                                obj1[i][j] = obj2[i][j];\n                            }\n                        }\n                    } else if (typeof obj2[i] === \"object\") {\n                        if (!obj1[i]) {\n                            obj1[i] = {};\n                        }\n\n                        obj1[i] = this.merge(obj1[i], obj2[i]);\n                    } else {\n                        obj1[i] = obj2[i];\n                    }\n                }\n            }\n\n            return obj1;\n        },\n\n        /**\n         * Creates a deep copy of an existing object, i.e. arrays or sub-objects are copied component resp.\n         * element-wise instead of just copying the reference. If a second object is supplied, the two objects\n         * are merged into one object. The properties of the second object have priority.\n         * @param {Object} obj This object will be copied.\n         * @param {Object} obj2 This object will merged into the newly created object\n         * @param {Boolean} [toLower=false] If true the keys are convert to lower case. This is needed for visProp, see JXG#copyAttributes\n         * @returns {Object} copy of obj or merge of obj and obj2.\n         */\n        deepCopy: function (obj, obj2, toLower) {\n            var c, i, prop, i2;\n\n            toLower = toLower || false;\n            if (typeof obj !== 'object' || obj === null) {\n                return obj;\n            }\n\n            // missing hasOwnProperty is on purpose in this function\n            if (this.isArray(obj)) {\n                c = [];\n                for (i = 0; i < obj.length; i++) {\n                    prop = obj[i];\n                    if (typeof prop === \"object\") {\n                        // We certainly do not want to recurse into a JSXGraph object.\n                        // This would for sure result in an infinite recursion.\n                        // As alternative we copy the id of the object.\n                        if (this.exists(prop.board)) {\n                            c[i] = prop.id;\n                        } else {\n                            c[i] = this.deepCopy(prop);\n                        }\n                    } else {\n                        c[i] = prop;\n                    }\n                }\n            } else {\n                c = {};\n                for (i in obj) {\n                    if (obj.hasOwnProperty(i)) {\n                        i2 = toLower ? i.toLowerCase() : i;\n                        prop = obj[i];\n                        if (prop !== null && typeof prop === \"object\") {\n                            if (this.exists(prop.board)) {\n                                c[i2] = prop.id;\n                            } else {\n                                c[i2] = this.deepCopy(prop);\n                            }\n                        } else {\n                            c[i2] = prop;\n                        }\n                    }\n                }\n\n                for (i in obj2) {\n                    if (obj2.hasOwnProperty(i)) {\n                        i2 = toLower ? i.toLowerCase() : i;\n\n                        prop = obj2[i];\n                        if (typeof prop === \"object\") {\n                            if (this.isArray(prop) || !this.exists(c[i2])) {\n                                c[i2] = this.deepCopy(prop);\n                            } else {\n                                c[i2] = this.deepCopy(c[i2], prop, toLower);\n                            }\n                        } else {\n                            c[i2] = prop;\n                        }\n                    }\n                }\n            }\n\n            return c;\n        },\n\n        /**\n         * In-place (deep) merging of attributes. Allows attributes like `{shadow: {enabled: true...}}`\n         *\n         * @param {Object} attr Object with attributes - usually containing default options\n         * @param {Object} special Special option values which overwrite (recursively) the default options\n         * @param {Boolean} [toLower=true] If true the keys are convert to lower case.\n         *\n         * @private\n         */\n        mergeAttr: function (attr, special, toLower) {\n            var e, e2, o;\n\n            toLower = toLower || true;\n\n            for (e in special) {\n                if (special.hasOwnProperty(e)) {\n                    e2 = (toLower) ? e.toLowerCase(): e;\n\n                    o = special[e];\n                    if (this.isObject(o) && o !== null &&\n                        // Do not recurse into a document object or a JSXGraph object\n                        !this.isDocumentOrFragment(o) && !this.exists(o.board) &&\n                        // Do not recurse if a string is provided as \"new String(...)\"\n                        typeof o.valueOf() !== 'string') {\n                        if (attr[e2] === undefined || attr[e2] === null || !this.isObject(attr[e2])) {\n                            // The last test handles the case:\n                            //   attr.draft = false;\n                            //   special.draft = { strokewidth: 4}\n                            attr[e2] = {};\n                        }\n                        this.mergeAttr(attr[e2], o, toLower);\n                    } else {\n                        // Flat copy\n                        // This is also used in the cases\n                        //   attr.shadow = { enabled: true ...}\n                        //   special.shadow = false;\n                        // and\n                        //   special.anchor is a JSXGraph element\n                        attr[e2] = o;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Generates an attributes object that is filled with default values from the Options object\n         * and overwritten by the user specified attributes.\n         * @param {Object} attributes user specified attributes\n         * @param {Object} options defaults options\n         * @param {String} s variable number of strings, e.g. 'slider', subtype 'point1'.\n         * @returns {Object} The resulting attributes object\n         */\n        copyAttributes: function (attributes, options, s) {\n            var a,\n                i,\n                len,\n                o,\n                isAvail,\n                primitives = {\n                    circle: 1,\n                    curve: 1,\n                    image: 1,\n                    line: 1,\n                    point: 1,\n                    polygon: 1,\n                    text: 1,\n                    ticks: 1,\n                    integral: 1\n                };\n\n            len = arguments.length;\n            if (len < 3 || primitives[s]) {\n                // Default options from Options.elements\n                a = JXG.deepCopy(options.elements, null, true);\n            } else {\n                a = {};\n            }\n\n            // Only the layer of the main element is set.\n            if (len < 4 && this.exists(s) && this.exists(options.layer[s])) {\n                a.layer = options.layer[s];\n            }\n\n            // Default options from the specific element like 'line' in\n            // copyAttribute(attributes, board.options, 'line')\n            o = options;\n            isAvail = true;\n            for (i = 2; i < len; i++) {\n                if (this.exists(o[arguments[i]])) {\n                    o = o[arguments[i]];\n                } else {\n                    isAvail = false;\n                    break;\n                }\n            }\n            if (isAvail) {\n                a = JXG.deepCopy(a, o, true);\n            }\n\n            // Merge the specific options given in the parameter 'attributes'\n            // into the default options.\n            // Additionally, we step into a subelement of attribute like line.point1 in case it is supplied as in\n            // copyAttribute(attributes, board.options, 'line', 'point1')\n            // In this case we would merge attributes.point1 into the global line.point1 attributes.\n            o = (typeof attributes === 'object') ? attributes : {};\n            isAvail = true;\n            for (i = 3; i < len; i++) {\n                if (this.exists(o[arguments[i]])) {\n                    o = o[arguments[i]];\n                } else {\n                    isAvail = false;\n                    break;\n                }\n            }\n            if (isAvail) {\n                this.mergeAttr(a, o, true);\n            }\n\n            if (arguments[2] === \"board\") {\n                // For board attributes we are done now.\n                return a;\n            }\n\n            // Special treatment of labels\n            o = options;\n            isAvail = true;\n            for (i = 2; i < len; i++) {\n                if (this.exists(o[arguments[i]])) {\n                    o = o[arguments[i]];\n                } else {\n                    isAvail = false;\n                    break;\n                }\n            }\n            if (isAvail && this.exists(o.label)) {\n                a.label = JXG.deepCopy(o.label, a.label);\n            }\n            a.label = JXG.deepCopy(options.label, a.label);\n\n            return a;\n        },\n\n        /**\n         * Copy all prototype methods from object \"superObject\" to object\n         * \"subObject\". The constructor of superObject will be available\n         * in subObject as subObject.constructor[constructorName].\n         * @param {Object} subObj A JavaScript object which receives new methods.\n         * @param {Object} superObj A JavaScript object which lends its prototype methods to subObject\n         * @returns {String} constructorName Under this name the constructor of superObj will be available\n         * in subObject.\n         * @private\n         */\n        copyPrototypeMethods: function (subObject, superObject, constructorName) {\n            var key;\n\n            subObject.prototype[constructorName] = superObject.prototype.constructor;\n            for (key in superObject.prototype) {\n                if (superObject.prototype.hasOwnProperty(key)) {\n                    subObject.prototype[key] = superObject.prototype[key];\n                }\n            }\n        },\n\n        /**\n         * Converts a JavaScript object into a JSON string.\n         * @param {Object} obj A JavaScript object, functions will be ignored.\n         * @param {Boolean} [noquote=false] No quotes around the name of a property.\n         * @returns {String} The given object stored in a JSON string.\n         */\n        toJSON: function (obj, noquote) {\n            var list, prop, i, s, val;\n\n            noquote = JXG.def(noquote, false);\n\n            // check for native JSON support:\n            if (typeof JSON && JSON.stringify && !noquote) {\n                try {\n                    s = JSON.stringify(obj);\n                    return s;\n                } catch (e) {\n                    // if something goes wrong, e.g. if obj contains functions we won't return\n                    // and use our own implementation as a fallback\n                }\n            }\n\n            switch (typeof obj) {\n                case \"object\":\n                    if (obj) {\n                        list = [];\n\n                        if (this.isArray(obj)) {\n                            for (i = 0; i < obj.length; i++) {\n                                list.push(JXG.toJSON(obj[i], noquote));\n                            }\n\n                            return \"[\" + list.join(\",\") + \"]\";\n                        }\n\n                        for (prop in obj) {\n                            if (obj.hasOwnProperty(prop)) {\n                                try {\n                                    val = JXG.toJSON(obj[prop], noquote);\n                                } catch (e2) {\n                                    val = \"\";\n                                }\n\n                                if (noquote) {\n                                    list.push(prop + \":\" + val);\n                                } else {\n                                    list.push('\"' + prop + '\":' + val);\n                                }\n                            }\n                        }\n\n                        return \"{\" + list.join(\",\") + \"} \";\n                    }\n                    return \"null\";\n                case \"string\":\n                    return \"'\" + obj.replace(/([\"'])/g, \"\\\\$1\") + \"'\";\n                case \"number\":\n                case \"boolean\":\n                    return obj.toString();\n            }\n\n            return \"0\";\n        },\n\n        /**\n         * Resets visPropOld.\n         * @param {JXG.GeometryElement} el\n         * @returns {GeometryElement}\n         */\n        clearVisPropOld: function (el) {\n            el.visPropOld = {\n                cssclass: \"\",\n                cssdefaultstyle: \"\",\n                cssstyle: \"\",\n                fillcolor: \"\",\n                fillopacity: \"\",\n                firstarrow: false,\n                fontsize: -1,\n                lastarrow: false,\n                left: -100000,\n                linecap: \"\",\n                shadow: false,\n                strokecolor: \"\",\n                strokeopacity: \"\",\n                strokewidth: \"\",\n                tabindex: -100000,\n                transitionduration: 0,\n                top: -100000,\n                visible: null\n            };\n\n            return el;\n        },\n\n        /**\n         * Checks if an object contains a key, whose value equals to val.\n         * @param {Object} obj\n         * @param val\n         * @returns {Boolean}\n         */\n        isInObject: function (obj, val) {\n            var el;\n\n            for (el in obj) {\n                if (obj.hasOwnProperty(el)) {\n                    if (obj[el] === val) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Replaces all occurences of &amp; by &amp;amp;, &gt; by &amp;gt;, and &lt; by &amp;lt;.\n         * @param {String} str\n         * @returns {String}\n         */\n        escapeHTML: function (str) {\n            return str.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        },\n\n        /**\n         * Eliminates all substrings enclosed by &lt; and &gt; and replaces all occurences of\n         * &amp;amp; by &amp;, &amp;gt; by &gt;, and &amp;lt; by &lt;.\n         * @param {String} str\n         * @returns {String}\n         */\n        unescapeHTML: function (str) {\n            // This regex is NOT insecure. We are replacing everything found with ''\n            /*jslint regexp:true*/\n            return str\n                .replace(/<\\/?[^>]+>/gi, \"\")\n                .replace(/&amp;/g, \"&\")\n                .replace(/&lt;/g, \"<\")\n                .replace(/&gt;/g, \">\");\n        },\n\n        /**\n         * Makes a string lower case except for the first character which will be upper case.\n         * @param {String} str Arbitrary string\n         * @returns {String} The capitalized string.\n         */\n        capitalize: function (str) {\n            return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();\n        },\n\n        /**\n         * Make numbers given as strings nicer by removing all unnecessary leading and trailing zeroes.\n         * @param {String} str\n         * @returns {String}\n         */\n        trimNumber: function (str) {\n            str = str.replace(/^0+/, \"\");\n            str = str.replace(/0+$/, \"\");\n\n            if (str[str.length - 1] === \".\" || str[str.length - 1] === \",\") {\n                str = str.slice(0, -1);\n            }\n\n            if (str[0] === \".\" || str[0] === \",\") {\n                str = \"0\" + str;\n            }\n\n            return str;\n        },\n\n        /**\n         * Filter an array of elements.\n         * @param {Array} list\n         * @param {Object|function} filter\n         * @returns {Array}\n         */\n        filterElements: function (list, filter) {\n            var i,\n                f,\n                item,\n                flower,\n                value,\n                visPropValue,\n                pass,\n                l = list.length,\n                result = [];\n\n            if (typeof filter !== \"function\" && typeof filter !== \"object\") {\n                return result;\n            }\n\n            for (i = 0; i < l; i++) {\n                pass = true;\n                item = list[i];\n\n                if (typeof filter === \"object\") {\n                    for (f in filter) {\n                        if (filter.hasOwnProperty(f)) {\n                            flower = f.toLowerCase();\n\n                            if (typeof item[f] === \"function\") {\n                                value = item[f]();\n                            } else {\n                                value = item[f];\n                            }\n\n                            if (item.visProp && typeof item.visProp[flower] === \"function\") {\n                                visPropValue = item.visProp[flower]();\n                            } else {\n                                visPropValue = item.visProp && item.visProp[flower];\n                            }\n\n                            if (typeof filter[f] === \"function\") {\n                                pass = filter[f](value) || filter[f](visPropValue);\n                            } else {\n                                pass = value === filter[f] || visPropValue === filter[f];\n                            }\n\n                            if (!pass) {\n                                break;\n                            }\n                        }\n                    }\n                } else if (typeof filter === \"function\") {\n                    pass = filter(item);\n                }\n\n                if (pass) {\n                    result.push(item);\n                }\n            }\n\n            return result;\n        },\n\n        /**\n         * Remove all leading and trailing whitespaces from a given string.\n         * @param {String} str\n         * @returns {String}\n         */\n        trim: function (str) {\n            // str = str.replace(/^\\s+/, '');\n            // str = str.replace(/\\s+$/, '');\n            //\n            // return str;\n            return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n        },\n\n        /**\n         * Convert HTML tags to entities or use html_sanitize if the google caja html sanitizer is available.\n         * @param {String} str\n         * @param {Boolean} caja\n         * @returns {String} Sanitized string\n         */\n        sanitizeHTML: function (str, caja) {\n            if (typeof html_sanitize === \"function\" && caja) {\n                return html_sanitize(\n                    str,\n                    function () {\n                        return undefined;\n                    },\n                    function (id) {\n                        return id;\n                    }\n                );\n            }\n\n            if (str && typeof str === \"string\") {\n                str = str.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n            }\n\n            return str;\n        },\n\n        /**\n         * If <tt>s</tt> is a slider, it returns the sliders value, otherwise it just returns the given value.\n         * @param {*} s\n         * @returns {*} s.Value() if s is an element of type slider, s otherwise\n         */\n        evalSlider: function (s) {\n            if (s && s.type === Const.OBJECT_TYPE_GLIDER && typeof s.Value === \"function\") {\n                return s.Value();\n            }\n\n            return s;\n        }\n    }\n);\n\nexport default JXG;\n","/**\n * Generate a random uuid.\n * Written by http://www.broofa.com (robert@broofa.com)\n *\n * Copyright (c) 2010 Robert Kieffer\n * Dual licensed under the MIT and GPL licenses.\n * @returns {String}\n * @example\n *   var uuid = JXG.Util.genUUID();\n *   > uuid = '92329D39-6F5C-4520-ABFC-AAB64544E172'\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\nimport JXG from \"../jxg\";\n\n// constants\nvar uuidCharsStr = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n    uuidChars = uuidCharsStr.split(\"\");\n\n/**\n * General utility routines\n * @namespace\n */\nJXG.Util = JXG.Util || {};\n\nJXG.Util.genUUID = function (prefix) {\n    var r,\n        i,\n        uuid = [],\n        rnd = 0;\n\n    prefix = prefix || \"\";\n\n    if (prefix !== \"\" && prefix.substr(prefix.length - 1) !== \"-\") {\n        prefix = prefix + \"-\";\n    }\n\n    for (i = 0; i < 36; i++) {\n        if (i === 8 || i === 13 || i === 18 || i === 23) {\n            uuid[i] = \"-\";\n        } else if (i === 14) {\n            uuid[i] = \"4\";\n        } else {\n            if (rnd <= 0x02) {\n                rnd = (0x2000000 + Math.random() * 0x1000000) | 0;\n            }\n\n            r = rnd & 0xf;\n            rnd = rnd >> 4;\n            uuid[i] = uuidChars[i === 19 ? (r & 0x3) | 0x8 : r];\n        }\n    }\n\n    return prefix + uuid.join(\"\");\n};\n\nexport default JXG.Util;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__841__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.hmd = function(module) {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: function() {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(__webpack_require__.s = 748);\n",""],"names":[],"sourceRoot":""}