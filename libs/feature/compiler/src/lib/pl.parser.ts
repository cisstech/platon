/* parser generated by jison 0.3.0 */
/**
 * Returns a Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */


import { v4 as uuidv4 } from 'uuid'

// VALUES

interface PLValue {
  readonly value: string | number | boolean | PLValue[] | {key: string, value: PLValue}[];
  readonly lineno: number;
  toJSON(visitor: PLVisitor): any | Promise<any>;
}

export class PLArray implements PLValue {
  constructor(
    readonly value: PLValue[],
    readonly lineno: number,
  ) {}
  async toJSON(visitor: PLVisitor) {
    const result: any[] = [];
    // do not use promise.all to allow cache file operations (@copyurl, @copycontent...)
    for (const e of this.value) {
      result.push(await e.toJSON(visitor));
    }
    return result;
  }
}

export class PLObject implements PLValue {
  constructor(
    readonly value: {key: string, value: PLValue}[],
    readonly lineno: number,
  ) {}
  async toJSON(visitor: PLVisitor) {
    // do not use promise.all to allow cache file operations (@copyurl, @copycontent...)
    for (let i = 0; i < this.value.length; i++) {
      this.value[i].value = await this.value[i].value.toJSON(visitor);
    }
    return this.value.reduce((acc: any, curr: any) => {
      acc[curr.key] = curr.value;
      return acc;
    }, {} as any);
  }
}

export class PLString implements PLValue {
  constructor(
    readonly value: string,
    readonly lineno: number,
  ) {}

  toJSON() { return this.value.trim(); }
}

export class PLNumber implements PLValue {
  constructor(
    readonly value: number,
    readonly lineno: number,
  ) {}
  toJSON() { return this.value; }
}

export class PLBoolean implements PLValue {
  constructor(
    readonly value: boolean,
    readonly lineno: number,
  ) {}
  toJSON() { return this.value; }
}

export class PLComponent implements PLValue {
  constructor(
    readonly value: string,
    readonly lineno: number,
  ) {}
  toJSON() { return { 'cid': uuidv4(), selector: this.value }; }
}

export class PLDict implements PLValue {
  constructor(
    readonly value: string,
    readonly lineno: number,
  ) {}
  async toJSON(visitor: PLVisitor) {
    const source = await visitor.visitExtends(this, false);
    return source.variables
  }
}

export class PLFileURL implements PLValue {
  constructor(
    readonly value: string,
    readonly lineno: number,
  ) {}
  toJSON(visitor: PLVisitor) { return visitor.visitCopyUrl(this); }
}

export class PLReference implements PLValue {
  constructor(
    readonly value: string,
    readonly lineno: number,
  ) {}
  toJSON(visitor: PLVisitor) { return visitor.visitReference(this); }
}

export class PLFileContent implements PLValue {
  constructor(
    readonly value: string,
    readonly lineno: number,
  ) {}
  toJSON(visitor: PLVisitor) { return visitor.visitCopyContent(this); }
}

// NODES

export interface PLNode {
  accept(visitor: PLVisitor): Promise<void>;
}

export class ExtendsNode implements PLNode {
  constructor(
    readonly path: string,
    readonly lineno: number
  ) {}
  async accept(visitor: PLVisitor): Promise<void> {
    await visitor.visitExtends(this, true);
  }
}

export class CommentNode implements PLNode {
  constructor(
    readonly value: string,
    readonly lineno: number
  ) {}
  accept(visitor: PLVisitor): Promise<void> {
    return visitor.visitComment(this);
  }
}

export class IncludeNode implements PLNode {
  constructor(
    readonly path: string,
    readonly alias: string,
    readonly lineno: number,
  ) {}
  accept(visitor: PLVisitor): Promise<void> {
    return visitor.visitInclude(this);
  }
}

export class AssignmentNode implements PLNode {
  constructor(
    readonly key: string,
    readonly value: PLValue,
    readonly lineno: number
  ) {}
  accept(visitor: PLVisitor): Promise<void> {
    return visitor.visitAssignment(this);
  }
}


// AST


export interface PLDependency {
  alias?: string;
  lineno: number;
  content: string;
  abspath: string;
}

export interface PLSourceFile {
  resource: string;
  version: string;
  abspath: string;
  errors: {
    lineno: number,
    abspath: string
    description: string
  }[];
  warnings: {
    lineno: number,
    abspath: string
    description: string
  }[];
  variables: Record<string, unknown>;
  dependencies: PLDependency[];
}

// VISITOR

export interface PLVisitor {
  visit(nodes: PLNode[]): Promise<PLSourceFile>;
  visitExtends(node: ExtendsNode | PLDict, merge: boolean): Promise<PLSourceFile>;
  visitInclude(node: IncludeNode): Promise<void>;
  visitComment(node: CommentNode): Promise<void>;
  visitAssignment(node: AssignmentNode): Promise<void>;
  visitCopyUrl(node: PLFileURL): Promise<string>;
  visitReference(node: PLReference): Promise<any>;
  visitCopyContent(node: PLFileContent): Promise<string>;
}



import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType, o } from '@ts-jison/parser';const $V0=[1,8],$V1=[1,9],$V2=[1,11],$V3=[1,10],$V4=[5,8,12,19,34],$V5=[1,24],$V6=[1,23],$V7=[1,25],$V8=[1,26],$V9=[1,27],$Va=[1,28],$Vb=[1,29],$Vc=[1,30],$Vd=[1,31],$Ve=[1,32],$Vf=[1,36],$Vg=[13,31],$Vh=[5,8,12,19,26,29,32,34],$Vi=[1,49],$Vj=[26,32],$Vk=[29,32];

export class PLParser extends JisonParser implements JisonParserApi {
    $?: any;

    constructor (yy = {}, lexer = new PLLexer(yy)) {
      super(yy, lexer);
    }

    symbols_: SymbolsType = {"error":2,"program":3,"statements":4,"EOF":5,"statement":6,"comment":7,"COMMENT":8,"assignment_statement":9,"include_statement":10,"extends_statement":11,"IDENTIFIER":12,"EQUALS":13,"value_multi":14,"value":15,"NUMBER":16,"BOOLEAN":17,"STRING":18,"EXTENDS":19,"PATH":20,"COPYURL":21,"COPYCONTENT":22,"COLON":23,"SELECTOR":24,"LBRACKET":25,"RBRACKET":26,"elements":27,"LBRACE":28,"RBRACE":29,"pairs":30,"ANY":31,"COMMA":32,"pair":33,"INCLUDE":34,"AS":35,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",5:"EOF",8:"COMMENT",12:"IDENTIFIER",13:"EQUALS",16:"NUMBER",17:"BOOLEAN",18:"STRING",19:"EXTENDS",20:"PATH",21:"COPYURL",22:"COPYCONTENT",23:"COLON",24:"SELECTOR",25:"LBRACKET",26:"RBRACKET",28:"LBRACE",29:"RBRACE",31:"ANY",32:"COMMA",34:"INCLUDE",35:"AS"};
    productions_: ProductionsType = [0,[3,2],[4,1],[4,1],[4,2],[4,2],[7,1],[6,1],[6,1],[6,1],[9,4],[9,3],[9,4],[9,3],[15,2],[15,1],[15,1],[15,1],[15,1],[15,2],[15,2],[15,2],[15,2],[15,2],[15,3],[15,2],[15,3],[14,2],[14,1],[27,1],[27,3],[30,1],[30,3],[33,3],[10,2],[10,4],[11,2]];
    table: Array<StateType> = [{3:1,4:2,6:3,7:4,8:$V0,9:5,10:6,11:7,12:$V1,19:$V2,34:$V3},{1:[3]},{5:[1,12],6:14,7:13,8:$V0,9:5,10:6,11:7,12:$V1,19:$V2,34:$V3},o($V4,[2,2]),o($V4,[2,3]),o($V4,[2,7]),o($V4,[2,8]),o($V4,[2,9]),o($V4,[2,6]),{13:[1,15]},{20:[1,16]},{20:[1,17]},{1:[2,1]},o($V4,[2,4]),o($V4,[2,5]),{8:[1,18],12:$V5,13:[1,19],14:20,15:21,16:$V6,17:$V7,18:$V8,19:$V9,21:$Va,22:$Vb,23:$Vc,25:$Vd,28:$Ve,31:[1,22]},o($V4,[2,34],{35:[1,33]}),o($V4,[2,36]),{8:$Vf,12:$V5,13:[1,34],15:35,16:$V6,17:$V7,18:$V8,19:$V9,21:$Va,22:$Vb,23:$Vc,25:$Vd,28:$Ve},o($V4,[2,11]),{13:[1,37],31:[1,38]},o($V4,[2,13]),o($Vg,[2,28]),o($Vh,[2,15]),o($Vh,[2,16]),o($Vh,[2,17]),o($Vh,[2,18]),{20:[1,39]},{20:[1,40]},{20:[1,41]},{24:[1,42]},{8:$Vf,12:$V5,15:45,16:$V6,17:$V7,18:$V8,19:$V9,21:$Va,22:$Vb,23:$Vc,25:$Vd,26:[1,43],27:44,28:$Ve},{12:$Vi,29:[1,46],30:47,33:48},{20:[1,50]},o($V4,[2,10]),o($Vh,[2,14]),{8:$Vf,12:$V5,15:35,16:$V6,17:$V7,18:$V8,19:$V9,21:$Va,22:$Vb,23:$Vc,25:$Vd,28:$Ve},o($V4,[2,12]),o($Vg,[2,27]),o($Vh,[2,19]),o($Vh,[2,20]),o($Vh,[2,21]),o($Vh,[2,22]),o($Vh,[2,23]),{26:[1,51],32:[1,52]},o($Vj,[2,29]),o($Vh,[2,25]),{29:[1,53],32:[1,54]},o($Vk,[2,31]),{23:[1,55]},o($V4,[2,35]),o($Vh,[2,24]),{8:$Vf,12:$V5,15:56,16:$V6,17:$V7,18:$V8,19:$V9,21:$Va,22:$Vb,23:$Vc,25:$Vd,28:$Ve},o($Vh,[2,26]),{12:$Vi,33:57},{8:$Vf,12:$V5,15:58,16:$V6,17:$V7,18:$V8,19:$V9,21:$Va,22:$Vb,23:$Vc,25:$Vd,28:$Ve},o($Vj,[2,30]),o($Vk,[2,32]),o($Vk,[2,33])];
    defaultActions: {[key:number]: any} = {12:[2,1]};

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
 return $$[$0-1] 
break;
case 2: case 29: case 31:
 this.$ = [$$[$0]]; 
break;
case 3:
 this.$ = [$$[$0]] 
break;
case 4:
 this.$ = $$[$0-1].concat($$[$0]) 
break;
case 5:
 this.$ = $$[$0-1].concat($$[$0]); 
break;
case 6:
 this.$ = new CommentNode($$[$0], yylineno + 1); 
break;
case 7: case 8: case 9: case 14:
 this.$ = $$[$0]; 
break;
case 10:
 this.$ = new AssignmentNode($$[$0-3], new PLString('', yylineno + 1), yylineno + 1); 
break;
case 11:
 this.$ = new AssignmentNode($$[$0-2], new PLString('', yylineno + 1), yylineno + 1); 
break;
case 12:
 this.$ = new AssignmentNode($$[$0-3], new PLString($$[$0-1], yylineno + 1), yylineno + 1); 
break;
case 13:
 this.$ = new AssignmentNode($$[$0-2], $$[$0], yylineno + 1); 
break;
case 15:
 this.$ = new PLNumber(Number($$[$0].replace(/_/g, '')), yylineno + 1); 
break;
case 16:
 this.$ = new PLReference($$[$0], yylineno + 1); 
break;
case 17:
 this.$ = new PLBoolean($$[$0].toLowerCase() === 'true', yylineno + 1); 
break;
case 18:
 this.$ = new PLString($$[$0].slice(1, -1), yylineno + 1); 
break;
case 19:
 this.$ = new PLDict($$[$0], yylineno + 1); 
break;
case 20:
 this.$ = new PLFileURL($$[$0], yylineno + 1); 
break;
case 21:
 this.$ = new PLFileContent($$[$0], yylineno + 1); 
break;
case 22:
 this.$ = new PLComponent($$[$0], yylineno + 1); 
break;
case 23:
 this.$ = new PLArray([], yylineno + 1); 
break;
case 24:
 this.$ = new PLArray($$[$0-1], yylineno + 1); 
break;
case 25:
 this.$ = new PLObject([], yylineno + 1); 
break;
case 26:
 this.$ = new PLObject($$[$0-1], yylineno + 1); 
break;
case 27:

        this.$ = $$[$0-1] + $$[$0];
      
break;
case 28:

        if ($$[$0].trim().startsWith('#!lang=')) {
          this.$ = '';
        } else {
          this.$ = $$[$0];
        }
    
break;
case 30: case 32:
 this.$ = $$[$0-2].concat($$[$0]); 
break;
case 33:
 this.$ = { key: $$[$0-2], value: $$[$0] }; 
break;
case 34:
 this.$ = new IncludeNode($$[$0], '', yylineno + 1); 
break;
case 35:
 this.$ = new IncludeNode($$[$0-2], $$[$0], yylineno + 1); 
break;
case 36:
 this.$ = new ExtendsNode($$[$0], yylineno + 1); 
break;
        }
    }
}


/* generated by ts-jison-lex 0.3.0 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';
export class PLLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"moduleName":"PL"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [/^(?:\s+)/,/^(?:#.*)/,/^(?:\/\/.*)/,/^(?:\/\*([^*]|\*[^\/])*\*\/)/,/^(?:==)/,/^(?:=)/,/^(?:@copycontent\b)/,/^(?:@copyurl\b)/,/^(?:@include\b)/,/^(?:@extends\b)/,/^(?:as\b)/,/^(?:\/[^\s\n\,]+)/,/^(?:[+-]?\d+((_|\.)+\d+)*)/,/^(?:[,])/,/^(?:[:])/,/^(?:[\{])/,/^(?:[\}])/,/^(?:[\[])/,/^(?:[\]])/,/^(?:true|false|True|False\b)/,/^(?:wc-[a-zA-Z0-9_-]+)/,/^(?:[a-zA-Z_](\.?[a-zA-Z0-9_])*)/,/^(?:"([^\\\"]|\\.)*")/,/^(?:$)/,/^(?:[^\n]*\n)/];
    conditions: any = {"MULTI":{"rules":[23,24],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:/* ignore whitespace */
      break;
    case 1:return 8
      break;
    case 2:return 8
      break;
    case 3:return 8
      break;
    case 4: this.begin('MULTI'); return 13; 
      break;
    case 5:return 13
      break;
    case 6:return 22
      break;
    case 7:return 21
      break;
    case 8:return 34
      break;
    case 9:return 19
      break;
    case 10:return 35
      break;
    case 11:return 20 // COMMA AT THE END ALLOW TO INCLUDES PATH INSIDE ARRAY
      break;
    case 12:return 16
      break;
    case 13:return 32
      break;
    case 14:return 23
      break;
    case 15:return 28
      break;
    case 16:return 29
      break;
    case 17:return 25
      break;
    case 18:return 26
      break;
    case 19:return 17
      break;
    case 20:return 24
      break;
    case 21:return 12
      break;
    case 22:return 18
      break;
    case 23:return 5
      break;
    case 24:
                          if (yy_.yytext.trim() === '==') {
                            this.popState();
                            return 13;
                          }
                          return 31
                         
      break;
        }
    }
}

